import { jsx, jsxs } from "react/jsx-runtime";
import { PassThrough } from "node:stream";
import { createReadableStreamFromReadable } from "@react-router/node";
import { ServerRouter, UNSAFE_withComponentProps, Outlet, UNSAFE_withErrorBoundaryProps, isRouteErrorResponse, Meta, Links, ScrollRestoration, Scripts, createCookieSessionStorage, redirect, useSearchParams, unstable_createContext, useRouteLoaderData } from "react-router";
import { isbot } from "isbot";
import { renderToPipeableStream } from "react-dom/server";
import { ethers, getAddress } from "ethers";
import { createContext, useState, useContext, useEffect, useRef, useCallback } from "react";
import { createActorContext } from "@xstate/react";
import { assign, fromPromise, setup } from "xstate";
import require$$1$2 from "http";
import require$$2 from "https";
import require$$0$2 from "url";
import require$$3 from "stream";
import require$$4 from "assert";
import require$$1 from "tty";
import require$$1$1 from "util";
import require$$0$1 from "os";
import require$$8 from "zlib";
import require$$1$3 from "path";
import require$$6 from "fs";
import require$$0$3 from "crypto";
import z from "zod";
import { SiweMessage } from "siwe";
import jwt from "jsonwebtoken";
import { createRequire } from "node:module";
import nacl from "tweetnacl";
import { Ed25519Signature2020 } from "@digitalbazaar/ed25519-signature-2020";
import * as vc from "@digitalbazaar/vc";
import { Ed25519VerificationKey2020 } from "@digitalbazaar/ed25519-verification-key-2020";
import "base85";
import { JsonLdDocumentLoader } from "jsonld-document-loader";
import * as ascii85 from "ascii85";
import { fileTypeFromBuffer } from "file-type";
import { Transak } from "@transak/transak-sdk";
import https from "node:https";
const streamTimeout = 5e3;
function handleRequest(request, responseStatusCode, responseHeaders, routerContext, loadContext) {
  return new Promise((resolve, reject) => {
    let shellRendered = false;
    let userAgent = request.headers.get("user-agent");
    let readyOption = userAgent && isbot(userAgent) || routerContext.isSpaMode ? "onAllReady" : "onShellReady";
    const { pipe, abort } = renderToPipeableStream(
      /* @__PURE__ */ jsx(ServerRouter, { context: routerContext, url: request.url }),
      {
        [readyOption]() {
          shellRendered = true;
          const body = new PassThrough();
          const stream = createReadableStreamFromReadable(body);
          responseHeaders.set("Content-Type", "text/html");
          resolve(
            new Response(stream, {
              headers: responseHeaders,
              status: responseStatusCode
            })
          );
          pipe(body);
        },
        onShellError(error) {
          reject(error);
        },
        onError(error) {
          responseStatusCode = 500;
          if (shellRendered) {
            console.error(error);
          }
        }
      }
    );
    setTimeout(abort, streamTimeout + 1e3);
  });
}
const entryServer = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: handleRequest,
  streamTimeout
}, Symbol.toStringTag, { value: "Module" }));
const SiweContext = createContext(null);
function useSiwe() {
  const context = useContext(SiweContext);
  if (!context) {
    throw new Error("useSiwe must be used within a SiweProvider");
  }
  return context;
}
function SiweProvider({ children }) {
  const [address, setAddress] = useState(null);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const signIn = async () => {
    try {
      if (!window.ethereum) {
        throw new Error("Please install MetaMask");
      }
      const [address2] = await window.ethereum.request({ method: "eth_requestAccounts" });
      const authResponse = await fetch(`/auth?address=${getAddress(address2)}`);
      const { user } = await authResponse.json();
      const signature2 = await window.ethereum.request({
        method: "personal_sign",
        params: [user.message, address2]
      });
      const signInResponse = await fetch("/auth", {
        method: "POST",
        body: JSON.stringify({ signature: signature2, address: address2 })
      });
      if (signInResponse.redirected) {
        setAddress(address2);
        setIsAuthenticated(true);
        window.location.href = signInResponse.url;
      }
    } catch (error) {
      console.error("Sign in error:", error);
      throw error;
    }
  };
  const signOut = async () => {
    await fetch("/auth", { method: "DELETE" });
    window.location.reload();
  };
  const signer = async () => {
    if (!window.ethereum) {
      throw new Error("Please install MetaMask");
    }
    return new ethers.BrowserProvider(window.ethereum).getSigner();
  };
  return /* @__PURE__ */ jsx(SiweContext.Provider, { value: { address, isAuthenticated, signIn, signOut, signer }, children });
}
const actions = {
  configure: assign({
    walletAddress: ({ event }) => event.address,
    provider: ({ event }) => event.provider
  }),
  reset: assign({
    walletAddress: null,
    provider: null,
    kycUrl: null,
    client: null,
    profile: null,
    loggedInClient: null,
    sharableToken: null,
    credential: null,
    sharedCredential: null,
    findCredentialAttempts: 0,
    data: null,
    errorMessage: null,
    noahUrl: null,
    hifiTosUrl: null,
    hifiTosId: null,
    hifiUrl: null,
    hifiKycStatus: null,
    getHifiKycStatusAttempts: 0,
    onRampAccount: null
  }),
  setClient: assign({
    client: ({ event }) => event.output
  }),
  setKycUrl: assign({
    kycUrl: ({ event }) => event.output
  }),
  setLoggedInClient: assign({
    loggedInClient: ({ event }) => event.output
  }),
  setCredential: assign({
    credential: ({ event }) => event.output
  }),
  incrementFindCredentialAttempts: assign({
    findCredentialAttempts: ({ context }) => context.findCredentialAttempts + 1
  }),
  setSharedCredential: assign({
    sharedCredential: ({ event }) => event.output ?? null
  }),
  setSharableToken: assign({
    sharableToken: ({ event }) => event.output
  }),
  setUserData: assign({
    data: ({ event }) => event.output
  }),
  setErrorMessage: assign({
    errorMessage: ({ event }) => event.error?.message
  }),
  setNoahUrl: assign({
    noahUrl: ({ event }) => event.output
  }),
  setHifiTosUrl: assign({
    hifiTosUrl: ({ event }) => event.output
  }),
  setHifiTosId: assign({
    hifiTosId: ({ event }) => event.signedAgreementId
  }),
  setHifiUrl: assign({
    hifiUrl: ({ event }) => event.output
  }),
  setHifiKycStatus: assign({
    hifiKycStatus: ({ event }) => event.output
  }),
  incrementGetHifiKycStatusAttempts: assign({
    getHifiKycStatusAttempts: ({ context }) => context.getHifiKycStatusAttempts + 1
  }),
  setOnRampAccount: assign({
    onRampAccount: ({ event }) => event.output
  })
};
var dist = {};
var nodeKwil = {};
var kwil = {};
var client = {};
var base64 = {};
var hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64) return base64;
  hasRequiredBase64 = 1;
  Object.defineProperty(base64, "__esModule", { value: true });
  base64.base64ToBytes = base64.bytesToBase64 = void 0;
  const base64abc = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/"
  ];
  const base64codes = [
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    62,
    255,
    255,
    255,
    63,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    255,
    255,
    255,
    0,
    255,
    255,
    255,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    255,
    255,
    255,
    255,
    255,
    255,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51
  ];
  function getBase64Code(charCode) {
    if (charCode >= base64codes.length) {
      throw new Error("Unable to parse base64 string.");
    }
    const code = base64codes[charCode];
    if (code === 255) {
      throw new Error("Unable to parse base64 string.");
    }
    return code;
  }
  function bytesToBase64(bytes2) {
    let result = "", i, l = bytes2.length;
    for (i = 2; i < l; i += 3) {
      result += base64abc[bytes2[i - 2] >> 2];
      result += base64abc[(bytes2[i - 2] & 3) << 4 | bytes2[i - 1] >> 4];
      result += base64abc[(bytes2[i - 1] & 15) << 2 | bytes2[i] >> 6];
      result += base64abc[bytes2[i] & 63];
    }
    if (i === l + 1) {
      result += base64abc[bytes2[i - 2] >> 2];
      result += base64abc[(bytes2[i - 2] & 3) << 4];
      result += "==";
    }
    if (i === l) {
      result += base64abc[bytes2[i - 2] >> 2];
      result += base64abc[(bytes2[i - 2] & 3) << 4 | bytes2[i - 1] >> 4];
      result += base64abc[(bytes2[i - 1] & 15) << 2];
      result += "=";
    }
    return result;
  }
  base64.bytesToBase64 = bytesToBase64;
  function base64ToBytes(str) {
    if (str.length % 4 !== 0) {
      throw new Error("Unable to parse base64 string.");
    }
    const index = str.indexOf("=");
    if (index !== -1 && index < str.length - 2) {
      throw new Error("Unable to parse base64 string.");
    }
    let missingOctets = str.endsWith("==") ? 2 : str.endsWith("=") ? 1 : 0, n = str.length, result = new Uint8Array(3 * (n / 4)), buffer;
    for (let i = 0, j = 0; i < n; i += 4, j += 3) {
      buffer = getBase64Code(str.charCodeAt(i)) << 18 | getBase64Code(str.charCodeAt(i + 1)) << 12 | getBase64Code(str.charCodeAt(i + 2)) << 6 | getBase64Code(str.charCodeAt(i + 3));
      result[j] = buffer >> 16;
      result[j + 1] = buffer >> 8 & 255;
      result[j + 2] = buffer & 255;
    }
    return result.subarray(0, result.length - missingOctets);
  }
  base64.base64ToBytes = base64ToBytes;
  return base64;
}
var api = {};
var axios$1 = { exports: {} };
var bind;
var hasRequiredBind;
function requireBind() {
  if (hasRequiredBind) return bind;
  hasRequiredBind = 1;
  bind = function bind2(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      return fn.apply(thisArg, args);
    };
  };
  return bind;
}
var utils;
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  var bind2 = requireBind();
  var toString = Object.prototype.toString;
  var kindOf = /* @__PURE__ */ function(cache) {
    return function(thing) {
      var str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    };
  }(/* @__PURE__ */ Object.create(null));
  function kindOfTest(type2) {
    type2 = type2.toLowerCase();
    return function isKindOf(thing) {
      return kindOf(thing) === type2;
    };
  }
  function isArray(val) {
    return Array.isArray(val);
  }
  function isUndefined(val) {
    return typeof val === "undefined";
  }
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
  }
  var isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    var result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  function isString(val) {
    return typeof val === "string";
  }
  function isNumber(val) {
    return typeof val === "number";
  }
  function isObject2(val) {
    return val !== null && typeof val === "object";
  }
  function isPlainObject(val) {
    if (kindOf(val) !== "object") {
      return false;
    }
    var prototype = Object.getPrototypeOf(val);
    return prototype === null || prototype === Object.prototype;
  }
  var isDate = kindOfTest("Date");
  var isFile = kindOfTest("File");
  var isBlob = kindOfTest("Blob");
  var isFileList = kindOfTest("FileList");
  function isFunction(val) {
    return toString.call(val) === "[object Function]";
  }
  function isStream(val) {
    return isObject2(val) && isFunction(val.pipe);
  }
  function isFormData(thing) {
    var pattern = "[object FormData]";
    return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
  }
  var isURLSearchParams = kindOfTest("URLSearchParams");
  function trim(str) {
    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
  }
  function isStandardBrowserEnv() {
    if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
      return false;
    }
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function forEach(obj, fn) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }
  function merge() {
    var result = {};
    function assignValue(val, key) {
      if (isPlainObject(result[key]) && isPlainObject(val)) {
        result[key] = merge(result[key], val);
      } else if (isPlainObject(val)) {
        result[key] = merge({}, val);
      } else if (isArray(val)) {
        result[key] = val.slice();
      } else {
        result[key] = val;
      }
    }
    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }
    return result;
  }
  function extend(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
      if (thisArg && typeof val === "function") {
        a[key] = bind2(val, thisArg);
      } else {
        a[key] = val;
      }
    });
    return a;
  }
  function stripBOM(content) {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  }
  function inherits(constructor, superConstructor, props, descriptors) {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors);
    constructor.prototype.constructor = constructor;
    props && Object.assign(constructor.prototype, props);
  }
  function toFlatObject(sourceObj, destObj, filter) {
    var props;
    var i;
    var prop;
    var merged = {};
    destObj = destObj || {};
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i = props.length;
      while (i-- > 0) {
        prop = props[i];
        if (!merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = Object.getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  }
  function endsWith(str, searchString, position) {
    str = String(str);
    if (position === void 0 || position > str.length) {
      position = str.length;
    }
    position -= searchString.length;
    var lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  }
  function toArray(thing) {
    if (!thing) return null;
    var i = thing.length;
    if (isUndefined(i)) return null;
    var arr = new Array(i);
    while (i-- > 0) {
      arr[i] = thing[i];
    }
    return arr;
  }
  var isTypedArray2 = /* @__PURE__ */ function(TypedArray) {
    return function(thing) {
      return TypedArray && thing instanceof TypedArray;
    };
  }(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
  utils = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isObject: isObject2,
    isPlainObject,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isFunction,
    isStream,
    isURLSearchParams,
    isStandardBrowserEnv,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    isTypedArray: isTypedArray2,
    isFileList
  };
  return utils;
}
var buildURL;
var hasRequiredBuildURL;
function requireBuildURL() {
  if (hasRequiredBuildURL) return buildURL;
  hasRequiredBuildURL = 1;
  var utils2 = requireUtils();
  function encode2(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  buildURL = function buildURL2(url, params, paramsSerializer) {
    if (!params) {
      return url;
    }
    var serializedParams;
    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils2.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];
      utils2.forEach(params, function serialize2(val, key) {
        if (val === null || typeof val === "undefined") {
          return;
        }
        if (utils2.isArray(val)) {
          key = key + "[]";
        } else {
          val = [val];
        }
        utils2.forEach(val, function parseValue(v) {
          if (utils2.isDate(v)) {
            v = v.toISOString();
          } else if (utils2.isObject(v)) {
            v = JSON.stringify(v);
          }
          parts.push(encode2(key) + "=" + encode2(v));
        });
      });
      serializedParams = parts.join("&");
    }
    if (serializedParams) {
      var hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  };
  return buildURL;
}
var InterceptorManager_1;
var hasRequiredInterceptorManager;
function requireInterceptorManager() {
  if (hasRequiredInterceptorManager) return InterceptorManager_1;
  hasRequiredInterceptorManager = 1;
  var utils2 = requireUtils();
  function InterceptorManager() {
    this.handlers = [];
  }
  InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  };
  InterceptorManager.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };
  InterceptorManager.prototype.forEach = function forEach(fn) {
    utils2.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  };
  InterceptorManager_1 = InterceptorManager;
  return InterceptorManager_1;
}
var normalizeHeaderName;
var hasRequiredNormalizeHeaderName;
function requireNormalizeHeaderName() {
  if (hasRequiredNormalizeHeaderName) return normalizeHeaderName;
  hasRequiredNormalizeHeaderName = 1;
  var utils2 = requireUtils();
  normalizeHeaderName = function normalizeHeaderName2(headers, normalizedName) {
    utils2.forEach(headers, function processHeader(value, name) {
      if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name];
      }
    });
  };
  return normalizeHeaderName;
}
var AxiosError_1;
var hasRequiredAxiosError;
function requireAxiosError() {
  if (hasRequiredAxiosError) return AxiosError_1;
  hasRequiredAxiosError = 1;
  var utils2 = requireUtils();
  function AxiosError(message2, code, config, request, response) {
    Error.call(this);
    this.message = message2;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    response && (this.response = response);
  }
  utils2.inherits(AxiosError, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: this.config,
        code: this.code,
        status: this.response && this.response.status ? this.response.status : null
      };
    }
  });
  var prototype = AxiosError.prototype;
  var descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED"
    // eslint-disable-next-line func-names
  ].forEach(function(code) {
    descriptors[code] = { value: code };
  });
  Object.defineProperties(AxiosError, descriptors);
  Object.defineProperty(prototype, "isAxiosError", { value: true });
  AxiosError.from = function(error, code, config, request, response, customProps) {
    var axiosError = Object.create(prototype);
    utils2.toFlatObject(error, axiosError, function filter(obj) {
      return obj !== Error.prototype;
    });
    AxiosError.call(axiosError, error.message, code, config, request, response);
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  AxiosError_1 = AxiosError;
  return AxiosError_1;
}
var transitional;
var hasRequiredTransitional;
function requireTransitional() {
  if (hasRequiredTransitional) return transitional;
  hasRequiredTransitional = 1;
  transitional = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  return transitional;
}
var toFormData_1;
var hasRequiredToFormData;
function requireToFormData() {
  if (hasRequiredToFormData) return toFormData_1;
  hasRequiredToFormData = 1;
  var utils2 = requireUtils();
  function toFormData(obj, formData) {
    formData = formData || new FormData();
    var stack = [];
    function convertValue(value) {
      if (value === null) return "";
      if (utils2.isDate(value)) {
        return value.toISOString();
      }
      if (utils2.isArrayBuffer(value) || utils2.isTypedArray(value)) {
        return typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function build(data2, parentKey) {
      if (utils2.isPlainObject(data2) || utils2.isArray(data2)) {
        if (stack.indexOf(data2) !== -1) {
          throw Error("Circular reference detected in " + parentKey);
        }
        stack.push(data2);
        utils2.forEach(data2, function each(value, key) {
          if (utils2.isUndefined(value)) return;
          var fullKey = parentKey ? parentKey + "." + key : key;
          var arr;
          if (value && !parentKey && typeof value === "object") {
            if (utils2.endsWith(key, "{}")) {
              value = JSON.stringify(value);
            } else if (utils2.endsWith(key, "[]") && (arr = utils2.toArray(value))) {
              arr.forEach(function(el) {
                !utils2.isUndefined(el) && formData.append(fullKey, convertValue(el));
              });
              return;
            }
          }
          build(value, fullKey);
        });
        stack.pop();
      } else {
        formData.append(parentKey, convertValue(data2));
      }
    }
    build(obj);
    return formData;
  }
  toFormData_1 = toFormData;
  return toFormData_1;
}
var settle;
var hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle) return settle;
  hasRequiredSettle = 1;
  var AxiosError = requireAxiosError();
  settle = function settle2(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError(
        "Request failed with status code " + response.status,
        [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  };
  return settle;
}
var cookies;
var hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies) return cookies;
  hasRequiredCookies = 1;
  var utils2 = requireUtils();
  cookies = utils2.isStandardBrowserEnv() ? (
    // Standard browser envs support document.cookie
    /* @__PURE__ */ function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils2.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils2.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils2.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    /* @__PURE__ */ function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove() {
        }
      };
    }()
  );
  return cookies;
}
var isAbsoluteURL;
var hasRequiredIsAbsoluteURL;
function requireIsAbsoluteURL() {
  if (hasRequiredIsAbsoluteURL) return isAbsoluteURL;
  hasRequiredIsAbsoluteURL = 1;
  isAbsoluteURL = function isAbsoluteURL2(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  };
  return isAbsoluteURL;
}
var combineURLs;
var hasRequiredCombineURLs;
function requireCombineURLs() {
  if (hasRequiredCombineURLs) return combineURLs;
  hasRequiredCombineURLs = 1;
  combineURLs = function combineURLs2(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  };
  return combineURLs;
}
var buildFullPath;
var hasRequiredBuildFullPath;
function requireBuildFullPath() {
  if (hasRequiredBuildFullPath) return buildFullPath;
  hasRequiredBuildFullPath = 1;
  var isAbsoluteURL2 = requireIsAbsoluteURL();
  var combineURLs2 = requireCombineURLs();
  buildFullPath = function buildFullPath2(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL2(requestedURL)) {
      return combineURLs2(baseURL, requestedURL);
    }
    return requestedURL;
  };
  return buildFullPath;
}
var parseHeaders;
var hasRequiredParseHeaders;
function requireParseHeaders() {
  if (hasRequiredParseHeaders) return parseHeaders;
  hasRequiredParseHeaders = 1;
  var utils2 = requireUtils();
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  parseHeaders = function parseHeaders2(headers) {
    var parsed = {};
    var key;
    var val;
    var i;
    if (!headers) {
      return parsed;
    }
    utils2.forEach(headers.split("\n"), function parser(line) {
      i = line.indexOf(":");
      key = utils2.trim(line.substr(0, i)).toLowerCase();
      val = utils2.trim(line.substr(i + 1));
      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === "set-cookie") {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  return parseHeaders;
}
var isURLSameOrigin;
var hasRequiredIsURLSameOrigin;
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin) return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var utils2 = requireUtils();
  isURLSameOrigin = utils2.isStandardBrowserEnv() ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin2(requestURL) {
        var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    /* @__PURE__ */ function nonStandardBrowserEnv() {
      return function isURLSameOrigin2() {
        return true;
      };
    }()
  );
  return isURLSameOrigin;
}
var CanceledError_1;
var hasRequiredCanceledError;
function requireCanceledError() {
  if (hasRequiredCanceledError) return CanceledError_1;
  hasRequiredCanceledError = 1;
  var AxiosError = requireAxiosError();
  var utils2 = requireUtils();
  function CanceledError(message2) {
    AxiosError.call(this, message2 == null ? "canceled" : message2, AxiosError.ERR_CANCELED);
    this.name = "CanceledError";
  }
  utils2.inherits(CanceledError, AxiosError, {
    __CANCEL__: true
  });
  CanceledError_1 = CanceledError;
  return CanceledError_1;
}
var parseProtocol;
var hasRequiredParseProtocol;
function requireParseProtocol() {
  if (hasRequiredParseProtocol) return parseProtocol;
  hasRequiredParseProtocol = 1;
  parseProtocol = function parseProtocol2(url) {
    var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
  };
  return parseProtocol;
}
var xhr;
var hasRequiredXhr;
function requireXhr() {
  if (hasRequiredXhr) return xhr;
  hasRequiredXhr = 1;
  var utils2 = requireUtils();
  var settle2 = requireSettle();
  var cookies2 = requireCookies();
  var buildURL2 = requireBuildURL();
  var buildFullPath2 = requireBuildFullPath();
  var parseHeaders2 = requireParseHeaders();
  var isURLSameOrigin2 = requireIsURLSameOrigin();
  var transitionalDefaults = requireTransitional();
  var AxiosError = requireAxiosError();
  var CanceledError = requireCanceledError();
  var parseProtocol2 = requireParseProtocol();
  xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;
      var responseType = config.responseType;
      var onCanceled;
      function done() {
        if (config.cancelToken) {
          config.cancelToken.unsubscribe(onCanceled);
        }
        if (config.signal) {
          config.signal.removeEventListener("abort", onCanceled);
        }
      }
      if (utils2.isFormData(requestData) && utils2.isStandardBrowserEnv()) {
        delete requestHeaders["Content-Type"];
      }
      var request = new XMLHttpRequest();
      if (config.auth) {
        var username = config.auth.username || "";
        var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath2(config.baseURL, config.url);
      request.open(config.method.toUpperCase(), buildURL2(fullPath, config.params, config.paramsSerializer), true);
      request.timeout = config.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders2(request.getAllResponseHeaders()) : null;
        var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        var response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };
        settle2(function _resolve(value) {
          resolve(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        var transitional2 = config.transitional || transitionalDefaults;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config,
          request
        ));
        request = null;
      };
      if (utils2.isStandardBrowserEnv()) {
        var xsrfValue = (config.withCredentials || isURLSameOrigin2(fullPath)) && config.xsrfCookieName ? cookies2.read(config.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request) {
        utils2.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
            delete requestHeaders[key];
          } else {
            request.setRequestHeader(key, val);
          }
        });
      }
      if (!utils2.isUndefined(config.withCredentials)) {
        request.withCredentials = !!config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = config.responseType;
      }
      if (typeof config.onDownloadProgress === "function") {
        request.addEventListener("progress", config.onDownloadProgress);
      }
      if (typeof config.onUploadProgress === "function" && request.upload) {
        request.upload.addEventListener("progress", config.onUploadProgress);
      }
      if (config.cancelToken || config.signal) {
        onCanceled = function(cancel) {
          if (!request) {
            return;
          }
          reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);
          request.abort();
          request = null;
        };
        config.cancelToken && config.cancelToken.subscribe(onCanceled);
        if (config.signal) {
          config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
        }
      }
      if (!requestData) {
        requestData = null;
      }
      var protocol = parseProtocol2(fullPath);
      if (protocol && ["http", "https", "file"].indexOf(protocol) === -1) {
        reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
        return;
      }
      request.send(requestData);
    });
  };
  return xhr;
}
var followRedirects = { exports: {} };
var src = { exports: {} };
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  function setup2(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace2) {
      let hash2 = 0;
      for (let i = 0; i < namespace2.length; i++) {
        hash2 = (hash2 << 5) - hash2 + namespace2.charCodeAt(i);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace2) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace2;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace2);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace2);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace2, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace2);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace2) => "-" + namespace2)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common = setup2;
  return common;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function(module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}
var node = { exports: {} };
var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag) return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = (flag, argv = process.argv) => {
    const prefix2 = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix2 + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
  return hasFlag;
}
var supportsColor_1;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor) return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const os = require$$0$1;
  const tty = require$$1;
  const hasFlag2 = requireHasFlag();
  const { env } = process;
  let flagForceColor;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
    flagForceColor = 0;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    flagForceColor = 1;
  }
  function envForceColor() {
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        return 1;
      }
      if (env.FORCE_COLOR === "false") {
        return 0;
      }
      return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
    const noFlagForceColor = envForceColor();
    if (noFlagForceColor !== void 0) {
      flagForceColor = noFlagForceColor;
    }
    const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
    if (forceColor === 0) {
      return 0;
    }
    if (sniffFlags) {
      if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
        return 3;
      }
      if (hasFlag2("color=256")) {
        return 2;
      }
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min2 = forceColor || 0;
    if (env.TERM === "dumb") {
      return min2;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((sign2) => sign2 in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min2;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version2 = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min2;
  }
  function getSupportLevel(stream, options = {}) {
    const level = supportsColor(stream, {
      streamIsTTY: stream && stream.isTTY,
      ...options
    });
    return translateLevel(level);
  }
  supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel({ isTTY: tty.isatty(1) }),
    stderr: getSupportLevel({ isTTY: tty.isatty(2) })
  };
  return supportsColor_1;
}
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node.exports;
  hasRequiredNode = 1;
  (function(module, exports) {
    const tty = require$$1;
    const util = require$$1$1;
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix2 = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix2 + args[0].split("\n").join("\n" + prefix2);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys2 = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys2.length; i++) {
        debug.inspectOpts[keys2[i]] = exports.inspectOpts[keys2[i]];
      }
    }
    module.exports = requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  })(node, node.exports);
  return node.exports;
}
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src.exports;
  hasRequiredSrc = 1;
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    src.exports = requireBrowser();
  } else {
    src.exports = requireNode();
  }
  return src.exports;
}
var debug_1;
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug) return debug_1;
  hasRequiredDebug = 1;
  var debug;
  debug_1 = function() {
    if (!debug) {
      try {
        debug = requireSrc()("follow-redirects");
      } catch (error) {
      }
      if (typeof debug !== "function") {
        debug = function() {
        };
      }
    }
    debug.apply(null, arguments);
  };
  return debug_1;
}
var hasRequiredFollowRedirects;
function requireFollowRedirects() {
  if (hasRequiredFollowRedirects) return followRedirects.exports;
  hasRequiredFollowRedirects = 1;
  var url = require$$0$2;
  var URL2 = url.URL;
  var http = require$$1$2;
  var https2 = require$$2;
  var Writable = require$$3.Writable;
  var assert = require$$4;
  var debug = requireDebug();
  (function detectUnsupportedEnvironment() {
    var looksLikeNode = typeof process !== "undefined";
    var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
    var looksLikeV8 = isFunction(Error.captureStackTrace);
    if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
      console.warn("The follow-redirects package should be excluded from browser builds.");
    }
  })();
  var useNativeURL = false;
  try {
    assert(new URL2(""));
  } catch (error) {
    useNativeURL = error.code === "ERR_INVALID_URL";
  }
  var preservedUrlFields = [
    "auth",
    "host",
    "hostname",
    "href",
    "path",
    "pathname",
    "port",
    "protocol",
    "query",
    "search",
    "hash"
  ];
  var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
  var eventHandlers = /* @__PURE__ */ Object.create(null);
  events.forEach(function(event) {
    eventHandlers[event] = function(arg1, arg2, arg3) {
      this._redirectable.emit(event, arg1, arg2, arg3);
    };
  });
  var InvalidUrlError = createErrorType(
    "ERR_INVALID_URL",
    "Invalid URL",
    TypeError
  );
  var RedirectionError = createErrorType(
    "ERR_FR_REDIRECTION_FAILURE",
    "Redirected request failed"
  );
  var TooManyRedirectsError = createErrorType(
    "ERR_FR_TOO_MANY_REDIRECTS",
    "Maximum number of redirects exceeded",
    RedirectionError
  );
  var MaxBodyLengthExceededError = createErrorType(
    "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
    "Request body larger than maxBodyLength limit"
  );
  var WriteAfterEndError = createErrorType(
    "ERR_STREAM_WRITE_AFTER_END",
    "write after end"
  );
  var destroy = Writable.prototype.destroy || noop;
  function RedirectableRequest(options, responseCallback) {
    Writable.call(this);
    this._sanitizeOptions(options);
    this._options = options;
    this._ended = false;
    this._ending = false;
    this._redirectCount = 0;
    this._redirects = [];
    this._requestBodyLength = 0;
    this._requestBodyBuffers = [];
    if (responseCallback) {
      this.on("response", responseCallback);
    }
    var self2 = this;
    this._onNativeResponse = function(response) {
      try {
        self2._processResponse(response);
      } catch (cause) {
        self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
      }
    };
    this._performRequest();
  }
  RedirectableRequest.prototype = Object.create(Writable.prototype);
  RedirectableRequest.prototype.abort = function() {
    destroyRequest(this._currentRequest);
    this._currentRequest.abort();
    this.emit("abort");
  };
  RedirectableRequest.prototype.destroy = function(error) {
    destroyRequest(this._currentRequest, error);
    destroy.call(this, error);
    return this;
  };
  RedirectableRequest.prototype.write = function(data2, encoding, callback) {
    if (this._ending) {
      throw new WriteAfterEndError();
    }
    if (!isString(data2) && !isBuffer(data2)) {
      throw new TypeError("data should be a string, Buffer or Uint8Array");
    }
    if (isFunction(encoding)) {
      callback = encoding;
      encoding = null;
    }
    if (data2.length === 0) {
      if (callback) {
        callback();
      }
      return;
    }
    if (this._requestBodyLength + data2.length <= this._options.maxBodyLength) {
      this._requestBodyLength += data2.length;
      this._requestBodyBuffers.push({ data: data2, encoding });
      this._currentRequest.write(data2, encoding, callback);
    } else {
      this.emit("error", new MaxBodyLengthExceededError());
      this.abort();
    }
  };
  RedirectableRequest.prototype.end = function(data2, encoding, callback) {
    if (isFunction(data2)) {
      callback = data2;
      data2 = encoding = null;
    } else if (isFunction(encoding)) {
      callback = encoding;
      encoding = null;
    }
    if (!data2) {
      this._ended = this._ending = true;
      this._currentRequest.end(null, null, callback);
    } else {
      var self2 = this;
      var currentRequest = this._currentRequest;
      this.write(data2, encoding, function() {
        self2._ended = true;
        currentRequest.end(null, null, callback);
      });
      this._ending = true;
    }
  };
  RedirectableRequest.prototype.setHeader = function(name, value) {
    this._options.headers[name] = value;
    this._currentRequest.setHeader(name, value);
  };
  RedirectableRequest.prototype.removeHeader = function(name) {
    delete this._options.headers[name];
    this._currentRequest.removeHeader(name);
  };
  RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
    var self2 = this;
    function destroyOnTimeout(socket) {
      socket.setTimeout(msecs);
      socket.removeListener("timeout", socket.destroy);
      socket.addListener("timeout", socket.destroy);
    }
    function startTimer(socket) {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
      }
      self2._timeout = setTimeout(function() {
        self2.emit("timeout");
        clearTimer();
      }, msecs);
      destroyOnTimeout(socket);
    }
    function clearTimer() {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
        self2._timeout = null;
      }
      self2.removeListener("abort", clearTimer);
      self2.removeListener("error", clearTimer);
      self2.removeListener("response", clearTimer);
      self2.removeListener("close", clearTimer);
      if (callback) {
        self2.removeListener("timeout", callback);
      }
      if (!self2.socket) {
        self2._currentRequest.removeListener("socket", startTimer);
      }
    }
    if (callback) {
      this.on("timeout", callback);
    }
    if (this.socket) {
      startTimer(this.socket);
    } else {
      this._currentRequest.once("socket", startTimer);
    }
    this.on("socket", destroyOnTimeout);
    this.on("abort", clearTimer);
    this.on("error", clearTimer);
    this.on("response", clearTimer);
    this.on("close", clearTimer);
    return this;
  };
  [
    "flushHeaders",
    "getHeader",
    "setNoDelay",
    "setSocketKeepAlive"
  ].forEach(function(method) {
    RedirectableRequest.prototype[method] = function(a, b) {
      return this._currentRequest[method](a, b);
    };
  });
  ["aborted", "connection", "socket"].forEach(function(property2) {
    Object.defineProperty(RedirectableRequest.prototype, property2, {
      get: function() {
        return this._currentRequest[property2];
      }
    });
  });
  RedirectableRequest.prototype._sanitizeOptions = function(options) {
    if (!options.headers) {
      options.headers = {};
    }
    if (options.host) {
      if (!options.hostname) {
        options.hostname = options.host;
      }
      delete options.host;
    }
    if (!options.pathname && options.path) {
      var searchPos = options.path.indexOf("?");
      if (searchPos < 0) {
        options.pathname = options.path;
      } else {
        options.pathname = options.path.substring(0, searchPos);
        options.search = options.path.substring(searchPos);
      }
    }
  };
  RedirectableRequest.prototype._performRequest = function() {
    var protocol = this._options.protocol;
    var nativeProtocol = this._options.nativeProtocols[protocol];
    if (!nativeProtocol) {
      throw new TypeError("Unsupported protocol " + protocol);
    }
    if (this._options.agents) {
      var scheme = protocol.slice(0, -1);
      this._options.agent = this._options.agents[scheme];
    }
    var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
    request._redirectable = this;
    for (var event of events) {
      request.on(event, eventHandlers[event]);
    }
    this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
      // When making a request to a proxy, []
      // a client MUST send the target URI in absolute-form [].
      this._options.path
    );
    if (this._isRedirect) {
      var i = 0;
      var self2 = this;
      var buffers = this._requestBodyBuffers;
      (function writeNext(error) {
        if (request === self2._currentRequest) {
          if (error) {
            self2.emit("error", error);
          } else if (i < buffers.length) {
            var buffer = buffers[i++];
            if (!request.finished) {
              request.write(buffer.data, buffer.encoding, writeNext);
            }
          } else if (self2._ended) {
            request.end();
          }
        }
      })();
    }
  };
  RedirectableRequest.prototype._processResponse = function(response) {
    var statusCode = response.statusCode;
    if (this._options.trackRedirects) {
      this._redirects.push({
        url: this._currentUrl,
        headers: response.headers,
        statusCode
      });
    }
    var location = response.headers.location;
    if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
      response.responseUrl = this._currentUrl;
      response.redirects = this._redirects;
      this.emit("response", response);
      this._requestBodyBuffers = [];
      return;
    }
    destroyRequest(this._currentRequest);
    response.destroy();
    if (++this._redirectCount > this._options.maxRedirects) {
      throw new TooManyRedirectsError();
    }
    var requestHeaders;
    var beforeRedirect = this._options.beforeRedirect;
    if (beforeRedirect) {
      requestHeaders = Object.assign({
        // The Host header was set by nativeProtocol.request
        Host: response.req.getHeader("host")
      }, this._options.headers);
    }
    var method = this._options.method;
    if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
    // the server is redirecting the user agent to a different resource []
    // A user agent can perform a retrieval request targeting that URI
    // (a GET or HEAD request if using HTTP) []
    statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
      this._options.method = "GET";
      this._requestBodyBuffers = [];
      removeMatchingHeaders(/^content-/i, this._options.headers);
    }
    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
    var currentUrlParts = parseUrl(this._currentUrl);
    var currentHost = currentHostHeader || currentUrlParts.host;
    var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
    var redirectUrl = resolveUrl(location, currentUrl);
    debug("redirecting to", redirectUrl.href);
    this._isRedirect = true;
    spreadUrlObject(redirectUrl, this._options);
    if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
      removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
    }
    if (isFunction(beforeRedirect)) {
      var responseDetails = {
        headers: response.headers,
        statusCode
      };
      var requestDetails = {
        url: currentUrl,
        method,
        headers: requestHeaders
      };
      beforeRedirect(this._options, responseDetails, requestDetails);
      this._sanitizeOptions(this._options);
    }
    this._performRequest();
  };
  function wrap(protocols) {
    var exports = {
      maxRedirects: 21,
      maxBodyLength: 10 * 1024 * 1024
    };
    var nativeProtocols = {};
    Object.keys(protocols).forEach(function(scheme) {
      var protocol = scheme + ":";
      var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
      var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);
      function request(input, options, callback) {
        if (isURL(input)) {
          input = spreadUrlObject(input);
        } else if (isString(input)) {
          input = spreadUrlObject(parseUrl(input));
        } else {
          callback = options;
          options = validateUrl(input);
          input = { protocol };
        }
        if (isFunction(options)) {
          callback = options;
          options = null;
        }
        options = Object.assign({
          maxRedirects: exports.maxRedirects,
          maxBodyLength: exports.maxBodyLength
        }, input, options);
        options.nativeProtocols = nativeProtocols;
        if (!isString(options.host) && !isString(options.hostname)) {
          options.hostname = "::1";
        }
        assert.equal(options.protocol, protocol, "protocol mismatch");
        debug("options", options);
        return new RedirectableRequest(options, callback);
      }
      function get2(input, options, callback) {
        var wrappedRequest = wrappedProtocol.request(input, options, callback);
        wrappedRequest.end();
        return wrappedRequest;
      }
      Object.defineProperties(wrappedProtocol, {
        request: { value: request, configurable: true, enumerable: true, writable: true },
        get: { value: get2, configurable: true, enumerable: true, writable: true }
      });
    });
    return exports;
  }
  function noop() {
  }
  function parseUrl(input) {
    var parsed;
    if (useNativeURL) {
      parsed = new URL2(input);
    } else {
      parsed = validateUrl(url.parse(input));
      if (!isString(parsed.protocol)) {
        throw new InvalidUrlError({ input });
      }
    }
    return parsed;
  }
  function resolveUrl(relative, base2) {
    return useNativeURL ? new URL2(relative, base2) : parseUrl(url.resolve(base2, relative));
  }
  function validateUrl(input) {
    if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
      throw new InvalidUrlError({ input: input.href || input });
    }
    if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
      throw new InvalidUrlError({ input: input.href || input });
    }
    return input;
  }
  function spreadUrlObject(urlObject, target) {
    var spread2 = target || {};
    for (var key of preservedUrlFields) {
      spread2[key] = urlObject[key];
    }
    if (spread2.hostname.startsWith("[")) {
      spread2.hostname = spread2.hostname.slice(1, -1);
    }
    if (spread2.port !== "") {
      spread2.port = Number(spread2.port);
    }
    spread2.path = spread2.search ? spread2.pathname + spread2.search : spread2.pathname;
    return spread2;
  }
  function removeMatchingHeaders(regex2, headers) {
    var lastValue;
    for (var header in headers) {
      if (regex2.test(header)) {
        lastValue = headers[header];
        delete headers[header];
      }
    }
    return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
  }
  function createErrorType(code, message2, baseClass) {
    function CustomError(properties) {
      if (isFunction(Error.captureStackTrace)) {
        Error.captureStackTrace(this, this.constructor);
      }
      Object.assign(this, properties || {});
      this.code = code;
      this.message = this.cause ? message2 + ": " + this.cause.message : message2;
    }
    CustomError.prototype = new (baseClass || Error)();
    Object.defineProperties(CustomError.prototype, {
      constructor: {
        value: CustomError,
        enumerable: false
      },
      name: {
        value: "Error [" + code + "]",
        enumerable: false
      }
    });
    return CustomError;
  }
  function destroyRequest(request, error) {
    for (var event of events) {
      request.removeListener(event, eventHandlers[event]);
    }
    request.on("error", noop);
    request.destroy(error);
  }
  function isSubdomain(subdomain, domain) {
    assert(isString(subdomain) && isString(domain));
    var dot = subdomain.length - domain.length - 1;
    return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
  }
  function isString(value) {
    return typeof value === "string" || value instanceof String;
  }
  function isFunction(value) {
    return typeof value === "function";
  }
  function isBuffer(value) {
    return typeof value === "object" && "length" in value;
  }
  function isURL(value) {
    return URL2 && value instanceof URL2;
  }
  followRedirects.exports = wrap({ http, https: https2 });
  followRedirects.exports.wrap = wrap;
  return followRedirects.exports;
}
var data;
var hasRequiredData;
function requireData() {
  if (hasRequiredData) return data;
  hasRequiredData = 1;
  data = {
    "version": "0.27.2"
  };
  return data;
}
var http_1;
var hasRequiredHttp;
function requireHttp() {
  if (hasRequiredHttp) return http_1;
  hasRequiredHttp = 1;
  var utils2 = requireUtils();
  var settle2 = requireSettle();
  var buildFullPath2 = requireBuildFullPath();
  var buildURL2 = requireBuildURL();
  var http = require$$1$2;
  var https2 = require$$2;
  var httpFollow = requireFollowRedirects().http;
  var httpsFollow = requireFollowRedirects().https;
  var url = require$$0$2;
  var zlib = require$$8;
  var VERSION = requireData().version;
  var transitionalDefaults = requireTransitional();
  var AxiosError = requireAxiosError();
  var CanceledError = requireCanceledError();
  var isHttps = /https:?/;
  var supportedProtocols = ["http:", "https:", "file:"];
  function setProxy(options, proxy, location) {
    options.hostname = proxy.host;
    options.host = proxy.host;
    options.port = proxy.port;
    options.path = location;
    if (proxy.auth) {
      var base642 = Buffer.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base642;
    }
    options.beforeRedirect = function beforeRedirect(redirection) {
      redirection.headers.host = redirection.host;
      setProxy(redirection, proxy, redirection.href);
    };
  }
  http_1 = function httpAdapter(config) {
    return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
      var onCanceled;
      function done() {
        if (config.cancelToken) {
          config.cancelToken.unsubscribe(onCanceled);
        }
        if (config.signal) {
          config.signal.removeEventListener("abort", onCanceled);
        }
      }
      var resolve = function resolve2(value) {
        done();
        resolvePromise(value);
      };
      var rejected = false;
      var reject = function reject2(value) {
        done();
        rejected = true;
        rejectPromise(value);
      };
      var data2 = config.data;
      var headers = config.headers;
      var headerNames = {};
      Object.keys(headers).forEach(function storeLowerName(name) {
        headerNames[name.toLowerCase()] = name;
      });
      if ("user-agent" in headerNames) {
        if (!headers[headerNames["user-agent"]]) {
          delete headers[headerNames["user-agent"]];
        }
      } else {
        headers["User-Agent"] = "axios/" + VERSION;
      }
      if (utils2.isFormData(data2) && utils2.isFunction(data2.getHeaders)) {
        Object.assign(headers, data2.getHeaders());
      } else if (data2 && !utils2.isStream(data2)) {
        if (Buffer.isBuffer(data2)) ;
        else if (utils2.isArrayBuffer(data2)) {
          data2 = Buffer.from(new Uint8Array(data2));
        } else if (utils2.isString(data2)) {
          data2 = Buffer.from(data2, "utf-8");
        } else {
          return reject(new AxiosError(
            "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
            AxiosError.ERR_BAD_REQUEST,
            config
          ));
        }
        if (config.maxBodyLength > -1 && data2.length > config.maxBodyLength) {
          return reject(new AxiosError(
            "Request body larger than maxBodyLength limit",
            AxiosError.ERR_BAD_REQUEST,
            config
          ));
        }
        if (!headerNames["content-length"]) {
          headers["Content-Length"] = data2.length;
        }
      }
      var auth2 = void 0;
      if (config.auth) {
        var username = config.auth.username || "";
        var password = config.auth.password || "";
        auth2 = username + ":" + password;
      }
      var fullPath = buildFullPath2(config.baseURL, config.url);
      var parsed = url.parse(fullPath);
      var protocol = parsed.protocol || supportedProtocols[0];
      if (supportedProtocols.indexOf(protocol) === -1) {
        return reject(new AxiosError(
          "Unsupported protocol " + protocol,
          AxiosError.ERR_BAD_REQUEST,
          config
        ));
      }
      if (!auth2 && parsed.auth) {
        var urlAuth = parsed.auth.split(":");
        var urlUsername = urlAuth[0] || "";
        var urlPassword = urlAuth[1] || "";
        auth2 = urlUsername + ":" + urlPassword;
      }
      if (auth2 && headerNames.authorization) {
        delete headers[headerNames.authorization];
      }
      var isHttpsRequest = isHttps.test(protocol);
      var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
      try {
        buildURL2(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, "");
      } catch (err) {
        var customErr = new Error(err.message);
        customErr.config = config;
        customErr.url = config.url;
        customErr.exists = true;
        reject(customErr);
      }
      var options = {
        path: buildURL2(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ""),
        method: config.method.toUpperCase(),
        headers,
        agent,
        agents: { http: config.httpAgent, https: config.httpsAgent },
        auth: auth2
      };
      if (config.socketPath) {
        options.socketPath = config.socketPath;
      } else {
        options.hostname = parsed.hostname;
        options.port = parsed.port;
      }
      var proxy = config.proxy;
      if (!proxy && proxy !== false) {
        var proxyEnv = protocol.slice(0, -1) + "_proxy";
        var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
        if (proxyUrl) {
          var parsedProxyUrl = url.parse(proxyUrl);
          var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
          var shouldProxy = true;
          if (noProxyEnv) {
            var noProxy = noProxyEnv.split(",").map(function trim(s) {
              return s.trim();
            });
            shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
              if (!proxyElement) {
                return false;
              }
              if (proxyElement === "*") {
                return true;
              }
              if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                return true;
              }
              return parsed.hostname === proxyElement;
            });
          }
          if (shouldProxy) {
            proxy = {
              host: parsedProxyUrl.hostname,
              port: parsedProxyUrl.port,
              protocol: parsedProxyUrl.protocol
            };
            if (parsedProxyUrl.auth) {
              var proxyUrlAuth = parsedProxyUrl.auth.split(":");
              proxy.auth = {
                username: proxyUrlAuth[0],
                password: proxyUrlAuth[1]
              };
            }
          }
        }
      }
      if (proxy) {
        options.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "");
        setProxy(options, proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
      }
      var transport;
      var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
      if (config.transport) {
        transport = config.transport;
      } else if (config.maxRedirects === 0) {
        transport = isHttpsProxy ? https2 : http;
      } else {
        if (config.maxRedirects) {
          options.maxRedirects = config.maxRedirects;
        }
        if (config.beforeRedirect) {
          options.beforeRedirect = config.beforeRedirect;
        }
        transport = isHttpsProxy ? httpsFollow : httpFollow;
      }
      if (config.maxBodyLength > -1) {
        options.maxBodyLength = config.maxBodyLength;
      }
      if (config.insecureHTTPParser) {
        options.insecureHTTPParser = config.insecureHTTPParser;
      }
      var req = transport.request(options, function handleResponse(res) {
        if (req.aborted) return;
        var stream = res;
        var lastRequest = res.req || req;
        if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config.decompress !== false) {
          switch (res.headers["content-encoding"]) {
            /*eslint default-case:0*/
            case "gzip":
            case "compress":
            case "deflate":
              stream = stream.pipe(zlib.createUnzip());
              delete res.headers["content-encoding"];
              break;
          }
        }
        var response = {
          status: res.statusCode,
          statusText: res.statusMessage,
          headers: res.headers,
          config,
          request: lastRequest
        };
        if (config.responseType === "stream") {
          response.data = stream;
          settle2(resolve, reject, response);
        } else {
          var responseBuffer = [];
          var totalResponseBytes = 0;
          stream.on("data", function handleStreamData(chunk) {
            responseBuffer.push(chunk);
            totalResponseBytes += chunk.length;
            if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
              rejected = true;
              stream.destroy();
              reject(new AxiosError(
                "maxContentLength size of " + config.maxContentLength + " exceeded",
                AxiosError.ERR_BAD_RESPONSE,
                config,
                lastRequest
              ));
            }
          });
          stream.on("aborted", function handlerStreamAborted() {
            if (rejected) {
              return;
            }
            stream.destroy();
            reject(new AxiosError(
              "maxContentLength size of " + config.maxContentLength + " exceeded",
              AxiosError.ERR_BAD_RESPONSE,
              config,
              lastRequest
            ));
          });
          stream.on("error", function handleStreamError(err) {
            if (req.aborted) return;
            reject(AxiosError.from(err, null, config, lastRequest));
          });
          stream.on("end", function handleStreamEnd() {
            try {
              var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
              if (config.responseType !== "arraybuffer") {
                responseData = responseData.toString(config.responseEncoding);
                if (!config.responseEncoding || config.responseEncoding === "utf8") {
                  responseData = utils2.stripBOM(responseData);
                }
              }
              response.data = responseData;
            } catch (err) {
              reject(AxiosError.from(err, null, config, response.request, response));
            }
            settle2(resolve, reject, response);
          });
        }
      });
      req.on("error", function handleRequestError(err) {
        reject(AxiosError.from(err, null, config, req));
      });
      req.on("socket", function handleRequestSocket(socket) {
        socket.setKeepAlive(true, 1e3 * 60);
      });
      if (config.timeout) {
        var timeout = parseInt(config.timeout, 10);
        if (isNaN(timeout)) {
          reject(new AxiosError(
            "error trying to parse `config.timeout` to int",
            AxiosError.ERR_BAD_OPTION_VALUE,
            config,
            req
          ));
          return;
        }
        req.setTimeout(timeout, function handleRequestTimeout() {
          req.abort();
          var transitional2 = config.transitional || transitionalDefaults;
          reject(new AxiosError(
            "timeout of " + timeout + "ms exceeded",
            transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            req
          ));
        });
      }
      if (config.cancelToken || config.signal) {
        onCanceled = function(cancel) {
          if (req.aborted) return;
          req.abort();
          reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);
        };
        config.cancelToken && config.cancelToken.subscribe(onCanceled);
        if (config.signal) {
          config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
        }
      }
      if (utils2.isStream(data2)) {
        data2.on("error", function handleStreamError(err) {
          reject(AxiosError.from(err, config, null, req));
        }).pipe(req);
      } else {
        req.end(data2);
      }
    });
  };
  return http_1;
}
var delayed_stream;
var hasRequiredDelayed_stream;
function requireDelayed_stream() {
  if (hasRequiredDelayed_stream) return delayed_stream;
  hasRequiredDelayed_stream = 1;
  var Stream = require$$3.Stream;
  var util = require$$1$1;
  delayed_stream = DelayedStream;
  function DelayedStream() {
    this.source = null;
    this.dataSize = 0;
    this.maxDataSize = 1024 * 1024;
    this.pauseStream = true;
    this._maxDataSizeExceeded = false;
    this._released = false;
    this._bufferedEvents = [];
  }
  util.inherits(DelayedStream, Stream);
  DelayedStream.create = function(source, options) {
    var delayedStream = new this();
    options = options || {};
    for (var option in options) {
      delayedStream[option] = options[option];
    }
    delayedStream.source = source;
    var realEmit = source.emit;
    source.emit = function() {
      delayedStream._handleEmit(arguments);
      return realEmit.apply(source, arguments);
    };
    source.on("error", function() {
    });
    if (delayedStream.pauseStream) {
      source.pause();
    }
    return delayedStream;
  };
  Object.defineProperty(DelayedStream.prototype, "readable", {
    configurable: true,
    enumerable: true,
    get: function() {
      return this.source.readable;
    }
  });
  DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
  };
  DelayedStream.prototype.resume = function() {
    if (!this._released) {
      this.release();
    }
    this.source.resume();
  };
  DelayedStream.prototype.pause = function() {
    this.source.pause();
  };
  DelayedStream.prototype.release = function() {
    this._released = true;
    this._bufferedEvents.forEach(function(args) {
      this.emit.apply(this, args);
    }.bind(this));
    this._bufferedEvents = [];
  };
  DelayedStream.prototype.pipe = function() {
    var r = Stream.prototype.pipe.apply(this, arguments);
    this.resume();
    return r;
  };
  DelayedStream.prototype._handleEmit = function(args) {
    if (this._released) {
      this.emit.apply(this, args);
      return;
    }
    if (args[0] === "data") {
      this.dataSize += args[1].length;
      this._checkIfMaxDataSizeExceeded();
    }
    this._bufferedEvents.push(args);
  };
  DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (this._maxDataSizeExceeded) {
      return;
    }
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    this._maxDataSizeExceeded = true;
    var message2 = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this.emit("error", new Error(message2));
  };
  return delayed_stream;
}
var combined_stream;
var hasRequiredCombined_stream;
function requireCombined_stream() {
  if (hasRequiredCombined_stream) return combined_stream;
  hasRequiredCombined_stream = 1;
  var util = require$$1$1;
  var Stream = require$$3.Stream;
  var DelayedStream = requireDelayed_stream();
  combined_stream = CombinedStream;
  function CombinedStream() {
    this.writable = false;
    this.readable = true;
    this.dataSize = 0;
    this.maxDataSize = 2 * 1024 * 1024;
    this.pauseStreams = true;
    this._released = false;
    this._streams = [];
    this._currentStream = null;
    this._insideLoop = false;
    this._pendingNext = false;
  }
  util.inherits(CombinedStream, Stream);
  CombinedStream.create = function(options) {
    var combinedStream = new this();
    options = options || {};
    for (var option in options) {
      combinedStream[option] = options[option];
    }
    return combinedStream;
  };
  CombinedStream.isStreamLike = function(stream) {
    return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
  };
  CombinedStream.prototype.append = function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      if (!(stream instanceof DelayedStream)) {
        var newStream = DelayedStream.create(stream, {
          maxDataSize: Infinity,
          pauseStream: this.pauseStreams
        });
        stream.on("data", this._checkDataSize.bind(this));
        stream = newStream;
      }
      this._handleErrors(stream);
      if (this.pauseStreams) {
        stream.pause();
      }
    }
    this._streams.push(stream);
    return this;
  };
  CombinedStream.prototype.pipe = function(dest, options) {
    Stream.prototype.pipe.call(this, dest, options);
    this.resume();
    return dest;
  };
  CombinedStream.prototype._getNext = function() {
    this._currentStream = null;
    if (this._insideLoop) {
      this._pendingNext = true;
      return;
    }
    this._insideLoop = true;
    try {
      do {
        this._pendingNext = false;
        this._realGetNext();
      } while (this._pendingNext);
    } finally {
      this._insideLoop = false;
    }
  };
  CombinedStream.prototype._realGetNext = function() {
    var stream = this._streams.shift();
    if (typeof stream == "undefined") {
      this.end();
      return;
    }
    if (typeof stream !== "function") {
      this._pipeNext(stream);
      return;
    }
    var getStream = stream;
    getStream(function(stream2) {
      var isStreamLike = CombinedStream.isStreamLike(stream2);
      if (isStreamLike) {
        stream2.on("data", this._checkDataSize.bind(this));
        this._handleErrors(stream2);
      }
      this._pipeNext(stream2);
    }.bind(this));
  };
  CombinedStream.prototype._pipeNext = function(stream) {
    this._currentStream = stream;
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on("end", this._getNext.bind(this));
      stream.pipe(this, { end: false });
      return;
    }
    var value = stream;
    this.write(value);
    this._getNext();
  };
  CombinedStream.prototype._handleErrors = function(stream) {
    var self2 = this;
    stream.on("error", function(err) {
      self2._emitError(err);
    });
  };
  CombinedStream.prototype.write = function(data2) {
    this.emit("data", data2);
  };
  CombinedStream.prototype.pause = function() {
    if (!this.pauseStreams) {
      return;
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
    this.emit("pause");
  };
  CombinedStream.prototype.resume = function() {
    if (!this._released) {
      this._released = true;
      this.writable = true;
      this._getNext();
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
    this.emit("resume");
  };
  CombinedStream.prototype.end = function() {
    this._reset();
    this.emit("end");
  };
  CombinedStream.prototype.destroy = function() {
    this._reset();
    this.emit("close");
  };
  CombinedStream.prototype._reset = function() {
    this.writable = false;
    this._streams = [];
    this._currentStream = null;
  };
  CombinedStream.prototype._checkDataSize = function() {
    this._updateDataSize();
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    var message2 = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this._emitError(new Error(message2));
  };
  CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self2 = this;
    this._streams.forEach(function(stream) {
      if (!stream.dataSize) {
        return;
      }
      self2.dataSize += stream.dataSize;
    });
    if (this._currentStream && this._currentStream.dataSize) {
      this.dataSize += this._currentStream.dataSize;
    }
  };
  CombinedStream.prototype._emitError = function(err) {
    this._reset();
    this.emit("error", err);
  };
  return combined_stream;
}
var mimeTypes = {};
const require$$0 = {
  "application/1d-interleaved-parityfec": { "source": "iana" },
  "application/3gpdash-qoe-report+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/3gpp-ims+xml": { "source": "iana", "compressible": true },
  "application/3gpphal+json": { "source": "iana", "compressible": true },
  "application/3gpphalforms+json": { "source": "iana", "compressible": true },
  "application/a2l": { "source": "iana" },
  "application/ace+cbor": { "source": "iana" },
  "application/activemessage": { "source": "iana" },
  "application/activity+json": { "source": "iana", "compressible": true },
  "application/alto-costmap+json": { "source": "iana", "compressible": true },
  "application/alto-costmapfilter+json": { "source": "iana", "compressible": true },
  "application/alto-directory+json": { "source": "iana", "compressible": true },
  "application/alto-endpointcost+json": { "source": "iana", "compressible": true },
  "application/alto-endpointcostparams+json": { "source": "iana", "compressible": true },
  "application/alto-endpointprop+json": { "source": "iana", "compressible": true },
  "application/alto-endpointpropparams+json": { "source": "iana", "compressible": true },
  "application/alto-error+json": { "source": "iana", "compressible": true },
  "application/alto-networkmap+json": { "source": "iana", "compressible": true },
  "application/alto-networkmapfilter+json": { "source": "iana", "compressible": true },
  "application/alto-updatestreamcontrol+json": { "source": "iana", "compressible": true },
  "application/alto-updatestreamparams+json": { "source": "iana", "compressible": true },
  "application/aml": { "source": "iana" },
  "application/andrew-inset": { "source": "iana", "extensions": ["ez"] },
  "application/applefile": { "source": "iana" },
  "application/applixware": { "source": "apache", "extensions": ["aw"] },
  "application/at+jwt": { "source": "iana" },
  "application/atf": { "source": "iana" },
  "application/atfx": { "source": "iana" },
  "application/atom+xml": { "source": "iana", "compressible": true, "extensions": ["atom"] },
  "application/atomcat+xml": { "source": "iana", "compressible": true, "extensions": ["atomcat"] },
  "application/atomdeleted+xml": { "source": "iana", "compressible": true, "extensions": ["atomdeleted"] },
  "application/atomicmail": { "source": "iana" },
  "application/atomsvc+xml": { "source": "iana", "compressible": true, "extensions": ["atomsvc"] },
  "application/atsc-dwd+xml": { "source": "iana", "compressible": true, "extensions": ["dwd"] },
  "application/atsc-dynamic-event-message": { "source": "iana" },
  "application/atsc-held+xml": { "source": "iana", "compressible": true, "extensions": ["held"] },
  "application/atsc-rdt+json": { "source": "iana", "compressible": true },
  "application/atsc-rsat+xml": { "source": "iana", "compressible": true, "extensions": ["rsat"] },
  "application/atxml": { "source": "iana" },
  "application/auth-policy+xml": { "source": "iana", "compressible": true },
  "application/bacnet-xdd+zip": { "source": "iana", "compressible": false },
  "application/batch-smtp": { "source": "iana" },
  "application/bdoc": { "compressible": false, "extensions": ["bdoc"] },
  "application/beep+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/calendar+json": { "source": "iana", "compressible": true },
  "application/calendar+xml": { "source": "iana", "compressible": true, "extensions": ["xcs"] },
  "application/call-completion": { "source": "iana" },
  "application/cals-1840": { "source": "iana" },
  "application/captive+json": { "source": "iana", "compressible": true },
  "application/cbor": { "source": "iana" },
  "application/cbor-seq": { "source": "iana" },
  "application/cccex": { "source": "iana" },
  "application/ccmp+xml": { "source": "iana", "compressible": true },
  "application/ccxml+xml": { "source": "iana", "compressible": true, "extensions": ["ccxml"] },
  "application/cdfx+xml": { "source": "iana", "compressible": true, "extensions": ["cdfx"] },
  "application/cdmi-capability": { "source": "iana", "extensions": ["cdmia"] },
  "application/cdmi-container": { "source": "iana", "extensions": ["cdmic"] },
  "application/cdmi-domain": { "source": "iana", "extensions": ["cdmid"] },
  "application/cdmi-object": { "source": "iana", "extensions": ["cdmio"] },
  "application/cdmi-queue": { "source": "iana", "extensions": ["cdmiq"] },
  "application/cdni": { "source": "iana" },
  "application/cea": { "source": "iana" },
  "application/cea-2018+xml": { "source": "iana", "compressible": true },
  "application/cellml+xml": { "source": "iana", "compressible": true },
  "application/cfw": { "source": "iana" },
  "application/city+json": { "source": "iana", "compressible": true },
  "application/clr": { "source": "iana" },
  "application/clue+xml": { "source": "iana", "compressible": true },
  "application/clue_info+xml": { "source": "iana", "compressible": true },
  "application/cms": { "source": "iana" },
  "application/cnrp+xml": { "source": "iana", "compressible": true },
  "application/coap-group+json": { "source": "iana", "compressible": true },
  "application/coap-payload": { "source": "iana" },
  "application/commonground": { "source": "iana" },
  "application/conference-info+xml": { "source": "iana", "compressible": true },
  "application/cose": { "source": "iana" },
  "application/cose-key": { "source": "iana" },
  "application/cose-key-set": { "source": "iana" },
  "application/cpl+xml": { "source": "iana", "compressible": true, "extensions": ["cpl"] },
  "application/csrattrs": { "source": "iana" },
  "application/csta+xml": { "source": "iana", "compressible": true },
  "application/cstadata+xml": { "source": "iana", "compressible": true },
  "application/csvm+json": { "source": "iana", "compressible": true },
  "application/cu-seeme": { "source": "apache", "extensions": ["cu"] },
  "application/cwt": { "source": "iana" },
  "application/cybercash": { "source": "iana" },
  "application/dart": { "compressible": true },
  "application/dash+xml": { "source": "iana", "compressible": true, "extensions": ["mpd"] },
  "application/dash-patch+xml": { "source": "iana", "compressible": true, "extensions": ["mpp"] },
  "application/dashdelta": { "source": "iana" },
  "application/davmount+xml": { "source": "iana", "compressible": true, "extensions": ["davmount"] },
  "application/dca-rft": { "source": "iana" },
  "application/dcd": { "source": "iana" },
  "application/dec-dx": { "source": "iana" },
  "application/dialog-info+xml": { "source": "iana", "compressible": true },
  "application/dicom": { "source": "iana" },
  "application/dicom+json": { "source": "iana", "compressible": true },
  "application/dicom+xml": { "source": "iana", "compressible": true },
  "application/dii": { "source": "iana" },
  "application/dit": { "source": "iana" },
  "application/dns": { "source": "iana" },
  "application/dns+json": { "source": "iana", "compressible": true },
  "application/dns-message": { "source": "iana" },
  "application/docbook+xml": { "source": "apache", "compressible": true, "extensions": ["dbk"] },
  "application/dots+cbor": { "source": "iana" },
  "application/dskpp+xml": { "source": "iana", "compressible": true },
  "application/dssc+der": { "source": "iana", "extensions": ["dssc"] },
  "application/dssc+xml": { "source": "iana", "compressible": true, "extensions": ["xdssc"] },
  "application/dvcs": { "source": "iana" },
  "application/ecmascript": { "source": "iana", "compressible": true, "extensions": ["es", "ecma"] },
  "application/edi-consent": { "source": "iana" },
  "application/edi-x12": { "source": "iana", "compressible": false },
  "application/edifact": { "source": "iana", "compressible": false },
  "application/efi": { "source": "iana" },
  "application/elm+json": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/elm+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.cap+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/emergencycalldata.comment+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.control+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.deviceinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.ecall.msd": { "source": "iana" },
  "application/emergencycalldata.providerinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.serviceinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.subscriberinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.veds+xml": { "source": "iana", "compressible": true },
  "application/emma+xml": { "source": "iana", "compressible": true, "extensions": ["emma"] },
  "application/emotionml+xml": { "source": "iana", "compressible": true, "extensions": ["emotionml"] },
  "application/encaprtp": { "source": "iana" },
  "application/epp+xml": { "source": "iana", "compressible": true },
  "application/epub+zip": { "source": "iana", "compressible": false, "extensions": ["epub"] },
  "application/eshop": { "source": "iana" },
  "application/exi": { "source": "iana", "extensions": ["exi"] },
  "application/expect-ct-report+json": { "source": "iana", "compressible": true },
  "application/express": { "source": "iana", "extensions": ["exp"] },
  "application/fastinfoset": { "source": "iana" },
  "application/fastsoap": { "source": "iana" },
  "application/fdt+xml": { "source": "iana", "compressible": true, "extensions": ["fdt"] },
  "application/fhir+json": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/fhir+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/fido.trusted-apps+json": { "compressible": true },
  "application/fits": { "source": "iana" },
  "application/flexfec": { "source": "iana" },
  "application/font-sfnt": { "source": "iana" },
  "application/font-tdpfr": { "source": "iana", "extensions": ["pfr"] },
  "application/font-woff": { "source": "iana", "compressible": false },
  "application/framework-attributes+xml": { "source": "iana", "compressible": true },
  "application/geo+json": { "source": "iana", "compressible": true, "extensions": ["geojson"] },
  "application/geo+json-seq": { "source": "iana" },
  "application/geopackage+sqlite3": { "source": "iana" },
  "application/geoxacml+xml": { "source": "iana", "compressible": true },
  "application/gltf-buffer": { "source": "iana" },
  "application/gml+xml": { "source": "iana", "compressible": true, "extensions": ["gml"] },
  "application/gpx+xml": { "source": "apache", "compressible": true, "extensions": ["gpx"] },
  "application/gxf": { "source": "apache", "extensions": ["gxf"] },
  "application/gzip": { "source": "iana", "compressible": false, "extensions": ["gz"] },
  "application/h224": { "source": "iana" },
  "application/held+xml": { "source": "iana", "compressible": true },
  "application/hjson": { "extensions": ["hjson"] },
  "application/http": { "source": "iana" },
  "application/hyperstudio": { "source": "iana", "extensions": ["stk"] },
  "application/ibe-key-request+xml": { "source": "iana", "compressible": true },
  "application/ibe-pkg-reply+xml": { "source": "iana", "compressible": true },
  "application/ibe-pp-data": { "source": "iana" },
  "application/iges": { "source": "iana" },
  "application/im-iscomposing+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/index": { "source": "iana" },
  "application/index.cmd": { "source": "iana" },
  "application/index.obj": { "source": "iana" },
  "application/index.response": { "source": "iana" },
  "application/index.vnd": { "source": "iana" },
  "application/inkml+xml": { "source": "iana", "compressible": true, "extensions": ["ink", "inkml"] },
  "application/iotp": { "source": "iana" },
  "application/ipfix": { "source": "iana", "extensions": ["ipfix"] },
  "application/ipp": { "source": "iana" },
  "application/isup": { "source": "iana" },
  "application/its+xml": { "source": "iana", "compressible": true, "extensions": ["its"] },
  "application/java-archive": { "source": "apache", "compressible": false, "extensions": ["jar", "war", "ear"] },
  "application/java-serialized-object": { "source": "apache", "compressible": false, "extensions": ["ser"] },
  "application/java-vm": { "source": "apache", "compressible": false, "extensions": ["class"] },
  "application/javascript": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["js", "mjs"] },
  "application/jf2feed+json": { "source": "iana", "compressible": true },
  "application/jose": { "source": "iana" },
  "application/jose+json": { "source": "iana", "compressible": true },
  "application/jrd+json": { "source": "iana", "compressible": true },
  "application/jscalendar+json": { "source": "iana", "compressible": true },
  "application/json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["json", "map"] },
  "application/json-patch+json": { "source": "iana", "compressible": true },
  "application/json-seq": { "source": "iana" },
  "application/json5": { "extensions": ["json5"] },
  "application/jsonml+json": { "source": "apache", "compressible": true, "extensions": ["jsonml"] },
  "application/jwk+json": { "source": "iana", "compressible": true },
  "application/jwk-set+json": { "source": "iana", "compressible": true },
  "application/jwt": { "source": "iana" },
  "application/kpml-request+xml": { "source": "iana", "compressible": true },
  "application/kpml-response+xml": { "source": "iana", "compressible": true },
  "application/ld+json": { "source": "iana", "compressible": true, "extensions": ["jsonld"] },
  "application/lgr+xml": { "source": "iana", "compressible": true, "extensions": ["lgr"] },
  "application/link-format": { "source": "iana" },
  "application/load-control+xml": { "source": "iana", "compressible": true },
  "application/lost+xml": { "source": "iana", "compressible": true, "extensions": ["lostxml"] },
  "application/lostsync+xml": { "source": "iana", "compressible": true },
  "application/lpf+zip": { "source": "iana", "compressible": false },
  "application/lxf": { "source": "iana" },
  "application/mac-binhex40": { "source": "iana", "extensions": ["hqx"] },
  "application/mac-compactpro": { "source": "apache", "extensions": ["cpt"] },
  "application/macwriteii": { "source": "iana" },
  "application/mads+xml": { "source": "iana", "compressible": true, "extensions": ["mads"] },
  "application/manifest+json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["webmanifest"] },
  "application/marc": { "source": "iana", "extensions": ["mrc"] },
  "application/marcxml+xml": { "source": "iana", "compressible": true, "extensions": ["mrcx"] },
  "application/mathematica": { "source": "iana", "extensions": ["ma", "nb", "mb"] },
  "application/mathml+xml": { "source": "iana", "compressible": true, "extensions": ["mathml"] },
  "application/mathml-content+xml": { "source": "iana", "compressible": true },
  "application/mathml-presentation+xml": { "source": "iana", "compressible": true },
  "application/mbms-associated-procedure-description+xml": { "source": "iana", "compressible": true },
  "application/mbms-deregister+xml": { "source": "iana", "compressible": true },
  "application/mbms-envelope+xml": { "source": "iana", "compressible": true },
  "application/mbms-msk+xml": { "source": "iana", "compressible": true },
  "application/mbms-msk-response+xml": { "source": "iana", "compressible": true },
  "application/mbms-protection-description+xml": { "source": "iana", "compressible": true },
  "application/mbms-reception-report+xml": { "source": "iana", "compressible": true },
  "application/mbms-register+xml": { "source": "iana", "compressible": true },
  "application/mbms-register-response+xml": { "source": "iana", "compressible": true },
  "application/mbms-schedule+xml": { "source": "iana", "compressible": true },
  "application/mbms-user-service-description+xml": { "source": "iana", "compressible": true },
  "application/mbox": { "source": "iana", "extensions": ["mbox"] },
  "application/media-policy-dataset+xml": { "source": "iana", "compressible": true, "extensions": ["mpf"] },
  "application/media_control+xml": { "source": "iana", "compressible": true },
  "application/mediaservercontrol+xml": { "source": "iana", "compressible": true, "extensions": ["mscml"] },
  "application/merge-patch+json": { "source": "iana", "compressible": true },
  "application/metalink+xml": { "source": "apache", "compressible": true, "extensions": ["metalink"] },
  "application/metalink4+xml": { "source": "iana", "compressible": true, "extensions": ["meta4"] },
  "application/mets+xml": { "source": "iana", "compressible": true, "extensions": ["mets"] },
  "application/mf4": { "source": "iana" },
  "application/mikey": { "source": "iana" },
  "application/mipc": { "source": "iana" },
  "application/missing-blocks+cbor-seq": { "source": "iana" },
  "application/mmt-aei+xml": { "source": "iana", "compressible": true, "extensions": ["maei"] },
  "application/mmt-usd+xml": { "source": "iana", "compressible": true, "extensions": ["musd"] },
  "application/mods+xml": { "source": "iana", "compressible": true, "extensions": ["mods"] },
  "application/moss-keys": { "source": "iana" },
  "application/moss-signature": { "source": "iana" },
  "application/mosskey-data": { "source": "iana" },
  "application/mosskey-request": { "source": "iana" },
  "application/mp21": { "source": "iana", "extensions": ["m21", "mp21"] },
  "application/mp4": { "source": "iana", "extensions": ["mp4s", "m4p"] },
  "application/mpeg4-generic": { "source": "iana" },
  "application/mpeg4-iod": { "source": "iana" },
  "application/mpeg4-iod-xmt": { "source": "iana" },
  "application/mrb-consumer+xml": { "source": "iana", "compressible": true },
  "application/mrb-publish+xml": { "source": "iana", "compressible": true },
  "application/msc-ivr+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/msc-mixer+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/msword": { "source": "iana", "compressible": false, "extensions": ["doc", "dot"] },
  "application/mud+json": { "source": "iana", "compressible": true },
  "application/multipart-core": { "source": "iana" },
  "application/mxf": { "source": "iana", "extensions": ["mxf"] },
  "application/n-quads": { "source": "iana", "extensions": ["nq"] },
  "application/n-triples": { "source": "iana", "extensions": ["nt"] },
  "application/nasdata": { "source": "iana" },
  "application/news-checkgroups": { "source": "iana", "charset": "US-ASCII" },
  "application/news-groupinfo": { "source": "iana", "charset": "US-ASCII" },
  "application/news-transmission": { "source": "iana" },
  "application/nlsml+xml": { "source": "iana", "compressible": true },
  "application/node": { "source": "iana", "extensions": ["cjs"] },
  "application/nss": { "source": "iana" },
  "application/oauth-authz-req+jwt": { "source": "iana" },
  "application/oblivious-dns-message": { "source": "iana" },
  "application/ocsp-request": { "source": "iana" },
  "application/ocsp-response": { "source": "iana" },
  "application/octet-stream": { "source": "iana", "compressible": false, "extensions": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"] },
  "application/oda": { "source": "iana", "extensions": ["oda"] },
  "application/odm+xml": { "source": "iana", "compressible": true },
  "application/odx": { "source": "iana" },
  "application/oebps-package+xml": { "source": "iana", "compressible": true, "extensions": ["opf"] },
  "application/ogg": { "source": "iana", "compressible": false, "extensions": ["ogx"] },
  "application/omdoc+xml": { "source": "apache", "compressible": true, "extensions": ["omdoc"] },
  "application/onenote": { "source": "apache", "extensions": ["onetoc", "onetoc2", "onetmp", "onepkg"] },
  "application/opc-nodeset+xml": { "source": "iana", "compressible": true },
  "application/oscore": { "source": "iana" },
  "application/oxps": { "source": "iana", "extensions": ["oxps"] },
  "application/p21": { "source": "iana" },
  "application/p21+zip": { "source": "iana", "compressible": false },
  "application/p2p-overlay+xml": { "source": "iana", "compressible": true, "extensions": ["relo"] },
  "application/parityfec": { "source": "iana" },
  "application/passport": { "source": "iana" },
  "application/patch-ops-error+xml": { "source": "iana", "compressible": true, "extensions": ["xer"] },
  "application/pdf": { "source": "iana", "compressible": false, "extensions": ["pdf"] },
  "application/pdx": { "source": "iana" },
  "application/pem-certificate-chain": { "source": "iana" },
  "application/pgp-encrypted": { "source": "iana", "compressible": false, "extensions": ["pgp"] },
  "application/pgp-keys": { "source": "iana", "extensions": ["asc"] },
  "application/pgp-signature": { "source": "iana", "extensions": ["asc", "sig"] },
  "application/pics-rules": { "source": "apache", "extensions": ["prf"] },
  "application/pidf+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/pidf-diff+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/pkcs10": { "source": "iana", "extensions": ["p10"] },
  "application/pkcs12": { "source": "iana" },
  "application/pkcs7-mime": { "source": "iana", "extensions": ["p7m", "p7c"] },
  "application/pkcs7-signature": { "source": "iana", "extensions": ["p7s"] },
  "application/pkcs8": { "source": "iana", "extensions": ["p8"] },
  "application/pkcs8-encrypted": { "source": "iana" },
  "application/pkix-attr-cert": { "source": "iana", "extensions": ["ac"] },
  "application/pkix-cert": { "source": "iana", "extensions": ["cer"] },
  "application/pkix-crl": { "source": "iana", "extensions": ["crl"] },
  "application/pkix-pkipath": { "source": "iana", "extensions": ["pkipath"] },
  "application/pkixcmp": { "source": "iana", "extensions": ["pki"] },
  "application/pls+xml": { "source": "iana", "compressible": true, "extensions": ["pls"] },
  "application/poc-settings+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/postscript": { "source": "iana", "compressible": true, "extensions": ["ai", "eps", "ps"] },
  "application/ppsp-tracker+json": { "source": "iana", "compressible": true },
  "application/problem+json": { "source": "iana", "compressible": true },
  "application/problem+xml": { "source": "iana", "compressible": true },
  "application/provenance+xml": { "source": "iana", "compressible": true, "extensions": ["provx"] },
  "application/prs.alvestrand.titrax-sheet": { "source": "iana" },
  "application/prs.cww": { "source": "iana", "extensions": ["cww"] },
  "application/prs.cyn": { "source": "iana", "charset": "7-BIT" },
  "application/prs.hpub+zip": { "source": "iana", "compressible": false },
  "application/prs.nprend": { "source": "iana" },
  "application/prs.plucker": { "source": "iana" },
  "application/prs.rdf-xml-crypt": { "source": "iana" },
  "application/prs.xsf+xml": { "source": "iana", "compressible": true },
  "application/pskc+xml": { "source": "iana", "compressible": true, "extensions": ["pskcxml"] },
  "application/pvd+json": { "source": "iana", "compressible": true },
  "application/qsig": { "source": "iana" },
  "application/raml+yaml": { "compressible": true, "extensions": ["raml"] },
  "application/raptorfec": { "source": "iana" },
  "application/rdap+json": { "source": "iana", "compressible": true },
  "application/rdf+xml": { "source": "iana", "compressible": true, "extensions": ["rdf", "owl"] },
  "application/reginfo+xml": { "source": "iana", "compressible": true, "extensions": ["rif"] },
  "application/relax-ng-compact-syntax": { "source": "iana", "extensions": ["rnc"] },
  "application/remote-printing": { "source": "iana" },
  "application/reputon+json": { "source": "iana", "compressible": true },
  "application/resource-lists+xml": { "source": "iana", "compressible": true, "extensions": ["rl"] },
  "application/resource-lists-diff+xml": { "source": "iana", "compressible": true, "extensions": ["rld"] },
  "application/rfc+xml": { "source": "iana", "compressible": true },
  "application/riscos": { "source": "iana" },
  "application/rlmi+xml": { "source": "iana", "compressible": true },
  "application/rls-services+xml": { "source": "iana", "compressible": true, "extensions": ["rs"] },
  "application/route-apd+xml": { "source": "iana", "compressible": true, "extensions": ["rapd"] },
  "application/route-s-tsid+xml": { "source": "iana", "compressible": true, "extensions": ["sls"] },
  "application/route-usd+xml": { "source": "iana", "compressible": true, "extensions": ["rusd"] },
  "application/rpki-ghostbusters": { "source": "iana", "extensions": ["gbr"] },
  "application/rpki-manifest": { "source": "iana", "extensions": ["mft"] },
  "application/rpki-publication": { "source": "iana" },
  "application/rpki-roa": { "source": "iana", "extensions": ["roa"] },
  "application/rpki-updown": { "source": "iana" },
  "application/rsd+xml": { "source": "apache", "compressible": true, "extensions": ["rsd"] },
  "application/rss+xml": { "source": "apache", "compressible": true, "extensions": ["rss"] },
  "application/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] },
  "application/rtploopback": { "source": "iana" },
  "application/rtx": { "source": "iana" },
  "application/samlassertion+xml": { "source": "iana", "compressible": true },
  "application/samlmetadata+xml": { "source": "iana", "compressible": true },
  "application/sarif+json": { "source": "iana", "compressible": true },
  "application/sarif-external-properties+json": { "source": "iana", "compressible": true },
  "application/sbe": { "source": "iana" },
  "application/sbml+xml": { "source": "iana", "compressible": true, "extensions": ["sbml"] },
  "application/scaip+xml": { "source": "iana", "compressible": true },
  "application/scim+json": { "source": "iana", "compressible": true },
  "application/scvp-cv-request": { "source": "iana", "extensions": ["scq"] },
  "application/scvp-cv-response": { "source": "iana", "extensions": ["scs"] },
  "application/scvp-vp-request": { "source": "iana", "extensions": ["spq"] },
  "application/scvp-vp-response": { "source": "iana", "extensions": ["spp"] },
  "application/sdp": { "source": "iana", "extensions": ["sdp"] },
  "application/secevent+jwt": { "source": "iana" },
  "application/senml+cbor": { "source": "iana" },
  "application/senml+json": { "source": "iana", "compressible": true },
  "application/senml+xml": { "source": "iana", "compressible": true, "extensions": ["senmlx"] },
  "application/senml-etch+cbor": { "source": "iana" },
  "application/senml-etch+json": { "source": "iana", "compressible": true },
  "application/senml-exi": { "source": "iana" },
  "application/sensml+cbor": { "source": "iana" },
  "application/sensml+json": { "source": "iana", "compressible": true },
  "application/sensml+xml": { "source": "iana", "compressible": true, "extensions": ["sensmlx"] },
  "application/sensml-exi": { "source": "iana" },
  "application/sep+xml": { "source": "iana", "compressible": true },
  "application/sep-exi": { "source": "iana" },
  "application/session-info": { "source": "iana" },
  "application/set-payment": { "source": "iana" },
  "application/set-payment-initiation": { "source": "iana", "extensions": ["setpay"] },
  "application/set-registration": { "source": "iana" },
  "application/set-registration-initiation": { "source": "iana", "extensions": ["setreg"] },
  "application/sgml": { "source": "iana" },
  "application/sgml-open-catalog": { "source": "iana" },
  "application/shf+xml": { "source": "iana", "compressible": true, "extensions": ["shf"] },
  "application/sieve": { "source": "iana", "extensions": ["siv", "sieve"] },
  "application/simple-filter+xml": { "source": "iana", "compressible": true },
  "application/simple-message-summary": { "source": "iana" },
  "application/simplesymbolcontainer": { "source": "iana" },
  "application/sipc": { "source": "iana" },
  "application/slate": { "source": "iana" },
  "application/smil": { "source": "iana" },
  "application/smil+xml": { "source": "iana", "compressible": true, "extensions": ["smi", "smil"] },
  "application/smpte336m": { "source": "iana" },
  "application/soap+fastinfoset": { "source": "iana" },
  "application/soap+xml": { "source": "iana", "compressible": true },
  "application/sparql-query": { "source": "iana", "extensions": ["rq"] },
  "application/sparql-results+xml": { "source": "iana", "compressible": true, "extensions": ["srx"] },
  "application/spdx+json": { "source": "iana", "compressible": true },
  "application/spirits-event+xml": { "source": "iana", "compressible": true },
  "application/sql": { "source": "iana" },
  "application/srgs": { "source": "iana", "extensions": ["gram"] },
  "application/srgs+xml": { "source": "iana", "compressible": true, "extensions": ["grxml"] },
  "application/sru+xml": { "source": "iana", "compressible": true, "extensions": ["sru"] },
  "application/ssdl+xml": { "source": "apache", "compressible": true, "extensions": ["ssdl"] },
  "application/ssml+xml": { "source": "iana", "compressible": true, "extensions": ["ssml"] },
  "application/stix+json": { "source": "iana", "compressible": true },
  "application/swid+xml": { "source": "iana", "compressible": true, "extensions": ["swidtag"] },
  "application/tamp-apex-update": { "source": "iana" },
  "application/tamp-apex-update-confirm": { "source": "iana" },
  "application/tamp-community-update": { "source": "iana" },
  "application/tamp-community-update-confirm": { "source": "iana" },
  "application/tamp-error": { "source": "iana" },
  "application/tamp-sequence-adjust": { "source": "iana" },
  "application/tamp-sequence-adjust-confirm": { "source": "iana" },
  "application/tamp-status-query": { "source": "iana" },
  "application/tamp-status-response": { "source": "iana" },
  "application/tamp-update": { "source": "iana" },
  "application/tamp-update-confirm": { "source": "iana" },
  "application/tar": { "compressible": true },
  "application/taxii+json": { "source": "iana", "compressible": true },
  "application/td+json": { "source": "iana", "compressible": true },
  "application/tei+xml": { "source": "iana", "compressible": true, "extensions": ["tei", "teicorpus"] },
  "application/tetra_isi": { "source": "iana" },
  "application/thraud+xml": { "source": "iana", "compressible": true, "extensions": ["tfi"] },
  "application/timestamp-query": { "source": "iana" },
  "application/timestamp-reply": { "source": "iana" },
  "application/timestamped-data": { "source": "iana", "extensions": ["tsd"] },
  "application/tlsrpt+gzip": { "source": "iana" },
  "application/tlsrpt+json": { "source": "iana", "compressible": true },
  "application/tnauthlist": { "source": "iana" },
  "application/token-introspection+jwt": { "source": "iana" },
  "application/toml": { "compressible": true, "extensions": ["toml"] },
  "application/trickle-ice-sdpfrag": { "source": "iana" },
  "application/trig": { "source": "iana", "extensions": ["trig"] },
  "application/ttml+xml": { "source": "iana", "compressible": true, "extensions": ["ttml"] },
  "application/tve-trigger": { "source": "iana" },
  "application/tzif": { "source": "iana" },
  "application/tzif-leap": { "source": "iana" },
  "application/ubjson": { "compressible": false, "extensions": ["ubj"] },
  "application/ulpfec": { "source": "iana" },
  "application/urc-grpsheet+xml": { "source": "iana", "compressible": true },
  "application/urc-ressheet+xml": { "source": "iana", "compressible": true, "extensions": ["rsheet"] },
  "application/urc-targetdesc+xml": { "source": "iana", "compressible": true, "extensions": ["td"] },
  "application/urc-uisocketdesc+xml": { "source": "iana", "compressible": true },
  "application/vcard+json": { "source": "iana", "compressible": true },
  "application/vcard+xml": { "source": "iana", "compressible": true },
  "application/vemmi": { "source": "iana" },
  "application/vividence.scriptfile": { "source": "apache" },
  "application/vnd.1000minds.decision-model+xml": { "source": "iana", "compressible": true, "extensions": ["1km"] },
  "application/vnd.3gpp-prose+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc3ch+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-v2x-local-service-information": { "source": "iana" },
  "application/vnd.3gpp.5gnas": { "source": "iana" },
  "application/vnd.3gpp.access-transfer-events+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.bsf+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.gmop+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.gtpc": { "source": "iana" },
  "application/vnd.3gpp.interworking-data": { "source": "iana" },
  "application/vnd.3gpp.lpp": { "source": "iana" },
  "application/vnd.3gpp.mc-signalling-ear": { "source": "iana" },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-payload": { "source": "iana" },
  "application/vnd.3gpp.mcdata-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-signalling": { "source": "iana" },
  "application/vnd.3gpp.mcdata-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-floor-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-signed+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mid-call+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.ngap": { "source": "iana" },
  "application/vnd.3gpp.pfcp": { "source": "iana" },
  "application/vnd.3gpp.pic-bw-large": { "source": "iana", "extensions": ["plb"] },
  "application/vnd.3gpp.pic-bw-small": { "source": "iana", "extensions": ["psb"] },
  "application/vnd.3gpp.pic-bw-var": { "source": "iana", "extensions": ["pvb"] },
  "application/vnd.3gpp.s1ap": { "source": "iana" },
  "application/vnd.3gpp.sms": { "source": "iana" },
  "application/vnd.3gpp.sms+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.srvcc-ext+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.srvcc-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.state-and-event-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.ussd+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp2.bcmcsinfo+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp2.sms": { "source": "iana" },
  "application/vnd.3gpp2.tcap": { "source": "iana", "extensions": ["tcap"] },
  "application/vnd.3lightssoftware.imagescal": { "source": "iana" },
  "application/vnd.3m.post-it-notes": { "source": "iana", "extensions": ["pwn"] },
  "application/vnd.accpac.simply.aso": { "source": "iana", "extensions": ["aso"] },
  "application/vnd.accpac.simply.imp": { "source": "iana", "extensions": ["imp"] },
  "application/vnd.acucobol": { "source": "iana", "extensions": ["acu"] },
  "application/vnd.acucorp": { "source": "iana", "extensions": ["atc", "acutc"] },
  "application/vnd.adobe.air-application-installer-package+zip": { "source": "apache", "compressible": false, "extensions": ["air"] },
  "application/vnd.adobe.flash.movie": { "source": "iana" },
  "application/vnd.adobe.formscentral.fcdt": { "source": "iana", "extensions": ["fcdt"] },
  "application/vnd.adobe.fxp": { "source": "iana", "extensions": ["fxp", "fxpl"] },
  "application/vnd.adobe.partial-upload": { "source": "iana" },
  "application/vnd.adobe.xdp+xml": { "source": "iana", "compressible": true, "extensions": ["xdp"] },
  "application/vnd.adobe.xfdf": { "source": "iana", "extensions": ["xfdf"] },
  "application/vnd.aether.imp": { "source": "iana" },
  "application/vnd.afpc.afplinedata": { "source": "iana" },
  "application/vnd.afpc.afplinedata-pagedef": { "source": "iana" },
  "application/vnd.afpc.cmoca-cmresource": { "source": "iana" },
  "application/vnd.afpc.foca-charset": { "source": "iana" },
  "application/vnd.afpc.foca-codedfont": { "source": "iana" },
  "application/vnd.afpc.foca-codepage": { "source": "iana" },
  "application/vnd.afpc.modca": { "source": "iana" },
  "application/vnd.afpc.modca-cmtable": { "source": "iana" },
  "application/vnd.afpc.modca-formdef": { "source": "iana" },
  "application/vnd.afpc.modca-mediummap": { "source": "iana" },
  "application/vnd.afpc.modca-objectcontainer": { "source": "iana" },
  "application/vnd.afpc.modca-overlay": { "source": "iana" },
  "application/vnd.afpc.modca-pagesegment": { "source": "iana" },
  "application/vnd.age": { "source": "iana", "extensions": ["age"] },
  "application/vnd.ah-barcode": { "source": "iana" },
  "application/vnd.ahead.space": { "source": "iana", "extensions": ["ahead"] },
  "application/vnd.airzip.filesecure.azf": { "source": "iana", "extensions": ["azf"] },
  "application/vnd.airzip.filesecure.azs": { "source": "iana", "extensions": ["azs"] },
  "application/vnd.amadeus+json": { "source": "iana", "compressible": true },
  "application/vnd.amazon.ebook": { "source": "apache", "extensions": ["azw"] },
  "application/vnd.amazon.mobi8-ebook": { "source": "iana" },
  "application/vnd.americandynamics.acc": { "source": "iana", "extensions": ["acc"] },
  "application/vnd.amiga.ami": { "source": "iana", "extensions": ["ami"] },
  "application/vnd.amundsen.maze+xml": { "source": "iana", "compressible": true },
  "application/vnd.android.ota": { "source": "iana" },
  "application/vnd.android.package-archive": { "source": "apache", "compressible": false, "extensions": ["apk"] },
  "application/vnd.anki": { "source": "iana" },
  "application/vnd.anser-web-certificate-issue-initiation": { "source": "iana", "extensions": ["cii"] },
  "application/vnd.anser-web-funds-transfer-initiation": { "source": "apache", "extensions": ["fti"] },
  "application/vnd.antix.game-component": { "source": "iana", "extensions": ["atx"] },
  "application/vnd.apache.arrow.file": { "source": "iana" },
  "application/vnd.apache.arrow.stream": { "source": "iana" },
  "application/vnd.apache.thrift.binary": { "source": "iana" },
  "application/vnd.apache.thrift.compact": { "source": "iana" },
  "application/vnd.apache.thrift.json": { "source": "iana" },
  "application/vnd.api+json": { "source": "iana", "compressible": true },
  "application/vnd.aplextor.warrp+json": { "source": "iana", "compressible": true },
  "application/vnd.apothekende.reservation+json": { "source": "iana", "compressible": true },
  "application/vnd.apple.installer+xml": { "source": "iana", "compressible": true, "extensions": ["mpkg"] },
  "application/vnd.apple.keynote": { "source": "iana", "extensions": ["key"] },
  "application/vnd.apple.mpegurl": { "source": "iana", "extensions": ["m3u8"] },
  "application/vnd.apple.numbers": { "source": "iana", "extensions": ["numbers"] },
  "application/vnd.apple.pages": { "source": "iana", "extensions": ["pages"] },
  "application/vnd.apple.pkpass": { "compressible": false, "extensions": ["pkpass"] },
  "application/vnd.arastra.swi": { "source": "iana" },
  "application/vnd.aristanetworks.swi": { "source": "iana", "extensions": ["swi"] },
  "application/vnd.artisan+json": { "source": "iana", "compressible": true },
  "application/vnd.artsquare": { "source": "iana" },
  "application/vnd.astraea-software.iota": { "source": "iana", "extensions": ["iota"] },
  "application/vnd.audiograph": { "source": "iana", "extensions": ["aep"] },
  "application/vnd.autopackage": { "source": "iana" },
  "application/vnd.avalon+json": { "source": "iana", "compressible": true },
  "application/vnd.avistar+xml": { "source": "iana", "compressible": true },
  "application/vnd.balsamiq.bmml+xml": { "source": "iana", "compressible": true, "extensions": ["bmml"] },
  "application/vnd.balsamiq.bmpr": { "source": "iana" },
  "application/vnd.banana-accounting": { "source": "iana" },
  "application/vnd.bbf.usp.error": { "source": "iana" },
  "application/vnd.bbf.usp.msg": { "source": "iana" },
  "application/vnd.bbf.usp.msg+json": { "source": "iana", "compressible": true },
  "application/vnd.bekitzur-stech+json": { "source": "iana", "compressible": true },
  "application/vnd.bint.med-content": { "source": "iana" },
  "application/vnd.biopax.rdf+xml": { "source": "iana", "compressible": true },
  "application/vnd.blink-idb-value-wrapper": { "source": "iana" },
  "application/vnd.blueice.multipass": { "source": "iana", "extensions": ["mpm"] },
  "application/vnd.bluetooth.ep.oob": { "source": "iana" },
  "application/vnd.bluetooth.le.oob": { "source": "iana" },
  "application/vnd.bmi": { "source": "iana", "extensions": ["bmi"] },
  "application/vnd.bpf": { "source": "iana" },
  "application/vnd.bpf3": { "source": "iana" },
  "application/vnd.businessobjects": { "source": "iana", "extensions": ["rep"] },
  "application/vnd.byu.uapi+json": { "source": "iana", "compressible": true },
  "application/vnd.cab-jscript": { "source": "iana" },
  "application/vnd.canon-cpdl": { "source": "iana" },
  "application/vnd.canon-lips": { "source": "iana" },
  "application/vnd.capasystems-pg+json": { "source": "iana", "compressible": true },
  "application/vnd.cendio.thinlinc.clientconf": { "source": "iana" },
  "application/vnd.century-systems.tcp_stream": { "source": "iana" },
  "application/vnd.chemdraw+xml": { "source": "iana", "compressible": true, "extensions": ["cdxml"] },
  "application/vnd.chess-pgn": { "source": "iana" },
  "application/vnd.chipnuts.karaoke-mmd": { "source": "iana", "extensions": ["mmd"] },
  "application/vnd.ciedi": { "source": "iana" },
  "application/vnd.cinderella": { "source": "iana", "extensions": ["cdy"] },
  "application/vnd.cirpack.isdn-ext": { "source": "iana" },
  "application/vnd.citationstyles.style+xml": { "source": "iana", "compressible": true, "extensions": ["csl"] },
  "application/vnd.claymore": { "source": "iana", "extensions": ["cla"] },
  "application/vnd.cloanto.rp9": { "source": "iana", "extensions": ["rp9"] },
  "application/vnd.clonk.c4group": { "source": "iana", "extensions": ["c4g", "c4d", "c4f", "c4p", "c4u"] },
  "application/vnd.cluetrust.cartomobile-config": { "source": "iana", "extensions": ["c11amc"] },
  "application/vnd.cluetrust.cartomobile-config-pkg": { "source": "iana", "extensions": ["c11amz"] },
  "application/vnd.coffeescript": { "source": "iana" },
  "application/vnd.collabio.xodocuments.document": { "source": "iana" },
  "application/vnd.collabio.xodocuments.document-template": { "source": "iana" },
  "application/vnd.collabio.xodocuments.presentation": { "source": "iana" },
  "application/vnd.collabio.xodocuments.presentation-template": { "source": "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet": { "source": "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet-template": { "source": "iana" },
  "application/vnd.collection+json": { "source": "iana", "compressible": true },
  "application/vnd.collection.doc+json": { "source": "iana", "compressible": true },
  "application/vnd.collection.next+json": { "source": "iana", "compressible": true },
  "application/vnd.comicbook+zip": { "source": "iana", "compressible": false },
  "application/vnd.comicbook-rar": { "source": "iana" },
  "application/vnd.commerce-battelle": { "source": "iana" },
  "application/vnd.commonspace": { "source": "iana", "extensions": ["csp"] },
  "application/vnd.contact.cmsg": { "source": "iana", "extensions": ["cdbcmsg"] },
  "application/vnd.coreos.ignition+json": { "source": "iana", "compressible": true },
  "application/vnd.cosmocaller": { "source": "iana", "extensions": ["cmc"] },
  "application/vnd.crick.clicker": { "source": "iana", "extensions": ["clkx"] },
  "application/vnd.crick.clicker.keyboard": { "source": "iana", "extensions": ["clkk"] },
  "application/vnd.crick.clicker.palette": { "source": "iana", "extensions": ["clkp"] },
  "application/vnd.crick.clicker.template": { "source": "iana", "extensions": ["clkt"] },
  "application/vnd.crick.clicker.wordbank": { "source": "iana", "extensions": ["clkw"] },
  "application/vnd.criticaltools.wbs+xml": { "source": "iana", "compressible": true, "extensions": ["wbs"] },
  "application/vnd.cryptii.pipe+json": { "source": "iana", "compressible": true },
  "application/vnd.crypto-shade-file": { "source": "iana" },
  "application/vnd.cryptomator.encrypted": { "source": "iana" },
  "application/vnd.cryptomator.vault": { "source": "iana" },
  "application/vnd.ctc-posml": { "source": "iana", "extensions": ["pml"] },
  "application/vnd.ctct.ws+xml": { "source": "iana", "compressible": true },
  "application/vnd.cups-pdf": { "source": "iana" },
  "application/vnd.cups-postscript": { "source": "iana" },
  "application/vnd.cups-ppd": { "source": "iana", "extensions": ["ppd"] },
  "application/vnd.cups-raster": { "source": "iana" },
  "application/vnd.cups-raw": { "source": "iana" },
  "application/vnd.curl": { "source": "iana" },
  "application/vnd.curl.car": { "source": "apache", "extensions": ["car"] },
  "application/vnd.curl.pcurl": { "source": "apache", "extensions": ["pcurl"] },
  "application/vnd.cyan.dean.root+xml": { "source": "iana", "compressible": true },
  "application/vnd.cybank": { "source": "iana" },
  "application/vnd.cyclonedx+json": { "source": "iana", "compressible": true },
  "application/vnd.cyclonedx+xml": { "source": "iana", "compressible": true },
  "application/vnd.d2l.coursepackage1p0+zip": { "source": "iana", "compressible": false },
  "application/vnd.d3m-dataset": { "source": "iana" },
  "application/vnd.d3m-problem": { "source": "iana" },
  "application/vnd.dart": { "source": "iana", "compressible": true, "extensions": ["dart"] },
  "application/vnd.data-vision.rdz": { "source": "iana", "extensions": ["rdz"] },
  "application/vnd.datapackage+json": { "source": "iana", "compressible": true },
  "application/vnd.dataresource+json": { "source": "iana", "compressible": true },
  "application/vnd.dbf": { "source": "iana", "extensions": ["dbf"] },
  "application/vnd.debian.binary-package": { "source": "iana" },
  "application/vnd.dece.data": { "source": "iana", "extensions": ["uvf", "uvvf", "uvd", "uvvd"] },
  "application/vnd.dece.ttml+xml": { "source": "iana", "compressible": true, "extensions": ["uvt", "uvvt"] },
  "application/vnd.dece.unspecified": { "source": "iana", "extensions": ["uvx", "uvvx"] },
  "application/vnd.dece.zip": { "source": "iana", "extensions": ["uvz", "uvvz"] },
  "application/vnd.denovo.fcselayout-link": { "source": "iana", "extensions": ["fe_launch"] },
  "application/vnd.desmume.movie": { "source": "iana" },
  "application/vnd.dir-bi.plate-dl-nosuffix": { "source": "iana" },
  "application/vnd.dm.delegation+xml": { "source": "iana", "compressible": true },
  "application/vnd.dna": { "source": "iana", "extensions": ["dna"] },
  "application/vnd.document+json": { "source": "iana", "compressible": true },
  "application/vnd.dolby.mlp": { "source": "apache", "extensions": ["mlp"] },
  "application/vnd.dolby.mobile.1": { "source": "iana" },
  "application/vnd.dolby.mobile.2": { "source": "iana" },
  "application/vnd.doremir.scorecloud-binary-document": { "source": "iana" },
  "application/vnd.dpgraph": { "source": "iana", "extensions": ["dpg"] },
  "application/vnd.dreamfactory": { "source": "iana", "extensions": ["dfac"] },
  "application/vnd.drive+json": { "source": "iana", "compressible": true },
  "application/vnd.ds-keypoint": { "source": "apache", "extensions": ["kpxx"] },
  "application/vnd.dtg.local": { "source": "iana" },
  "application/vnd.dtg.local.flash": { "source": "iana" },
  "application/vnd.dtg.local.html": { "source": "iana" },
  "application/vnd.dvb.ait": { "source": "iana", "extensions": ["ait"] },
  "application/vnd.dvb.dvbisl+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.dvbj": { "source": "iana" },
  "application/vnd.dvb.esgcontainer": { "source": "iana" },
  "application/vnd.dvb.ipdcdftnotifaccess": { "source": "iana" },
  "application/vnd.dvb.ipdcesgaccess": { "source": "iana" },
  "application/vnd.dvb.ipdcesgaccess2": { "source": "iana" },
  "application/vnd.dvb.ipdcesgpdd": { "source": "iana" },
  "application/vnd.dvb.ipdcroaming": { "source": "iana" },
  "application/vnd.dvb.iptv.alfec-base": { "source": "iana" },
  "application/vnd.dvb.iptv.alfec-enhancement": { "source": "iana" },
  "application/vnd.dvb.notif-aggregate-root+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-container+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-generic+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-msglist+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-registration-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-registration-response+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-init+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.pfr": { "source": "iana" },
  "application/vnd.dvb.service": { "source": "iana", "extensions": ["svc"] },
  "application/vnd.dxr": { "source": "iana" },
  "application/vnd.dynageo": { "source": "iana", "extensions": ["geo"] },
  "application/vnd.dzr": { "source": "iana" },
  "application/vnd.easykaraoke.cdgdownload": { "source": "iana" },
  "application/vnd.ecdis-update": { "source": "iana" },
  "application/vnd.ecip.rlp": { "source": "iana" },
  "application/vnd.eclipse.ditto+json": { "source": "iana", "compressible": true },
  "application/vnd.ecowin.chart": { "source": "iana", "extensions": ["mag"] },
  "application/vnd.ecowin.filerequest": { "source": "iana" },
  "application/vnd.ecowin.fileupdate": { "source": "iana" },
  "application/vnd.ecowin.series": { "source": "iana" },
  "application/vnd.ecowin.seriesrequest": { "source": "iana" },
  "application/vnd.ecowin.seriesupdate": { "source": "iana" },
  "application/vnd.efi.img": { "source": "iana" },
  "application/vnd.efi.iso": { "source": "iana" },
  "application/vnd.emclient.accessrequest+xml": { "source": "iana", "compressible": true },
  "application/vnd.enliven": { "source": "iana", "extensions": ["nml"] },
  "application/vnd.enphase.envoy": { "source": "iana" },
  "application/vnd.eprints.data+xml": { "source": "iana", "compressible": true },
  "application/vnd.epson.esf": { "source": "iana", "extensions": ["esf"] },
  "application/vnd.epson.msf": { "source": "iana", "extensions": ["msf"] },
  "application/vnd.epson.quickanime": { "source": "iana", "extensions": ["qam"] },
  "application/vnd.epson.salt": { "source": "iana", "extensions": ["slt"] },
  "application/vnd.epson.ssf": { "source": "iana", "extensions": ["ssf"] },
  "application/vnd.ericsson.quickcall": { "source": "iana" },
  "application/vnd.espass-espass+zip": { "source": "iana", "compressible": false },
  "application/vnd.eszigno3+xml": { "source": "iana", "compressible": true, "extensions": ["es3", "et3"] },
  "application/vnd.etsi.aoc+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.asic-e+zip": { "source": "iana", "compressible": false },
  "application/vnd.etsi.asic-s+zip": { "source": "iana", "compressible": false },
  "application/vnd.etsi.cug+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvcommand+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvdiscovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-bc+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-cod+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-npvr+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvservice+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsync+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvueprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.mcid+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.mheg5": { "source": "iana" },
  "application/vnd.etsi.overload-control-policy-dataset+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.pstn+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.sci+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.simservs+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.timestamp-token": { "source": "iana" },
  "application/vnd.etsi.tsl+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.tsl.der": { "source": "iana" },
  "application/vnd.eu.kasparian.car+json": { "source": "iana", "compressible": true },
  "application/vnd.eudora.data": { "source": "iana" },
  "application/vnd.evolv.ecig.profile": { "source": "iana" },
  "application/vnd.evolv.ecig.settings": { "source": "iana" },
  "application/vnd.evolv.ecig.theme": { "source": "iana" },
  "application/vnd.exstream-empower+zip": { "source": "iana", "compressible": false },
  "application/vnd.exstream-package": { "source": "iana" },
  "application/vnd.ezpix-album": { "source": "iana", "extensions": ["ez2"] },
  "application/vnd.ezpix-package": { "source": "iana", "extensions": ["ez3"] },
  "application/vnd.f-secure.mobile": { "source": "iana" },
  "application/vnd.familysearch.gedcom+zip": { "source": "iana", "compressible": false },
  "application/vnd.fastcopy-disk-image": { "source": "iana" },
  "application/vnd.fdf": { "source": "iana", "extensions": ["fdf"] },
  "application/vnd.fdsn.mseed": { "source": "iana", "extensions": ["mseed"] },
  "application/vnd.fdsn.seed": { "source": "iana", "extensions": ["seed", "dataless"] },
  "application/vnd.ffsns": { "source": "iana" },
  "application/vnd.ficlab.flb+zip": { "source": "iana", "compressible": false },
  "application/vnd.filmit.zfc": { "source": "iana" },
  "application/vnd.fints": { "source": "iana" },
  "application/vnd.firemonkeys.cloudcell": { "source": "iana" },
  "application/vnd.flographit": { "source": "iana", "extensions": ["gph"] },
  "application/vnd.fluxtime.clip": { "source": "iana", "extensions": ["ftc"] },
  "application/vnd.font-fontforge-sfd": { "source": "iana" },
  "application/vnd.framemaker": { "source": "iana", "extensions": ["fm", "frame", "maker", "book"] },
  "application/vnd.frogans.fnc": { "source": "iana", "extensions": ["fnc"] },
  "application/vnd.frogans.ltf": { "source": "iana", "extensions": ["ltf"] },
  "application/vnd.fsc.weblaunch": { "source": "iana", "extensions": ["fsc"] },
  "application/vnd.fujifilm.fb.docuworks": { "source": "iana" },
  "application/vnd.fujifilm.fb.docuworks.binder": { "source": "iana" },
  "application/vnd.fujifilm.fb.docuworks.container": { "source": "iana" },
  "application/vnd.fujifilm.fb.jfi+xml": { "source": "iana", "compressible": true },
  "application/vnd.fujitsu.oasys": { "source": "iana", "extensions": ["oas"] },
  "application/vnd.fujitsu.oasys2": { "source": "iana", "extensions": ["oa2"] },
  "application/vnd.fujitsu.oasys3": { "source": "iana", "extensions": ["oa3"] },
  "application/vnd.fujitsu.oasysgp": { "source": "iana", "extensions": ["fg5"] },
  "application/vnd.fujitsu.oasysprs": { "source": "iana", "extensions": ["bh2"] },
  "application/vnd.fujixerox.art-ex": { "source": "iana" },
  "application/vnd.fujixerox.art4": { "source": "iana" },
  "application/vnd.fujixerox.ddd": { "source": "iana", "extensions": ["ddd"] },
  "application/vnd.fujixerox.docuworks": { "source": "iana", "extensions": ["xdw"] },
  "application/vnd.fujixerox.docuworks.binder": { "source": "iana", "extensions": ["xbd"] },
  "application/vnd.fujixerox.docuworks.container": { "source": "iana" },
  "application/vnd.fujixerox.hbpl": { "source": "iana" },
  "application/vnd.fut-misnet": { "source": "iana" },
  "application/vnd.futoin+cbor": { "source": "iana" },
  "application/vnd.futoin+json": { "source": "iana", "compressible": true },
  "application/vnd.fuzzysheet": { "source": "iana", "extensions": ["fzs"] },
  "application/vnd.genomatix.tuxedo": { "source": "iana", "extensions": ["txd"] },
  "application/vnd.gentics.grd+json": { "source": "iana", "compressible": true },
  "application/vnd.geo+json": { "source": "iana", "compressible": true },
  "application/vnd.geocube+xml": { "source": "iana", "compressible": true },
  "application/vnd.geogebra.file": { "source": "iana", "extensions": ["ggb"] },
  "application/vnd.geogebra.slides": { "source": "iana" },
  "application/vnd.geogebra.tool": { "source": "iana", "extensions": ["ggt"] },
  "application/vnd.geometry-explorer": { "source": "iana", "extensions": ["gex", "gre"] },
  "application/vnd.geonext": { "source": "iana", "extensions": ["gxt"] },
  "application/vnd.geoplan": { "source": "iana", "extensions": ["g2w"] },
  "application/vnd.geospace": { "source": "iana", "extensions": ["g3w"] },
  "application/vnd.gerber": { "source": "iana" },
  "application/vnd.globalplatform.card-content-mgt": { "source": "iana" },
  "application/vnd.globalplatform.card-content-mgt-response": { "source": "iana" },
  "application/vnd.gmx": { "source": "iana", "extensions": ["gmx"] },
  "application/vnd.google-apps.document": { "compressible": false, "extensions": ["gdoc"] },
  "application/vnd.google-apps.presentation": { "compressible": false, "extensions": ["gslides"] },
  "application/vnd.google-apps.spreadsheet": { "compressible": false, "extensions": ["gsheet"] },
  "application/vnd.google-earth.kml+xml": { "source": "iana", "compressible": true, "extensions": ["kml"] },
  "application/vnd.google-earth.kmz": { "source": "iana", "compressible": false, "extensions": ["kmz"] },
  "application/vnd.gov.sk.e-form+xml": { "source": "iana", "compressible": true },
  "application/vnd.gov.sk.e-form+zip": { "source": "iana", "compressible": false },
  "application/vnd.gov.sk.xmldatacontainer+xml": { "source": "iana", "compressible": true },
  "application/vnd.grafeq": { "source": "iana", "extensions": ["gqf", "gqs"] },
  "application/vnd.gridmp": { "source": "iana" },
  "application/vnd.groove-account": { "source": "iana", "extensions": ["gac"] },
  "application/vnd.groove-help": { "source": "iana", "extensions": ["ghf"] },
  "application/vnd.groove-identity-message": { "source": "iana", "extensions": ["gim"] },
  "application/vnd.groove-injector": { "source": "iana", "extensions": ["grv"] },
  "application/vnd.groove-tool-message": { "source": "iana", "extensions": ["gtm"] },
  "application/vnd.groove-tool-template": { "source": "iana", "extensions": ["tpl"] },
  "application/vnd.groove-vcard": { "source": "iana", "extensions": ["vcg"] },
  "application/vnd.hal+json": { "source": "iana", "compressible": true },
  "application/vnd.hal+xml": { "source": "iana", "compressible": true, "extensions": ["hal"] },
  "application/vnd.handheld-entertainment+xml": { "source": "iana", "compressible": true, "extensions": ["zmm"] },
  "application/vnd.hbci": { "source": "iana", "extensions": ["hbci"] },
  "application/vnd.hc+json": { "source": "iana", "compressible": true },
  "application/vnd.hcl-bireports": { "source": "iana" },
  "application/vnd.hdt": { "source": "iana" },
  "application/vnd.heroku+json": { "source": "iana", "compressible": true },
  "application/vnd.hhe.lesson-player": { "source": "iana", "extensions": ["les"] },
  "application/vnd.hl7cda+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.hl7v2+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.hp-hpgl": { "source": "iana", "extensions": ["hpgl"] },
  "application/vnd.hp-hpid": { "source": "iana", "extensions": ["hpid"] },
  "application/vnd.hp-hps": { "source": "iana", "extensions": ["hps"] },
  "application/vnd.hp-jlyt": { "source": "iana", "extensions": ["jlt"] },
  "application/vnd.hp-pcl": { "source": "iana", "extensions": ["pcl"] },
  "application/vnd.hp-pclxl": { "source": "iana", "extensions": ["pclxl"] },
  "application/vnd.httphone": { "source": "iana" },
  "application/vnd.hydrostatix.sof-data": { "source": "iana", "extensions": ["sfd-hdstx"] },
  "application/vnd.hyper+json": { "source": "iana", "compressible": true },
  "application/vnd.hyper-item+json": { "source": "iana", "compressible": true },
  "application/vnd.hyperdrive+json": { "source": "iana", "compressible": true },
  "application/vnd.hzn-3d-crossword": { "source": "iana" },
  "application/vnd.ibm.afplinedata": { "source": "iana" },
  "application/vnd.ibm.electronic-media": { "source": "iana" },
  "application/vnd.ibm.minipay": { "source": "iana", "extensions": ["mpy"] },
  "application/vnd.ibm.modcap": { "source": "iana", "extensions": ["afp", "listafp", "list3820"] },
  "application/vnd.ibm.rights-management": { "source": "iana", "extensions": ["irm"] },
  "application/vnd.ibm.secure-container": { "source": "iana", "extensions": ["sc"] },
  "application/vnd.iccprofile": { "source": "iana", "extensions": ["icc", "icm"] },
  "application/vnd.ieee.1905": { "source": "iana" },
  "application/vnd.igloader": { "source": "iana", "extensions": ["igl"] },
  "application/vnd.imagemeter.folder+zip": { "source": "iana", "compressible": false },
  "application/vnd.imagemeter.image+zip": { "source": "iana", "compressible": false },
  "application/vnd.immervision-ivp": { "source": "iana", "extensions": ["ivp"] },
  "application/vnd.immervision-ivu": { "source": "iana", "extensions": ["ivu"] },
  "application/vnd.ims.imsccv1p1": { "source": "iana" },
  "application/vnd.ims.imsccv1p2": { "source": "iana" },
  "application/vnd.ims.imsccv1p3": { "source": "iana" },
  "application/vnd.ims.lis.v2.result+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolproxy+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolproxy.id+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolsettings+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": { "source": "iana", "compressible": true },
  "application/vnd.informedcontrol.rms+xml": { "source": "iana", "compressible": true },
  "application/vnd.informix-visionary": { "source": "iana" },
  "application/vnd.infotech.project": { "source": "iana" },
  "application/vnd.infotech.project+xml": { "source": "iana", "compressible": true },
  "application/vnd.innopath.wamp.notification": { "source": "iana" },
  "application/vnd.insors.igm": { "source": "iana", "extensions": ["igm"] },
  "application/vnd.intercon.formnet": { "source": "iana", "extensions": ["xpw", "xpx"] },
  "application/vnd.intergeo": { "source": "iana", "extensions": ["i2g"] },
  "application/vnd.intertrust.digibox": { "source": "iana" },
  "application/vnd.intertrust.nncp": { "source": "iana" },
  "application/vnd.intu.qbo": { "source": "iana", "extensions": ["qbo"] },
  "application/vnd.intu.qfx": { "source": "iana", "extensions": ["qfx"] },
  "application/vnd.iptc.g2.catalogitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.conceptitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.knowledgeitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.newsitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.newsmessage+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.packageitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.planningitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.ipunplugged.rcprofile": { "source": "iana", "extensions": ["rcprofile"] },
  "application/vnd.irepository.package+xml": { "source": "iana", "compressible": true, "extensions": ["irp"] },
  "application/vnd.is-xpr": { "source": "iana", "extensions": ["xpr"] },
  "application/vnd.isac.fcs": { "source": "iana", "extensions": ["fcs"] },
  "application/vnd.iso11783-10+zip": { "source": "iana", "compressible": false },
  "application/vnd.jam": { "source": "iana", "extensions": ["jam"] },
  "application/vnd.japannet-directory-service": { "source": "iana" },
  "application/vnd.japannet-jpnstore-wakeup": { "source": "iana" },
  "application/vnd.japannet-payment-wakeup": { "source": "iana" },
  "application/vnd.japannet-registration": { "source": "iana" },
  "application/vnd.japannet-registration-wakeup": { "source": "iana" },
  "application/vnd.japannet-setstore-wakeup": { "source": "iana" },
  "application/vnd.japannet-verification": { "source": "iana" },
  "application/vnd.japannet-verification-wakeup": { "source": "iana" },
  "application/vnd.jcp.javame.midlet-rms": { "source": "iana", "extensions": ["rms"] },
  "application/vnd.jisp": { "source": "iana", "extensions": ["jisp"] },
  "application/vnd.joost.joda-archive": { "source": "iana", "extensions": ["joda"] },
  "application/vnd.jsk.isdn-ngn": { "source": "iana" },
  "application/vnd.kahootz": { "source": "iana", "extensions": ["ktz", "ktr"] },
  "application/vnd.kde.karbon": { "source": "iana", "extensions": ["karbon"] },
  "application/vnd.kde.kchart": { "source": "iana", "extensions": ["chrt"] },
  "application/vnd.kde.kformula": { "source": "iana", "extensions": ["kfo"] },
  "application/vnd.kde.kivio": { "source": "iana", "extensions": ["flw"] },
  "application/vnd.kde.kontour": { "source": "iana", "extensions": ["kon"] },
  "application/vnd.kde.kpresenter": { "source": "iana", "extensions": ["kpr", "kpt"] },
  "application/vnd.kde.kspread": { "source": "iana", "extensions": ["ksp"] },
  "application/vnd.kde.kword": { "source": "iana", "extensions": ["kwd", "kwt"] },
  "application/vnd.kenameaapp": { "source": "iana", "extensions": ["htke"] },
  "application/vnd.kidspiration": { "source": "iana", "extensions": ["kia"] },
  "application/vnd.kinar": { "source": "iana", "extensions": ["kne", "knp"] },
  "application/vnd.koan": { "source": "iana", "extensions": ["skp", "skd", "skt", "skm"] },
  "application/vnd.kodak-descriptor": { "source": "iana", "extensions": ["sse"] },
  "application/vnd.las": { "source": "iana" },
  "application/vnd.las.las+json": { "source": "iana", "compressible": true },
  "application/vnd.las.las+xml": { "source": "iana", "compressible": true, "extensions": ["lasxml"] },
  "application/vnd.laszip": { "source": "iana" },
  "application/vnd.leap+json": { "source": "iana", "compressible": true },
  "application/vnd.liberty-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.llamagraphics.life-balance.desktop": { "source": "iana", "extensions": ["lbd"] },
  "application/vnd.llamagraphics.life-balance.exchange+xml": { "source": "iana", "compressible": true, "extensions": ["lbe"] },
  "application/vnd.logipipe.circuit+zip": { "source": "iana", "compressible": false },
  "application/vnd.loom": { "source": "iana" },
  "application/vnd.lotus-1-2-3": { "source": "iana", "extensions": ["123"] },
  "application/vnd.lotus-approach": { "source": "iana", "extensions": ["apr"] },
  "application/vnd.lotus-freelance": { "source": "iana", "extensions": ["pre"] },
  "application/vnd.lotus-notes": { "source": "iana", "extensions": ["nsf"] },
  "application/vnd.lotus-organizer": { "source": "iana", "extensions": ["org"] },
  "application/vnd.lotus-screencam": { "source": "iana", "extensions": ["scm"] },
  "application/vnd.lotus-wordpro": { "source": "iana", "extensions": ["lwp"] },
  "application/vnd.macports.portpkg": { "source": "iana", "extensions": ["portpkg"] },
  "application/vnd.mapbox-vector-tile": { "source": "iana", "extensions": ["mvt"] },
  "application/vnd.marlin.drm.actiontoken+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.conftoken+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.license+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.mdcf": { "source": "iana" },
  "application/vnd.mason+json": { "source": "iana", "compressible": true },
  "application/vnd.maxar.archive.3tz+zip": { "source": "iana", "compressible": false },
  "application/vnd.maxmind.maxmind-db": { "source": "iana" },
  "application/vnd.mcd": { "source": "iana", "extensions": ["mcd"] },
  "application/vnd.medcalcdata": { "source": "iana", "extensions": ["mc1"] },
  "application/vnd.mediastation.cdkey": { "source": "iana", "extensions": ["cdkey"] },
  "application/vnd.meridian-slingshot": { "source": "iana" },
  "application/vnd.mfer": { "source": "iana", "extensions": ["mwf"] },
  "application/vnd.mfmp": { "source": "iana", "extensions": ["mfm"] },
  "application/vnd.micro+json": { "source": "iana", "compressible": true },
  "application/vnd.micrografx.flo": { "source": "iana", "extensions": ["flo"] },
  "application/vnd.micrografx.igx": { "source": "iana", "extensions": ["igx"] },
  "application/vnd.microsoft.portable-executable": { "source": "iana" },
  "application/vnd.microsoft.windows.thumbnail-cache": { "source": "iana" },
  "application/vnd.miele+json": { "source": "iana", "compressible": true },
  "application/vnd.mif": { "source": "iana", "extensions": ["mif"] },
  "application/vnd.minisoft-hp3000-save": { "source": "iana" },
  "application/vnd.mitsubishi.misty-guard.trustweb": { "source": "iana" },
  "application/vnd.mobius.daf": { "source": "iana", "extensions": ["daf"] },
  "application/vnd.mobius.dis": { "source": "iana", "extensions": ["dis"] },
  "application/vnd.mobius.mbk": { "source": "iana", "extensions": ["mbk"] },
  "application/vnd.mobius.mqy": { "source": "iana", "extensions": ["mqy"] },
  "application/vnd.mobius.msl": { "source": "iana", "extensions": ["msl"] },
  "application/vnd.mobius.plc": { "source": "iana", "extensions": ["plc"] },
  "application/vnd.mobius.txf": { "source": "iana", "extensions": ["txf"] },
  "application/vnd.mophun.application": { "source": "iana", "extensions": ["mpn"] },
  "application/vnd.mophun.certificate": { "source": "iana", "extensions": ["mpc"] },
  "application/vnd.motorola.flexsuite": { "source": "iana" },
  "application/vnd.motorola.flexsuite.adsi": { "source": "iana" },
  "application/vnd.motorola.flexsuite.fis": { "source": "iana" },
  "application/vnd.motorola.flexsuite.gotap": { "source": "iana" },
  "application/vnd.motorola.flexsuite.kmr": { "source": "iana" },
  "application/vnd.motorola.flexsuite.ttc": { "source": "iana" },
  "application/vnd.motorola.flexsuite.wem": { "source": "iana" },
  "application/vnd.motorola.iprm": { "source": "iana" },
  "application/vnd.mozilla.xul+xml": { "source": "iana", "compressible": true, "extensions": ["xul"] },
  "application/vnd.ms-3mfdocument": { "source": "iana" },
  "application/vnd.ms-artgalry": { "source": "iana", "extensions": ["cil"] },
  "application/vnd.ms-asf": { "source": "iana" },
  "application/vnd.ms-cab-compressed": { "source": "iana", "extensions": ["cab"] },
  "application/vnd.ms-color.iccprofile": { "source": "apache" },
  "application/vnd.ms-excel": { "source": "iana", "compressible": false, "extensions": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"] },
  "application/vnd.ms-excel.addin.macroenabled.12": { "source": "iana", "extensions": ["xlam"] },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": { "source": "iana", "extensions": ["xlsb"] },
  "application/vnd.ms-excel.sheet.macroenabled.12": { "source": "iana", "extensions": ["xlsm"] },
  "application/vnd.ms-excel.template.macroenabled.12": { "source": "iana", "extensions": ["xltm"] },
  "application/vnd.ms-fontobject": { "source": "iana", "compressible": true, "extensions": ["eot"] },
  "application/vnd.ms-htmlhelp": { "source": "iana", "extensions": ["chm"] },
  "application/vnd.ms-ims": { "source": "iana", "extensions": ["ims"] },
  "application/vnd.ms-lrm": { "source": "iana", "extensions": ["lrm"] },
  "application/vnd.ms-office.activex+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-officetheme": { "source": "iana", "extensions": ["thmx"] },
  "application/vnd.ms-opentype": { "source": "apache", "compressible": true },
  "application/vnd.ms-outlook": { "compressible": false, "extensions": ["msg"] },
  "application/vnd.ms-package.obfuscated-opentype": { "source": "apache" },
  "application/vnd.ms-pki.seccat": { "source": "apache", "extensions": ["cat"] },
  "application/vnd.ms-pki.stl": { "source": "apache", "extensions": ["stl"] },
  "application/vnd.ms-playready.initiator+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-powerpoint": { "source": "iana", "compressible": false, "extensions": ["ppt", "pps", "pot"] },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": { "source": "iana", "extensions": ["ppam"] },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": { "source": "iana", "extensions": ["pptm"] },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": { "source": "iana", "extensions": ["sldm"] },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": { "source": "iana", "extensions": ["ppsm"] },
  "application/vnd.ms-powerpoint.template.macroenabled.12": { "source": "iana", "extensions": ["potm"] },
  "application/vnd.ms-printdevicecapabilities+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-printing.printticket+xml": { "source": "apache", "compressible": true },
  "application/vnd.ms-printschematicket+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-project": { "source": "iana", "extensions": ["mpp", "mpt"] },
  "application/vnd.ms-tnef": { "source": "iana" },
  "application/vnd.ms-windows.devicepairing": { "source": "iana" },
  "application/vnd.ms-windows.nwprinting.oob": { "source": "iana" },
  "application/vnd.ms-windows.printerpairing": { "source": "iana" },
  "application/vnd.ms-windows.wsd.oob": { "source": "iana" },
  "application/vnd.ms-wmdrm.lic-chlg-req": { "source": "iana" },
  "application/vnd.ms-wmdrm.lic-resp": { "source": "iana" },
  "application/vnd.ms-wmdrm.meter-chlg-req": { "source": "iana" },
  "application/vnd.ms-wmdrm.meter-resp": { "source": "iana" },
  "application/vnd.ms-word.document.macroenabled.12": { "source": "iana", "extensions": ["docm"] },
  "application/vnd.ms-word.template.macroenabled.12": { "source": "iana", "extensions": ["dotm"] },
  "application/vnd.ms-works": { "source": "iana", "extensions": ["wps", "wks", "wcm", "wdb"] },
  "application/vnd.ms-wpl": { "source": "iana", "extensions": ["wpl"] },
  "application/vnd.ms-xpsdocument": { "source": "iana", "compressible": false, "extensions": ["xps"] },
  "application/vnd.msa-disk-image": { "source": "iana" },
  "application/vnd.mseq": { "source": "iana", "extensions": ["mseq"] },
  "application/vnd.msign": { "source": "iana" },
  "application/vnd.multiad.creator": { "source": "iana" },
  "application/vnd.multiad.creator.cif": { "source": "iana" },
  "application/vnd.music-niff": { "source": "iana" },
  "application/vnd.musician": { "source": "iana", "extensions": ["mus"] },
  "application/vnd.muvee.style": { "source": "iana", "extensions": ["msty"] },
  "application/vnd.mynfc": { "source": "iana", "extensions": ["taglet"] },
  "application/vnd.nacamar.ybrid+json": { "source": "iana", "compressible": true },
  "application/vnd.ncd.control": { "source": "iana" },
  "application/vnd.ncd.reference": { "source": "iana" },
  "application/vnd.nearst.inv+json": { "source": "iana", "compressible": true },
  "application/vnd.nebumind.line": { "source": "iana" },
  "application/vnd.nervana": { "source": "iana" },
  "application/vnd.netfpx": { "source": "iana" },
  "application/vnd.neurolanguage.nlu": { "source": "iana", "extensions": ["nlu"] },
  "application/vnd.nimn": { "source": "iana" },
  "application/vnd.nintendo.nitro.rom": { "source": "iana" },
  "application/vnd.nintendo.snes.rom": { "source": "iana" },
  "application/vnd.nitf": { "source": "iana", "extensions": ["ntf", "nitf"] },
  "application/vnd.noblenet-directory": { "source": "iana", "extensions": ["nnd"] },
  "application/vnd.noblenet-sealer": { "source": "iana", "extensions": ["nns"] },
  "application/vnd.noblenet-web": { "source": "iana", "extensions": ["nnw"] },
  "application/vnd.nokia.catalogs": { "source": "iana" },
  "application/vnd.nokia.conml+wbxml": { "source": "iana" },
  "application/vnd.nokia.conml+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.iptv.config+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.isds-radio-presets": { "source": "iana" },
  "application/vnd.nokia.landmark+wbxml": { "source": "iana" },
  "application/vnd.nokia.landmark+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.landmarkcollection+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.n-gage.ac+xml": { "source": "iana", "compressible": true, "extensions": ["ac"] },
  "application/vnd.nokia.n-gage.data": { "source": "iana", "extensions": ["ngdat"] },
  "application/vnd.nokia.n-gage.symbian.install": { "source": "iana", "extensions": ["n-gage"] },
  "application/vnd.nokia.ncd": { "source": "iana" },
  "application/vnd.nokia.pcd+wbxml": { "source": "iana" },
  "application/vnd.nokia.pcd+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.radio-preset": { "source": "iana", "extensions": ["rpst"] },
  "application/vnd.nokia.radio-presets": { "source": "iana", "extensions": ["rpss"] },
  "application/vnd.novadigm.edm": { "source": "iana", "extensions": ["edm"] },
  "application/vnd.novadigm.edx": { "source": "iana", "extensions": ["edx"] },
  "application/vnd.novadigm.ext": { "source": "iana", "extensions": ["ext"] },
  "application/vnd.ntt-local.content-share": { "source": "iana" },
  "application/vnd.ntt-local.file-transfer": { "source": "iana" },
  "application/vnd.ntt-local.ogw_remote-access": { "source": "iana" },
  "application/vnd.ntt-local.sip-ta_remote": { "source": "iana" },
  "application/vnd.ntt-local.sip-ta_tcp_stream": { "source": "iana" },
  "application/vnd.oasis.opendocument.chart": { "source": "iana", "extensions": ["odc"] },
  "application/vnd.oasis.opendocument.chart-template": { "source": "iana", "extensions": ["otc"] },
  "application/vnd.oasis.opendocument.database": { "source": "iana", "extensions": ["odb"] },
  "application/vnd.oasis.opendocument.formula": { "source": "iana", "extensions": ["odf"] },
  "application/vnd.oasis.opendocument.formula-template": { "source": "iana", "extensions": ["odft"] },
  "application/vnd.oasis.opendocument.graphics": { "source": "iana", "compressible": false, "extensions": ["odg"] },
  "application/vnd.oasis.opendocument.graphics-template": { "source": "iana", "extensions": ["otg"] },
  "application/vnd.oasis.opendocument.image": { "source": "iana", "extensions": ["odi"] },
  "application/vnd.oasis.opendocument.image-template": { "source": "iana", "extensions": ["oti"] },
  "application/vnd.oasis.opendocument.presentation": { "source": "iana", "compressible": false, "extensions": ["odp"] },
  "application/vnd.oasis.opendocument.presentation-template": { "source": "iana", "extensions": ["otp"] },
  "application/vnd.oasis.opendocument.spreadsheet": { "source": "iana", "compressible": false, "extensions": ["ods"] },
  "application/vnd.oasis.opendocument.spreadsheet-template": { "source": "iana", "extensions": ["ots"] },
  "application/vnd.oasis.opendocument.text": { "source": "iana", "compressible": false, "extensions": ["odt"] },
  "application/vnd.oasis.opendocument.text-master": { "source": "iana", "extensions": ["odm"] },
  "application/vnd.oasis.opendocument.text-template": { "source": "iana", "extensions": ["ott"] },
  "application/vnd.oasis.opendocument.text-web": { "source": "iana", "extensions": ["oth"] },
  "application/vnd.obn": { "source": "iana" },
  "application/vnd.ocf+cbor": { "source": "iana" },
  "application/vnd.oci.image.manifest.v1+json": { "source": "iana", "compressible": true },
  "application/vnd.oftn.l10n+json": { "source": "iana", "compressible": true },
  "application/vnd.oipf.contentaccessdownload+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.contentaccessstreaming+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.cspg-hexbinary": { "source": "iana" },
  "application/vnd.oipf.dae.svg+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.dae.xhtml+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.mippvcontrolmessage+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.pae.gem": { "source": "iana" },
  "application/vnd.oipf.spdiscovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.spdlist+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.ueprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.userprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.olpc-sugar": { "source": "iana", "extensions": ["xo"] },
  "application/vnd.oma-scws-config": { "source": "iana" },
  "application/vnd.oma-scws-http-request": { "source": "iana" },
  "application/vnd.oma-scws-http-response": { "source": "iana" },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.drm-trigger+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.imd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.ltkm": { "source": "iana" },
  "application/vnd.oma.bcast.notification+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.provisioningtrigger": { "source": "iana" },
  "application/vnd.oma.bcast.sgboot": { "source": "iana" },
  "application/vnd.oma.bcast.sgdd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.sgdu": { "source": "iana" },
  "application/vnd.oma.bcast.simple-symbol-container": { "source": "iana" },
  "application/vnd.oma.bcast.smartcard-trigger+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.sprov+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.stkm": { "source": "iana" },
  "application/vnd.oma.cab-address-book+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-feature-handler+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-pcc+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-subs-invite+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-user-prefs+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.dcd": { "source": "iana" },
  "application/vnd.oma.dcdc": { "source": "iana" },
  "application/vnd.oma.dd2+xml": { "source": "iana", "compressible": true, "extensions": ["dd2"] },
  "application/vnd.oma.drm.risd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.group-usage-list+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.lwm2m+cbor": { "source": "iana" },
  "application/vnd.oma.lwm2m+json": { "source": "iana", "compressible": true },
  "application/vnd.oma.lwm2m+tlv": { "source": "iana" },
  "application/vnd.oma.pal+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.detailed-progress-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.final-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.groups+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.invocation-descriptor+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.optimized-progress-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.push": { "source": "iana" },
  "application/vnd.oma.scidm.messages+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.xcap-directory+xml": { "source": "iana", "compressible": true },
  "application/vnd.omads-email+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omads-file+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omads-folder+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omaloc-supl-init": { "source": "iana" },
  "application/vnd.onepager": { "source": "iana" },
  "application/vnd.onepagertamp": { "source": "iana" },
  "application/vnd.onepagertamx": { "source": "iana" },
  "application/vnd.onepagertat": { "source": "iana" },
  "application/vnd.onepagertatp": { "source": "iana" },
  "application/vnd.onepagertatx": { "source": "iana" },
  "application/vnd.openblox.game+xml": { "source": "iana", "compressible": true, "extensions": ["obgx"] },
  "application/vnd.openblox.game-binary": { "source": "iana" },
  "application/vnd.openeye.oeb": { "source": "iana" },
  "application/vnd.openofficeorg.extension": { "source": "apache", "extensions": ["oxt"] },
  "application/vnd.openstreetmap.data+xml": { "source": "iana", "compressible": true, "extensions": ["osm"] },
  "application/vnd.opentimestamps.ots": { "source": "iana" },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawing+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": { "source": "iana", "compressible": false, "extensions": ["pptx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": { "source": "iana", "extensions": ["sldx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": { "source": "iana", "extensions": ["ppsx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.template": { "source": "iana", "extensions": ["potx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": { "source": "iana", "compressible": false, "extensions": ["xlsx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": { "source": "iana", "extensions": ["xltx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.theme+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.vmldrawing": { "source": "iana" },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": { "source": "iana", "compressible": false, "extensions": ["docx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": { "source": "iana", "extensions": ["dotx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.core-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.relationships+xml": { "source": "iana", "compressible": true },
  "application/vnd.oracle.resource+json": { "source": "iana", "compressible": true },
  "application/vnd.orange.indata": { "source": "iana" },
  "application/vnd.osa.netdeploy": { "source": "iana" },
  "application/vnd.osgeo.mapguide.package": { "source": "iana", "extensions": ["mgp"] },
  "application/vnd.osgi.bundle": { "source": "iana" },
  "application/vnd.osgi.dp": { "source": "iana", "extensions": ["dp"] },
  "application/vnd.osgi.subsystem": { "source": "iana", "extensions": ["esa"] },
  "application/vnd.otps.ct-kip+xml": { "source": "iana", "compressible": true },
  "application/vnd.oxli.countgraph": { "source": "iana" },
  "application/vnd.pagerduty+json": { "source": "iana", "compressible": true },
  "application/vnd.palm": { "source": "iana", "extensions": ["pdb", "pqa", "oprc"] },
  "application/vnd.panoply": { "source": "iana" },
  "application/vnd.paos.xml": { "source": "iana" },
  "application/vnd.patentdive": { "source": "iana" },
  "application/vnd.patientecommsdoc": { "source": "iana" },
  "application/vnd.pawaafile": { "source": "iana", "extensions": ["paw"] },
  "application/vnd.pcos": { "source": "iana" },
  "application/vnd.pg.format": { "source": "iana", "extensions": ["str"] },
  "application/vnd.pg.osasli": { "source": "iana", "extensions": ["ei6"] },
  "application/vnd.piaccess.application-licence": { "source": "iana" },
  "application/vnd.picsel": { "source": "iana", "extensions": ["efif"] },
  "application/vnd.pmi.widget": { "source": "iana", "extensions": ["wg"] },
  "application/vnd.poc.group-advertisement+xml": { "source": "iana", "compressible": true },
  "application/vnd.pocketlearn": { "source": "iana", "extensions": ["plf"] },
  "application/vnd.powerbuilder6": { "source": "iana", "extensions": ["pbd"] },
  "application/vnd.powerbuilder6-s": { "source": "iana" },
  "application/vnd.powerbuilder7": { "source": "iana" },
  "application/vnd.powerbuilder7-s": { "source": "iana" },
  "application/vnd.powerbuilder75": { "source": "iana" },
  "application/vnd.powerbuilder75-s": { "source": "iana" },
  "application/vnd.preminet": { "source": "iana" },
  "application/vnd.previewsystems.box": { "source": "iana", "extensions": ["box"] },
  "application/vnd.proteus.magazine": { "source": "iana", "extensions": ["mgz"] },
  "application/vnd.psfs": { "source": "iana" },
  "application/vnd.publishare-delta-tree": { "source": "iana", "extensions": ["qps"] },
  "application/vnd.pvi.ptid1": { "source": "iana", "extensions": ["ptid"] },
  "application/vnd.pwg-multiplexed": { "source": "iana" },
  "application/vnd.pwg-xhtml-print+xml": { "source": "iana", "compressible": true },
  "application/vnd.qualcomm.brew-app-res": { "source": "iana" },
  "application/vnd.quarantainenet": { "source": "iana" },
  "application/vnd.quark.quarkxpress": { "source": "iana", "extensions": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"] },
  "application/vnd.quobject-quoxdocument": { "source": "iana" },
  "application/vnd.radisys.moml+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-conf+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-conn+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-dialog+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-stream+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-conf+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-base+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-group+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-speech+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-transform+xml": { "source": "iana", "compressible": true },
  "application/vnd.rainstor.data": { "source": "iana" },
  "application/vnd.rapid": { "source": "iana" },
  "application/vnd.rar": { "source": "iana", "extensions": ["rar"] },
  "application/vnd.realvnc.bed": { "source": "iana", "extensions": ["bed"] },
  "application/vnd.recordare.musicxml": { "source": "iana", "extensions": ["mxl"] },
  "application/vnd.recordare.musicxml+xml": { "source": "iana", "compressible": true, "extensions": ["musicxml"] },
  "application/vnd.renlearn.rlprint": { "source": "iana" },
  "application/vnd.resilient.logic": { "source": "iana" },
  "application/vnd.restful+json": { "source": "iana", "compressible": true },
  "application/vnd.rig.cryptonote": { "source": "iana", "extensions": ["cryptonote"] },
  "application/vnd.rim.cod": { "source": "apache", "extensions": ["cod"] },
  "application/vnd.rn-realmedia": { "source": "apache", "extensions": ["rm"] },
  "application/vnd.rn-realmedia-vbr": { "source": "apache", "extensions": ["rmvb"] },
  "application/vnd.route66.link66+xml": { "source": "iana", "compressible": true, "extensions": ["link66"] },
  "application/vnd.rs-274x": { "source": "iana" },
  "application/vnd.ruckus.download": { "source": "iana" },
  "application/vnd.s3sms": { "source": "iana" },
  "application/vnd.sailingtracker.track": { "source": "iana", "extensions": ["st"] },
  "application/vnd.sar": { "source": "iana" },
  "application/vnd.sbm.cid": { "source": "iana" },
  "application/vnd.sbm.mid2": { "source": "iana" },
  "application/vnd.scribus": { "source": "iana" },
  "application/vnd.sealed.3df": { "source": "iana" },
  "application/vnd.sealed.csf": { "source": "iana" },
  "application/vnd.sealed.doc": { "source": "iana" },
  "application/vnd.sealed.eml": { "source": "iana" },
  "application/vnd.sealed.mht": { "source": "iana" },
  "application/vnd.sealed.net": { "source": "iana" },
  "application/vnd.sealed.ppt": { "source": "iana" },
  "application/vnd.sealed.tiff": { "source": "iana" },
  "application/vnd.sealed.xls": { "source": "iana" },
  "application/vnd.sealedmedia.softseal.html": { "source": "iana" },
  "application/vnd.sealedmedia.softseal.pdf": { "source": "iana" },
  "application/vnd.seemail": { "source": "iana", "extensions": ["see"] },
  "application/vnd.seis+json": { "source": "iana", "compressible": true },
  "application/vnd.sema": { "source": "iana", "extensions": ["sema"] },
  "application/vnd.semd": { "source": "iana", "extensions": ["semd"] },
  "application/vnd.semf": { "source": "iana", "extensions": ["semf"] },
  "application/vnd.shade-save-file": { "source": "iana" },
  "application/vnd.shana.informed.formdata": { "source": "iana", "extensions": ["ifm"] },
  "application/vnd.shana.informed.formtemplate": { "source": "iana", "extensions": ["itp"] },
  "application/vnd.shana.informed.interchange": { "source": "iana", "extensions": ["iif"] },
  "application/vnd.shana.informed.package": { "source": "iana", "extensions": ["ipk"] },
  "application/vnd.shootproof+json": { "source": "iana", "compressible": true },
  "application/vnd.shopkick+json": { "source": "iana", "compressible": true },
  "application/vnd.shp": { "source": "iana" },
  "application/vnd.shx": { "source": "iana" },
  "application/vnd.sigrok.session": { "source": "iana" },
  "application/vnd.simtech-mindmapper": { "source": "iana", "extensions": ["twd", "twds"] },
  "application/vnd.siren+json": { "source": "iana", "compressible": true },
  "application/vnd.smaf": { "source": "iana", "extensions": ["mmf"] },
  "application/vnd.smart.notebook": { "source": "iana" },
  "application/vnd.smart.teacher": { "source": "iana", "extensions": ["teacher"] },
  "application/vnd.snesdev-page-table": { "source": "iana" },
  "application/vnd.software602.filler.form+xml": { "source": "iana", "compressible": true, "extensions": ["fo"] },
  "application/vnd.software602.filler.form-xml-zip": { "source": "iana" },
  "application/vnd.solent.sdkm+xml": { "source": "iana", "compressible": true, "extensions": ["sdkm", "sdkd"] },
  "application/vnd.spotfire.dxp": { "source": "iana", "extensions": ["dxp"] },
  "application/vnd.spotfire.sfs": { "source": "iana", "extensions": ["sfs"] },
  "application/vnd.sqlite3": { "source": "iana" },
  "application/vnd.sss-cod": { "source": "iana" },
  "application/vnd.sss-dtf": { "source": "iana" },
  "application/vnd.sss-ntf": { "source": "iana" },
  "application/vnd.stardivision.calc": { "source": "apache", "extensions": ["sdc"] },
  "application/vnd.stardivision.draw": { "source": "apache", "extensions": ["sda"] },
  "application/vnd.stardivision.impress": { "source": "apache", "extensions": ["sdd"] },
  "application/vnd.stardivision.math": { "source": "apache", "extensions": ["smf"] },
  "application/vnd.stardivision.writer": { "source": "apache", "extensions": ["sdw", "vor"] },
  "application/vnd.stardivision.writer-global": { "source": "apache", "extensions": ["sgl"] },
  "application/vnd.stepmania.package": { "source": "iana", "extensions": ["smzip"] },
  "application/vnd.stepmania.stepchart": { "source": "iana", "extensions": ["sm"] },
  "application/vnd.street-stream": { "source": "iana" },
  "application/vnd.sun.wadl+xml": { "source": "iana", "compressible": true, "extensions": ["wadl"] },
  "application/vnd.sun.xml.calc": { "source": "apache", "extensions": ["sxc"] },
  "application/vnd.sun.xml.calc.template": { "source": "apache", "extensions": ["stc"] },
  "application/vnd.sun.xml.draw": { "source": "apache", "extensions": ["sxd"] },
  "application/vnd.sun.xml.draw.template": { "source": "apache", "extensions": ["std"] },
  "application/vnd.sun.xml.impress": { "source": "apache", "extensions": ["sxi"] },
  "application/vnd.sun.xml.impress.template": { "source": "apache", "extensions": ["sti"] },
  "application/vnd.sun.xml.math": { "source": "apache", "extensions": ["sxm"] },
  "application/vnd.sun.xml.writer": { "source": "apache", "extensions": ["sxw"] },
  "application/vnd.sun.xml.writer.global": { "source": "apache", "extensions": ["sxg"] },
  "application/vnd.sun.xml.writer.template": { "source": "apache", "extensions": ["stw"] },
  "application/vnd.sus-calendar": { "source": "iana", "extensions": ["sus", "susp"] },
  "application/vnd.svd": { "source": "iana", "extensions": ["svd"] },
  "application/vnd.swiftview-ics": { "source": "iana" },
  "application/vnd.sycle+xml": { "source": "iana", "compressible": true },
  "application/vnd.syft+json": { "source": "iana", "compressible": true },
  "application/vnd.symbian.install": { "source": "apache", "extensions": ["sis", "sisx"] },
  "application/vnd.syncml+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["xsm"] },
  "application/vnd.syncml.dm+wbxml": { "source": "iana", "charset": "UTF-8", "extensions": ["bdm"] },
  "application/vnd.syncml.dm+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["xdm"] },
  "application/vnd.syncml.dm.notification": { "source": "iana" },
  "application/vnd.syncml.dmddf+wbxml": { "source": "iana" },
  "application/vnd.syncml.dmddf+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["ddf"] },
  "application/vnd.syncml.dmtnds+wbxml": { "source": "iana" },
  "application/vnd.syncml.dmtnds+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.syncml.ds.notification": { "source": "iana" },
  "application/vnd.tableschema+json": { "source": "iana", "compressible": true },
  "application/vnd.tao.intent-module-archive": { "source": "iana", "extensions": ["tao"] },
  "application/vnd.tcpdump.pcap": { "source": "iana", "extensions": ["pcap", "cap", "dmp"] },
  "application/vnd.think-cell.ppttc+json": { "source": "iana", "compressible": true },
  "application/vnd.tmd.mediaflex.api+xml": { "source": "iana", "compressible": true },
  "application/vnd.tml": { "source": "iana" },
  "application/vnd.tmobile-livetv": { "source": "iana", "extensions": ["tmo"] },
  "application/vnd.tri.onesource": { "source": "iana" },
  "application/vnd.trid.tpt": { "source": "iana", "extensions": ["tpt"] },
  "application/vnd.triscape.mxs": { "source": "iana", "extensions": ["mxs"] },
  "application/vnd.trueapp": { "source": "iana", "extensions": ["tra"] },
  "application/vnd.truedoc": { "source": "iana" },
  "application/vnd.ubisoft.webplayer": { "source": "iana" },
  "application/vnd.ufdl": { "source": "iana", "extensions": ["ufd", "ufdl"] },
  "application/vnd.uiq.theme": { "source": "iana", "extensions": ["utz"] },
  "application/vnd.umajin": { "source": "iana", "extensions": ["umj"] },
  "application/vnd.unity": { "source": "iana", "extensions": ["unityweb"] },
  "application/vnd.uoml+xml": { "source": "iana", "compressible": true, "extensions": ["uoml"] },
  "application/vnd.uplanet.alert": { "source": "iana" },
  "application/vnd.uplanet.alert-wbxml": { "source": "iana" },
  "application/vnd.uplanet.bearer-choice": { "source": "iana" },
  "application/vnd.uplanet.bearer-choice-wbxml": { "source": "iana" },
  "application/vnd.uplanet.cacheop": { "source": "iana" },
  "application/vnd.uplanet.cacheop-wbxml": { "source": "iana" },
  "application/vnd.uplanet.channel": { "source": "iana" },
  "application/vnd.uplanet.channel-wbxml": { "source": "iana" },
  "application/vnd.uplanet.list": { "source": "iana" },
  "application/vnd.uplanet.list-wbxml": { "source": "iana" },
  "application/vnd.uplanet.listcmd": { "source": "iana" },
  "application/vnd.uplanet.listcmd-wbxml": { "source": "iana" },
  "application/vnd.uplanet.signal": { "source": "iana" },
  "application/vnd.uri-map": { "source": "iana" },
  "application/vnd.valve.source.material": { "source": "iana" },
  "application/vnd.vcx": { "source": "iana", "extensions": ["vcx"] },
  "application/vnd.vd-study": { "source": "iana" },
  "application/vnd.vectorworks": { "source": "iana" },
  "application/vnd.vel+json": { "source": "iana", "compressible": true },
  "application/vnd.verimatrix.vcas": { "source": "iana" },
  "application/vnd.veritone.aion+json": { "source": "iana", "compressible": true },
  "application/vnd.veryant.thin": { "source": "iana" },
  "application/vnd.ves.encrypted": { "source": "iana" },
  "application/vnd.vidsoft.vidconference": { "source": "iana" },
  "application/vnd.visio": { "source": "iana", "extensions": ["vsd", "vst", "vss", "vsw"] },
  "application/vnd.visionary": { "source": "iana", "extensions": ["vis"] },
  "application/vnd.vividence.scriptfile": { "source": "iana" },
  "application/vnd.vsf": { "source": "iana", "extensions": ["vsf"] },
  "application/vnd.wap.sic": { "source": "iana" },
  "application/vnd.wap.slc": { "source": "iana" },
  "application/vnd.wap.wbxml": { "source": "iana", "charset": "UTF-8", "extensions": ["wbxml"] },
  "application/vnd.wap.wmlc": { "source": "iana", "extensions": ["wmlc"] },
  "application/vnd.wap.wmlscriptc": { "source": "iana", "extensions": ["wmlsc"] },
  "application/vnd.webturbo": { "source": "iana", "extensions": ["wtb"] },
  "application/vnd.wfa.dpp": { "source": "iana" },
  "application/vnd.wfa.p2p": { "source": "iana" },
  "application/vnd.wfa.wsc": { "source": "iana" },
  "application/vnd.windows.devicepairing": { "source": "iana" },
  "application/vnd.wmc": { "source": "iana" },
  "application/vnd.wmf.bootstrap": { "source": "iana" },
  "application/vnd.wolfram.mathematica": { "source": "iana" },
  "application/vnd.wolfram.mathematica.package": { "source": "iana" },
  "application/vnd.wolfram.player": { "source": "iana", "extensions": ["nbp"] },
  "application/vnd.wordperfect": { "source": "iana", "extensions": ["wpd"] },
  "application/vnd.wqd": { "source": "iana", "extensions": ["wqd"] },
  "application/vnd.wrq-hp3000-labelled": { "source": "iana" },
  "application/vnd.wt.stf": { "source": "iana", "extensions": ["stf"] },
  "application/vnd.wv.csp+wbxml": { "source": "iana" },
  "application/vnd.wv.csp+xml": { "source": "iana", "compressible": true },
  "application/vnd.wv.ssp+xml": { "source": "iana", "compressible": true },
  "application/vnd.xacml+json": { "source": "iana", "compressible": true },
  "application/vnd.xara": { "source": "iana", "extensions": ["xar"] },
  "application/vnd.xfdl": { "source": "iana", "extensions": ["xfdl"] },
  "application/vnd.xfdl.webform": { "source": "iana" },
  "application/vnd.xmi+xml": { "source": "iana", "compressible": true },
  "application/vnd.xmpie.cpkg": { "source": "iana" },
  "application/vnd.xmpie.dpkg": { "source": "iana" },
  "application/vnd.xmpie.plan": { "source": "iana" },
  "application/vnd.xmpie.ppkg": { "source": "iana" },
  "application/vnd.xmpie.xlim": { "source": "iana" },
  "application/vnd.yamaha.hv-dic": { "source": "iana", "extensions": ["hvd"] },
  "application/vnd.yamaha.hv-script": { "source": "iana", "extensions": ["hvs"] },
  "application/vnd.yamaha.hv-voice": { "source": "iana", "extensions": ["hvp"] },
  "application/vnd.yamaha.openscoreformat": { "source": "iana", "extensions": ["osf"] },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": { "source": "iana", "compressible": true, "extensions": ["osfpvg"] },
  "application/vnd.yamaha.remote-setup": { "source": "iana" },
  "application/vnd.yamaha.smaf-audio": { "source": "iana", "extensions": ["saf"] },
  "application/vnd.yamaha.smaf-phrase": { "source": "iana", "extensions": ["spf"] },
  "application/vnd.yamaha.through-ngn": { "source": "iana" },
  "application/vnd.yamaha.tunnel-udpencap": { "source": "iana" },
  "application/vnd.yaoweme": { "source": "iana" },
  "application/vnd.yellowriver-custom-menu": { "source": "iana", "extensions": ["cmp"] },
  "application/vnd.youtube.yt": { "source": "iana" },
  "application/vnd.zul": { "source": "iana", "extensions": ["zir", "zirz"] },
  "application/vnd.zzazz.deck+xml": { "source": "iana", "compressible": true, "extensions": ["zaz"] },
  "application/voicexml+xml": { "source": "iana", "compressible": true, "extensions": ["vxml"] },
  "application/voucher-cms+json": { "source": "iana", "compressible": true },
  "application/vq-rtcpxr": { "source": "iana" },
  "application/wasm": { "source": "iana", "compressible": true, "extensions": ["wasm"] },
  "application/watcherinfo+xml": { "source": "iana", "compressible": true, "extensions": ["wif"] },
  "application/webpush-options+json": { "source": "iana", "compressible": true },
  "application/whoispp-query": { "source": "iana" },
  "application/whoispp-response": { "source": "iana" },
  "application/widget": { "source": "iana", "extensions": ["wgt"] },
  "application/winhlp": { "source": "apache", "extensions": ["hlp"] },
  "application/wita": { "source": "iana" },
  "application/wordperfect5.1": { "source": "iana" },
  "application/wsdl+xml": { "source": "iana", "compressible": true, "extensions": ["wsdl"] },
  "application/wspolicy+xml": { "source": "iana", "compressible": true, "extensions": ["wspolicy"] },
  "application/x-7z-compressed": { "source": "apache", "compressible": false, "extensions": ["7z"] },
  "application/x-abiword": { "source": "apache", "extensions": ["abw"] },
  "application/x-ace-compressed": { "source": "apache", "extensions": ["ace"] },
  "application/x-amf": { "source": "apache" },
  "application/x-apple-diskimage": { "source": "apache", "extensions": ["dmg"] },
  "application/x-arj": { "compressible": false, "extensions": ["arj"] },
  "application/x-authorware-bin": { "source": "apache", "extensions": ["aab", "x32", "u32", "vox"] },
  "application/x-authorware-map": { "source": "apache", "extensions": ["aam"] },
  "application/x-authorware-seg": { "source": "apache", "extensions": ["aas"] },
  "application/x-bcpio": { "source": "apache", "extensions": ["bcpio"] },
  "application/x-bdoc": { "compressible": false, "extensions": ["bdoc"] },
  "application/x-bittorrent": { "source": "apache", "extensions": ["torrent"] },
  "application/x-blorb": { "source": "apache", "extensions": ["blb", "blorb"] },
  "application/x-bzip": { "source": "apache", "compressible": false, "extensions": ["bz"] },
  "application/x-bzip2": { "source": "apache", "compressible": false, "extensions": ["bz2", "boz"] },
  "application/x-cbr": { "source": "apache", "extensions": ["cbr", "cba", "cbt", "cbz", "cb7"] },
  "application/x-cdlink": { "source": "apache", "extensions": ["vcd"] },
  "application/x-cfs-compressed": { "source": "apache", "extensions": ["cfs"] },
  "application/x-chat": { "source": "apache", "extensions": ["chat"] },
  "application/x-chess-pgn": { "source": "apache", "extensions": ["pgn"] },
  "application/x-chrome-extension": { "extensions": ["crx"] },
  "application/x-cocoa": { "source": "nginx", "extensions": ["cco"] },
  "application/x-compress": { "source": "apache" },
  "application/x-conference": { "source": "apache", "extensions": ["nsc"] },
  "application/x-cpio": { "source": "apache", "extensions": ["cpio"] },
  "application/x-csh": { "source": "apache", "extensions": ["csh"] },
  "application/x-deb": { "compressible": false },
  "application/x-debian-package": { "source": "apache", "extensions": ["deb", "udeb"] },
  "application/x-dgc-compressed": { "source": "apache", "extensions": ["dgc"] },
  "application/x-director": { "source": "apache", "extensions": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"] },
  "application/x-doom": { "source": "apache", "extensions": ["wad"] },
  "application/x-dtbncx+xml": { "source": "apache", "compressible": true, "extensions": ["ncx"] },
  "application/x-dtbook+xml": { "source": "apache", "compressible": true, "extensions": ["dtb"] },
  "application/x-dtbresource+xml": { "source": "apache", "compressible": true, "extensions": ["res"] },
  "application/x-dvi": { "source": "apache", "compressible": false, "extensions": ["dvi"] },
  "application/x-envoy": { "source": "apache", "extensions": ["evy"] },
  "application/x-eva": { "source": "apache", "extensions": ["eva"] },
  "application/x-font-bdf": { "source": "apache", "extensions": ["bdf"] },
  "application/x-font-dos": { "source": "apache" },
  "application/x-font-framemaker": { "source": "apache" },
  "application/x-font-ghostscript": { "source": "apache", "extensions": ["gsf"] },
  "application/x-font-libgrx": { "source": "apache" },
  "application/x-font-linux-psf": { "source": "apache", "extensions": ["psf"] },
  "application/x-font-pcf": { "source": "apache", "extensions": ["pcf"] },
  "application/x-font-snf": { "source": "apache", "extensions": ["snf"] },
  "application/x-font-speedo": { "source": "apache" },
  "application/x-font-sunos-news": { "source": "apache" },
  "application/x-font-type1": { "source": "apache", "extensions": ["pfa", "pfb", "pfm", "afm"] },
  "application/x-font-vfont": { "source": "apache" },
  "application/x-freearc": { "source": "apache", "extensions": ["arc"] },
  "application/x-futuresplash": { "source": "apache", "extensions": ["spl"] },
  "application/x-gca-compressed": { "source": "apache", "extensions": ["gca"] },
  "application/x-glulx": { "source": "apache", "extensions": ["ulx"] },
  "application/x-gnumeric": { "source": "apache", "extensions": ["gnumeric"] },
  "application/x-gramps-xml": { "source": "apache", "extensions": ["gramps"] },
  "application/x-gtar": { "source": "apache", "extensions": ["gtar"] },
  "application/x-gzip": { "source": "apache" },
  "application/x-hdf": { "source": "apache", "extensions": ["hdf"] },
  "application/x-httpd-php": { "compressible": true, "extensions": ["php"] },
  "application/x-install-instructions": { "source": "apache", "extensions": ["install"] },
  "application/x-iso9660-image": { "source": "apache", "extensions": ["iso"] },
  "application/x-iwork-keynote-sffkey": { "extensions": ["key"] },
  "application/x-iwork-numbers-sffnumbers": { "extensions": ["numbers"] },
  "application/x-iwork-pages-sffpages": { "extensions": ["pages"] },
  "application/x-java-archive-diff": { "source": "nginx", "extensions": ["jardiff"] },
  "application/x-java-jnlp-file": { "source": "apache", "compressible": false, "extensions": ["jnlp"] },
  "application/x-javascript": { "compressible": true },
  "application/x-keepass2": { "extensions": ["kdbx"] },
  "application/x-latex": { "source": "apache", "compressible": false, "extensions": ["latex"] },
  "application/x-lua-bytecode": { "extensions": ["luac"] },
  "application/x-lzh-compressed": { "source": "apache", "extensions": ["lzh", "lha"] },
  "application/x-makeself": { "source": "nginx", "extensions": ["run"] },
  "application/x-mie": { "source": "apache", "extensions": ["mie"] },
  "application/x-mobipocket-ebook": { "source": "apache", "extensions": ["prc", "mobi"] },
  "application/x-mpegurl": { "compressible": false },
  "application/x-ms-application": { "source": "apache", "extensions": ["application"] },
  "application/x-ms-shortcut": { "source": "apache", "extensions": ["lnk"] },
  "application/x-ms-wmd": { "source": "apache", "extensions": ["wmd"] },
  "application/x-ms-wmz": { "source": "apache", "extensions": ["wmz"] },
  "application/x-ms-xbap": { "source": "apache", "extensions": ["xbap"] },
  "application/x-msaccess": { "source": "apache", "extensions": ["mdb"] },
  "application/x-msbinder": { "source": "apache", "extensions": ["obd"] },
  "application/x-mscardfile": { "source": "apache", "extensions": ["crd"] },
  "application/x-msclip": { "source": "apache", "extensions": ["clp"] },
  "application/x-msdos-program": { "extensions": ["exe"] },
  "application/x-msdownload": { "source": "apache", "extensions": ["exe", "dll", "com", "bat", "msi"] },
  "application/x-msmediaview": { "source": "apache", "extensions": ["mvb", "m13", "m14"] },
  "application/x-msmetafile": { "source": "apache", "extensions": ["wmf", "wmz", "emf", "emz"] },
  "application/x-msmoney": { "source": "apache", "extensions": ["mny"] },
  "application/x-mspublisher": { "source": "apache", "extensions": ["pub"] },
  "application/x-msschedule": { "source": "apache", "extensions": ["scd"] },
  "application/x-msterminal": { "source": "apache", "extensions": ["trm"] },
  "application/x-mswrite": { "source": "apache", "extensions": ["wri"] },
  "application/x-netcdf": { "source": "apache", "extensions": ["nc", "cdf"] },
  "application/x-ns-proxy-autoconfig": { "compressible": true, "extensions": ["pac"] },
  "application/x-nzb": { "source": "apache", "extensions": ["nzb"] },
  "application/x-perl": { "source": "nginx", "extensions": ["pl", "pm"] },
  "application/x-pilot": { "source": "nginx", "extensions": ["prc", "pdb"] },
  "application/x-pkcs12": { "source": "apache", "compressible": false, "extensions": ["p12", "pfx"] },
  "application/x-pkcs7-certificates": { "source": "apache", "extensions": ["p7b", "spc"] },
  "application/x-pkcs7-certreqresp": { "source": "apache", "extensions": ["p7r"] },
  "application/x-pki-message": { "source": "iana" },
  "application/x-rar-compressed": { "source": "apache", "compressible": false, "extensions": ["rar"] },
  "application/x-redhat-package-manager": { "source": "nginx", "extensions": ["rpm"] },
  "application/x-research-info-systems": { "source": "apache", "extensions": ["ris"] },
  "application/x-sea": { "source": "nginx", "extensions": ["sea"] },
  "application/x-sh": { "source": "apache", "compressible": true, "extensions": ["sh"] },
  "application/x-shar": { "source": "apache", "extensions": ["shar"] },
  "application/x-shockwave-flash": { "source": "apache", "compressible": false, "extensions": ["swf"] },
  "application/x-silverlight-app": { "source": "apache", "extensions": ["xap"] },
  "application/x-sql": { "source": "apache", "extensions": ["sql"] },
  "application/x-stuffit": { "source": "apache", "compressible": false, "extensions": ["sit"] },
  "application/x-stuffitx": { "source": "apache", "extensions": ["sitx"] },
  "application/x-subrip": { "source": "apache", "extensions": ["srt"] },
  "application/x-sv4cpio": { "source": "apache", "extensions": ["sv4cpio"] },
  "application/x-sv4crc": { "source": "apache", "extensions": ["sv4crc"] },
  "application/x-t3vm-image": { "source": "apache", "extensions": ["t3"] },
  "application/x-tads": { "source": "apache", "extensions": ["gam"] },
  "application/x-tar": { "source": "apache", "compressible": true, "extensions": ["tar"] },
  "application/x-tcl": { "source": "apache", "extensions": ["tcl", "tk"] },
  "application/x-tex": { "source": "apache", "extensions": ["tex"] },
  "application/x-tex-tfm": { "source": "apache", "extensions": ["tfm"] },
  "application/x-texinfo": { "source": "apache", "extensions": ["texinfo", "texi"] },
  "application/x-tgif": { "source": "apache", "extensions": ["obj"] },
  "application/x-ustar": { "source": "apache", "extensions": ["ustar"] },
  "application/x-virtualbox-hdd": { "compressible": true, "extensions": ["hdd"] },
  "application/x-virtualbox-ova": { "compressible": true, "extensions": ["ova"] },
  "application/x-virtualbox-ovf": { "compressible": true, "extensions": ["ovf"] },
  "application/x-virtualbox-vbox": { "compressible": true, "extensions": ["vbox"] },
  "application/x-virtualbox-vbox-extpack": { "compressible": false, "extensions": ["vbox-extpack"] },
  "application/x-virtualbox-vdi": { "compressible": true, "extensions": ["vdi"] },
  "application/x-virtualbox-vhd": { "compressible": true, "extensions": ["vhd"] },
  "application/x-virtualbox-vmdk": { "compressible": true, "extensions": ["vmdk"] },
  "application/x-wais-source": { "source": "apache", "extensions": ["src"] },
  "application/x-web-app-manifest+json": { "compressible": true, "extensions": ["webapp"] },
  "application/x-www-form-urlencoded": { "source": "iana", "compressible": true },
  "application/x-x509-ca-cert": { "source": "iana", "extensions": ["der", "crt", "pem"] },
  "application/x-x509-ca-ra-cert": { "source": "iana" },
  "application/x-x509-next-ca-cert": { "source": "iana" },
  "application/x-xfig": { "source": "apache", "extensions": ["fig"] },
  "application/x-xliff+xml": { "source": "apache", "compressible": true, "extensions": ["xlf"] },
  "application/x-xpinstall": { "source": "apache", "compressible": false, "extensions": ["xpi"] },
  "application/x-xz": { "source": "apache", "extensions": ["xz"] },
  "application/x-zmachine": { "source": "apache", "extensions": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"] },
  "application/x400-bp": { "source": "iana" },
  "application/xacml+xml": { "source": "iana", "compressible": true },
  "application/xaml+xml": { "source": "apache", "compressible": true, "extensions": ["xaml"] },
  "application/xcap-att+xml": { "source": "iana", "compressible": true, "extensions": ["xav"] },
  "application/xcap-caps+xml": { "source": "iana", "compressible": true, "extensions": ["xca"] },
  "application/xcap-diff+xml": { "source": "iana", "compressible": true, "extensions": ["xdf"] },
  "application/xcap-el+xml": { "source": "iana", "compressible": true, "extensions": ["xel"] },
  "application/xcap-error+xml": { "source": "iana", "compressible": true },
  "application/xcap-ns+xml": { "source": "iana", "compressible": true, "extensions": ["xns"] },
  "application/xcon-conference-info+xml": { "source": "iana", "compressible": true },
  "application/xcon-conference-info-diff+xml": { "source": "iana", "compressible": true },
  "application/xenc+xml": { "source": "iana", "compressible": true, "extensions": ["xenc"] },
  "application/xhtml+xml": { "source": "iana", "compressible": true, "extensions": ["xhtml", "xht"] },
  "application/xhtml-voice+xml": { "source": "apache", "compressible": true },
  "application/xliff+xml": { "source": "iana", "compressible": true, "extensions": ["xlf"] },
  "application/xml": { "source": "iana", "compressible": true, "extensions": ["xml", "xsl", "xsd", "rng"] },
  "application/xml-dtd": { "source": "iana", "compressible": true, "extensions": ["dtd"] },
  "application/xml-external-parsed-entity": { "source": "iana" },
  "application/xml-patch+xml": { "source": "iana", "compressible": true },
  "application/xmpp+xml": { "source": "iana", "compressible": true },
  "application/xop+xml": { "source": "iana", "compressible": true, "extensions": ["xop"] },
  "application/xproc+xml": { "source": "apache", "compressible": true, "extensions": ["xpl"] },
  "application/xslt+xml": { "source": "iana", "compressible": true, "extensions": ["xsl", "xslt"] },
  "application/xspf+xml": { "source": "apache", "compressible": true, "extensions": ["xspf"] },
  "application/xv+xml": { "source": "iana", "compressible": true, "extensions": ["mxml", "xhvml", "xvml", "xvm"] },
  "application/yang": { "source": "iana", "extensions": ["yang"] },
  "application/yang-data+json": { "source": "iana", "compressible": true },
  "application/yang-data+xml": { "source": "iana", "compressible": true },
  "application/yang-patch+json": { "source": "iana", "compressible": true },
  "application/yang-patch+xml": { "source": "iana", "compressible": true },
  "application/yin+xml": { "source": "iana", "compressible": true, "extensions": ["yin"] },
  "application/zip": { "source": "iana", "compressible": false, "extensions": ["zip"] },
  "application/zlib": { "source": "iana" },
  "application/zstd": { "source": "iana" },
  "audio/1d-interleaved-parityfec": { "source": "iana" },
  "audio/32kadpcm": { "source": "iana" },
  "audio/3gpp": { "source": "iana", "compressible": false, "extensions": ["3gpp"] },
  "audio/3gpp2": { "source": "iana" },
  "audio/aac": { "source": "iana" },
  "audio/ac3": { "source": "iana" },
  "audio/adpcm": { "source": "apache", "extensions": ["adp"] },
  "audio/amr": { "source": "iana", "extensions": ["amr"] },
  "audio/amr-wb": { "source": "iana" },
  "audio/amr-wb+": { "source": "iana" },
  "audio/aptx": { "source": "iana" },
  "audio/asc": { "source": "iana" },
  "audio/atrac-advanced-lossless": { "source": "iana" },
  "audio/atrac-x": { "source": "iana" },
  "audio/atrac3": { "source": "iana" },
  "audio/basic": { "source": "iana", "compressible": false, "extensions": ["au", "snd"] },
  "audio/bv16": { "source": "iana" },
  "audio/bv32": { "source": "iana" },
  "audio/clearmode": { "source": "iana" },
  "audio/cn": { "source": "iana" },
  "audio/dat12": { "source": "iana" },
  "audio/dls": { "source": "iana" },
  "audio/dsr-es201108": { "source": "iana" },
  "audio/dsr-es202050": { "source": "iana" },
  "audio/dsr-es202211": { "source": "iana" },
  "audio/dsr-es202212": { "source": "iana" },
  "audio/dv": { "source": "iana" },
  "audio/dvi4": { "source": "iana" },
  "audio/eac3": { "source": "iana" },
  "audio/encaprtp": { "source": "iana" },
  "audio/evrc": { "source": "iana" },
  "audio/evrc-qcp": { "source": "iana" },
  "audio/evrc0": { "source": "iana" },
  "audio/evrc1": { "source": "iana" },
  "audio/evrcb": { "source": "iana" },
  "audio/evrcb0": { "source": "iana" },
  "audio/evrcb1": { "source": "iana" },
  "audio/evrcnw": { "source": "iana" },
  "audio/evrcnw0": { "source": "iana" },
  "audio/evrcnw1": { "source": "iana" },
  "audio/evrcwb": { "source": "iana" },
  "audio/evrcwb0": { "source": "iana" },
  "audio/evrcwb1": { "source": "iana" },
  "audio/evs": { "source": "iana" },
  "audio/flexfec": { "source": "iana" },
  "audio/fwdred": { "source": "iana" },
  "audio/g711-0": { "source": "iana" },
  "audio/g719": { "source": "iana" },
  "audio/g722": { "source": "iana" },
  "audio/g7221": { "source": "iana" },
  "audio/g723": { "source": "iana" },
  "audio/g726-16": { "source": "iana" },
  "audio/g726-24": { "source": "iana" },
  "audio/g726-32": { "source": "iana" },
  "audio/g726-40": { "source": "iana" },
  "audio/g728": { "source": "iana" },
  "audio/g729": { "source": "iana" },
  "audio/g7291": { "source": "iana" },
  "audio/g729d": { "source": "iana" },
  "audio/g729e": { "source": "iana" },
  "audio/gsm": { "source": "iana" },
  "audio/gsm-efr": { "source": "iana" },
  "audio/gsm-hr-08": { "source": "iana" },
  "audio/ilbc": { "source": "iana" },
  "audio/ip-mr_v2.5": { "source": "iana" },
  "audio/isac": { "source": "apache" },
  "audio/l16": { "source": "iana" },
  "audio/l20": { "source": "iana" },
  "audio/l24": { "source": "iana", "compressible": false },
  "audio/l8": { "source": "iana" },
  "audio/lpc": { "source": "iana" },
  "audio/melp": { "source": "iana" },
  "audio/melp1200": { "source": "iana" },
  "audio/melp2400": { "source": "iana" },
  "audio/melp600": { "source": "iana" },
  "audio/mhas": { "source": "iana" },
  "audio/midi": { "source": "apache", "extensions": ["mid", "midi", "kar", "rmi"] },
  "audio/mobile-xmf": { "source": "iana", "extensions": ["mxmf"] },
  "audio/mp3": { "compressible": false, "extensions": ["mp3"] },
  "audio/mp4": { "source": "iana", "compressible": false, "extensions": ["m4a", "mp4a"] },
  "audio/mp4a-latm": { "source": "iana" },
  "audio/mpa": { "source": "iana" },
  "audio/mpa-robust": { "source": "iana" },
  "audio/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"] },
  "audio/mpeg4-generic": { "source": "iana" },
  "audio/musepack": { "source": "apache" },
  "audio/ogg": { "source": "iana", "compressible": false, "extensions": ["oga", "ogg", "spx", "opus"] },
  "audio/opus": { "source": "iana" },
  "audio/parityfec": { "source": "iana" },
  "audio/pcma": { "source": "iana" },
  "audio/pcma-wb": { "source": "iana" },
  "audio/pcmu": { "source": "iana" },
  "audio/pcmu-wb": { "source": "iana" },
  "audio/prs.sid": { "source": "iana" },
  "audio/qcelp": { "source": "iana" },
  "audio/raptorfec": { "source": "iana" },
  "audio/red": { "source": "iana" },
  "audio/rtp-enc-aescm128": { "source": "iana" },
  "audio/rtp-midi": { "source": "iana" },
  "audio/rtploopback": { "source": "iana" },
  "audio/rtx": { "source": "iana" },
  "audio/s3m": { "source": "apache", "extensions": ["s3m"] },
  "audio/scip": { "source": "iana" },
  "audio/silk": { "source": "apache", "extensions": ["sil"] },
  "audio/smv": { "source": "iana" },
  "audio/smv-qcp": { "source": "iana" },
  "audio/smv0": { "source": "iana" },
  "audio/sofa": { "source": "iana" },
  "audio/sp-midi": { "source": "iana" },
  "audio/speex": { "source": "iana" },
  "audio/t140c": { "source": "iana" },
  "audio/t38": { "source": "iana" },
  "audio/telephone-event": { "source": "iana" },
  "audio/tetra_acelp": { "source": "iana" },
  "audio/tetra_acelp_bb": { "source": "iana" },
  "audio/tone": { "source": "iana" },
  "audio/tsvcis": { "source": "iana" },
  "audio/uemclip": { "source": "iana" },
  "audio/ulpfec": { "source": "iana" },
  "audio/usac": { "source": "iana" },
  "audio/vdvi": { "source": "iana" },
  "audio/vmr-wb": { "source": "iana" },
  "audio/vnd.3gpp.iufp": { "source": "iana" },
  "audio/vnd.4sb": { "source": "iana" },
  "audio/vnd.audiokoz": { "source": "iana" },
  "audio/vnd.celp": { "source": "iana" },
  "audio/vnd.cisco.nse": { "source": "iana" },
  "audio/vnd.cmles.radio-events": { "source": "iana" },
  "audio/vnd.cns.anp1": { "source": "iana" },
  "audio/vnd.cns.inf1": { "source": "iana" },
  "audio/vnd.dece.audio": { "source": "iana", "extensions": ["uva", "uvva"] },
  "audio/vnd.digital-winds": { "source": "iana", "extensions": ["eol"] },
  "audio/vnd.dlna.adts": { "source": "iana" },
  "audio/vnd.dolby.heaac.1": { "source": "iana" },
  "audio/vnd.dolby.heaac.2": { "source": "iana" },
  "audio/vnd.dolby.mlp": { "source": "iana" },
  "audio/vnd.dolby.mps": { "source": "iana" },
  "audio/vnd.dolby.pl2": { "source": "iana" },
  "audio/vnd.dolby.pl2x": { "source": "iana" },
  "audio/vnd.dolby.pl2z": { "source": "iana" },
  "audio/vnd.dolby.pulse.1": { "source": "iana" },
  "audio/vnd.dra": { "source": "iana", "extensions": ["dra"] },
  "audio/vnd.dts": { "source": "iana", "extensions": ["dts"] },
  "audio/vnd.dts.hd": { "source": "iana", "extensions": ["dtshd"] },
  "audio/vnd.dts.uhd": { "source": "iana" },
  "audio/vnd.dvb.file": { "source": "iana" },
  "audio/vnd.everad.plj": { "source": "iana" },
  "audio/vnd.hns.audio": { "source": "iana" },
  "audio/vnd.lucent.voice": { "source": "iana", "extensions": ["lvp"] },
  "audio/vnd.ms-playready.media.pya": { "source": "iana", "extensions": ["pya"] },
  "audio/vnd.nokia.mobile-xmf": { "source": "iana" },
  "audio/vnd.nortel.vbk": { "source": "iana" },
  "audio/vnd.nuera.ecelp4800": { "source": "iana", "extensions": ["ecelp4800"] },
  "audio/vnd.nuera.ecelp7470": { "source": "iana", "extensions": ["ecelp7470"] },
  "audio/vnd.nuera.ecelp9600": { "source": "iana", "extensions": ["ecelp9600"] },
  "audio/vnd.octel.sbc": { "source": "iana" },
  "audio/vnd.presonus.multitrack": { "source": "iana" },
  "audio/vnd.qcelp": { "source": "iana" },
  "audio/vnd.rhetorex.32kadpcm": { "source": "iana" },
  "audio/vnd.rip": { "source": "iana", "extensions": ["rip"] },
  "audio/vnd.rn-realaudio": { "compressible": false },
  "audio/vnd.sealedmedia.softseal.mpeg": { "source": "iana" },
  "audio/vnd.vmx.cvsd": { "source": "iana" },
  "audio/vnd.wave": { "compressible": false },
  "audio/vorbis": { "source": "iana", "compressible": false },
  "audio/vorbis-config": { "source": "iana" },
  "audio/wav": { "compressible": false, "extensions": ["wav"] },
  "audio/wave": { "compressible": false, "extensions": ["wav"] },
  "audio/webm": { "source": "apache", "compressible": false, "extensions": ["weba"] },
  "audio/x-aac": { "source": "apache", "compressible": false, "extensions": ["aac"] },
  "audio/x-aiff": { "source": "apache", "extensions": ["aif", "aiff", "aifc"] },
  "audio/x-caf": { "source": "apache", "compressible": false, "extensions": ["caf"] },
  "audio/x-flac": { "source": "apache", "extensions": ["flac"] },
  "audio/x-m4a": { "source": "nginx", "extensions": ["m4a"] },
  "audio/x-matroska": { "source": "apache", "extensions": ["mka"] },
  "audio/x-mpegurl": { "source": "apache", "extensions": ["m3u"] },
  "audio/x-ms-wax": { "source": "apache", "extensions": ["wax"] },
  "audio/x-ms-wma": { "source": "apache", "extensions": ["wma"] },
  "audio/x-pn-realaudio": { "source": "apache", "extensions": ["ram", "ra"] },
  "audio/x-pn-realaudio-plugin": { "source": "apache", "extensions": ["rmp"] },
  "audio/x-realaudio": { "source": "nginx", "extensions": ["ra"] },
  "audio/x-tta": { "source": "apache" },
  "audio/x-wav": { "source": "apache", "extensions": ["wav"] },
  "audio/xm": { "source": "apache", "extensions": ["xm"] },
  "chemical/x-cdx": { "source": "apache", "extensions": ["cdx"] },
  "chemical/x-cif": { "source": "apache", "extensions": ["cif"] },
  "chemical/x-cmdf": { "source": "apache", "extensions": ["cmdf"] },
  "chemical/x-cml": { "source": "apache", "extensions": ["cml"] },
  "chemical/x-csml": { "source": "apache", "extensions": ["csml"] },
  "chemical/x-pdb": { "source": "apache" },
  "chemical/x-xyz": { "source": "apache", "extensions": ["xyz"] },
  "font/collection": { "source": "iana", "extensions": ["ttc"] },
  "font/otf": { "source": "iana", "compressible": true, "extensions": ["otf"] },
  "font/sfnt": { "source": "iana" },
  "font/ttf": { "source": "iana", "compressible": true, "extensions": ["ttf"] },
  "font/woff": { "source": "iana", "extensions": ["woff"] },
  "font/woff2": { "source": "iana", "extensions": ["woff2"] },
  "image/aces": { "source": "iana", "extensions": ["exr"] },
  "image/apng": { "compressible": false, "extensions": ["apng"] },
  "image/avci": { "source": "iana", "extensions": ["avci"] },
  "image/avcs": { "source": "iana", "extensions": ["avcs"] },
  "image/avif": { "source": "iana", "compressible": false, "extensions": ["avif"] },
  "image/bmp": { "source": "iana", "compressible": true, "extensions": ["bmp"] },
  "image/cgm": { "source": "iana", "extensions": ["cgm"] },
  "image/dicom-rle": { "source": "iana", "extensions": ["drle"] },
  "image/emf": { "source": "iana", "extensions": ["emf"] },
  "image/fits": { "source": "iana", "extensions": ["fits"] },
  "image/g3fax": { "source": "iana", "extensions": ["g3"] },
  "image/gif": { "source": "iana", "compressible": false, "extensions": ["gif"] },
  "image/heic": { "source": "iana", "extensions": ["heic"] },
  "image/heic-sequence": { "source": "iana", "extensions": ["heics"] },
  "image/heif": { "source": "iana", "extensions": ["heif"] },
  "image/heif-sequence": { "source": "iana", "extensions": ["heifs"] },
  "image/hej2k": { "source": "iana", "extensions": ["hej2"] },
  "image/hsj2": { "source": "iana", "extensions": ["hsj2"] },
  "image/ief": { "source": "iana", "extensions": ["ief"] },
  "image/jls": { "source": "iana", "extensions": ["jls"] },
  "image/jp2": { "source": "iana", "compressible": false, "extensions": ["jp2", "jpg2"] },
  "image/jpeg": { "source": "iana", "compressible": false, "extensions": ["jpeg", "jpg", "jpe"] },
  "image/jph": { "source": "iana", "extensions": ["jph"] },
  "image/jphc": { "source": "iana", "extensions": ["jhc"] },
  "image/jpm": { "source": "iana", "compressible": false, "extensions": ["jpm"] },
  "image/jpx": { "source": "iana", "compressible": false, "extensions": ["jpx", "jpf"] },
  "image/jxr": { "source": "iana", "extensions": ["jxr"] },
  "image/jxra": { "source": "iana", "extensions": ["jxra"] },
  "image/jxrs": { "source": "iana", "extensions": ["jxrs"] },
  "image/jxs": { "source": "iana", "extensions": ["jxs"] },
  "image/jxsc": { "source": "iana", "extensions": ["jxsc"] },
  "image/jxsi": { "source": "iana", "extensions": ["jxsi"] },
  "image/jxss": { "source": "iana", "extensions": ["jxss"] },
  "image/ktx": { "source": "iana", "extensions": ["ktx"] },
  "image/ktx2": { "source": "iana", "extensions": ["ktx2"] },
  "image/naplps": { "source": "iana" },
  "image/pjpeg": { "compressible": false },
  "image/png": { "source": "iana", "compressible": false, "extensions": ["png"] },
  "image/prs.btif": { "source": "iana", "extensions": ["btif"] },
  "image/prs.pti": { "source": "iana", "extensions": ["pti"] },
  "image/pwg-raster": { "source": "iana" },
  "image/sgi": { "source": "apache", "extensions": ["sgi"] },
  "image/svg+xml": { "source": "iana", "compressible": true, "extensions": ["svg", "svgz"] },
  "image/t38": { "source": "iana", "extensions": ["t38"] },
  "image/tiff": { "source": "iana", "compressible": false, "extensions": ["tif", "tiff"] },
  "image/tiff-fx": { "source": "iana", "extensions": ["tfx"] },
  "image/vnd.adobe.photoshop": { "source": "iana", "compressible": true, "extensions": ["psd"] },
  "image/vnd.airzip.accelerator.azv": { "source": "iana", "extensions": ["azv"] },
  "image/vnd.cns.inf2": { "source": "iana" },
  "image/vnd.dece.graphic": { "source": "iana", "extensions": ["uvi", "uvvi", "uvg", "uvvg"] },
  "image/vnd.djvu": { "source": "iana", "extensions": ["djvu", "djv"] },
  "image/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] },
  "image/vnd.dwg": { "source": "iana", "extensions": ["dwg"] },
  "image/vnd.dxf": { "source": "iana", "extensions": ["dxf"] },
  "image/vnd.fastbidsheet": { "source": "iana", "extensions": ["fbs"] },
  "image/vnd.fpx": { "source": "iana", "extensions": ["fpx"] },
  "image/vnd.fst": { "source": "iana", "extensions": ["fst"] },
  "image/vnd.fujixerox.edmics-mmr": { "source": "iana", "extensions": ["mmr"] },
  "image/vnd.fujixerox.edmics-rlc": { "source": "iana", "extensions": ["rlc"] },
  "image/vnd.globalgraphics.pgb": { "source": "iana" },
  "image/vnd.microsoft.icon": { "source": "iana", "compressible": true, "extensions": ["ico"] },
  "image/vnd.mix": { "source": "iana" },
  "image/vnd.mozilla.apng": { "source": "iana" },
  "image/vnd.ms-dds": { "compressible": true, "extensions": ["dds"] },
  "image/vnd.ms-modi": { "source": "iana", "extensions": ["mdi"] },
  "image/vnd.ms-photo": { "source": "apache", "extensions": ["wdp"] },
  "image/vnd.net-fpx": { "source": "iana", "extensions": ["npx"] },
  "image/vnd.pco.b16": { "source": "iana", "extensions": ["b16"] },
  "image/vnd.radiance": { "source": "iana" },
  "image/vnd.sealed.png": { "source": "iana" },
  "image/vnd.sealedmedia.softseal.gif": { "source": "iana" },
  "image/vnd.sealedmedia.softseal.jpg": { "source": "iana" },
  "image/vnd.svf": { "source": "iana" },
  "image/vnd.tencent.tap": { "source": "iana", "extensions": ["tap"] },
  "image/vnd.valve.source.texture": { "source": "iana", "extensions": ["vtf"] },
  "image/vnd.wap.wbmp": { "source": "iana", "extensions": ["wbmp"] },
  "image/vnd.xiff": { "source": "iana", "extensions": ["xif"] },
  "image/vnd.zbrush.pcx": { "source": "iana", "extensions": ["pcx"] },
  "image/webp": { "source": "apache", "extensions": ["webp"] },
  "image/wmf": { "source": "iana", "extensions": ["wmf"] },
  "image/x-3ds": { "source": "apache", "extensions": ["3ds"] },
  "image/x-cmu-raster": { "source": "apache", "extensions": ["ras"] },
  "image/x-cmx": { "source": "apache", "extensions": ["cmx"] },
  "image/x-freehand": { "source": "apache", "extensions": ["fh", "fhc", "fh4", "fh5", "fh7"] },
  "image/x-icon": { "source": "apache", "compressible": true, "extensions": ["ico"] },
  "image/x-jng": { "source": "nginx", "extensions": ["jng"] },
  "image/x-mrsid-image": { "source": "apache", "extensions": ["sid"] },
  "image/x-ms-bmp": { "source": "nginx", "compressible": true, "extensions": ["bmp"] },
  "image/x-pcx": { "source": "apache", "extensions": ["pcx"] },
  "image/x-pict": { "source": "apache", "extensions": ["pic", "pct"] },
  "image/x-portable-anymap": { "source": "apache", "extensions": ["pnm"] },
  "image/x-portable-bitmap": { "source": "apache", "extensions": ["pbm"] },
  "image/x-portable-graymap": { "source": "apache", "extensions": ["pgm"] },
  "image/x-portable-pixmap": { "source": "apache", "extensions": ["ppm"] },
  "image/x-rgb": { "source": "apache", "extensions": ["rgb"] },
  "image/x-tga": { "source": "apache", "extensions": ["tga"] },
  "image/x-xbitmap": { "source": "apache", "extensions": ["xbm"] },
  "image/x-xcf": { "compressible": false },
  "image/x-xpixmap": { "source": "apache", "extensions": ["xpm"] },
  "image/x-xwindowdump": { "source": "apache", "extensions": ["xwd"] },
  "message/cpim": { "source": "iana" },
  "message/delivery-status": { "source": "iana" },
  "message/disposition-notification": { "source": "iana", "extensions": ["disposition-notification"] },
  "message/external-body": { "source": "iana" },
  "message/feedback-report": { "source": "iana" },
  "message/global": { "source": "iana", "extensions": ["u8msg"] },
  "message/global-delivery-status": { "source": "iana", "extensions": ["u8dsn"] },
  "message/global-disposition-notification": { "source": "iana", "extensions": ["u8mdn"] },
  "message/global-headers": { "source": "iana", "extensions": ["u8hdr"] },
  "message/http": { "source": "iana", "compressible": false },
  "message/imdn+xml": { "source": "iana", "compressible": true },
  "message/news": { "source": "iana" },
  "message/partial": { "source": "iana", "compressible": false },
  "message/rfc822": { "source": "iana", "compressible": true, "extensions": ["eml", "mime"] },
  "message/s-http": { "source": "iana" },
  "message/sip": { "source": "iana" },
  "message/sipfrag": { "source": "iana" },
  "message/tracking-status": { "source": "iana" },
  "message/vnd.si.simp": { "source": "iana" },
  "message/vnd.wfa.wsc": { "source": "iana", "extensions": ["wsc"] },
  "model/3mf": { "source": "iana", "extensions": ["3mf"] },
  "model/e57": { "source": "iana" },
  "model/gltf+json": { "source": "iana", "compressible": true, "extensions": ["gltf"] },
  "model/gltf-binary": { "source": "iana", "compressible": true, "extensions": ["glb"] },
  "model/iges": { "source": "iana", "compressible": false, "extensions": ["igs", "iges"] },
  "model/mesh": { "source": "iana", "compressible": false, "extensions": ["msh", "mesh", "silo"] },
  "model/mtl": { "source": "iana", "extensions": ["mtl"] },
  "model/obj": { "source": "iana", "extensions": ["obj"] },
  "model/step": { "source": "iana" },
  "model/step+xml": { "source": "iana", "compressible": true, "extensions": ["stpx"] },
  "model/step+zip": { "source": "iana", "compressible": false, "extensions": ["stpz"] },
  "model/step-xml+zip": { "source": "iana", "compressible": false, "extensions": ["stpxz"] },
  "model/stl": { "source": "iana", "extensions": ["stl"] },
  "model/vnd.collada+xml": { "source": "iana", "compressible": true, "extensions": ["dae"] },
  "model/vnd.dwf": { "source": "iana", "extensions": ["dwf"] },
  "model/vnd.flatland.3dml": { "source": "iana" },
  "model/vnd.gdl": { "source": "iana", "extensions": ["gdl"] },
  "model/vnd.gs-gdl": { "source": "apache" },
  "model/vnd.gs.gdl": { "source": "iana" },
  "model/vnd.gtw": { "source": "iana", "extensions": ["gtw"] },
  "model/vnd.moml+xml": { "source": "iana", "compressible": true },
  "model/vnd.mts": { "source": "iana", "extensions": ["mts"] },
  "model/vnd.opengex": { "source": "iana", "extensions": ["ogex"] },
  "model/vnd.parasolid.transmit.binary": { "source": "iana", "extensions": ["x_b"] },
  "model/vnd.parasolid.transmit.text": { "source": "iana", "extensions": ["x_t"] },
  "model/vnd.pytha.pyox": { "source": "iana" },
  "model/vnd.rosette.annotated-data-model": { "source": "iana" },
  "model/vnd.sap.vds": { "source": "iana", "extensions": ["vds"] },
  "model/vnd.usdz+zip": { "source": "iana", "compressible": false, "extensions": ["usdz"] },
  "model/vnd.valve.source.compiled-map": { "source": "iana", "extensions": ["bsp"] },
  "model/vnd.vtu": { "source": "iana", "extensions": ["vtu"] },
  "model/vrml": { "source": "iana", "compressible": false, "extensions": ["wrl", "vrml"] },
  "model/x3d+binary": { "source": "apache", "compressible": false, "extensions": ["x3db", "x3dbz"] },
  "model/x3d+fastinfoset": { "source": "iana", "extensions": ["x3db"] },
  "model/x3d+vrml": { "source": "apache", "compressible": false, "extensions": ["x3dv", "x3dvz"] },
  "model/x3d+xml": { "source": "iana", "compressible": true, "extensions": ["x3d", "x3dz"] },
  "model/x3d-vrml": { "source": "iana", "extensions": ["x3dv"] },
  "multipart/alternative": { "source": "iana", "compressible": false },
  "multipart/appledouble": { "source": "iana" },
  "multipart/byteranges": { "source": "iana" },
  "multipart/digest": { "source": "iana" },
  "multipart/encrypted": { "source": "iana", "compressible": false },
  "multipart/form-data": { "source": "iana", "compressible": false },
  "multipart/header-set": { "source": "iana" },
  "multipart/mixed": { "source": "iana" },
  "multipart/multilingual": { "source": "iana" },
  "multipart/parallel": { "source": "iana" },
  "multipart/related": { "source": "iana", "compressible": false },
  "multipart/report": { "source": "iana" },
  "multipart/signed": { "source": "iana", "compressible": false },
  "multipart/vnd.bint.med-plus": { "source": "iana" },
  "multipart/voice-message": { "source": "iana" },
  "multipart/x-mixed-replace": { "source": "iana" },
  "text/1d-interleaved-parityfec": { "source": "iana" },
  "text/cache-manifest": { "source": "iana", "compressible": true, "extensions": ["appcache", "manifest"] },
  "text/calendar": { "source": "iana", "extensions": ["ics", "ifb"] },
  "text/calender": { "compressible": true },
  "text/cmd": { "compressible": true },
  "text/coffeescript": { "extensions": ["coffee", "litcoffee"] },
  "text/cql": { "source": "iana" },
  "text/cql-expression": { "source": "iana" },
  "text/cql-identifier": { "source": "iana" },
  "text/css": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["css"] },
  "text/csv": { "source": "iana", "compressible": true, "extensions": ["csv"] },
  "text/csv-schema": { "source": "iana" },
  "text/directory": { "source": "iana" },
  "text/dns": { "source": "iana" },
  "text/ecmascript": { "source": "iana" },
  "text/encaprtp": { "source": "iana" },
  "text/enriched": { "source": "iana" },
  "text/fhirpath": { "source": "iana" },
  "text/flexfec": { "source": "iana" },
  "text/fwdred": { "source": "iana" },
  "text/gff3": { "source": "iana" },
  "text/grammar-ref-list": { "source": "iana" },
  "text/html": { "source": "iana", "compressible": true, "extensions": ["html", "htm", "shtml"] },
  "text/jade": { "extensions": ["jade"] },
  "text/javascript": { "source": "iana", "compressible": true },
  "text/jcr-cnd": { "source": "iana" },
  "text/jsx": { "compressible": true, "extensions": ["jsx"] },
  "text/less": { "compressible": true, "extensions": ["less"] },
  "text/markdown": { "source": "iana", "compressible": true, "extensions": ["markdown", "md"] },
  "text/mathml": { "source": "nginx", "extensions": ["mml"] },
  "text/mdx": { "compressible": true, "extensions": ["mdx"] },
  "text/mizar": { "source": "iana" },
  "text/n3": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["n3"] },
  "text/parameters": { "source": "iana", "charset": "UTF-8" },
  "text/parityfec": { "source": "iana" },
  "text/plain": { "source": "iana", "compressible": true, "extensions": ["txt", "text", "conf", "def", "list", "log", "in", "ini"] },
  "text/provenance-notation": { "source": "iana", "charset": "UTF-8" },
  "text/prs.fallenstein.rst": { "source": "iana" },
  "text/prs.lines.tag": { "source": "iana", "extensions": ["dsc"] },
  "text/prs.prop.logic": { "source": "iana" },
  "text/raptorfec": { "source": "iana" },
  "text/red": { "source": "iana" },
  "text/rfc822-headers": { "source": "iana" },
  "text/richtext": { "source": "iana", "compressible": true, "extensions": ["rtx"] },
  "text/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] },
  "text/rtp-enc-aescm128": { "source": "iana" },
  "text/rtploopback": { "source": "iana" },
  "text/rtx": { "source": "iana" },
  "text/sgml": { "source": "iana", "extensions": ["sgml", "sgm"] },
  "text/shaclc": { "source": "iana" },
  "text/shex": { "source": "iana", "extensions": ["shex"] },
  "text/slim": { "extensions": ["slim", "slm"] },
  "text/spdx": { "source": "iana", "extensions": ["spdx"] },
  "text/strings": { "source": "iana" },
  "text/stylus": { "extensions": ["stylus", "styl"] },
  "text/t140": { "source": "iana" },
  "text/tab-separated-values": { "source": "iana", "compressible": true, "extensions": ["tsv"] },
  "text/troff": { "source": "iana", "extensions": ["t", "tr", "roff", "man", "me", "ms"] },
  "text/turtle": { "source": "iana", "charset": "UTF-8", "extensions": ["ttl"] },
  "text/ulpfec": { "source": "iana" },
  "text/uri-list": { "source": "iana", "compressible": true, "extensions": ["uri", "uris", "urls"] },
  "text/vcard": { "source": "iana", "compressible": true, "extensions": ["vcard"] },
  "text/vnd.a": { "source": "iana" },
  "text/vnd.abc": { "source": "iana" },
  "text/vnd.ascii-art": { "source": "iana" },
  "text/vnd.curl": { "source": "iana", "extensions": ["curl"] },
  "text/vnd.curl.dcurl": { "source": "apache", "extensions": ["dcurl"] },
  "text/vnd.curl.mcurl": { "source": "apache", "extensions": ["mcurl"] },
  "text/vnd.curl.scurl": { "source": "apache", "extensions": ["scurl"] },
  "text/vnd.debian.copyright": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.dmclientscript": { "source": "iana" },
  "text/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] },
  "text/vnd.esmertec.theme-descriptor": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.familysearch.gedcom": { "source": "iana", "extensions": ["ged"] },
  "text/vnd.ficlab.flt": { "source": "iana" },
  "text/vnd.fly": { "source": "iana", "extensions": ["fly"] },
  "text/vnd.fmi.flexstor": { "source": "iana", "extensions": ["flx"] },
  "text/vnd.gml": { "source": "iana" },
  "text/vnd.graphviz": { "source": "iana", "extensions": ["gv"] },
  "text/vnd.hans": { "source": "iana" },
  "text/vnd.hgl": { "source": "iana" },
  "text/vnd.in3d.3dml": { "source": "iana", "extensions": ["3dml"] },
  "text/vnd.in3d.spot": { "source": "iana", "extensions": ["spot"] },
  "text/vnd.iptc.newsml": { "source": "iana" },
  "text/vnd.iptc.nitf": { "source": "iana" },
  "text/vnd.latex-z": { "source": "iana" },
  "text/vnd.motorola.reflex": { "source": "iana" },
  "text/vnd.ms-mediapackage": { "source": "iana" },
  "text/vnd.net2phone.commcenter.command": { "source": "iana" },
  "text/vnd.radisys.msml-basic-layout": { "source": "iana" },
  "text/vnd.senx.warpscript": { "source": "iana" },
  "text/vnd.si.uricatalogue": { "source": "iana" },
  "text/vnd.sosi": { "source": "iana" },
  "text/vnd.sun.j2me.app-descriptor": { "source": "iana", "charset": "UTF-8", "extensions": ["jad"] },
  "text/vnd.trolltech.linguist": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.wap.si": { "source": "iana" },
  "text/vnd.wap.sl": { "source": "iana" },
  "text/vnd.wap.wml": { "source": "iana", "extensions": ["wml"] },
  "text/vnd.wap.wmlscript": { "source": "iana", "extensions": ["wmls"] },
  "text/vtt": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["vtt"] },
  "text/x-asm": { "source": "apache", "extensions": ["s", "asm"] },
  "text/x-c": { "source": "apache", "extensions": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"] },
  "text/x-component": { "source": "nginx", "extensions": ["htc"] },
  "text/x-fortran": { "source": "apache", "extensions": ["f", "for", "f77", "f90"] },
  "text/x-gwt-rpc": { "compressible": true },
  "text/x-handlebars-template": { "extensions": ["hbs"] },
  "text/x-java-source": { "source": "apache", "extensions": ["java"] },
  "text/x-jquery-tmpl": { "compressible": true },
  "text/x-lua": { "extensions": ["lua"] },
  "text/x-markdown": { "compressible": true, "extensions": ["mkd"] },
  "text/x-nfo": { "source": "apache", "extensions": ["nfo"] },
  "text/x-opml": { "source": "apache", "extensions": ["opml"] },
  "text/x-org": { "compressible": true, "extensions": ["org"] },
  "text/x-pascal": { "source": "apache", "extensions": ["p", "pas"] },
  "text/x-processing": { "compressible": true, "extensions": ["pde"] },
  "text/x-sass": { "extensions": ["sass"] },
  "text/x-scss": { "extensions": ["scss"] },
  "text/x-setext": { "source": "apache", "extensions": ["etx"] },
  "text/x-sfv": { "source": "apache", "extensions": ["sfv"] },
  "text/x-suse-ymp": { "compressible": true, "extensions": ["ymp"] },
  "text/x-uuencode": { "source": "apache", "extensions": ["uu"] },
  "text/x-vcalendar": { "source": "apache", "extensions": ["vcs"] },
  "text/x-vcard": { "source": "apache", "extensions": ["vcf"] },
  "text/xml": { "source": "iana", "compressible": true, "extensions": ["xml"] },
  "text/xml-external-parsed-entity": { "source": "iana" },
  "text/yaml": { "compressible": true, "extensions": ["yaml", "yml"] },
  "video/1d-interleaved-parityfec": { "source": "iana" },
  "video/3gpp": { "source": "iana", "extensions": ["3gp", "3gpp"] },
  "video/3gpp-tt": { "source": "iana" },
  "video/3gpp2": { "source": "iana", "extensions": ["3g2"] },
  "video/av1": { "source": "iana" },
  "video/bmpeg": { "source": "iana" },
  "video/bt656": { "source": "iana" },
  "video/celb": { "source": "iana" },
  "video/dv": { "source": "iana" },
  "video/encaprtp": { "source": "iana" },
  "video/ffv1": { "source": "iana" },
  "video/flexfec": { "source": "iana" },
  "video/h261": { "source": "iana", "extensions": ["h261"] },
  "video/h263": { "source": "iana", "extensions": ["h263"] },
  "video/h263-1998": { "source": "iana" },
  "video/h263-2000": { "source": "iana" },
  "video/h264": { "source": "iana", "extensions": ["h264"] },
  "video/h264-rcdo": { "source": "iana" },
  "video/h264-svc": { "source": "iana" },
  "video/h265": { "source": "iana" },
  "video/iso.segment": { "source": "iana", "extensions": ["m4s"] },
  "video/jpeg": { "source": "iana", "extensions": ["jpgv"] },
  "video/jpeg2000": { "source": "iana" },
  "video/jpm": { "source": "apache", "extensions": ["jpm", "jpgm"] },
  "video/jxsv": { "source": "iana" },
  "video/mj2": { "source": "iana", "extensions": ["mj2", "mjp2"] },
  "video/mp1s": { "source": "iana" },
  "video/mp2p": { "source": "iana" },
  "video/mp2t": { "source": "iana", "extensions": ["ts"] },
  "video/mp4": { "source": "iana", "compressible": false, "extensions": ["mp4", "mp4v", "mpg4"] },
  "video/mp4v-es": { "source": "iana" },
  "video/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpeg", "mpg", "mpe", "m1v", "m2v"] },
  "video/mpeg4-generic": { "source": "iana" },
  "video/mpv": { "source": "iana" },
  "video/nv": { "source": "iana" },
  "video/ogg": { "source": "iana", "compressible": false, "extensions": ["ogv"] },
  "video/parityfec": { "source": "iana" },
  "video/pointer": { "source": "iana" },
  "video/quicktime": { "source": "iana", "compressible": false, "extensions": ["qt", "mov"] },
  "video/raptorfec": { "source": "iana" },
  "video/raw": { "source": "iana" },
  "video/rtp-enc-aescm128": { "source": "iana" },
  "video/rtploopback": { "source": "iana" },
  "video/rtx": { "source": "iana" },
  "video/scip": { "source": "iana" },
  "video/smpte291": { "source": "iana" },
  "video/smpte292m": { "source": "iana" },
  "video/ulpfec": { "source": "iana" },
  "video/vc1": { "source": "iana" },
  "video/vc2": { "source": "iana" },
  "video/vnd.cctv": { "source": "iana" },
  "video/vnd.dece.hd": { "source": "iana", "extensions": ["uvh", "uvvh"] },
  "video/vnd.dece.mobile": { "source": "iana", "extensions": ["uvm", "uvvm"] },
  "video/vnd.dece.mp4": { "source": "iana" },
  "video/vnd.dece.pd": { "source": "iana", "extensions": ["uvp", "uvvp"] },
  "video/vnd.dece.sd": { "source": "iana", "extensions": ["uvs", "uvvs"] },
  "video/vnd.dece.video": { "source": "iana", "extensions": ["uvv", "uvvv"] },
  "video/vnd.directv.mpeg": { "source": "iana" },
  "video/vnd.directv.mpeg-tts": { "source": "iana" },
  "video/vnd.dlna.mpeg-tts": { "source": "iana" },
  "video/vnd.dvb.file": { "source": "iana", "extensions": ["dvb"] },
  "video/vnd.fvt": { "source": "iana", "extensions": ["fvt"] },
  "video/vnd.hns.video": { "source": "iana" },
  "video/vnd.iptvforum.1dparityfec-1010": { "source": "iana" },
  "video/vnd.iptvforum.1dparityfec-2005": { "source": "iana" },
  "video/vnd.iptvforum.2dparityfec-1010": { "source": "iana" },
  "video/vnd.iptvforum.2dparityfec-2005": { "source": "iana" },
  "video/vnd.iptvforum.ttsavc": { "source": "iana" },
  "video/vnd.iptvforum.ttsmpeg2": { "source": "iana" },
  "video/vnd.motorola.video": { "source": "iana" },
  "video/vnd.motorola.videop": { "source": "iana" },
  "video/vnd.mpegurl": { "source": "iana", "extensions": ["mxu", "m4u"] },
  "video/vnd.ms-playready.media.pyv": { "source": "iana", "extensions": ["pyv"] },
  "video/vnd.nokia.interleaved-multimedia": { "source": "iana" },
  "video/vnd.nokia.mp4vr": { "source": "iana" },
  "video/vnd.nokia.videovoip": { "source": "iana" },
  "video/vnd.objectvideo": { "source": "iana" },
  "video/vnd.radgamettools.bink": { "source": "iana" },
  "video/vnd.radgamettools.smacker": { "source": "iana" },
  "video/vnd.sealed.mpeg1": { "source": "iana" },
  "video/vnd.sealed.mpeg4": { "source": "iana" },
  "video/vnd.sealed.swf": { "source": "iana" },
  "video/vnd.sealedmedia.softseal.mov": { "source": "iana" },
  "video/vnd.uvvu.mp4": { "source": "iana", "extensions": ["uvu", "uvvu"] },
  "video/vnd.vivo": { "source": "iana", "extensions": ["viv"] },
  "video/vnd.youtube.yt": { "source": "iana" },
  "video/vp8": { "source": "iana" },
  "video/vp9": { "source": "iana" },
  "video/webm": { "source": "apache", "compressible": false, "extensions": ["webm"] },
  "video/x-f4v": { "source": "apache", "extensions": ["f4v"] },
  "video/x-fli": { "source": "apache", "extensions": ["fli"] },
  "video/x-flv": { "source": "apache", "compressible": false, "extensions": ["flv"] },
  "video/x-m4v": { "source": "apache", "extensions": ["m4v"] },
  "video/x-matroska": { "source": "apache", "compressible": false, "extensions": ["mkv", "mk3d", "mks"] },
  "video/x-mng": { "source": "apache", "extensions": ["mng"] },
  "video/x-ms-asf": { "source": "apache", "extensions": ["asf", "asx"] },
  "video/x-ms-vob": { "source": "apache", "extensions": ["vob"] },
  "video/x-ms-wm": { "source": "apache", "extensions": ["wm"] },
  "video/x-ms-wmv": { "source": "apache", "compressible": false, "extensions": ["wmv"] },
  "video/x-ms-wmx": { "source": "apache", "extensions": ["wmx"] },
  "video/x-ms-wvx": { "source": "apache", "extensions": ["wvx"] },
  "video/x-msvideo": { "source": "apache", "extensions": ["avi"] },
  "video/x-sgi-movie": { "source": "apache", "extensions": ["movie"] },
  "video/x-smv": { "source": "apache", "extensions": ["smv"] },
  "x-conference/x-cooltalk": { "source": "apache", "extensions": ["ice"] },
  "x-shader/x-fragment": { "compressible": true },
  "x-shader/x-vertex": { "compressible": true }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var mimeDb;
var hasRequiredMimeDb;
function requireMimeDb() {
  if (hasRequiredMimeDb) return mimeDb;
  hasRequiredMimeDb = 1;
  mimeDb = require$$0;
  return mimeDb;
}
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredMimeTypes;
function requireMimeTypes() {
  if (hasRequiredMimeTypes) return mimeTypes;
  hasRequiredMimeTypes = 1;
  (function(exports) {
    var db = requireMimeDb();
    var extname = require$$1$3.extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset;
    exports.charsets = { lookup: charset };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = /* @__PURE__ */ Object.create(null);
    exports.lookup = lookup;
    exports.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports.charset(mime);
        if (charset2) mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2);
      var exts = match && exports.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    function populateMaps(extensions, types2) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type2) {
        var mime = db[type2];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type2] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types2[extension2]) {
            var from = preference.indexOf(db[types2[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types2[extension2] !== "application/octet-stream" && (from > to || from === to && types2[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types2[extension2] = type2;
        }
      });
    }
  })(mimeTypes);
  return mimeTypes;
}
var defer_1;
var hasRequiredDefer;
function requireDefer() {
  if (hasRequiredDefer) return defer_1;
  hasRequiredDefer = 1;
  defer_1 = defer;
  function defer(fn) {
    var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
    if (nextTick) {
      nextTick(fn);
    } else {
      setTimeout(fn, 0);
    }
  }
  return defer_1;
}
var async_1;
var hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async_1;
  hasRequiredAsync = 1;
  var defer = requireDefer();
  async_1 = async;
  function async(callback) {
    var isAsync = false;
    defer(function() {
      isAsync = true;
    });
    return function async_callback(err, result) {
      if (isAsync) {
        callback(err, result);
      } else {
        defer(function nextTick_callback() {
          callback(err, result);
        });
      }
    };
  }
  return async_1;
}
var abort_1;
var hasRequiredAbort;
function requireAbort() {
  if (hasRequiredAbort) return abort_1;
  hasRequiredAbort = 1;
  abort_1 = abort;
  function abort(state) {
    Object.keys(state.jobs).forEach(clean.bind(state));
    state.jobs = {};
  }
  function clean(key) {
    if (typeof this.jobs[key] == "function") {
      this.jobs[key]();
    }
  }
  return abort_1;
}
var iterate_1;
var hasRequiredIterate;
function requireIterate() {
  if (hasRequiredIterate) return iterate_1;
  hasRequiredIterate = 1;
  var async = requireAsync(), abort = requireAbort();
  iterate_1 = iterate;
  function iterate(list, iterator, state, callback) {
    var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
    state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
      if (!(key in state.jobs)) {
        return;
      }
      delete state.jobs[key];
      if (error) {
        abort(state);
      } else {
        state.results[key] = output;
      }
      callback(error, state.results);
    });
  }
  function runJob(iterator, key, item, callback) {
    var aborter;
    if (iterator.length == 2) {
      aborter = iterator(item, async(callback));
    } else {
      aborter = iterator(item, key, async(callback));
    }
    return aborter;
  }
  return iterate_1;
}
var state_1;
var hasRequiredState;
function requireState() {
  if (hasRequiredState) return state_1;
  hasRequiredState = 1;
  state_1 = state;
  function state(list, sortMethod) {
    var isNamedList = !Array.isArray(list), initState = {
      index: 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs: {},
      results: isNamedList ? {} : [],
      size: isNamedList ? Object.keys(list).length : list.length
    };
    if (sortMethod) {
      initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
        return sortMethod(list[a], list[b]);
      });
    }
    return initState;
  }
  return state_1;
}
var terminator_1;
var hasRequiredTerminator;
function requireTerminator() {
  if (hasRequiredTerminator) return terminator_1;
  hasRequiredTerminator = 1;
  var abort = requireAbort(), async = requireAsync();
  terminator_1 = terminator;
  function terminator(callback) {
    if (!Object.keys(this.jobs).length) {
      return;
    }
    this.index = this.size;
    abort(this);
    async(callback)(null, this.results);
  }
  return terminator_1;
}
var parallel_1;
var hasRequiredParallel;
function requireParallel() {
  if (hasRequiredParallel) return parallel_1;
  hasRequiredParallel = 1;
  var iterate = requireIterate(), initState = requireState(), terminator = requireTerminator();
  parallel_1 = parallel;
  function parallel(list, iterator, callback) {
    var state = initState(list);
    while (state.index < (state["keyedList"] || list).length) {
      iterate(list, iterator, state, function(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        if (Object.keys(state.jobs).length === 0) {
          callback(null, state.results);
          return;
        }
      });
      state.index++;
    }
    return terminator.bind(state, callback);
  }
  return parallel_1;
}
var serialOrdered = { exports: {} };
var hasRequiredSerialOrdered;
function requireSerialOrdered() {
  if (hasRequiredSerialOrdered) return serialOrdered.exports;
  hasRequiredSerialOrdered = 1;
  var iterate = requireIterate(), initState = requireState(), terminator = requireTerminator();
  serialOrdered.exports = serialOrdered$1;
  serialOrdered.exports.ascending = ascending;
  serialOrdered.exports.descending = descending;
  function serialOrdered$1(list, iterator, sortMethod, callback) {
    var state = initState(list, sortMethod);
    iterate(list, iterator, state, function iteratorHandler(error, result) {
      if (error) {
        callback(error, result);
        return;
      }
      state.index++;
      if (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, iteratorHandler);
        return;
      }
      callback(null, state.results);
    });
    return terminator.bind(state, callback);
  }
  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  function descending(a, b) {
    return -1 * ascending(a, b);
  }
  return serialOrdered.exports;
}
var serial_1;
var hasRequiredSerial$1;
function requireSerial$1() {
  if (hasRequiredSerial$1) return serial_1;
  hasRequiredSerial$1 = 1;
  var serialOrdered2 = requireSerialOrdered();
  serial_1 = serial2;
  function serial2(list, iterator, callback) {
    return serialOrdered2(list, iterator, null, callback);
  }
  return serial_1;
}
var asynckit;
var hasRequiredAsynckit;
function requireAsynckit() {
  if (hasRequiredAsynckit) return asynckit;
  hasRequiredAsynckit = 1;
  asynckit = {
    parallel: requireParallel(),
    serial: requireSerial$1(),
    serialOrdered: requireSerialOrdered()
  };
  return asynckit;
}
var esObjectAtoms;
var hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  if (hasRequiredEsObjectAtoms) return esObjectAtoms;
  hasRequiredEsObjectAtoms = 1;
  esObjectAtoms = Object;
  return esObjectAtoms;
}
var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
  if (hasRequiredEsErrors) return esErrors;
  hasRequiredEsErrors = 1;
  esErrors = Error;
  return esErrors;
}
var _eval;
var hasRequired_eval;
function require_eval() {
  if (hasRequired_eval) return _eval;
  hasRequired_eval = 1;
  _eval = EvalError;
  return _eval;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  range = RangeError;
  return range;
}
var ref;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  ref = ReferenceError;
  return ref;
}
var syntax;
var hasRequiredSyntax;
function requireSyntax() {
  if (hasRequiredSyntax) return syntax;
  hasRequiredSyntax = 1;
  syntax = SyntaxError;
  return syntax;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  type = TypeError;
  return type;
}
var uri;
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  uri = URIError;
  return uri;
}
var abs;
var hasRequiredAbs;
function requireAbs() {
  if (hasRequiredAbs) return abs;
  hasRequiredAbs = 1;
  abs = Math.abs;
  return abs;
}
var floor;
var hasRequiredFloor;
function requireFloor() {
  if (hasRequiredFloor) return floor;
  hasRequiredFloor = 1;
  floor = Math.floor;
  return floor;
}
var max$1;
var hasRequiredMax$1;
function requireMax$1() {
  if (hasRequiredMax$1) return max$1;
  hasRequiredMax$1 = 1;
  max$1 = Math.max;
  return max$1;
}
var min;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin) return min;
  hasRequiredMin = 1;
  min = Math.min;
  return min;
}
var pow;
var hasRequiredPow;
function requirePow() {
  if (hasRequiredPow) return pow;
  hasRequiredPow = 1;
  pow = Math.pow;
  return pow;
}
var round;
var hasRequiredRound;
function requireRound() {
  if (hasRequiredRound) return round;
  hasRequiredRound = 1;
  round = Math.round;
  return round;
}
var _isNaN;
var hasRequired_isNaN;
function require_isNaN() {
  if (hasRequired_isNaN) return _isNaN;
  hasRequired_isNaN = 1;
  _isNaN = Number.isNaN || function isNaN2(a) {
    return a !== a;
  };
  return _isNaN;
}
var sign;
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign;
  hasRequiredSign = 1;
  var $isNaN = /* @__PURE__ */ require_isNaN();
  sign = function sign2(number) {
    if ($isNaN(number) || number === 0) {
      return number;
    }
    return number < 0 ? -1 : 1;
  };
  return sign;
}
var gOPD;
var hasRequiredGOPD;
function requireGOPD() {
  if (hasRequiredGOPD) return gOPD;
  hasRequiredGOPD = 1;
  gOPD = Object.getOwnPropertyDescriptor;
  return gOPD;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var $gOPD = /* @__PURE__ */ requireGOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  esDefineProperty = $defineProperty;
  return esDefineProperty;
}
var shams$1;
var hasRequiredShams$1;
function requireShams$1() {
  if (hasRequiredShams$1) return shams$1;
  hasRequiredShams$1 = 1;
  shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams$1;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams$1();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  Object_getPrototypeOf = $Object.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b) {
    var arr = [];
    for (var i = 0; i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0; i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation = function bind2(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var bind2 = requireFunctionBind();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var $reflectApply = requireReflectApply();
  actualApply = $reflectApply || bind2.call($call, $apply);
  return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind2 = requireFunctionBind();
  var $TypeError = /* @__PURE__ */ requireType();
  var $call = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind2, $call, args);
  };
  return callBindApplyHelpers;
}
var get$1;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get$1;
  hasRequiredGet = 1;
  var callBind = requireCallBindApplyHelpers();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  get$1 = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object(value));
    }
  ) : false;
  return get$1;
}
var getProto;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = /* @__PURE__ */ requireGet();
  getProto = reflectGetProto ? function getProto2(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto2(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto2(O) {
    return getDunderProto(O);
  } : null;
  return getProto;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind2 = requireFunctionBind();
  hasown = bind2.call(call, $hasOwn);
  return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  var $Error = /* @__PURE__ */ requireEsErrors();
  var $EvalError = /* @__PURE__ */ require_eval();
  var $RangeError = /* @__PURE__ */ requireRange();
  var $ReferenceError = /* @__PURE__ */ requireRef();
  var $SyntaxError = /* @__PURE__ */ requireSyntax();
  var $TypeError = /* @__PURE__ */ requireType();
  var $URIError = /* @__PURE__ */ requireUri();
  var abs2 = /* @__PURE__ */ requireAbs();
  var floor2 = /* @__PURE__ */ requireFloor();
  var max2 = /* @__PURE__ */ requireMax$1();
  var min2 = /* @__PURE__ */ requireMin();
  var pow2 = /* @__PURE__ */ requirePow();
  var round2 = /* @__PURE__ */ requireRound();
  var sign2 = /* @__PURE__ */ requireSign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = /* @__PURE__ */ requireGopd();
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var getProto2 = requireGetProto();
  var $ObjectGPO = requireObject_getPrototypeOf();
  var $ReflectGPO = requireReflect_getPrototypeOf();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1 : getProto2(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs2,
    "%Math.floor%": floor2,
    "%Math.max%": max2,
    "%Math.min%": min2,
    "%Math.pow%": pow2,
    "%Math.round%": round2,
    "%Math.sign%": sign2,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto2) {
    try {
      null.error;
    } catch (e) {
      var errorProto = getProto2(getProto2(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto2) {
        value = getProto2(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind2 = requireFunctionBind();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var $concat = bind2.call($call, Array.prototype.concat);
  var $spliceApply = bind2.call($apply, Array.prototype.splice);
  var $replace = bind2.call($call, String.prototype.replace);
  var $strSlice = bind2.call($call, String.prototype.slice);
  var $exec = bind2.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void 0;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var hasSymbols2 = requireShams$1();
  shams = function hasToStringTagShams() {
    return hasSymbols2() && !!Symbol.toStringTag;
  };
  return shams;
}
var esSetTostringtag;
var hasRequiredEsSetTostringtag;
function requireEsSetTostringtag() {
  if (hasRequiredEsSetTostringtag) return esSetTostringtag;
  hasRequiredEsSetTostringtag = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
  var hasToStringTag = requireShams()();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var $TypeError = /* @__PURE__ */ requireType();
  var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
  esSetTostringtag = function setToStringTag(object, value) {
    var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
    var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
    if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
      throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
    }
    if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
      if ($defineProperty) {
        $defineProperty(object, toStringTag, {
          configurable: !nonConfigurable,
          enumerable: false,
          value,
          writable: false
        });
      } else {
        object[toStringTag] = value;
      }
    }
  };
  return esSetTostringtag;
}
var populate;
var hasRequiredPopulate;
function requirePopulate() {
  if (hasRequiredPopulate) return populate;
  hasRequiredPopulate = 1;
  populate = function(dst, src2) {
    Object.keys(src2).forEach(function(prop) {
      dst[prop] = dst[prop] || src2[prop];
    });
    return dst;
  };
  return populate;
}
var form_data;
var hasRequiredForm_data;
function requireForm_data() {
  if (hasRequiredForm_data) return form_data;
  hasRequiredForm_data = 1;
  var CombinedStream = requireCombined_stream();
  var util = require$$1$1;
  var path = require$$1$3;
  var http = require$$1$2;
  var https2 = require$$2;
  var parseUrl = require$$0$2.parse;
  var fs = require$$6;
  var Stream = require$$3.Stream;
  var mime = requireMimeTypes();
  var asynckit2 = requireAsynckit();
  var setToStringTag = /* @__PURE__ */ requireEsSetTostringtag();
  var populate2 = requirePopulate();
  form_data = FormData2;
  util.inherits(FormData2, CombinedStream);
  function FormData2(options) {
    if (!(this instanceof FormData2)) {
      return new FormData2(options);
    }
    this._overheadLength = 0;
    this._valueLength = 0;
    this._valuesToMeasure = [];
    CombinedStream.call(this);
    options = options || {};
    for (var option in options) {
      this[option] = options[option];
    }
  }
  FormData2.LINE_BREAK = "\r\n";
  FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
  FormData2.prototype.append = function(field, value, options) {
    options = options || {};
    if (typeof options == "string") {
      options = { filename: options };
    }
    var append = CombinedStream.prototype.append.bind(this);
    if (typeof value == "number") {
      value = "" + value;
    }
    if (Array.isArray(value)) {
      this._error(new Error("Arrays are not supported."));
      return;
    }
    var header = this._multiPartHeader(field, value, options);
    var footer = this._multiPartFooter();
    append(header);
    append(value);
    append(footer);
    this._trackLength(header, value, options);
  };
  FormData2.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    if (options.knownLength != null) {
      valueLength += +options.knownLength;
    } else if (Buffer.isBuffer(value)) {
      valueLength = value.length;
    } else if (typeof value === "string") {
      valueLength = Buffer.byteLength(value);
    }
    this._valueLength += valueLength;
    this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
    if (!value || !value.path && !(value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) && !(value instanceof Stream)) {
      return;
    }
    if (!options.knownLength) {
      this._valuesToMeasure.push(value);
    }
  };
  FormData2.prototype._lengthRetriever = function(value, callback) {
    if (Object.prototype.hasOwnProperty.call(value, "fd")) {
      if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
        callback(null, value.end + 1 - (value.start ? value.start : 0));
      } else {
        fs.stat(value.path, function(err, stat) {
          var fileSize;
          if (err) {
            callback(err);
            return;
          }
          fileSize = stat.size - (value.start ? value.start : 0);
          callback(null, fileSize);
        });
      }
    } else if (Object.prototype.hasOwnProperty.call(value, "httpVersion")) {
      callback(null, +value.headers["content-length"]);
    } else if (Object.prototype.hasOwnProperty.call(value, "httpModule")) {
      value.on("response", function(response) {
        value.pause();
        callback(null, +response.headers["content-length"]);
      });
      value.resume();
    } else {
      callback("Unknown stream");
    }
  };
  FormData2.prototype._multiPartHeader = function(field, value, options) {
    if (typeof options.header == "string") {
      return options.header;
    }
    var contentDisposition = this._getContentDisposition(value, options);
    var contentType = this._getContentType(value, options);
    var contents = "";
    var headers = {
      // add custom disposition as third element or keep it two elements if not
      "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
      // if no content type. allow it to be empty array
      "Content-Type": [].concat(contentType || [])
    };
    if (typeof options.header == "object") {
      populate2(headers, options.header);
    }
    var header;
    for (var prop in headers) {
      if (Object.prototype.hasOwnProperty.call(headers, prop)) {
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
        }
      }
    }
    return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
  };
  FormData2.prototype._getContentDisposition = function(value, options) {
    var filename, contentDisposition;
    if (typeof options.filepath === "string") {
      filename = path.normalize(options.filepath).replace(/\\/g, "/");
    } else if (options.filename || value.name || value.path) {
      filename = path.basename(options.filename || value.name || value.path);
    } else if (value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) {
      filename = path.basename(value.client._httpMessage.path || "");
    }
    if (filename) {
      contentDisposition = 'filename="' + filename + '"';
    }
    return contentDisposition;
  };
  FormData2.prototype._getContentType = function(value, options) {
    var contentType = options.contentType;
    if (!contentType && value.name) {
      contentType = mime.lookup(value.name);
    }
    if (!contentType && value.path) {
      contentType = mime.lookup(value.path);
    }
    if (!contentType && value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) {
      contentType = value.headers["content-type"];
    }
    if (!contentType && (options.filepath || options.filename)) {
      contentType = mime.lookup(options.filepath || options.filename);
    }
    if (!contentType && typeof value == "object") {
      contentType = FormData2.DEFAULT_CONTENT_TYPE;
    }
    return contentType;
  };
  FormData2.prototype._multiPartFooter = function() {
    return function(next) {
      var footer = FormData2.LINE_BREAK;
      var lastPart = this._streams.length === 0;
      if (lastPart) {
        footer += this._lastBoundary();
      }
      next(footer);
    }.bind(this);
  };
  FormData2.prototype._lastBoundary = function() {
    return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
  };
  FormData2.prototype.getHeaders = function(userHeaders) {
    var header;
    var formHeaders = {
      "content-type": "multipart/form-data; boundary=" + this.getBoundary()
    };
    for (header in userHeaders) {
      if (Object.prototype.hasOwnProperty.call(userHeaders, header)) {
        formHeaders[header.toLowerCase()] = userHeaders[header];
      }
    }
    return formHeaders;
  };
  FormData2.prototype.setBoundary = function(boundary) {
    this._boundary = boundary;
  };
  FormData2.prototype.getBoundary = function() {
    if (!this._boundary) {
      this._generateBoundary();
    }
    return this._boundary;
  };
  FormData2.prototype.getBuffer = function() {
    var dataBuffer = new Buffer.alloc(0);
    var boundary = this.getBoundary();
    for (var i = 0, len = this._streams.length; i < len; i++) {
      if (typeof this._streams[i] !== "function") {
        if (Buffer.isBuffer(this._streams[i])) {
          dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
        } else {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
        }
        if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
        }
      }
    }
    return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
  };
  FormData2.prototype._generateBoundary = function() {
    var boundary = "--------------------------";
    for (var i = 0; i < 24; i++) {
      boundary += Math.floor(Math.random() * 10).toString(16);
    }
    this._boundary = boundary;
  };
  FormData2.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this.hasKnownLength()) {
      this._error(new Error("Cannot calculate proper length in synchronous way."));
    }
    return knownLength;
  };
  FormData2.prototype.hasKnownLength = function() {
    var hasKnownLength = true;
    if (this._valuesToMeasure.length) {
      hasKnownLength = false;
    }
    return hasKnownLength;
  };
  FormData2.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this._valuesToMeasure.length) {
      process.nextTick(cb.bind(this, null, knownLength));
      return;
    }
    asynckit2.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
      if (err) {
        cb(err);
        return;
      }
      values.forEach(function(length) {
        knownLength += length;
      });
      cb(null, knownLength);
    });
  };
  FormData2.prototype.submit = function(params, cb) {
    var request, options, defaults = { method: "post" };
    if (typeof params == "string") {
      params = parseUrl(params);
      options = populate2({
        port: params.port,
        path: params.pathname,
        host: params.hostname,
        protocol: params.protocol
      }, defaults);
    } else {
      options = populate2(params, defaults);
      if (!options.port) {
        options.port = options.protocol == "https:" ? 443 : 80;
      }
    }
    options.headers = this.getHeaders(params.headers);
    if (options.protocol == "https:") {
      request = https2.request(options);
    } else {
      request = http.request(options);
    }
    this.getLength(function(err, length) {
      if (err && err !== "Unknown stream") {
        this._error(err);
        return;
      }
      if (length) {
        request.setHeader("Content-Length", length);
      }
      this.pipe(request);
      if (cb) {
        var onResponse;
        var callback = function(error, responce) {
          request.removeListener("error", callback);
          request.removeListener("response", onResponse);
          return cb.call(this, error, responce);
        };
        onResponse = callback.bind(this, null);
        request.on("error", callback);
        request.on("response", onResponse);
      }
    }.bind(this));
    return request;
  };
  FormData2.prototype._error = function(err) {
    if (!this.error) {
      this.error = err;
      this.pause();
      this.emit("error", err);
    }
  };
  FormData2.prototype.toString = function() {
    return "[object FormData]";
  };
  setToStringTag(FormData2, "FormData");
  return form_data;
}
var FormData$1;
var hasRequiredFormData;
function requireFormData() {
  if (hasRequiredFormData) return FormData$1;
  hasRequiredFormData = 1;
  FormData$1 = requireForm_data();
  return FormData$1;
}
var defaults_1;
var hasRequiredDefaults;
function requireDefaults() {
  if (hasRequiredDefaults) return defaults_1;
  hasRequiredDefaults = 1;
  var utils2 = requireUtils();
  var normalizeHeaderName2 = requireNormalizeHeaderName();
  var AxiosError = requireAxiosError();
  var transitionalDefaults = requireTransitional();
  var toFormData = requireToFormData();
  var DEFAULT_CONTENT_TYPE = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  function setContentTypeIfUnset(headers, value) {
    if (!utils2.isUndefined(headers) && utils2.isUndefined(headers["Content-Type"])) {
      headers["Content-Type"] = value;
    }
  }
  function getDefaultAdapter() {
    var adapter;
    if (typeof XMLHttpRequest !== "undefined") {
      adapter = requireXhr();
    } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
      adapter = requireHttp();
    }
    return adapter;
  }
  function stringifySafely(rawValue, parser, encoder) {
    if (utils2.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils2.trim(rawValue);
      } catch (e) {
        if (e.name !== "SyntaxError") {
          throw e;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  var defaults = {
    transitional: transitionalDefaults,
    adapter: getDefaultAdapter(),
    transformRequest: [function transformRequest(data2, headers) {
      normalizeHeaderName2(headers, "Accept");
      normalizeHeaderName2(headers, "Content-Type");
      if (utils2.isFormData(data2) || utils2.isArrayBuffer(data2) || utils2.isBuffer(data2) || utils2.isStream(data2) || utils2.isFile(data2) || utils2.isBlob(data2)) {
        return data2;
      }
      if (utils2.isArrayBufferView(data2)) {
        return data2.buffer;
      }
      if (utils2.isURLSearchParams(data2)) {
        setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
        return data2.toString();
      }
      var isObjectPayload = utils2.isObject(data2);
      var contentType = headers && headers["Content-Type"];
      var isFileList;
      if ((isFileList = utils2.isFileList(data2)) || isObjectPayload && contentType === "multipart/form-data") {
        var _FormData = this.env && this.env.FormData;
        return toFormData(isFileList ? { "files[]": data2 } : data2, _FormData && new _FormData());
      } else if (isObjectPayload || contentType === "application/json") {
        setContentTypeIfUnset(headers, "application/json");
        return stringifySafely(data2);
      }
      return data2;
    }],
    transformResponse: [function transformResponse(data2) {
      var transitional2 = this.transitional || defaults.transitional;
      var silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      var forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
      var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
      if (strictJSONParsing || forcedJSONParsing && utils2.isString(data2) && data2.length) {
        try {
          return JSON.parse(data2);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === "SyntaxError") {
              throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e;
          }
        }
      }
      return data2;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: requireFormData()
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    }
  };
  utils2.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
    defaults.headers[method] = {};
  });
  utils2.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    defaults.headers[method] = utils2.merge(DEFAULT_CONTENT_TYPE);
  });
  defaults_1 = defaults;
  return defaults_1;
}
var transformData;
var hasRequiredTransformData;
function requireTransformData() {
  if (hasRequiredTransformData) return transformData;
  hasRequiredTransformData = 1;
  var utils2 = requireUtils();
  var defaults = requireDefaults();
  transformData = function transformData2(data2, headers, fns) {
    var context = this || defaults;
    utils2.forEach(fns, function transform(fn) {
      data2 = fn.call(context, data2, headers);
    });
    return data2;
  };
  return transformData;
}
var isCancel;
var hasRequiredIsCancel;
function requireIsCancel() {
  if (hasRequiredIsCancel) return isCancel;
  hasRequiredIsCancel = 1;
  isCancel = function isCancel2(value) {
    return !!(value && value.__CANCEL__);
  };
  return isCancel;
}
var dispatchRequest;
var hasRequiredDispatchRequest;
function requireDispatchRequest() {
  if (hasRequiredDispatchRequest) return dispatchRequest;
  hasRequiredDispatchRequest = 1;
  var utils2 = requireUtils();
  var transformData2 = requireTransformData();
  var isCancel2 = requireIsCancel();
  var defaults = requireDefaults();
  var CanceledError = requireCanceledError();
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
      throw new CanceledError();
    }
  }
  dispatchRequest = function dispatchRequest2(config) {
    throwIfCancellationRequested(config);
    config.headers = config.headers || {};
    config.data = transformData2.call(
      config,
      config.data,
      config.headers,
      config.transformRequest
    );
    config.headers = utils2.merge(
      config.headers.common || {},
      config.headers[config.method] || {},
      config.headers
    );
    utils2.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      function cleanHeaderConfig(method) {
        delete config.headers[method];
      }
    );
    var adapter = config.adapter || defaults.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData2.call(
        config,
        response.data,
        response.headers,
        config.transformResponse
      );
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel2(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData2.call(
            config,
            reason.response.data,
            reason.response.headers,
            config.transformResponse
          );
        }
      }
      return Promise.reject(reason);
    });
  };
  return dispatchRequest;
}
var mergeConfig;
var hasRequiredMergeConfig;
function requireMergeConfig() {
  if (hasRequiredMergeConfig) return mergeConfig;
  hasRequiredMergeConfig = 1;
  var utils2 = requireUtils();
  mergeConfig = function mergeConfig2(config1, config2) {
    config2 = config2 || {};
    var config = {};
    function getMergedValue(target, source) {
      if (utils2.isPlainObject(target) && utils2.isPlainObject(source)) {
        return utils2.merge(target, source);
      } else if (utils2.isPlainObject(source)) {
        return utils2.merge({}, source);
      } else if (utils2.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(prop) {
      if (!utils2.isUndefined(config2[prop])) {
        return getMergedValue(config1[prop], config2[prop]);
      } else if (!utils2.isUndefined(config1[prop])) {
        return getMergedValue(void 0, config1[prop]);
      }
    }
    function valueFromConfig2(prop) {
      if (!utils2.isUndefined(config2[prop])) {
        return getMergedValue(void 0, config2[prop]);
      }
    }
    function defaultToConfig2(prop) {
      if (!utils2.isUndefined(config2[prop])) {
        return getMergedValue(void 0, config2[prop]);
      } else if (!utils2.isUndefined(config1[prop])) {
        return getMergedValue(void 0, config1[prop]);
      }
    }
    function mergeDirectKeys(prop) {
      if (prop in config2) {
        return getMergedValue(config1[prop], config2[prop]);
      } else if (prop in config1) {
        return getMergedValue(void 0, config1[prop]);
      }
    }
    var mergeMap = {
      "url": valueFromConfig2,
      "method": valueFromConfig2,
      "data": valueFromConfig2,
      "baseURL": defaultToConfig2,
      "transformRequest": defaultToConfig2,
      "transformResponse": defaultToConfig2,
      "paramsSerializer": defaultToConfig2,
      "timeout": defaultToConfig2,
      "timeoutMessage": defaultToConfig2,
      "withCredentials": defaultToConfig2,
      "adapter": defaultToConfig2,
      "responseType": defaultToConfig2,
      "xsrfCookieName": defaultToConfig2,
      "xsrfHeaderName": defaultToConfig2,
      "onUploadProgress": defaultToConfig2,
      "onDownloadProgress": defaultToConfig2,
      "decompress": defaultToConfig2,
      "maxContentLength": defaultToConfig2,
      "maxBodyLength": defaultToConfig2,
      "beforeRedirect": defaultToConfig2,
      "transport": defaultToConfig2,
      "httpAgent": defaultToConfig2,
      "httpsAgent": defaultToConfig2,
      "cancelToken": defaultToConfig2,
      "socketPath": defaultToConfig2,
      "responseEncoding": defaultToConfig2,
      "validateStatus": mergeDirectKeys
    };
    utils2.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
      var merge = mergeMap[prop] || mergeDeepProperties;
      var configValue = merge(prop);
      utils2.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
  };
  return mergeConfig;
}
var validator;
var hasRequiredValidator;
function requireValidator() {
  if (hasRequiredValidator) return validator;
  hasRequiredValidator = 1;
  var VERSION = requireData().version;
  var AxiosError = requireAxiosError();
  var validators = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type2, i) {
    validators[type2] = function validator2(thing) {
      return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
    };
  });
  var deprecatedWarnings = {};
  validators.transitional = function transitional2(validator2, version2, message2) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message2 ? ". " + message2 : "");
    }
    return function(value, opt, opts) {
      if (validator2 === false) {
        throw new AxiosError(
          formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
          AxiosError.ERR_DEPRECATED
        );
      }
      if (version2 && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version2 + " and will be removed in the near future"
          )
        );
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
    }
    var keys2 = Object.keys(options);
    var i = keys2.length;
    while (i-- > 0) {
      var opt = keys2[i];
      var validator2 = schema[opt];
      if (validator2) {
        var value = options[opt];
        var result = value === void 0 || validator2(value, opt, options);
        if (result !== true) {
          throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
      }
    }
  }
  validator = {
    assertOptions,
    validators
  };
  return validator;
}
var Axios_1;
var hasRequiredAxios$2;
function requireAxios$2() {
  if (hasRequiredAxios$2) return Axios_1;
  hasRequiredAxios$2 = 1;
  var utils2 = requireUtils();
  var buildURL2 = requireBuildURL();
  var InterceptorManager = requireInterceptorManager();
  var dispatchRequest2 = requireDispatchRequest();
  var mergeConfig2 = requireMergeConfig();
  var buildFullPath2 = requireBuildFullPath();
  var validator2 = requireValidator();
  var validators = validator2.validators;
  function Axios(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  Axios.prototype.request = function request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig2(this.defaults, config);
    if (config.method) {
      config.method = config.method.toLowerCase();
    } else if (this.defaults.method) {
      config.method = this.defaults.method.toLowerCase();
    } else {
      config.method = "get";
    }
    var transitional2 = config.transitional;
    if (transitional2 !== void 0) {
      validator2.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    var requestInterceptorChain = [];
    var synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    var responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    var promise;
    if (!synchronousRequestInterceptors) {
      var chain = [dispatchRequest2, void 0];
      Array.prototype.unshift.apply(chain, requestInterceptorChain);
      chain = chain.concat(responseInterceptorChain);
      promise = Promise.resolve(config);
      while (chain.length) {
        promise = promise.then(chain.shift(), chain.shift());
      }
      return promise;
    }
    var newConfig = config;
    while (requestInterceptorChain.length) {
      var onFulfilled = requestInterceptorChain.shift();
      var onRejected = requestInterceptorChain.shift();
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected(error);
        break;
      }
    }
    try {
      promise = dispatchRequest2(newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    while (responseInterceptorChain.length) {
      promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
    }
    return promise;
  };
  Axios.prototype.getUri = function getUri(config) {
    config = mergeConfig2(this.defaults, config);
    var fullPath = buildFullPath2(config.baseURL, config.url);
    return buildURL2(fullPath, config.params, config.paramsSerializer);
  };
  utils2.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios.prototype[method] = function(url, config) {
      return this.request(mergeConfig2(config || {}, {
        method,
        url,
        data: (config || {}).data
      }));
    };
  });
  utils2.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data2, config) {
        return this.request(mergeConfig2(config || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url,
          data: data2
        }));
      };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  Axios_1 = Axios;
  return Axios_1;
}
var CancelToken_1;
var hasRequiredCancelToken;
function requireCancelToken() {
  if (hasRequiredCancelToken) return CancelToken_1;
  hasRequiredCancelToken = 1;
  var CanceledError = requireCanceledError();
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    var token = this;
    this.promise.then(function(cancel) {
      if (!token._listeners) return;
      var i;
      var l = token._listeners.length;
      for (i = 0; i < l; i++) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = function(onfulfilled) {
      var _resolve;
      var promise = new Promise(function(resolve) {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message2) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError(message2);
      resolvePromise(token.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.prototype.subscribe = function subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  };
  CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    var index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  };
  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  };
  CancelToken_1 = CancelToken;
  return CancelToken_1;
}
var spread;
var hasRequiredSpread;
function requireSpread() {
  if (hasRequiredSpread) return spread;
  hasRequiredSpread = 1;
  spread = function spread2(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };
  return spread;
}
var isAxiosError;
var hasRequiredIsAxiosError;
function requireIsAxiosError() {
  if (hasRequiredIsAxiosError) return isAxiosError;
  hasRequiredIsAxiosError = 1;
  var utils2 = requireUtils();
  isAxiosError = function isAxiosError2(payload) {
    return utils2.isObject(payload) && payload.isAxiosError === true;
  };
  return isAxiosError;
}
var hasRequiredAxios$1;
function requireAxios$1() {
  if (hasRequiredAxios$1) return axios$1.exports;
  hasRequiredAxios$1 = 1;
  var utils2 = requireUtils();
  var bind2 = requireBind();
  var Axios = requireAxios$2();
  var mergeConfig2 = requireMergeConfig();
  var defaults = requireDefaults();
  function createInstance(defaultConfig) {
    var context = new Axios(defaultConfig);
    var instance = bind2(Axios.prototype.request, context);
    utils2.extend(instance, Axios.prototype, context);
    utils2.extend(instance, context);
    instance.create = function create(instanceConfig) {
      return createInstance(mergeConfig2(defaultConfig, instanceConfig));
    };
    return instance;
  }
  var axios2 = createInstance(defaults);
  axios2.Axios = Axios;
  axios2.CanceledError = requireCanceledError();
  axios2.CancelToken = requireCancelToken();
  axios2.isCancel = requireIsCancel();
  axios2.VERSION = requireData().version;
  axios2.toFormData = requireToFormData();
  axios2.AxiosError = requireAxiosError();
  axios2.Cancel = axios2.CanceledError;
  axios2.all = function all(promises) {
    return Promise.all(promises);
  };
  axios2.spread = requireSpread();
  axios2.isAxiosError = requireIsAxiosError();
  axios$1.exports = axios2;
  axios$1.exports.default = axios2;
  return axios$1.exports;
}
var axios;
var hasRequiredAxios;
function requireAxios() {
  if (hasRequiredAxios) return axios;
  hasRequiredAxios = 1;
  axios = requireAxios$1();
  return axios;
}
var hasRequiredApi;
function requireApi() {
  if (hasRequiredApi) return api;
  hasRequiredApi = 1;
  var __importDefault = api && api.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(api, "__esModule", { value: true });
  api.Api = void 0;
  const axios_1 = __importDefault(requireAxios());
  class Api {
    constructor(opts) {
      this.config = this.mergeDefaults(opts);
    }
    mergeDefaults(opts) {
      if (!opts.kwilProvider) {
        throw new Error("No Kwil provider URL provided in configuration");
      }
      return {
        kwilProvider: opts.kwilProvider,
        timeout: opts.timeout || 1e4,
        logging: opts.logging || false,
        logger: opts.logger || console.log,
        cache: opts.cache || 10 * 60
      };
    }
    async get(endpoint, config) {
      try {
        return await this.request().get(endpoint, config);
      } catch (error) {
        if (error.response && error.response.status) {
          return error.response;
        }
        throw error;
      }
    }
    async post(endpoint, body, config) {
      try {
        return await this.request().post(endpoint, body, config);
      } catch (error) {
        if (error.response && error.response.status) {
          return error.response;
        }
        throw error;
      }
    }
    /**
     * Get an AxiosInstance with the base configuration setup to fire off
     * a request to the network.
     */
    request() {
      let headers = {};
      if (this.cookie) {
        headers.Cookie = this.cookie;
      }
      let instance = axios_1.default.create({
        baseURL: this.config.kwilProvider,
        timeout: this.config.timeout,
        maxContentLength: 1024 * 1024 * 512,
        withCredentials: true,
        headers
      });
      if (this.config.logging) {
        instance.interceptors.request.use((request) => {
          this.config.logger(`Requesting: ${request.baseURL}${request.url}`);
          return request;
        });
        instance.interceptors.response.use((response) => {
          this.config.logger(`Response:   ${response.config.url} - ${response.status}`);
          return response;
        });
      }
      return instance;
    }
  }
  api.Api = Api;
  return api;
}
var serial = {};
var umd = { exports: {} };
var hasRequiredUmd;
function requireUmd() {
  if (hasRequiredUmd) return umd.exports;
  hasRequiredUmd = 1;
  (function(module, exports) {
    var Long = function(exports2) {
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      /**
       * @license
       * Copyright 2009 The Closure Library Authors
       * Copyright 2020 Daniel Wirtz / The long.js Authors.
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       *
       * SPDX-License-Identifier: Apache-2.0
       */
      var wasm = null;
      try {
        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
          // \0asm
          0,
          97,
          115,
          109,
          // version 1
          1,
          0,
          0,
          0,
          // section "type"
          1,
          13,
          2,
          // 0, () => i32
          96,
          0,
          1,
          127,
          // 1, (i32, i32, i32, i32) => i32
          96,
          4,
          127,
          127,
          127,
          127,
          1,
          127,
          // section "function"
          3,
          7,
          6,
          // 0, type 0
          0,
          // 1, type 1
          1,
          // 2, type 1
          1,
          // 3, type 1
          1,
          // 4, type 1
          1,
          // 5, type 1
          1,
          // section "global"
          6,
          6,
          1,
          // 0, "high", mutable i32
          127,
          1,
          65,
          0,
          11,
          // section "export"
          7,
          50,
          6,
          // 0, "mul"
          3,
          109,
          117,
          108,
          0,
          1,
          // 1, "div_s"
          5,
          100,
          105,
          118,
          95,
          115,
          0,
          2,
          // 2, "div_u"
          5,
          100,
          105,
          118,
          95,
          117,
          0,
          3,
          // 3, "rem_s"
          5,
          114,
          101,
          109,
          95,
          115,
          0,
          4,
          // 4, "rem_u"
          5,
          114,
          101,
          109,
          95,
          117,
          0,
          5,
          // 5, "get_high"
          8,
          103,
          101,
          116,
          95,
          104,
          105,
          103,
          104,
          0,
          0,
          // section "code"
          10,
          191,
          1,
          6,
          // 0, "get_high"
          4,
          0,
          35,
          0,
          11,
          // 1, "mul"
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          126,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          // 2, "div_s"
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          127,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          // 3, "div_u"
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          128,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          // 4, "rem_s"
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          129,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          // 5, "rem_u"
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          130,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11
        ])), {}).exports;
      } catch {
      }
      function Long2(low, high, unsigned) {
        this.low = low | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
      }
      Long2.prototype.__isLong__;
      Object.defineProperty(Long2.prototype, "__isLong__", {
        value: true
      });
      function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
      }
      function ctz32(value) {
        var c = Math.clz32(value & -value);
        return value ? 31 - c : c;
      }
      Long2.isLong = isLong;
      var INT_CACHE = {};
      var UINT_CACHE = {};
      function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
          value >>>= 0;
          if (cache = 0 <= value && value < 256) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj) return cachedObj;
          }
          obj = fromBits(value, 0, true);
          if (cache) UINT_CACHE[value] = obj;
          return obj;
        } else {
          value |= 0;
          if (cache = -128 <= value && value < 128) {
            cachedObj = INT_CACHE[value];
            if (cachedObj) return cachedObj;
          }
          obj = fromBits(value, value < 0 ? -1 : 0, false);
          if (cache) INT_CACHE[value] = obj;
          return obj;
        }
      }
      Long2.fromInt = fromInt;
      function fromNumber(value, unsigned) {
        if (isNaN(value)) return unsigned ? UZERO : ZERO;
        if (unsigned) {
          if (value < 0) return UZERO;
          if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
        } else {
          if (value <= -9223372036854776e3) return MIN_VALUE;
          if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
        }
        if (value < 0) return fromNumber(-value, unsigned).neg();
        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
      }
      Long2.fromNumber = fromNumber;
      function fromBits(lowBits, highBits, unsigned) {
        return new Long2(lowBits, highBits, unsigned);
      }
      Long2.fromBits = fromBits;
      var pow_dbl = Math.pow;
      function fromString(str, unsigned, radix) {
        if (str.length === 0) throw Error("empty string");
        if (typeof unsigned === "number") {
          radix = unsigned;
          unsigned = false;
        } else {
          unsigned = !!unsigned;
        }
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return unsigned ? UZERO : ZERO;
        radix = radix || 10;
        if (radix < 2 || 36 < radix) throw RangeError("radix");
        var p;
        if ((p = str.indexOf("-")) > 0) throw Error("interior hyphen");
        else if (p === 0) {
          return fromString(str.substring(1), unsigned, radix).neg();
        }
        var radixToPower = fromNumber(pow_dbl(radix, 8));
        var result = ZERO;
        for (var i = 0; i < str.length; i += 8) {
          var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
          if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
          } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
          }
        }
        result.unsigned = unsigned;
        return result;
      }
      Long2.fromString = fromString;
      function fromValue(val, unsigned) {
        if (typeof val === "number") return fromNumber(val, unsigned);
        if (typeof val === "string") return fromString(val, unsigned);
        return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
      }
      Long2.fromValue = fromValue;
      var TWO_PWR_16_DBL = 1 << 16;
      var TWO_PWR_24_DBL = 1 << 24;
      var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
      var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
      var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
      var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
      var ZERO = fromInt(0);
      Long2.ZERO = ZERO;
      var UZERO = fromInt(0, true);
      Long2.UZERO = UZERO;
      var ONE = fromInt(1);
      Long2.ONE = ONE;
      var UONE = fromInt(1, true);
      Long2.UONE = UONE;
      var NEG_ONE = fromInt(-1);
      Long2.NEG_ONE = NEG_ONE;
      var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
      Long2.MAX_VALUE = MAX_VALUE;
      var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
      Long2.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
      var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
      Long2.MIN_VALUE = MIN_VALUE;
      var LongPrototype = Long2.prototype;
      LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      };
      LongPrototype.toNumber = function toNumber() {
        if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
      };
      LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix) throw RangeError("radix");
        if (this.isZero()) return "0";
        if (this.isNegative()) {
          if (this.eq(MIN_VALUE)) {
            var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
          } else return "-" + this.neg().toString(radix);
        }
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
        var result = "";
        while (true) {
          var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero()) return digits + result;
          else {
            while (digits.length < 6) digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      };
      LongPrototype.getHighBits = function getHighBits() {
        return this.high;
      };
      LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
      };
      LongPrototype.getLowBits = function getLowBits() {
        return this.low;
      };
      LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
      };
      LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative())
          return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
        return this.high != 0 ? bit + 33 : bit + 1;
      };
      LongPrototype.isSafeInteger = function isSafeInteger() {
        var top11Bits = this.high >> 21;
        if (!top11Bits) return true;
        if (this.unsigned) return false;
        return top11Bits === -1 && !(this.low === 0 && this.high === -2097152);
      };
      LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
      };
      LongPrototype.eqz = LongPrototype.isZero;
      LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
      };
      LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
      };
      LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
      };
      LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
      };
      LongPrototype.equals = function equals(other) {
        if (!isLong(other)) other = fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
        return this.high === other.high && this.low === other.low;
      };
      LongPrototype.eq = LongPrototype.equals;
      LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(
          /* validates */
          other
        );
      };
      LongPrototype.neq = LongPrototype.notEquals;
      LongPrototype.ne = LongPrototype.notEquals;
      LongPrototype.lessThan = function lessThan(other) {
        return this.comp(
          /* validates */
          other
        ) < 0;
      };
      LongPrototype.lt = LongPrototype.lessThan;
      LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) <= 0;
      };
      LongPrototype.lte = LongPrototype.lessThanOrEqual;
      LongPrototype.le = LongPrototype.lessThanOrEqual;
      LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(
          /* validates */
          other
        ) > 0;
      };
      LongPrototype.gt = LongPrototype.greaterThan;
      LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) >= 0;
      };
      LongPrototype.gte = LongPrototype.greaterThanOrEqual;
      LongPrototype.ge = LongPrototype.greaterThanOrEqual;
      LongPrototype.compare = function compare(other) {
        if (!isLong(other)) other = fromValue(other);
        if (this.eq(other)) return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg) return -1;
        if (!thisNeg && otherNeg) return 1;
        if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      };
      LongPrototype.comp = LongPrototype.compare;
      LongPrototype.negate = function negate2() {
        if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
        return this.not().add(ONE);
      };
      LongPrototype.neg = LongPrototype.negate;
      LongPrototype.add = function add(addend) {
        if (!isLong(addend)) addend = fromValue(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 65535;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
      };
      LongPrototype.sub = LongPrototype.subtract;
      LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero()) return this;
        if (!isLong(multiplier)) multiplier = fromValue(multiplier);
        if (wasm) {
          var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
        if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
        if (this.isNegative()) {
          if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
          else return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 65535;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.mul = LongPrototype.multiply;
      LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor)) divisor = fromValue(divisor);
        if (divisor.isZero()) throw Error("division by zero");
        if (wasm) {
          if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
            return this;
          }
          var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        if (this.isZero()) return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE;
            else if (divisor.eq(MIN_VALUE)) return ONE;
            else {
              var halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(ZERO)) {
                return divisor.isNegative() ? ONE : NEG_ONE;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
          if (this.isNegative()) {
            if (divisor.isNegative()) return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
          res = ZERO;
        } else {
          if (!divisor.unsigned) divisor = divisor.toUnsigned();
          if (divisor.gt(this)) return UZERO;
          if (divisor.gt(this.shru(1)))
            return UONE;
          res = UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero()) approxRes = ONE;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      };
      LongPrototype.div = LongPrototype.divide;
      LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor)) divisor = fromValue(divisor);
        if (wasm) {
          var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        return this.sub(this.div(divisor).mul(divisor));
      };
      LongPrototype.mod = LongPrototype.modulo;
      LongPrototype.rem = LongPrototype.modulo;
      LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
      };
      LongPrototype.countLeadingZeros = function countLeadingZeros() {
        return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
      };
      LongPrototype.clz = LongPrototype.countLeadingZeros;
      LongPrototype.countTrailingZeros = function countTrailingZeros() {
        return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
      };
      LongPrototype.ctz = LongPrototype.countTrailingZeros;
      LongPrototype.and = function and(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      };
      LongPrototype.or = function or(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      };
      LongPrototype.xor = function xor(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      };
      LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else return fromBits(0, this.low << numBits - 32, this.unsigned);
      };
      LongPrototype.shl = LongPrototype.shiftLeft;
      LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      };
      LongPrototype.shr = LongPrototype.shiftRight;
      LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
        if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
        return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
      };
      LongPrototype.shru = LongPrototype.shiftRightUnsigned;
      LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
      LongPrototype.rotateLeft = function rotateLeft(numBits) {
        var b;
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
        if (numBits < 32) {
          b = 32 - numBits;
          return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
        }
        numBits -= 32;
        b = 32 - numBits;
        return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
      };
      LongPrototype.rotl = LongPrototype.rotateLeft;
      LongPrototype.rotateRight = function rotateRight(numBits) {
        var b;
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
        if (numBits < 32) {
          b = 32 - numBits;
          return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
        }
        numBits -= 32;
        b = 32 - numBits;
        return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
      };
      LongPrototype.rotr = LongPrototype.rotateRight;
      LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned) return this;
        return fromBits(this.low, this.high, false);
      };
      LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned) return this;
        return fromBits(this.low, this.high, true);
      };
      LongPrototype.toBytes = function toBytes(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      };
      LongPrototype.toBytesLE = function toBytesLE() {
        var hi = this.high, lo = this.low;
        return [lo & 255, lo >>> 8 & 255, lo >>> 16 & 255, lo >>> 24, hi & 255, hi >>> 8 & 255, hi >>> 16 & 255, hi >>> 24];
      };
      LongPrototype.toBytesBE = function toBytesBE() {
        var hi = this.high, lo = this.low;
        return [hi >>> 24, hi >>> 16 & 255, hi >>> 8 & 255, hi & 255, lo >>> 24, lo >>> 16 & 255, lo >>> 8 & 255, lo & 255];
      };
      Long2.fromBytes = function fromBytes(bytes2, unsigned, le) {
        return le ? Long2.fromBytesLE(bytes2, unsigned) : Long2.fromBytesBE(bytes2, unsigned);
      };
      Long2.fromBytesLE = function fromBytesLE(bytes2, unsigned) {
        return new Long2(bytes2[0] | bytes2[1] << 8 | bytes2[2] << 16 | bytes2[3] << 24, bytes2[4] | bytes2[5] << 8 | bytes2[6] << 16 | bytes2[7] << 24, unsigned);
      };
      Long2.fromBytesBE = function fromBytesBE(bytes2, unsigned) {
        return new Long2(bytes2[4] << 24 | bytes2[5] << 16 | bytes2[6] << 8 | bytes2[7], bytes2[0] << 24 | bytes2[1] << 16 | bytes2[2] << 8 | bytes2[3], unsigned);
      };
      if (typeof BigInt === "function") {
        Long2.fromBigInt = function fromBigInt2(value, unsigned) {
          var lowBits = Number(BigInt.asIntN(32, value));
          var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));
          return fromBits(lowBits, highBits, unsigned);
        };
        Long2.fromValue = function fromValueWithBigInt(value, unsigned) {
          if (typeof value === "bigint") return fromBigInt(value, unsigned);
          return fromValue(value, unsigned);
        };
        LongPrototype.toBigInt = function toBigInt() {
          var lowBigInt = BigInt(this.low >>> 0);
          var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);
          return highBigInt << BigInt(32) | lowBigInt;
        };
      }
      exports2.default = Long2;
      return "default" in exports2 ? exports2.default : exports2;
    }({});
    module.exports = Long;
  })(umd);
  return umd.exports;
}
var strings = {};
var objects = {};
var hasRequiredObjects;
function requireObjects() {
  if (hasRequiredObjects) return objects;
  hasRequiredObjects = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objects = exports.NillableError = void 0;
    const NillablErrorSymbol = Symbol();
    const NILL_ERROR_MESSAGE = "value cannot be null or undefined";
    class NillableError extends Error {
      constructor(message2 = NILL_ERROR_MESSAGE) {
        super(message2 || NILL_ERROR_MESSAGE);
      }
      get [NillablErrorSymbol]() {
        return true;
      }
    }
    exports.NillableError = NillableError;
    exports.objects = {
      isNilError: (error) => {
        return error[NillablErrorSymbol] === true;
      },
      // returns true if the value is null or undefined,
      // else will return false.
      isNil: (value) => {
        return value === null || value === void 0;
      },
      // returns false if the value is null or undefined,
      // else will return true.
      isNotNil: (value) => {
        return !exports.objects.isNil(value);
      },
      /**
       * Helper function to validate required fields with a requireNonNil error.
       * @param values An object containing field names and their corresponding values.
       * @param errorMessageTemplate A function to generate error messages dynamically.
       */
      validateFields: (values, errorMessageTemplate) => {
        for (const key in values) {
          exports.objects.requireNonNil(values[key], errorMessageTemplate(key));
        }
        return values;
      },
      // If value is null or undefined, then an error is thrown, else
      // value is returned.
      requireNonNil: (value, message2) => {
        if (!exports.objects.isNil(value)) {
          return value;
        }
        if (typeof message2 === "function") {
          throw message2(value);
        }
        throw new NillableError(message2);
      },
      // If value is null or undefined, then an error is thrown, else
      // value is returned.
      requireNonNilNumber: (value, message2) => {
        if (typeof value === "number") {
          return value;
        }
        if (typeof message2 === "function") {
          throw message2(value);
        }
        if (!value) {
          throw new NillableError(message2);
        }
        throw new Error("value is not a number, it is a " + typeof value);
      },
      requireMaxLength: (value, maxLength, message2) => {
        if (!value) {
          if (typeof message2 === "function") {
            throw message2(value);
          }
          throw new Error(message2 || "value is null or undefined");
        }
        if (typeof value.toString !== "function") {
          throw new Error("value does not have a toString() method");
        }
        if (value.toString().length > maxLength) {
          if (typeof message2 === "function") {
            throw message2(value);
          }
          throw new Error(message2 || `value is longer than ${maxLength} characters`);
        }
        return value;
      },
      /**
       * Validates that optional parameters, if provided, are not null.
       *
       * @param options - The options object containing the parameters to validate.
       * @param fields - An array of field names to validate.
       * @throws Error if any field is explicitly provided but null.
       */
      validateOptionalFields(options, fields) {
        fields.forEach((field) => {
          if (options[field] !== void 0 && options[field] === null) {
            throw new Error(`${String(field)} must not be null.`);
          }
        });
      },
      /**
       * Validates required parameters for the class or function, are not null or undefined.
       *
       * @param options - The options object containing the parameters to validate.
       * @param fields - An array of field names to validate.
       * @throws Error if any field is explicitly provided but null.
       */
      validateRequiredFields(options, fields) {
        fields.forEach((field) => {
          if (options[field] === void 0 && options[field] === null) {
            throw new Error(`${String(field)} must not be null.`);
          }
        });
        return options;
      }
    };
  })(objects);
  return objects;
}
var hasRequiredStrings;
function requireStrings() {
  if (hasRequiredStrings) return strings;
  hasRequiredStrings = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.strings = void 0;
    const objects_1 = requireObjects();
    exports.strings = {
      is: (value) => {
        return typeof value === "string";
      },
      // If value is null or undefined, then an error is thrown, else
      // value is returned.
      requireNonNil: (value, message2) => {
        if (exports.strings.is(value)) {
          return value;
        }
        if (typeof message2 === "function") {
          throw message2();
        }
        throw new Error("value is not a string, it is a " + (!value ? "null or undefined" : typeof value));
      },
      // If value is null or undefined, then an error is thrown, else
      // value is returned.
      requireNonNilElse: (value, defaultValue) => {
        if (!objects_1.objects.isNil(value)) {
          return value;
        }
        if (typeof defaultValue === "function") {
          defaultValue(value);
        }
        if (exports.strings.is(defaultValue)) {
          return defaultValue;
        }
        throw new Error("defaultValue is not a string, it is a " + (!value ? "null or undefined" : typeof value));
      },
      // NOTE: Will throw an exception if not a string/null/undefined.
      isNilOrEmpty: (value) => {
        if (objects_1.objects.isNil(value)) {
          return true;
        }
        if (exports.strings.is(value)) {
          return value === "";
        }
        throw new Error("value is not a string or null, it is a " + (!value ? "undefined" : typeof value));
      },
      // NOTE: Will throw an exception if not a string/null/undefined.
      isNilOrWhitespace: (value) => {
        return exports.strings.isNilOrEmpty(value) || value.trim().length === 0;
      }
    };
  })(strings);
  return strings;
}
var hasRequiredSerial;
function requireSerial() {
  if (hasRequiredSerial) return serial;
  hasRequiredSerial = 1;
  var __importDefault = serial && serial.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(serial, "__esModule", { value: true });
  serial.bytesToBoolean = serial.booleanToBytes = serial.bytesToInt64 = serial.int64ToBytes = serial.bytesToInt32 = serial.int32ToBytes = serial.bytesToString = serial.hexToBase64 = serial.base64ToHex = serial.hexToBytes = serial.bytesToHex = serial.bytesToEthHex = serial.hexToNumber = serial.numberToHex = serial.numberToEthHex = serial.numberToBytes = serial.hexToString = serial.stringToHex = serial.stringToEthHex = serial.stringToBytes = void 0;
  const long_1 = __importDefault(requireUmd());
  const strings_1 = requireStrings();
  const objects_1 = requireObjects();
  const base64_1 = requireBase64();
  function stringToBytes(str) {
    return new TextEncoder().encode(str);
  }
  serial.stringToBytes = stringToBytes;
  function stringToEthHex(str) {
    let hex = "0x";
    hex += stringToHex(str);
    return hex;
  }
  serial.stringToEthHex = stringToEthHex;
  function stringToHex(str) {
    return stringToBytes(str).reduce((str2, byte) => str2 + byte.toString(16).padStart(2, "0"), "");
  }
  serial.stringToHex = stringToHex;
  function hexToString(hex) {
    strings_1.strings.requireNonNil(hex);
    return bytesToString(hexToBytes(hex));
  }
  serial.hexToString = hexToString;
  function numberToBytes(num) {
    const buffer = new ArrayBuffer(8);
    const view = new DataView(buffer);
    if (typeof num === "number") {
      if (num < 0 || num > 9007199254740991) {
        throw new Error("Number out of bounds for safe integer representation");
      }
      const high = Math.floor(num / 4294967296);
      const low = num % 4294967296;
      view.setUint32(0, high);
      view.setUint32(4, low);
    } else if (typeof num === "bigint") {
      if (num < 0n || num > 0xffffffffffffffffn) {
        throw new Error("Number out of bounds for Uint64 representation");
      }
      const high = Number(num >> 32n);
      const low = Number(num & 0xffffffffn);
      view.setUint32(0, high);
      view.setUint32(4, low);
    } else {
      throw new Error("Unsupported type for conversion to bytes");
    }
    return new Uint8Array(buffer);
  }
  serial.numberToBytes = numberToBytes;
  function numberToEthHex(num) {
    return "0x" + numberToHex(num);
  }
  serial.numberToEthHex = numberToEthHex;
  function numberToHex(num) {
    let hex = num.toString(16);
    if (hex.length % 2 !== 0) {
      hex = "0" + hex;
    }
    return hex;
  }
  serial.numberToHex = numberToHex;
  function hexToNumber(hex) {
    strings_1.strings.requireNonNil(hex);
    if (hex.length % 2 !== 0) {
      throw new Error(`invalid hex string: ${hex}`);
    }
    if (hex.startsWith("0x")) {
      hex = hex.slice(2);
    }
    return parseInt(hex, 16);
  }
  serial.hexToNumber = hexToNumber;
  function bytesToEthHex(bytes2) {
    return "0x" + bytesToHex(bytes2);
  }
  serial.bytesToEthHex = bytesToEthHex;
  function bytesToHex(bytes2) {
    return bytes2.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
  }
  serial.bytesToHex = bytesToHex;
  function hexToBytes(hex) {
    strings_1.strings.requireNonNil(hex);
    if (hex.length % 2 !== 0) {
      throw new Error(`invalid hex string: ${hex}`);
    }
    if (hex.startsWith("0x")) {
      hex = hex.slice(2);
    }
    const bytes2 = new Uint8Array(hex.length / 2);
    for (let i = 0; i < hex.length; i += 2) {
      bytes2[i / 2] = parseInt(hex.slice(i, i + 2), 16);
    }
    return bytes2;
  }
  serial.hexToBytes = hexToBytes;
  function base64ToHex(base642) {
    return bytesToHex((0, base64_1.base64ToBytes)(base642));
  }
  serial.base64ToHex = base64ToHex;
  function hexToBase64(hex) {
    return (0, base64_1.bytesToBase64)(hexToBytes(hex));
  }
  serial.hexToBase64 = hexToBase64;
  function bytesToString(bytes2) {
    return new TextDecoder().decode(bytes2);
  }
  serial.bytesToString = bytesToString;
  function int32ToBytes(num) {
    objects_1.objects.requireNonNilNumber(num);
    const buffer = new ArrayBuffer(4);
    const view = new DataView(buffer);
    view.setInt32(0, num, true);
    return new Uint8Array(buffer);
  }
  serial.int32ToBytes = int32ToBytes;
  function bytesToInt32(bytes2) {
    objects_1.objects.requireNonNil(bytes2);
    const buffer = new ArrayBuffer(4);
    const view = new DataView(buffer);
    for (let i = 0; i < bytes2.length; i++) {
      view.setInt8(i, bytes2[i]);
    }
    return view.getInt32(0, true);
  }
  serial.bytesToInt32 = bytesToInt32;
  function int64ToBytes(num) {
    objects_1.objects.requireNonNilNumber(num);
    const longNum = long_1.default.fromNumber(num, true);
    const buffer = new ArrayBuffer(8);
    const view = new DataView(buffer);
    view.setInt32(0, longNum.low, true);
    view.setInt32(4, longNum.high, true);
    return new Uint8Array(buffer);
  }
  serial.int64ToBytes = int64ToBytes;
  function bytesToInt64(bytes2) {
    objects_1.objects.requireNonNil(bytes2);
    const buffer = new ArrayBuffer(8);
    const view = new DataView(buffer);
    for (let i = 0; i < bytes2.length; i++) {
      view.setInt8(i, bytes2[i]);
    }
    return view.getInt32(0, true);
  }
  serial.bytesToInt64 = bytesToInt64;
  function booleanToBytes(bool) {
    objects_1.objects.requireNonNil(bool);
    const buffer = new ArrayBuffer(1);
    const view = new DataView(buffer);
    view.setUint8(0, bool ? 1 : 0);
    return new Uint8Array(buffer);
  }
  serial.booleanToBytes = booleanToBytes;
  function bytesToBoolean(bytes2) {
    objects_1.objects.requireNonNil(bytes2);
    const buffer = new ArrayBuffer(1);
    const view = new DataView(buffer);
    for (let i = 0; i < bytes2.length; i++) {
      view.setUint8(i, bytes2[i]);
    }
    return view.getUint8(0) === 1;
  }
  serial.bytesToBoolean = bytesToBoolean;
  return serial;
}
var enums = {};
var hasRequiredEnums;
function requireEnums() {
  if (hasRequiredEnums) return enums;
  hasRequiredEnums = 1;
  Object.defineProperty(enums, "__esModule", { value: true });
  enums.AccessModifier = enums.AccountKeyType = enums.AccountStatus = enums.AuthErrorCodes = enums.BroadcastSyncType = enums.AuthenticationMode = enums.EnvironmentType = enums.BytesEncodingStatus = enums.SerializationType = enums.PayloadType = enums.EncodingType = enums.IndexType = enums.AttributeType = enums.VarType = void 0;
  var VarType;
  (function(VarType2) {
    VarType2["UUID"] = "uuid";
    VarType2["TEXT"] = "text";
    VarType2["INT8"] = "int8";
    VarType2["BOOL"] = "bool";
    VarType2["NUMERIC"] = "numeric";
    VarType2["NULL"] = "null";
    VarType2["BYTEA"] = "bytea";
    VarType2["UNKNOWN"] = "unknown";
  })(VarType || (enums.VarType = VarType = {}));
  var AttributeType;
  (function(AttributeType2) {
    AttributeType2["INVALID_TYPE"] = "";
    AttributeType2["PRIMARY_KEY"] = "PRIMARY_KEY";
    AttributeType2["UNIQUE"] = "UNIQUE";
    AttributeType2["NOT_NULL"] = "NOT_NULL";
    AttributeType2["DEFAULT"] = "DEFAULT";
    AttributeType2["MIN"] = "MIN";
    AttributeType2["MAX"] = "MAX";
    AttributeType2["MIN_LENGTH"] = "MIN_LENGTH";
    AttributeType2["MAX_LENGTH"] = "MAX_LENGTH";
  })(AttributeType || (enums.AttributeType = AttributeType = {}));
  var IndexType;
  (function(IndexType2) {
    IndexType2["INVALID_INDEX_TYPE"] = "";
    IndexType2["BTREE"] = "BTREE";
    IndexType2["UNIQUE_BTREE"] = "UNIQUE_BTREE";
  })(IndexType || (enums.IndexType = IndexType = {}));
  var EncodingType;
  (function(EncodingType2) {
    EncodingType2[EncodingType2["INVALID_ENCODING_TYPE"] = 0] = "INVALID_ENCODING_TYPE";
    EncodingType2[EncodingType2["RLP_ENCODING"] = 1] = "RLP_ENCODING";
  })(EncodingType || (enums.EncodingType = EncodingType = {}));
  var PayloadType;
  (function(PayloadType2) {
    PayloadType2["INVALID_PAYLOAD_TYPE"] = "invalid";
    PayloadType2["EXECUTE_ACTION"] = "execute";
    PayloadType2["CALL_ACTION"] = "call_action";
    PayloadType2["TRANSFER"] = "transfer";
    PayloadType2["RAW_STATEMENT"] = "raw_statement";
  })(PayloadType || (enums.PayloadType = PayloadType = {}));
  var SerializationType;
  (function(SerializationType2) {
    SerializationType2["INVALID_SERIALIZATION_TYPE"] = "invalid";
    SerializationType2["SIGNED_MSG_CONCAT"] = "concat";
    SerializationType2["SIGNED_MSG_EIP712"] = "eip712";
  })(SerializationType || (enums.SerializationType = SerializationType = {}));
  var BytesEncodingStatus;
  (function(BytesEncodingStatus2) {
    BytesEncodingStatus2["INVALID_ENCODING_STATUS"] = "invalid";
    BytesEncodingStatus2["BASE64_ENCODED"] = "base64_encoded";
    BytesEncodingStatus2["HEX_ENCODED"] = "hex_encoded";
    BytesEncodingStatus2["UINT8_ENCODED"] = "uint8_encoded";
  })(BytesEncodingStatus || (enums.BytesEncodingStatus = BytesEncodingStatus = {}));
  var EnvironmentType;
  (function(EnvironmentType2) {
    EnvironmentType2["BROWSER"] = "browser";
    EnvironmentType2["NODE"] = "node";
  })(EnvironmentType || (enums.EnvironmentType = EnvironmentType = {}));
  var AuthenticationMode;
  (function(AuthenticationMode2) {
    AuthenticationMode2["PRIVATE"] = "private";
    AuthenticationMode2["OPEN"] = "open";
  })(AuthenticationMode || (enums.AuthenticationMode = AuthenticationMode = {}));
  var BroadcastSyncType;
  (function(BroadcastSyncType2) {
    BroadcastSyncType2[BroadcastSyncType2["SYNC"] = 0] = "SYNC";
    BroadcastSyncType2[BroadcastSyncType2["COMMIT"] = 1] = "COMMIT";
  })(BroadcastSyncType || (enums.BroadcastSyncType = BroadcastSyncType = {}));
  var AuthErrorCodes;
  (function(AuthErrorCodes2) {
    AuthErrorCodes2[AuthErrorCodes2["PRIVATE_MODE"] = -1001] = "PRIVATE_MODE";
    AuthErrorCodes2[AuthErrorCodes2["KGW_MODE"] = -901] = "KGW_MODE";
  })(AuthErrorCodes || (enums.AuthErrorCodes = AuthErrorCodes = {}));
  var AccountStatus;
  (function(AccountStatus2) {
    AccountStatus2[AccountStatus2["LATEST"] = 0] = "LATEST";
    AccountStatus2[AccountStatus2["PENDING"] = 1] = "PENDING";
  })(AccountStatus || (enums.AccountStatus = AccountStatus = {}));
  var AccountKeyType;
  (function(AccountKeyType2) {
    AccountKeyType2["SECP256K1"] = "secp256k1";
    AccountKeyType2["ED25519"] = "ed25519";
  })(AccountKeyType || (enums.AccountKeyType = AccountKeyType = {}));
  var AccessModifier;
  (function(AccessModifier2) {
    AccessModifier2["PUBLIC"] = "PUBLIC";
    AccessModifier2["PRIVATE"] = "PRIVATE";
    AccessModifier2["VIEW"] = "VIEW";
  })(AccessModifier || (enums.AccessModifier = AccessModifier = {}));
  return enums;
}
var jsonrpc = {};
var hasRequiredJsonrpc;
function requireJsonrpc() {
  if (hasRequiredJsonrpc) return jsonrpc;
  hasRequiredJsonrpc = 1;
  Object.defineProperty(jsonrpc, "__esModule", { value: true });
  jsonrpc.JSONRPCMethod = void 0;
  var JSONRPCMethod;
  (function(JSONRPCMethod2) {
    JSONRPCMethod2["METHOD_HEALTH"] = "user.health";
    JSONRPCMethod2["METHOD_PING"] = "user.ping";
    JSONRPCMethod2["METHOD_CHAIN_INFO"] = "user.chain_info";
    JSONRPCMethod2["METHOD_ACCOUNT"] = "user.account";
    JSONRPCMethod2["METHOD_BROADCAST"] = "user.broadcast";
    JSONRPCMethod2["METHOD_CALL"] = "user.call";
    JSONRPCMethod2["METHOD_DATABASES"] = "user.databases";
    JSONRPCMethod2["METHOD_PRICE"] = "user.estimate_price";
    JSONRPCMethod2["METHOD_QUERY"] = "user.query";
    JSONRPCMethod2["METHOD_TX_QUERY"] = "user.tx_query";
    JSONRPCMethod2["METHOD_SCHEMA"] = "user.schema";
    JSONRPCMethod2["METHOD_KGW_PARAM"] = "kgw.authn_param";
    JSONRPCMethod2["METHOD_KGW_AUTHN"] = "kgw.authn";
    JSONRPCMethod2["METHOD_KGW_LOGOUT"] = "kgw.logout";
    JSONRPCMethod2["METHOD_CHALLENGE"] = "user.challenge";
  })(JSONRPCMethod || (jsonrpc.JSONRPCMethod = JSONRPCMethod = {}));
  return jsonrpc;
}
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client;
  hasRequiredClient = 1;
  Object.defineProperty(client, "__esModule", { value: true });
  const base64_1 = requireBase64();
  const api_1 = requireApi();
  const serial_12 = requireSerial();
  const enums_1 = requireEnums();
  const jsonrpc_1 = requireJsonrpc();
  class Client extends api_1.Api {
    constructor(opts) {
      super(opts);
      this.jsonRpcId = 1;
      this.unconfirmedNonce = opts.unconfirmedNonce || false;
    }
    async getAuthenticateClient() {
      const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_KGW_PARAM, {});
      const res = await super.post(`/rpc/v1`, body);
      return checkRes(res, (r) => r.result);
    }
    async postAuthenticateClient(authBody) {
      const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_KGW_AUTHN, authBody);
      const res = await super.post(`/rpc/v1`, body);
      if (typeof window === "undefined") {
        return checkRes(res, (r) => {
          const cookie = res.headers["set-cookie"];
          if (!cookie) {
            throw new Error("No cookie received from gateway. An error occurred with authentication.");
          }
          return {
            ...r.result,
            cookie: cookie[0]
          };
        });
      }
      return checkRes(res, (r) => r.result);
    }
    // TODO: Update once KGW is updated for JSON RPC - DO NOT MERGE WITHOUT RESOLVING
    async logoutClient(identifier) {
      const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_KGW_LOGOUT, {
        account: identifier ? (0, serial_12.bytesToHex)(identifier) : ""
      });
      const res = await super.post(`/rpc/v1`, body);
      if (typeof window === "undefined") {
        return checkRes(res, (r) => {
          const cookie = res.headers["set-cookie"];
          if (!cookie) {
            throw new Error("No cookie received from gateway. An error occured with logout.");
          }
          if (cookie[0].startsWith("kgw_session=;")) {
            this.cookie = void 0;
          } else {
            this.cookie = cookie[0];
          }
          return {
            ...r.result,
            cookie: cookie[0]
          };
        });
      }
      return checkRes(res, (r) => r.result);
    }
    async getAccountClient(accountId) {
      const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_ACCOUNT, {
        id: accountId,
        status: this.unconfirmedNonce ? enums_1.AccountStatus.PENDING : enums_1.AccountStatus.LATEST
      });
      const res = await super.post(`/rpc/v1`, body);
      return checkRes(res, (r) => {
        return {
          ...r.result,
          id: r.result.id
        };
      });
    }
    async listDatabasesClient(owner) {
      const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_DATABASES, {
        owner: owner ? (0, serial_12.bytesToHex)(owner) : void 0
      });
      const res = await super.post(`/rpc/v1`, body);
      return checkRes(res, (r) => {
        if (!r.result.databases) {
          return [];
        }
        return r.result.databases.map((db) => {
          return {
            ...db,
            owner: (0, serial_12.hexToBytes)(db.owner)
          };
        });
      });
    }
    async estimateCostClient(tx2) {
      const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_PRICE, {
        tx: tx2.txData
      });
      const res = await super.post(`/rpc/v1`, body);
      return checkRes(res, (r) => r.result.price);
    }
    async broadcastClient(tx2, broadcastSync) {
      if (!tx2.isSigned()) {
        throw new Error("Tx must be signed before broadcasting.");
      }
      const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_BROADCAST, {
        tx: tx2.txData,
        ...broadcastSync ? { sync: broadcastSync } : {}
      });
      const res = await super.post(`/rpc/v1`, body);
      return checkRes(res, (r) => {
        if (r.result.result && r.result.result?.code !== 0) {
          throw new Error(JSON.stringify(r.result) || `Transaction failed after broadcast.`);
        }
        return {
          tx_hash: (0, serial_12.base64ToHex)(r.result.tx_hash)
        };
      });
    }
    async pingClient() {
      const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_PING, {
        message: "ping"
      });
      const res = await super.post(`/rpc/v1`, body);
      return checkRes(res, (r) => r.result.message);
    }
    async chainInfoClient() {
      const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_CHAIN_INFO, {});
      const res = await super.post(`/rpc/v1`, body);
      return checkRes(res, (r) => {
        return {
          chain_id: r.result.chain_id,
          height: r.result.block_height.toString(),
          hash: r.result.block_hash
        };
      });
    }
    async healthModeCheckClient() {
      const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_HEALTH, {});
      const res = await super.post(`/rpc/v1`, body);
      return checkRes(res, (r) => r.result);
    }
    async challengeClient() {
      const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_CHALLENGE, {});
      const res = await super.post(`/rpc/v1`, body);
      return checkRes(res, (r) => r.result.challenge);
    }
    async selectQueryClient(query) {
      const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_QUERY, query);
      const res = await super.post(`/rpc/v1`, body);
      return checkRes(res, (r) => this.parseQueryResponse(r.result));
    }
    async txInfoClient(tx_hash) {
      const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_TX_QUERY, {
        tx_hash: (0, serial_12.hexToBase64)(tx_hash)
      });
      const res = await super.post(`/rpc/v1`, body);
      return checkRes(res, (r) => {
        return {
          ...r.result,
          tx: {
            ...r.result.tx,
            body: {
              ...r.result.tx.body,
              payload: (0, base64_1.base64ToBytes)(r.result.tx.body.payload),
              fee: BigInt(r.result.tx.body.fee || 0)
            },
            signature: {
              ...r.result.tx.signature,
              sig: (0, base64_1.base64ToBytes)(r.result.tx.signature.sig)
            },
            sender: (0, serial_12.hexToBytes)(r.result.tx.sender || "")
          }
        };
      });
    }
    async callClient(msg) {
      const body = this.buildJsonRpcRequest(jsonrpc_1.JSONRPCMethod.METHOD_CALL, {
        body: msg.body,
        auth_type: msg.auth_type,
        sender: msg.sender || "",
        signature: msg.signature || ""
      });
      const res = await super.post(`/rpc/v1`, body);
      const errorResponse = this.checkAuthError(res);
      if (errorResponse) {
        return errorResponse;
      }
      return checkRes(res, (r) => {
        return {
          result: this.parseQueryResponse(r.result.query_result)
        };
      });
    }
    buildJsonRpcRequest(method, params) {
      return {
        jsonrpc: "2.0",
        id: this.jsonRpcId++,
        method,
        params
      };
    }
    // Check for specific error codes and return http status, result of view action, and rpc authError code (if applicable)
    checkAuthError(res) {
      const errorCode = res.data.error?.code;
      if (errorCode === enums_1.AuthErrorCodes.PRIVATE_MODE || errorCode === enums_1.AuthErrorCodes.KGW_MODE) {
        return {
          status: res.status,
          data: void 0,
          authCode: errorCode
        };
      }
      return null;
    }
    parseQueryResponse(queryResponse) {
      const { column_names, values } = queryResponse;
      if (!values || values.length === 0) {
        return [];
      }
      const mapValueToColumn = (rowValues) => {
        const obj = {};
        for (let i = 0; i < column_names.length; i++) {
          obj[column_names[i]] = rowValues[i];
        }
        return obj;
      };
      return values.map(mapValueToColumn);
    }
  }
  client.default = Client;
  function checkRes(res, selector) {
    switch (res.status) {
      case 200:
        break;
      case 401:
        throw new Error(JSON.stringify(res.data) || "Unauthorized.");
      case 404:
        throw new Error(JSON.stringify(res.data) || "Not found.");
      case 500:
        throw new Error(JSON.stringify(res.data) || "Internal server error.");
      default:
        throw new Error(JSON.stringify(res.data) || "An unknown error has occurred.  Please check your network connection.");
    }
    if (!res.data) {
      throw new Error(`failed to parse response: ${res}`);
    }
    if (res.data.error) {
      const data2 = res.data.error.data ? `, data: ${JSON.stringify(res.data.error.data)}` : "";
      throw new Error(`JSON RPC call error: code: ${res.data.error.code}, message: ${res.data.error.message}` + data2);
    }
    if (res.data.jsonrpc !== "2.0") {
      throw new Error(JSON.stringify(res.data) || "Invalid JSON RPC response.");
    }
    if (!res.data.result) {
      throw new Error(JSON.stringify(res.data) || "No result in JSON RPC response.");
    }
    return {
      status: res.status,
      data: selector(res.data)
    };
  }
  return client;
}
var action$2 = {};
var types = {};
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  Object.defineProperty(types, "__esModule", { value: true });
  types.isValueType = types.Promisy = void 0;
  const objects_1 = requireObjects();
  var Promisy;
  (function(Promisy2) {
    async function resolve(promisy) {
      const fov = objects_1.objects.requireNonNil(promisy);
      const awaitable = typeof fov === "function" ? fov() : fov;
      return await awaitable;
    }
    Promisy2.resolve = resolve;
    async function resolveOrReject(promisy, nilError) {
      return objects_1.objects.isNil(promisy) ? Promise.reject(new objects_1.NillableError(nilError)) : resolve(promisy);
    }
    Promisy2.resolveOrReject = resolveOrReject;
  })(Promisy || (types.Promisy = Promisy = {}));
  function isValueType(v) {
    if (v === null || v === void 0 || typeof v === "string" || typeof v === "number" || typeof v === "boolean" || v instanceof Uint8Array) {
      return true;
    }
    if (Array.isArray(v)) {
      return v.every(isValueType);
    }
    return false;
  }
  types.isValueType = isValueType;
  return types;
}
var hasRequiredAction$1;
function requireAction$1() {
  if (hasRequiredAction$1) return action$2;
  hasRequiredAction$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ActionInput = exports.transformPositionalParam = exports.transformActionInput = exports.isNamedParam = exports.isNamedParams = exports.resolveParamTypes = void 0;
    const objects_1 = requireObjects();
    const types_1 = requireTypes();
    function resolveParamTypes(i, types2) {
      const paramTypes = [];
      if (!types2) {
        if (isNamedParam(i)) {
          for (const [k, v] of Object.entries(i)) {
            paramTypes.push({ v });
          }
        } else {
          for (let j = 0; j < i.length; j++) {
            paramTypes.push({ v: i[j] });
          }
        }
        return paramTypes;
      }
      if (isNamedParam(i)) {
        if (types2 && !Array.isArray(types2)) {
          for (const [k, v] of Object.entries(i)) {
            paramTypes.push({ v, o: types2[k] });
          }
        } else {
          Object.entries(i).forEach(([k, v], idx) => {
            paramTypes.push({ v, o: types2[idx] });
          });
        }
      } else {
        if (types2 && !Array.isArray(types2)) {
          const typeVals = Object.values(types2);
          for (let j = 0; j < i.length; j++) {
            paramTypes.push({ v: i[j], o: typeVals[j] });
          }
        } else {
          for (let j = 0; j < i.length; j++) {
            paramTypes.push({ v: i[j], o: types2[j] });
          }
        }
      }
      return paramTypes;
    }
    exports.resolveParamTypes = resolveParamTypes;
    function isNamedParams(i) {
      let isNamedParams2 = false;
      for (const p of i) {
        if (isNamedParam(p)) {
          isNamedParams2 = true;
          break;
        }
      }
      return isNamedParams2;
    }
    exports.isNamedParams = isNamedParams;
    function isNamedParam(i) {
      return typeof i === "object" && i !== null && !Array.isArray(i);
    }
    exports.isNamedParam = isNamedParam;
    function assertKey(key) {
      return objects_1.objects.requireNonNil(key, "key cannot be nil");
    }
    function lowercaseKey(key) {
      return key.toLowerCase();
    }
    exports.transformActionInput = {
      /**
       * Checks if all elements in the given array are instances of ActionInput.
       *
       * @param {unknown} i - The value to be checked.
       * @returns {boolean} - True if `inputs` is an array where every element is an ActionInput, otherwise false.
       */
      isActionInputArray(i) {
        return Array.isArray(i) && i.length > 0 && i.every((item) => item instanceof ActionInput);
      },
      /**
       * Transforms action inputs into entries format required by the API.
       * Used to support legacy ActionInput[] when calling a view action where only one input is required.
       *
       * @param {ActionInput[] | NamedParams[]} inputs - The input array to transform
       * @returns {NamedParams[]} - Array containing a single Entries object
       * @throws {Error} - If inputs array is empty
       */
      toSingleEntry(inputs) {
        if (!inputs.length) {
          return {};
        }
        const firstInput = inputs[0];
        if (firstInput instanceof ActionInput) {
          return firstInput.toEntries();
        }
        return firstInput;
      },
      /**
       * Transforms action inputs into entries format required by the API.
       * Used to support legacy ActionInput[] when calling an execute action where multiple inputs may be required.
       *
       * @param {ActionInput[] | NamedParams[]} inputs - The input array to transform
       * @returns {NamedParams[]} - Array containing entries objects
       * @throws {Error} - If inputs array is not valid
       */
      toNamedParams(inputs) {
        if (!exports.transformActionInput.isActionInputArray(inputs)) {
          throw new Error("Inputs array  must be an array of Entries or ActionInput objects");
        }
        const np = [];
        for (const input of inputs) {
          if (input instanceof ActionInput) {
            np.push(input.toEntries());
          }
        }
        return np;
      }
    };
    exports.transformPositionalParam = {
      /**
      * Checks if all elements in a given array are PositionalParams
      * @param {unknown} i - The value to be checked.
      * @returns {boolean} - True if `inputs` is an array where every element is a PositionalParam, otherwise false.
      */
      isPositionalParams(i) {
        return Array.isArray(i) && i.every((p) => (0, types_1.isValueType)(p));
      },
      /**
       * Checks if a given value is a PositionalParam
       * @param {unknown} i - The value to be checked.
       * @returns {boolean} - True if `i` is a PositionalParam, otherwise false.
       */
      isPositionalParam(i) {
        return (0, types_1.isValueType)(i);
      },
      /**
       * Transforms positional parameters into named parameters to be used for validation
       *
       * @param {PositionalParams[]} inputs - The input array to transform
       * @returns {NamedParams[]} - Array containing entries objects
       */
      toNamedParams(inputs) {
        return inputs.map((i) => {
          return exports.transformPositionalParam.toNamedParam(i);
        });
      },
      toNamedParam(i) {
        const np = {};
        i.forEach((v, idx) => {
          np[`$pstn_${idx}`] = v;
        });
        return np;
      }
    };
    class ActionInput {
      constructor() {
        this.map = {};
      }
      /**
       * Adds or replaces a value for a single action input.
       *
       * @param key - The action input name.
       * @param value - The value to put for the action input.
       * @returns The current `ActionInput` instance for chaining.
       */
      put(key, value) {
        key = lowercaseKey(key);
        this.map[assertKey(key)] = value;
        return this;
      }
      /**
       * Adds a value for a single action input if the key is not already present.
       *
       * @param key - The action input name.
       * @param value - The value to put for the action input.
       * @returns The current `ActionInput` instance for chaining.
       */
      putIfAbsent(key, value) {
        key = lowercaseKey(key);
        if (!this.containsKey(key)) {
          this.map[key] = value;
        }
        return this;
      }
      /**
       * Replaces a value for a single action input if the key is already present.
       *
       * @param key - The action input name.
       * @param value - The value to replace for the action input.
       * @returns The current `ActionInput` instance for chaining.
       */
      replace(key, value) {
        key = lowercaseKey(key);
        if (this.containsKey(key)) {
          this.map[key] = value;
        }
        return this;
      }
      /**
       * Retrieves an action input value given its key.
       *
       * @param key - The action input name.
       * @returns The value associated with the action input name.
       */
      get(key) {
        key = lowercaseKey(key);
        return this.map[assertKey(key)];
      }
      /**
       * Retrieves a value by its action input name, or a default value if the action input name is not present.
       *
       * @param key - The action input name.
       * @param defaultValue - The default value to return if the key is not present.
       * @returns The value associated with the key, or the default value.
       */
      getOrDefault(key, defaultValue) {
        key = lowercaseKey(key);
        return this.map[assertKey(key)] ?? defaultValue;
      }
      /**
       * Checks if the map contains a specific action input name.
       *
       * @param key - The action input name.
       * @returns True if the action input name is present, false otherwise.
       */
      containsKey(key) {
        key = lowercaseKey(key);
        return this.map.hasOwnProperty(assertKey(key));
      }
      /**
       * Removes a action input name and its associated value from the map.
       *
       * @param key - The action input name to remove.
       * @returns True if the key was present and is now removed, false otherwise.
       */
      remove(key) {
        key = lowercaseKey(key);
        return delete this.map[key];
      }
      /**
       * Converts the map of action inputs to an array of entries.
       *
       * @param filter - An optional filter function.
       * @returns A read-only array of entries.
       */
      toArray(filter) {
        return Object.entries(this.map).filter(filter ?? (() => true));
      }
      /**
       * Transforms the `ActionInput` to JSON.
       *
       * @returns A read-only map of entries.
       */
      toEntries() {
        return this.map;
      }
      /**
       * Allows `ActionInput` to be iterable.
       *
       * @returns An iterator over the array of entries.
       */
      [Symbol.iterator]() {
        return this.toArray()[Symbol.iterator]();
      }
      /**
       * Adds or replaces values from and object of action name/key-value pairs.
       *
       * @param obj - The object from which to extract action name/key-value pairs.
       * @returns The current `ActionInput` instance for chaining.
       */
      putFromObject(obj) {
        for (let [key, value] of Object.entries(objects_1.objects.requireNonNil(obj))) {
          key = lowercaseKey(key);
          this.map[assertKey(key)] = value;
        }
        return this;
      }
      /**
       * Adds values from and object of action name/key-value pairs if the key is not already present.
       *
       * @param obj - The object from which to extract key-value pairs.
       * @returns The current `ActionInput` instance for chaining.
       */
      putFromObjectIfAbsent(obj) {
        for (let [key, value] of Object.entries(objects_1.objects.requireNonNil(obj))) {
          key = lowercaseKey(key);
          if (!this.containsKey(key)) {
            this.map[assertKey(key)] = value;
          }
        }
        return this;
      }
      /**
       * Replaces values from and object of action name/key-value pairs if the key is already present.
       *
       * @param obj - The object from which to extract key-value pairs.
       * @returns The current `ActionInput` instance for chaining.
       */
      replaceFromObject(obj) {
        for (let [key, value] of Object.entries(objects_1.objects.requireNonNil(obj))) {
          key = lowercaseKey(key);
          if (this.containsKey(key)) {
            this.map[assertKey(key)] = value;
          }
        }
        return this;
      }
      /**
       * Creates multiple `ActionInput` instances from an array of objects.
       *
       * @param objs - An array of objects from which to create `ActionInput` instances.
       * @returns An array of `ActionInput` instances.
       */
      putFromObjects(objs) {
        const actions2 = [];
        for (const obj of objects_1.objects.requireNonNil(objs)) {
          actions2.push(ActionInput.fromObject(obj));
        }
        return actions2;
      }
      /**
       * Factory method to create a new instance of `ActionInput`.
       *
       * @returns A new `ActionInput` instance.
       */
      static of() {
        return new ActionInput();
      }
      /**
       * Creates a new `ActionInput` instance from an iterable array of entries.
       *
       * @param entries - The iterable of set of entries. Entries should be formatted as an array of `[inputName, value]`.
       * @returns A new `ActionInput` instance.
       */
      static from(entries) {
        const action2 = ActionInput.of();
        for (let [key, value] of entries) {
          key = lowercaseKey(key);
          action2.map[assertKey(key)] = value;
        }
        return action2;
      }
      /**
       * Creates a new `ActionInput` instance from an object.
       *
       * @param obj - The object from which to create the `ActionInput`.
       * @returns A new `ActionInput` instance.
       */
      static fromObject(obj) {
        const action2 = ActionInput.of();
        for (let [key, value] of Object.entries(objects_1.objects.requireNonNil(obj))) {
          key = lowercaseKey(key);
          action2.map[assertKey(key)] = value;
        }
        return action2;
      }
      /**
       * Creates multiple `ActionInput` instances from an array of objects.
       *
       * @param objs - An array of objects from which to create `ActionInput` instances.
       * @returns An array of `ActionInput` instances.
       */
      static fromObjects(objs) {
        const actions2 = [];
        for (const obj of objects_1.objects.requireNonNil(objs)) {
          actions2.push(ActionInput.fromObject(obj));
        }
        return actions2;
      }
    }
    exports.ActionInput = ActionInput;
  })(action$2);
  return action$2;
}
var intern = {};
var hasRequiredIntern;
function requireIntern() {
  if (hasRequiredIntern) return intern;
  hasRequiredIntern = 1;
  Object.defineProperty(intern, "__esModule", { value: true });
  intern.wrap = intern.unwrap = void 0;
  const objects_1 = requireObjects();
  const key = Symbol("estimate");
  function unwrap(kwil2) {
    objects_1.objects.requireNonNil(kwil2);
    return objects_1.objects.requireNonNil(kwil2[key]);
  }
  intern.unwrap = unwrap;
  function wrap(kwil2, method) {
    objects_1.objects.requireNonNil(kwil2);
    kwil2[key] = method;
  }
  intern.wrap = wrap;
  return intern;
}
var funder = {};
var payloadTx = {};
var signature = {};
var hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature) return signature;
  hasRequiredSignature = 1;
  Object.defineProperty(signature, "__esModule", { value: true });
  signature.executeSign = signature.isEthersSigner = signature.getSignatureType = signature.SignatureType = void 0;
  const serial_12 = requireSerial();
  var SignatureType;
  (function(SignatureType2) {
    SignatureType2["SIGNATURE_TYPE_INVALID"] = "invalid";
    SignatureType2["SECP256K1_PERSONAL"] = "secp256k1_ep";
    SignatureType2["ED25519"] = "ed25519";
  })(SignatureType || (signature.SignatureType = SignatureType = {}));
  function getSignatureType(signer) {
    if (isEthersSigner(signer)) {
      return SignatureType.SECP256K1_PERSONAL;
    }
    return SignatureType.SIGNATURE_TYPE_INVALID;
  }
  signature.getSignatureType = getSignatureType;
  async function ethSign(message2, signer) {
    return await signer.signMessage(message2);
  }
  function isEthersSigner(signer) {
    if (typeof signer === "object" && signer !== null && "signMessage" in signer && typeof signer.signMessage === "function") {
      return true;
    }
    return false;
  }
  signature.isEthersSigner = isEthersSigner;
  async function executeSign(msg, signer, signatureType) {
    if (isEthersSigner(signer) && signatureType === SignatureType.SECP256K1_PERSONAL) {
      const hexSig = await ethSign(msg, signer);
      let sigBytes = (0, serial_12.hexToBytes)(hexSig);
      return sigBytes;
    }
    if (!isEthersSigner(signer) && signatureType !== SignatureType.SIGNATURE_TYPE_INVALID) {
      if (typeof signer === "function") {
        const signature2 = await signer(msg);
        return signature2;
      } else {
        throw new Error("Something went wrong signing! Make sure your signer is a function that returns a Uint8Array.");
      }
    }
    throw new Error("Could not execute signature. Make sure you pass a signer from EtherJS or a function that returns a Uint8Array.");
  }
  signature.executeSign = executeSign;
  return signature;
}
var tx = {};
var hasRequiredTx;
function requireTx() {
  if (hasRequiredTx) return tx;
  hasRequiredTx = 1;
  Object.defineProperty(tx, "__esModule", { value: true });
  tx.Txn = tx.BaseTransaction = void 0;
  const signature_1 = requireSignature();
  const strings_1 = requireStrings();
  const enums_1 = requireEnums();
  class BaseTransaction {
    constructor(data2) {
      this.data = data2 || {
        signature: {
          sig: null,
          type: signature_1.SignatureType.SIGNATURE_TYPE_INVALID
        },
        body: {
          desc: "",
          payload: null,
          type: enums_1.PayloadType.INVALID_PAYLOAD_TYPE,
          fee: null,
          nonce: null,
          chain_id: ""
        },
        sender: null,
        serialization: enums_1.SerializationType.SIGNED_MSG_CONCAT
      };
    }
    get txData() {
      return this.data;
    }
    isSigned() {
      return !strings_1.strings.isNilOrEmpty(this.data.signature.sig);
    }
    get signature() {
      return this.data.signature;
    }
    get sender() {
      return this.data.sender;
    }
    get body() {
      return this.data.body;
    }
    get serialization() {
      return this.data.serialization;
    }
  }
  tx.BaseTransaction = BaseTransaction;
  var Txn;
  (function(Txn2) {
    function create(configure) {
      const tx2 = {
        signature: {
          sig: null,
          type: signature_1.SignatureType.SECP256K1_PERSONAL
        },
        body: {
          desc: "",
          payload: null,
          type: enums_1.PayloadType.INVALID_PAYLOAD_TYPE,
          fee: null,
          nonce: null,
          chain_id: ""
        },
        sender: null,
        serialization: enums_1.SerializationType.SIGNED_MSG_CONCAT
      };
      configure(tx2);
      return new BaseTransaction(tx2);
    }
    Txn2.create = create;
    function copy(source, configure) {
      return Txn2.create((tx2) => {
        tx2.body = source.body;
        tx2.signature = source.signature;
        tx2.body = source.body;
        tx2.sender = source.sender;
        tx2.serialization = source.serialization;
        configure(tx2);
      });
    }
    Txn2.copy = copy;
  })(Txn || (tx.Txn = Txn = {}));
  return tx;
}
var crypto$1 = {};
var sha$1 = { exports: {} };
var sha = sha$1.exports;
var hasRequiredSha;
function requireSha() {
  if (hasRequiredSha) return sha$1.exports;
  hasRequiredSha = 1;
  (function(module, exports) {
    !function(n, r) {
      module.exports = r();
    }(sha, function() {
      var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r = "ARRAYBUFFER not supported by this environment", t = "UINT8ARRAY not supported by this environment";
      function e(n2, r2, t2, e2) {
        var i2, o2, u2, f2 = r2 || [0], s2 = (t2 = t2 || 0) >>> 3, w2 = -1 === e2 ? 3 : 0;
        for (i2 = 0; i2 < n2.length; i2 += 1) o2 = (u2 = i2 + s2) >>> 2, f2.length <= o2 && f2.push(0), f2[o2] |= n2[i2] << 8 * (w2 + e2 * (u2 % 4));
        return { value: f2, binLen: 8 * n2.length + t2 };
      }
      function i(i2, o2, u2) {
        switch (o2) {
          case "UTF8":
          case "UTF16BE":
          case "UTF16LE":
            break;
          default:
            throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE");
        }
        switch (i2) {
          case "HEX":
            return function(n2, r2, t2) {
              return function(n3, r3, t3, e2) {
                var i3, o3, u3, f2;
                if (0 != n3.length % 2) throw new Error("String of HEX type must be in byte increments");
                var s2 = r3 || [0], w2 = (t3 = t3 || 0) >>> 3, a2 = -1 === e2 ? 3 : 0;
                for (i3 = 0; i3 < n3.length; i3 += 2) {
                  if (o3 = parseInt(n3.substr(i3, 2), 16), isNaN(o3)) throw new Error("String of HEX type contains invalid characters");
                  for (u3 = (f2 = (i3 >>> 1) + w2) >>> 2; s2.length <= u3; ) s2.push(0);
                  s2[u3] |= o3 << 8 * (a2 + e2 * (f2 % 4));
                }
                return { value: s2, binLen: 4 * n3.length + t3 };
              }(n2, r2, t2, u2);
            };
          case "TEXT":
            return function(n2, r2, t2) {
              return function(n3, r3, t3, e2, i3) {
                var o3, u3, f2, s2, w2, a2, h2, c2, v2 = 0, A2 = t3 || [0], E2 = (e2 = e2 || 0) >>> 3;
                if ("UTF8" === r3) for (h2 = -1 === i3 ? 3 : 0, f2 = 0; f2 < n3.length; f2 += 1) for (u3 = [], 128 > (o3 = n3.charCodeAt(f2)) ? u3.push(o3) : 2048 > o3 ? (u3.push(192 | o3 >>> 6), u3.push(128 | 63 & o3)) : 55296 > o3 || 57344 <= o3 ? u3.push(224 | o3 >>> 12, 128 | o3 >>> 6 & 63, 128 | 63 & o3) : (f2 += 1, o3 = 65536 + ((1023 & o3) << 10 | 1023 & n3.charCodeAt(f2)), u3.push(240 | o3 >>> 18, 128 | o3 >>> 12 & 63, 128 | o3 >>> 6 & 63, 128 | 63 & o3)), s2 = 0; s2 < u3.length; s2 += 1) {
                  for (w2 = (a2 = v2 + E2) >>> 2; A2.length <= w2; ) A2.push(0);
                  A2[w2] |= u3[s2] << 8 * (h2 + i3 * (a2 % 4)), v2 += 1;
                }
                else for (h2 = -1 === i3 ? 2 : 0, c2 = "UTF16LE" === r3 && 1 !== i3 || "UTF16LE" !== r3 && 1 === i3, f2 = 0; f2 < n3.length; f2 += 1) {
                  for (o3 = n3.charCodeAt(f2), true === c2 && (o3 = (s2 = 255 & o3) << 8 | o3 >>> 8), w2 = (a2 = v2 + E2) >>> 2; A2.length <= w2; ) A2.push(0);
                  A2[w2] |= o3 << 8 * (h2 + i3 * (a2 % 4)), v2 += 2;
                }
                return { value: A2, binLen: 8 * v2 + e2 };
              }(n2, o2, r2, t2, u2);
            };
          case "B64":
            return function(r2, t2, e2) {
              return function(r3, t3, e3, i3) {
                var o3, u3, f2, s2, w2, a2, h2 = 0, c2 = t3 || [0], v2 = (e3 = e3 || 0) >>> 3, A2 = -1 === i3 ? 3 : 0, E2 = r3.indexOf("=");
                if (-1 === r3.search(/^[a-zA-Z0-9=+/]+$/)) throw new Error("Invalid character in base-64 string");
                if (r3 = r3.replace(/=/g, ""), -1 !== E2 && E2 < r3.length) throw new Error("Invalid '=' found in base-64 string");
                for (o3 = 0; o3 < r3.length; o3 += 4) {
                  for (s2 = r3.substr(o3, 4), f2 = 0, u3 = 0; u3 < s2.length; u3 += 1) f2 |= n.indexOf(s2.charAt(u3)) << 18 - 6 * u3;
                  for (u3 = 0; u3 < s2.length - 1; u3 += 1) {
                    for (w2 = (a2 = h2 + v2) >>> 2; c2.length <= w2; ) c2.push(0);
                    c2[w2] |= (f2 >>> 16 - 8 * u3 & 255) << 8 * (A2 + i3 * (a2 % 4)), h2 += 1;
                  }
                }
                return { value: c2, binLen: 8 * h2 + e3 };
              }(r2, t2, e2, u2);
            };
          case "BYTES":
            return function(n2, r2, t2) {
              return function(n3, r3, t3, e2) {
                var i3, o3, u3, f2, s2 = r3 || [0], w2 = (t3 = t3 || 0) >>> 3, a2 = -1 === e2 ? 3 : 0;
                for (o3 = 0; o3 < n3.length; o3 += 1) i3 = n3.charCodeAt(o3), u3 = (f2 = o3 + w2) >>> 2, s2.length <= u3 && s2.push(0), s2[u3] |= i3 << 8 * (a2 + e2 * (f2 % 4));
                return { value: s2, binLen: 8 * n3.length + t3 };
              }(n2, r2, t2, u2);
            };
          case "ARRAYBUFFER":
            try {
              new ArrayBuffer(0);
            } catch (n2) {
              throw new Error(r);
            }
            return function(n2, r2, t2) {
              return function(n3, r3, t3, i3) {
                return e(new Uint8Array(n3), r3, t3, i3);
              }(n2, r2, t2, u2);
            };
          case "UINT8ARRAY":
            try {
              new Uint8Array(0);
            } catch (n2) {
              throw new Error(t);
            }
            return function(n2, r2, t2) {
              return e(n2, r2, t2, u2);
            };
          default:
            throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
        }
      }
      function o(e2, i2, o2, u2) {
        switch (e2) {
          case "HEX":
            return function(n2) {
              return function(n3, r2, t2, e3) {
                var i3, o3, u3 = "0123456789abcdef", f2 = "", s2 = r2 / 8, w2 = -1 === t2 ? 3 : 0;
                for (i3 = 0; i3 < s2; i3 += 1) o3 = n3[i3 >>> 2] >>> 8 * (w2 + t2 * (i3 % 4)), f2 += u3.charAt(o3 >>> 4 & 15) + u3.charAt(15 & o3);
                return e3.outputUpper ? f2.toUpperCase() : f2;
              }(n2, i2, o2, u2);
            };
          case "B64":
            return function(r2) {
              return function(r3, t2, e3, i3) {
                var o3, u3, f2, s2, w2, a2 = "", h2 = t2 / 8, c2 = -1 === e3 ? 3 : 0;
                for (o3 = 0; o3 < h2; o3 += 3) for (s2 = o3 + 1 < h2 ? r3[o3 + 1 >>> 2] : 0, w2 = o3 + 2 < h2 ? r3[o3 + 2 >>> 2] : 0, f2 = (r3[o3 >>> 2] >>> 8 * (c2 + e3 * (o3 % 4)) & 255) << 16 | (s2 >>> 8 * (c2 + e3 * ((o3 + 1) % 4)) & 255) << 8 | w2 >>> 8 * (c2 + e3 * ((o3 + 2) % 4)) & 255, u3 = 0; u3 < 4; u3 += 1) a2 += 8 * o3 + 6 * u3 <= t2 ? n.charAt(f2 >>> 6 * (3 - u3) & 63) : i3.b64Pad;
                return a2;
              }(r2, i2, o2, u2);
            };
          case "BYTES":
            return function(n2) {
              return function(n3, r2, t2) {
                var e3, i3, o3 = "", u3 = r2 / 8, f2 = -1 === t2 ? 3 : 0;
                for (e3 = 0; e3 < u3; e3 += 1) i3 = n3[e3 >>> 2] >>> 8 * (f2 + t2 * (e3 % 4)) & 255, o3 += String.fromCharCode(i3);
                return o3;
              }(n2, i2, o2);
            };
          case "ARRAYBUFFER":
            try {
              new ArrayBuffer(0);
            } catch (n2) {
              throw new Error(r);
            }
            return function(n2) {
              return function(n3, r2, t2) {
                var e3, i3 = r2 / 8, o3 = new ArrayBuffer(i3), u3 = new Uint8Array(o3), f2 = -1 === t2 ? 3 : 0;
                for (e3 = 0; e3 < i3; e3 += 1) u3[e3] = n3[e3 >>> 2] >>> 8 * (f2 + t2 * (e3 % 4)) & 255;
                return o3;
              }(n2, i2, o2);
            };
          case "UINT8ARRAY":
            try {
              new Uint8Array(0);
            } catch (n2) {
              throw new Error(t);
            }
            return function(n2) {
              return function(n3, r2, t2) {
                var e3, i3 = r2 / 8, o3 = -1 === t2 ? 3 : 0, u3 = new Uint8Array(i3);
                for (e3 = 0; e3 < i3; e3 += 1) u3[e3] = n3[e3 >>> 2] >>> 8 * (o3 + t2 * (e3 % 4)) & 255;
                return u3;
              }(n2, i2, o2);
            };
          default:
            throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
        }
      }
      var u = 4294967296, f = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], s = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428], w = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], a = "Chosen SHA variant is not supported", h = "Cannot set numRounds with MAC";
      function c(n2, r2) {
        var t2, e2, i2 = n2.binLen >>> 3, o2 = r2.binLen >>> 3, u2 = i2 << 3, f2 = 4 - i2 << 3;
        if (i2 % 4 != 0) {
          for (t2 = 0; t2 < o2; t2 += 4) e2 = i2 + t2 >>> 2, n2.value[e2] |= r2.value[t2 >>> 2] << u2, n2.value.push(0), n2.value[e2 + 1] |= r2.value[t2 >>> 2] >>> f2;
          return (n2.value.length << 2) - 4 >= o2 + i2 && n2.value.pop(), { value: n2.value, binLen: n2.binLen + r2.binLen };
        }
        return { value: n2.value.concat(r2.value), binLen: n2.binLen + r2.binLen };
      }
      function v(n2) {
        var r2 = { outputUpper: false, b64Pad: "=", outputLen: -1 }, t2 = n2 || {}, e2 = "Output length must be a multiple of 8";
        if (r2.outputUpper = t2.outputUpper || false, t2.b64Pad && (r2.b64Pad = t2.b64Pad), t2.outputLen) {
          if (t2.outputLen % 8 != 0) throw new Error(e2);
          r2.outputLen = t2.outputLen;
        } else if (t2.shakeLen) {
          if (t2.shakeLen % 8 != 0) throw new Error(e2);
          r2.outputLen = t2.shakeLen;
        }
        if ("boolean" != typeof r2.outputUpper) throw new Error("Invalid outputUpper formatting option");
        if ("string" != typeof r2.b64Pad) throw new Error("Invalid b64Pad formatting option");
        return r2;
      }
      function A(n2, r2, t2, e2) {
        var o2 = n2 + " must include a value and format";
        if (!r2) {
          if (!e2) throw new Error(o2);
          return e2;
        }
        if (void 0 === r2.value || !r2.format) throw new Error(o2);
        return i(r2.format, r2.encoding || "UTF8", t2)(r2.value);
      }
      var E = function() {
        function n2(n3, r2, t2) {
          var e2 = t2 || {};
          if (this.t = r2, this.i = e2.encoding || "UTF8", this.numRounds = e2.numRounds || 1, isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds) throw new Error("numRounds must a integer >= 1");
          this.o = n3, this.u = [], this.h = 0, this.v = false, this.A = 0, this.l = false, this.S = [], this.H = [];
        }
        return n2.prototype.update = function(n3) {
          var r2, t2 = 0, e2 = this.p >>> 5, i2 = this.m(n3, this.u, this.h), o2 = i2.binLen, u2 = i2.value, f2 = o2 >>> 5;
          for (r2 = 0; r2 < f2; r2 += e2) t2 + this.p <= o2 && (this.U = this.R(u2.slice(r2, r2 + e2), this.U), t2 += this.p);
          return this.A += t2, this.u = u2.slice(t2 >>> 5), this.h = o2 % this.p, this.v = true, this;
        }, n2.prototype.getHash = function(n3, r2) {
          var t2, e2, i2 = this.T, u2 = v(r2);
          if (this.C) {
            if (-1 === u2.outputLen) throw new Error("Output length must be specified in options");
            i2 = u2.outputLen;
          }
          var f2 = o(n3, i2, this.F, u2);
          if (this.l && this.K) return f2(this.K(u2));
          for (e2 = this.g(this.u.slice(), this.h, this.A, this.L(this.U), i2), t2 = 1; t2 < this.numRounds; t2 += 1) this.C && i2 % 32 != 0 && (e2[e2.length - 1] &= 16777215 >>> 24 - i2 % 32), e2 = this.g(e2, i2, 0, this.B(this.o), i2);
          return f2(e2);
        }, n2.prototype.setHMACKey = function(n3, r2, t2) {
          if (!this.k) throw new Error("Variant does not support HMAC");
          if (this.v) throw new Error("Cannot set MAC key after calling update");
          var e2 = i(r2, (t2 || {}).encoding || "UTF8", this.F);
          this.Y(e2(n3));
        }, n2.prototype.Y = function(n3) {
          var r2, t2 = this.p >>> 3, e2 = t2 / 4 - 1;
          if (1 !== this.numRounds) throw new Error(h);
          if (this.l) throw new Error("MAC key already set");
          for (t2 < n3.binLen / 8 && (n3.value = this.g(n3.value, n3.binLen, 0, this.B(this.o), this.T)); n3.value.length <= e2; ) n3.value.push(0);
          for (r2 = 0; r2 <= e2; r2 += 1) this.S[r2] = 909522486 ^ n3.value[r2], this.H[r2] = 1549556828 ^ n3.value[r2];
          this.U = this.R(this.S, this.U), this.A = this.p, this.l = true;
        }, n2.prototype.getHMAC = function(n3, r2) {
          var t2 = v(r2);
          return o(n3, this.T, this.F, t2)(this.N());
        }, n2.prototype.N = function() {
          var n3;
          if (!this.l) throw new Error("Cannot call getHMAC without first setting MAC key");
          var r2 = this.g(this.u.slice(), this.h, this.A, this.L(this.U), this.T);
          return n3 = this.R(this.H, this.B(this.o)), n3 = this.g(r2, this.T, this.p, n3, this.T);
        }, n2;
      }(), l = function(n2, r2) {
        return l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n3, r3) {
          n3.__proto__ = r3;
        } || function(n3, r3) {
          for (var t2 in r3) Object.prototype.hasOwnProperty.call(r3, t2) && (n3[t2] = r3[t2]);
        }, l(n2, r2);
      };
      function b(n2, r2) {
        if ("function" != typeof r2 && null !== r2) throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
        function t2() {
          this.constructor = n2;
        }
        l(n2, r2), n2.prototype = null === r2 ? Object.create(r2) : (t2.prototype = r2.prototype, new t2());
      }
      function S(n2, r2) {
        return n2 << r2 | n2 >>> 32 - r2;
      }
      function H(n2, r2) {
        return n2 >>> r2 | n2 << 32 - r2;
      }
      function d(n2, r2) {
        return n2 >>> r2;
      }
      function p(n2, r2, t2) {
        return n2 ^ r2 ^ t2;
      }
      function y(n2, r2, t2) {
        return n2 & r2 ^ ~n2 & t2;
      }
      function m(n2, r2, t2) {
        return n2 & r2 ^ n2 & t2 ^ r2 & t2;
      }
      function U(n2) {
        return H(n2, 2) ^ H(n2, 13) ^ H(n2, 22);
      }
      function R(n2, r2) {
        var t2 = (65535 & n2) + (65535 & r2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16)) << 16 | 65535 & t2;
      }
      function T(n2, r2, t2, e2) {
        var i2 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16)) << 16 | 65535 & i2;
      }
      function C(n2, r2, t2, e2, i2) {
        var o2 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2) + (65535 & i2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16) + (o2 >>> 16)) << 16 | 65535 & o2;
      }
      function F(n2) {
        return H(n2, 7) ^ H(n2, 18) ^ d(n2, 3);
      }
      function K2(n2) {
        return H(n2, 6) ^ H(n2, 11) ^ H(n2, 25);
      }
      function g(n2) {
        return [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      }
      function L(n2, r2) {
        var t2, e2, i2, o2, u2, f2, s2, w2 = [];
        for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o2 = r2[3], u2 = r2[4], s2 = 0; s2 < 80; s2 += 1) w2[s2] = s2 < 16 ? n2[s2] : S(w2[s2 - 3] ^ w2[s2 - 8] ^ w2[s2 - 14] ^ w2[s2 - 16], 1), f2 = s2 < 20 ? C(S(t2, 5), y(e2, i2, o2), u2, 1518500249, w2[s2]) : s2 < 40 ? C(S(t2, 5), p(e2, i2, o2), u2, 1859775393, w2[s2]) : s2 < 60 ? C(S(t2, 5), m(e2, i2, o2), u2, 2400959708, w2[s2]) : C(S(t2, 5), p(e2, i2, o2), u2, 3395469782, w2[s2]), u2 = o2, o2 = i2, i2 = S(e2, 30), e2 = t2, t2 = f2;
        return r2[0] = R(t2, r2[0]), r2[1] = R(e2, r2[1]), r2[2] = R(i2, r2[2]), r2[3] = R(o2, r2[3]), r2[4] = R(u2, r2[4]), r2;
      }
      function B(n2, r2, t2, e2) {
        for (var i2, o2 = 15 + (r2 + 65 >>> 9 << 4), f2 = r2 + t2; n2.length <= o2; ) n2.push(0);
        for (n2[r2 >>> 5] |= 128 << 24 - r2 % 32, n2[o2] = 4294967295 & f2, n2[o2 - 1] = f2 / u | 0, i2 = 0; i2 < n2.length; i2 += 16) e2 = L(n2.slice(i2, i2 + 16), e2);
        return e2;
      }
      "function" == typeof SuppressedError && SuppressedError;
      var k = function(n2) {
        function r2(r3, t2, e2) {
          var o2 = this;
          if ("SHA-1" !== r3) throw new Error(a);
          var u2 = e2 || {};
          return (o2 = n2.call(this, r3, t2, e2) || this).k = true, o2.K = o2.N, o2.F = -1, o2.m = i(o2.t, o2.i, o2.F), o2.R = L, o2.L = function(n3) {
            return n3.slice();
          }, o2.B = g, o2.g = B, o2.U = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], o2.p = 512, o2.T = 160, o2.C = false, u2.hmacKey && o2.Y(A("hmacKey", u2.hmacKey, o2.F)), o2;
        }
        return b(r2, n2), r2;
      }(E);
      function Y(n2) {
        return "SHA-224" == n2 ? s.slice() : w.slice();
      }
      function N(n2, r2) {
        var t2, e2, i2, o2, u2, s2, w2, a2, h2, c2, v2, A2, E2 = [];
        for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o2 = r2[3], u2 = r2[4], s2 = r2[5], w2 = r2[6], a2 = r2[7], v2 = 0; v2 < 64; v2 += 1) E2[v2] = v2 < 16 ? n2[v2] : T(H(A2 = E2[v2 - 2], 17) ^ H(A2, 19) ^ d(A2, 10), E2[v2 - 7], F(E2[v2 - 15]), E2[v2 - 16]), h2 = C(a2, K2(u2), y(u2, s2, w2), f[v2], E2[v2]), c2 = R(U(t2), m(t2, e2, i2)), a2 = w2, w2 = s2, s2 = u2, u2 = R(o2, h2), o2 = i2, i2 = e2, e2 = t2, t2 = R(h2, c2);
        return r2[0] = R(t2, r2[0]), r2[1] = R(e2, r2[1]), r2[2] = R(i2, r2[2]), r2[3] = R(o2, r2[3]), r2[4] = R(u2, r2[4]), r2[5] = R(s2, r2[5]), r2[6] = R(w2, r2[6]), r2[7] = R(a2, r2[7]), r2;
      }
      var I = function(n2) {
        function r2(r3, t2, e2) {
          var o2 = this;
          if ("SHA-224" !== r3 && "SHA-256" !== r3) throw new Error(a);
          var f2 = e2 || {};
          return (o2 = n2.call(this, r3, t2, e2) || this).K = o2.N, o2.k = true, o2.F = -1, o2.m = i(o2.t, o2.i, o2.F), o2.R = N, o2.L = function(n3) {
            return n3.slice();
          }, o2.B = Y, o2.g = function(n3, t3, e3, i2) {
            return function(n4, r4, t4, e4, i3) {
              for (var o3, f3 = 15 + (r4 + 65 >>> 9 << 4), s2 = r4 + t4; n4.length <= f3; ) n4.push(0);
              for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[f3] = 4294967295 & s2, n4[f3 - 1] = s2 / u | 0, o3 = 0; o3 < n4.length; o3 += 16) e4 = N(n4.slice(o3, o3 + 16), e4);
              return "SHA-224" === i3 ? [e4[0], e4[1], e4[2], e4[3], e4[4], e4[5], e4[6]] : e4;
            }(n3, t3, e3, i2, r3);
          }, o2.U = Y(r3), o2.p = 512, o2.T = "SHA-224" === r3 ? 224 : 256, o2.C = false, f2.hmacKey && o2.Y(A("hmacKey", f2.hmacKey, o2.F)), o2;
        }
        return b(r2, n2), r2;
      }(E), M = function(n2, r2) {
        this.I = n2, this.M = r2;
      };
      function X(n2, r2) {
        var t2;
        return r2 > 32 ? (t2 = 64 - r2, new M(n2.M << r2 | n2.I >>> t2, n2.I << r2 | n2.M >>> t2)) : 0 !== r2 ? (t2 = 32 - r2, new M(n2.I << r2 | n2.M >>> t2, n2.M << r2 | n2.I >>> t2)) : n2;
      }
      function z2(n2, r2) {
        var t2;
        return r2 < 32 ? (t2 = 32 - r2, new M(n2.I >>> r2 | n2.M << t2, n2.M >>> r2 | n2.I << t2)) : (t2 = 64 - r2, new M(n2.M >>> r2 | n2.I << t2, n2.I >>> r2 | n2.M << t2));
      }
      function O(n2, r2) {
        return new M(n2.I >>> r2, n2.M >>> r2 | n2.I << 32 - r2);
      }
      function j(n2, r2, t2) {
        return new M(n2.I & r2.I ^ ~n2.I & t2.I, n2.M & r2.M ^ ~n2.M & t2.M);
      }
      function _(n2, r2, t2) {
        return new M(n2.I & r2.I ^ n2.I & t2.I ^ r2.I & t2.I, n2.M & r2.M ^ n2.M & t2.M ^ r2.M & t2.M);
      }
      function x(n2) {
        var r2 = z2(n2, 28), t2 = z2(n2, 34), e2 = z2(n2, 39);
        return new M(r2.I ^ t2.I ^ e2.I, r2.M ^ t2.M ^ e2.M);
      }
      function P(n2, r2) {
        var t2, e2;
        t2 = (65535 & n2.M) + (65535 & r2.M);
        var i2 = (65535 & (e2 = (n2.M >>> 16) + (r2.M >>> 16) + (t2 >>> 16))) << 16 | 65535 & t2;
        return t2 = (65535 & n2.I) + (65535 & r2.I) + (e2 >>> 16), e2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2 >>> 16), new M((65535 & e2) << 16 | 65535 & t2, i2);
      }
      function V(n2, r2, t2, e2) {
        var i2, o2;
        i2 = (65535 & n2.M) + (65535 & r2.M) + (65535 & t2.M) + (65535 & e2.M);
        var u2 = (65535 & (o2 = (n2.M >>> 16) + (r2.M >>> 16) + (t2.M >>> 16) + (e2.M >>> 16) + (i2 >>> 16))) << 16 | 65535 & i2;
        return i2 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I) + (o2 >>> 16), o2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2 >>> 16), new M((65535 & o2) << 16 | 65535 & i2, u2);
      }
      function Z(n2, r2, t2, e2, i2) {
        var o2, u2;
        o2 = (65535 & n2.M) + (65535 & r2.M) + (65535 & t2.M) + (65535 & e2.M) + (65535 & i2.M);
        var f2 = (65535 & (u2 = (n2.M >>> 16) + (r2.M >>> 16) + (t2.M >>> 16) + (e2.M >>> 16) + (i2.M >>> 16) + (o2 >>> 16))) << 16 | 65535 & o2;
        return o2 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I) + (65535 & i2.I) + (u2 >>> 16), u2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2.I >>> 16) + (o2 >>> 16), new M((65535 & u2) << 16 | 65535 & o2, f2);
      }
      function q(n2, r2) {
        return new M(n2.I ^ r2.I, n2.M ^ r2.M);
      }
      function D(n2) {
        var r2 = z2(n2, 1), t2 = z2(n2, 8), e2 = O(n2, 7);
        return new M(r2.I ^ t2.I ^ e2.I, r2.M ^ t2.M ^ e2.M);
      }
      function G(n2) {
        var r2 = z2(n2, 14), t2 = z2(n2, 18), e2 = z2(n2, 41);
        return new M(r2.I ^ t2.I ^ e2.I, r2.M ^ t2.M ^ e2.M);
      }
      var J = [new M(f[0], 3609767458), new M(f[1], 602891725), new M(f[2], 3964484399), new M(f[3], 2173295548), new M(f[4], 4081628472), new M(f[5], 3053834265), new M(f[6], 2937671579), new M(f[7], 3664609560), new M(f[8], 2734883394), new M(f[9], 1164996542), new M(f[10], 1323610764), new M(f[11], 3590304994), new M(f[12], 4068182383), new M(f[13], 991336113), new M(f[14], 633803317), new M(f[15], 3479774868), new M(f[16], 2666613458), new M(f[17], 944711139), new M(f[18], 2341262773), new M(f[19], 2007800933), new M(f[20], 1495990901), new M(f[21], 1856431235), new M(f[22], 3175218132), new M(f[23], 2198950837), new M(f[24], 3999719339), new M(f[25], 766784016), new M(f[26], 2566594879), new M(f[27], 3203337956), new M(f[28], 1034457026), new M(f[29], 2466948901), new M(f[30], 3758326383), new M(f[31], 168717936), new M(f[32], 1188179964), new M(f[33], 1546045734), new M(f[34], 1522805485), new M(f[35], 2643833823), new M(f[36], 2343527390), new M(f[37], 1014477480), new M(f[38], 1206759142), new M(f[39], 344077627), new M(f[40], 1290863460), new M(f[41], 3158454273), new M(f[42], 3505952657), new M(f[43], 106217008), new M(f[44], 3606008344), new M(f[45], 1432725776), new M(f[46], 1467031594), new M(f[47], 851169720), new M(f[48], 3100823752), new M(f[49], 1363258195), new M(f[50], 3750685593), new M(f[51], 3785050280), new M(f[52], 3318307427), new M(f[53], 3812723403), new M(f[54], 2003034995), new M(f[55], 3602036899), new M(f[56], 1575990012), new M(f[57], 1125592928), new M(f[58], 2716904306), new M(f[59], 442776044), new M(f[60], 593698344), new M(f[61], 3733110249), new M(f[62], 2999351573), new M(f[63], 3815920427), new M(3391569614, 3928383900), new M(3515267271, 566280711), new M(3940187606, 3454069534), new M(4118630271, 4000239992), new M(116418474, 1914138554), new M(174292421, 2731055270), new M(289380356, 3203993006), new M(460393269, 320620315), new M(685471733, 587496836), new M(852142971, 1086792851), new M(1017036298, 365543100), new M(1126000580, 2618297676), new M(1288033470, 3409855158), new M(1501505948, 4234509866), new M(1607167915, 987167468), new M(1816402316, 1246189591)];
      function Q(n2) {
        return "SHA-384" === n2 ? [new M(3418070365, s[0]), new M(1654270250, s[1]), new M(2438529370, s[2]), new M(355462360, s[3]), new M(1731405415, s[4]), new M(41048885895, s[5]), new M(3675008525, s[6]), new M(1203062813, s[7])] : [new M(w[0], 4089235720), new M(w[1], 2227873595), new M(w[2], 4271175723), new M(w[3], 1595750129), new M(w[4], 2917565137), new M(w[5], 725511199), new M(w[6], 4215389547), new M(w[7], 327033209)];
      }
      function W(n2, r2) {
        var t2, e2, i2, o2, u2, f2, s2, w2, a2, h2, c2, v2, A2, E2, l2, b2, S2 = [];
        for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o2 = r2[3], u2 = r2[4], f2 = r2[5], s2 = r2[6], w2 = r2[7], c2 = 0; c2 < 80; c2 += 1) c2 < 16 ? (v2 = 2 * c2, S2[c2] = new M(n2[v2], n2[v2 + 1])) : S2[c2] = V((A2 = S2[c2 - 2], E2 = void 0, l2 = void 0, b2 = void 0, E2 = z2(A2, 19), l2 = z2(A2, 61), b2 = O(A2, 6), new M(E2.I ^ l2.I ^ b2.I, E2.M ^ l2.M ^ b2.M)), S2[c2 - 7], D(S2[c2 - 15]), S2[c2 - 16]), a2 = Z(w2, G(u2), j(u2, f2, s2), J[c2], S2[c2]), h2 = P(x(t2), _(t2, e2, i2)), w2 = s2, s2 = f2, f2 = u2, u2 = P(o2, a2), o2 = i2, i2 = e2, e2 = t2, t2 = P(a2, h2);
        return r2[0] = P(t2, r2[0]), r2[1] = P(e2, r2[1]), r2[2] = P(i2, r2[2]), r2[3] = P(o2, r2[3]), r2[4] = P(u2, r2[4]), r2[5] = P(f2, r2[5]), r2[6] = P(s2, r2[6]), r2[7] = P(w2, r2[7]), r2;
      }
      var $ = function(n2) {
        function r2(r3, t2, e2) {
          var o2 = this;
          if ("SHA-384" !== r3 && "SHA-512" !== r3) throw new Error(a);
          var f2 = e2 || {};
          return (o2 = n2.call(this, r3, t2, e2) || this).K = o2.N, o2.k = true, o2.F = -1, o2.m = i(o2.t, o2.i, o2.F), o2.R = W, o2.L = function(n3) {
            return n3.slice();
          }, o2.B = Q, o2.g = function(n3, t3, e3, i2) {
            return function(n4, r4, t4, e4, i3) {
              for (var o3, f3 = 31 + (r4 + 129 >>> 10 << 5), s2 = r4 + t4; n4.length <= f3; ) n4.push(0);
              for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[f3] = 4294967295 & s2, n4[f3 - 1] = s2 / u | 0, o3 = 0; o3 < n4.length; o3 += 32) e4 = W(n4.slice(o3, o3 + 32), e4);
              return "SHA-384" === i3 ? [e4[0].I, e4[0].M, e4[1].I, e4[1].M, e4[2].I, e4[2].M, e4[3].I, e4[3].M, e4[4].I, e4[4].M, e4[5].I, e4[5].M] : [e4[0].I, e4[0].M, e4[1].I, e4[1].M, e4[2].I, e4[2].M, e4[3].I, e4[3].M, e4[4].I, e4[4].M, e4[5].I, e4[5].M, e4[6].I, e4[6].M, e4[7].I, e4[7].M];
            }(n3, t3, e3, i2, r3);
          }, o2.U = Q(r3), o2.p = 1024, o2.T = "SHA-384" === r3 ? 384 : 512, o2.C = false, f2.hmacKey && o2.Y(A("hmacKey", f2.hmacKey, o2.F)), o2;
        }
        return b(r2, n2), r2;
      }(E), nn = [new M(0, 1), new M(0, 32898), new M(2147483648, 32906), new M(2147483648, 2147516416), new M(0, 32907), new M(0, 2147483649), new M(2147483648, 2147516545), new M(2147483648, 32777), new M(0, 138), new M(0, 136), new M(0, 2147516425), new M(0, 2147483658), new M(0, 2147516555), new M(2147483648, 139), new M(2147483648, 32905), new M(2147483648, 32771), new M(2147483648, 32770), new M(2147483648, 128), new M(0, 32778), new M(2147483648, 2147483658), new M(2147483648, 2147516545), new M(2147483648, 32896), new M(0, 2147483649), new M(2147483648, 2147516424)], rn = [[0, 36, 3, 41, 18], [1, 44, 10, 45, 2], [62, 6, 43, 15, 61], [28, 55, 25, 21, 56], [27, 20, 39, 8, 14]];
      function tn(n2) {
        var r2, t2 = [];
        for (r2 = 0; r2 < 5; r2 += 1) t2[r2] = [new M(0, 0), new M(0, 0), new M(0, 0), new M(0, 0), new M(0, 0)];
        return t2;
      }
      function en(n2) {
        var r2, t2 = [];
        for (r2 = 0; r2 < 5; r2 += 1) t2[r2] = n2[r2].slice();
        return t2;
      }
      function on(n2, r2) {
        var t2, e2, i2, o2, u2, f2, s2, w2, a2, h2 = [], c2 = [];
        if (null !== n2) for (e2 = 0; e2 < n2.length; e2 += 2) r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0] = q(r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0], new M(n2[e2 + 1], n2[e2]));
        for (t2 = 0; t2 < 24; t2 += 1) {
          for (o2 = tn(), e2 = 0; e2 < 5; e2 += 1) h2[e2] = (u2 = r2[e2][0], f2 = r2[e2][1], s2 = r2[e2][2], w2 = r2[e2][3], a2 = r2[e2][4], new M(u2.I ^ f2.I ^ s2.I ^ w2.I ^ a2.I, u2.M ^ f2.M ^ s2.M ^ w2.M ^ a2.M));
          for (e2 = 0; e2 < 5; e2 += 1) c2[e2] = q(h2[(e2 + 4) % 5], X(h2[(e2 + 1) % 5], 1));
          for (e2 = 0; e2 < 5; e2 += 1) for (i2 = 0; i2 < 5; i2 += 1) r2[e2][i2] = q(r2[e2][i2], c2[e2]);
          for (e2 = 0; e2 < 5; e2 += 1) for (i2 = 0; i2 < 5; i2 += 1) o2[i2][(2 * e2 + 3 * i2) % 5] = X(r2[e2][i2], rn[e2][i2]);
          for (e2 = 0; e2 < 5; e2 += 1) for (i2 = 0; i2 < 5; i2 += 1) r2[e2][i2] = q(o2[e2][i2], new M(~o2[(e2 + 1) % 5][i2].I & o2[(e2 + 2) % 5][i2].I, ~o2[(e2 + 1) % 5][i2].M & o2[(e2 + 2) % 5][i2].M));
          r2[0][0] = q(r2[0][0], nn[t2]);
        }
        return r2;
      }
      function un(n2) {
        var r2, t2, e2 = 0, i2 = [0, 0], o2 = [4294967295 & n2, n2 / u & 2097151];
        for (r2 = 6; r2 >= 0; r2--) 0 === (t2 = o2[r2 >> 2] >>> 8 * r2 & 255) && 0 === e2 || (i2[e2 + 1 >> 2] |= t2 << 8 * (e2 + 1), e2 += 1);
        return e2 = 0 !== e2 ? e2 : 1, i2[0] |= e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
      }
      function fn(n2) {
        return c(un(n2.binLen), n2);
      }
      function sn(n2, r2) {
        var t2, e2 = un(r2), i2 = r2 >>> 2, o2 = (i2 - (e2 = c(e2, n2)).value.length % i2) % i2;
        for (t2 = 0; t2 < o2; t2++) e2.value.push(0);
        return e2.value;
      }
      var wn = function(n2) {
        function r2(r3, t2, e2) {
          var o2 = this, u2 = 6, f2 = 0, s2 = e2 || {};
          if (1 !== (o2 = n2.call(this, r3, t2, e2) || this).numRounds) {
            if (s2.kmacKey || s2.hmacKey) throw new Error(h);
            if ("CSHAKE128" === o2.o || "CSHAKE256" === o2.o) throw new Error("Cannot set numRounds for CSHAKE variants");
          }
          switch (o2.F = 1, o2.m = i(o2.t, o2.i, o2.F), o2.R = on, o2.L = en, o2.B = tn, o2.U = tn(), o2.C = false, r3) {
            case "SHA3-224":
              o2.p = f2 = 1152, o2.T = 224, o2.k = true, o2.K = o2.N;
              break;
            case "SHA3-256":
              o2.p = f2 = 1088, o2.T = 256, o2.k = true, o2.K = o2.N;
              break;
            case "SHA3-384":
              o2.p = f2 = 832, o2.T = 384, o2.k = true, o2.K = o2.N;
              break;
            case "SHA3-512":
              o2.p = f2 = 576, o2.T = 512, o2.k = true, o2.K = o2.N;
              break;
            case "SHAKE128":
              u2 = 31, o2.p = f2 = 1344, o2.T = -1, o2.C = true, o2.k = false, o2.K = null;
              break;
            case "SHAKE256":
              u2 = 31, o2.p = f2 = 1088, o2.T = -1, o2.C = true, o2.k = false, o2.K = null;
              break;
            case "KMAC128":
              u2 = 4, o2.p = f2 = 1344, o2.X(e2), o2.T = -1, o2.C = true, o2.k = false, o2.K = o2.O;
              break;
            case "KMAC256":
              u2 = 4, o2.p = f2 = 1088, o2.X(e2), o2.T = -1, o2.C = true, o2.k = false, o2.K = o2.O;
              break;
            case "CSHAKE128":
              o2.p = f2 = 1344, u2 = o2.j(e2), o2.T = -1, o2.C = true, o2.k = false, o2.K = null;
              break;
            case "CSHAKE256":
              o2.p = f2 = 1088, u2 = o2.j(e2), o2.T = -1, o2.C = true, o2.k = false, o2.K = null;
              break;
            default:
              throw new Error(a);
          }
          return o2.g = function(n3, r4, t3, e3, i2) {
            return function(n4, r5, t4, e4, i3, o3, u3) {
              var f3, s3, w2 = 0, a2 = [], h2 = i3 >>> 5, c2 = r5 >>> 5;
              for (f3 = 0; f3 < c2 && r5 >= i3; f3 += h2) e4 = on(n4.slice(f3, f3 + h2), e4), r5 -= i3;
              for (n4 = n4.slice(f3), r5 %= i3; n4.length < h2; ) n4.push(0);
              for (n4[(f3 = r5 >>> 3) >> 2] ^= o3 << f3 % 4 * 8, n4[h2 - 1] ^= 2147483648, e4 = on(n4, e4); 32 * a2.length < u3 && (s3 = e4[w2 % 5][w2 / 5 | 0], a2.push(s3.M), !(32 * a2.length >= u3)); ) a2.push(s3.I), 0 == 64 * (w2 += 1) % i3 && (on(null, e4), w2 = 0);
              return a2;
            }(n3, r4, 0, e3, f2, u2, i2);
          }, s2.hmacKey && o2.Y(A("hmacKey", s2.hmacKey, o2.F)), o2;
        }
        return b(r2, n2), r2.prototype.j = function(n3, r3) {
          var t2 = function(n4) {
            var r4 = n4 || {};
            return { funcName: A("funcName", r4.funcName, 1, { value: [], binLen: 0 }), customization: A("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
          }(n3 || {});
          r3 && (t2.funcName = r3);
          var e2 = c(fn(t2.funcName), fn(t2.customization));
          if (0 !== t2.customization.binLen || 0 !== t2.funcName.binLen) {
            for (var i2 = sn(e2, this.p >>> 3), o2 = 0; o2 < i2.length; o2 += this.p >>> 5) this.U = this.R(i2.slice(o2, o2 + (this.p >>> 5)), this.U), this.A += this.p;
            return 4;
          }
          return 31;
        }, r2.prototype.X = function(n3) {
          var r3 = function(n4) {
            var r4 = n4 || {};
            return { kmacKey: A("kmacKey", r4.kmacKey, 1), funcName: { value: [1128353099], binLen: 32 }, customization: A("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
          }(n3 || {});
          this.j(n3, r3.funcName);
          for (var t2 = sn(fn(r3.kmacKey), this.p >>> 3), e2 = 0; e2 < t2.length; e2 += this.p >>> 5) this.U = this.R(t2.slice(e2, e2 + (this.p >>> 5)), this.U), this.A += this.p;
          this.l = true;
        }, r2.prototype.O = function(n3) {
          var r3 = c({ value: this.u.slice(), binLen: this.h }, function(n4) {
            var r4, t2, e2 = 0, i2 = [0, 0], o2 = [4294967295 & n4, n4 / u & 2097151];
            for (r4 = 6; r4 >= 0; r4--) 0 == (t2 = o2[r4 >> 2] >>> 8 * r4 & 255) && 0 === e2 || (i2[e2 >> 2] |= t2 << 8 * e2, e2 += 1);
            return i2[(e2 = 0 !== e2 ? e2 : 1) >> 2] |= e2 << 8 * e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
          }(n3.outputLen));
          return this.g(r3.value, r3.binLen, this.A, this.L(this.U), n3.outputLen);
        }, r2;
      }(E);
      return function() {
        function n2(n3, r2, t2) {
          if ("SHA-1" == n3) this._ = new k(n3, r2, t2);
          else if ("SHA-224" == n3 || "SHA-256" == n3) this._ = new I(n3, r2, t2);
          else if ("SHA-384" == n3 || "SHA-512" == n3) this._ = new $(n3, r2, t2);
          else {
            if ("SHA3-224" != n3 && "SHA3-256" != n3 && "SHA3-384" != n3 && "SHA3-512" != n3 && "SHAKE128" != n3 && "SHAKE256" != n3 && "CSHAKE128" != n3 && "CSHAKE256" != n3 && "KMAC128" != n3 && "KMAC256" != n3) throw new Error(a);
            this._ = new wn(n3, r2, t2);
          }
        }
        return n2.prototype.update = function(n3) {
          return this._.update(n3), this;
        }, n2.prototype.getHash = function(n3, r2) {
          return this._.getHash(n3, r2);
        }, n2.prototype.setHMACKey = function(n3, r2, t2) {
          this._.setHMACKey(n3, r2, t2);
        }, n2.prototype.getHMAC = function(n3, r2) {
          return this._.getHMAC(n3, r2);
        }, n2;
      }();
    });
  })(sha$1);
  return sha$1.exports;
}
var hasRequiredCrypto;
function requireCrypto() {
  if (hasRequiredCrypto) return crypto$1;
  hasRequiredCrypto = 1;
  var __importDefault = crypto$1 && crypto$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(crypto$1, "__esModule", { value: true });
  crypto$1.sha256BytesToBytes = crypto$1.sha224BytesToString = crypto$1.sha224StringToString = crypto$1.sha384StringToBytes = crypto$1.sha384BytesToBytes = crypto$1.sha384BytesToString = crypto$1.sha384StringToString = void 0;
  const jssha_1 = __importDefault(requireSha());
  function sha384StringToString(message2) {
    const shaObj = new jssha_1.default("SHA-384", "TEXT");
    shaObj.update(message2);
    return shaObj.getHash("HEX");
  }
  crypto$1.sha384StringToString = sha384StringToString;
  function sha384BytesToString(message2) {
    const shaObj = new jssha_1.default("SHA-384", "UINT8ARRAY");
    shaObj.update(message2);
    return shaObj.getHash("HEX");
  }
  crypto$1.sha384BytesToString = sha384BytesToString;
  function sha384BytesToBytes(message2) {
    const shaObj = new jssha_1.default("SHA-384", "UINT8ARRAY");
    shaObj.update(message2);
    return shaObj.getHash("UINT8ARRAY");
  }
  crypto$1.sha384BytesToBytes = sha384BytesToBytes;
  function sha384StringToBytes(message2) {
    const shaObj = new jssha_1.default("SHA-384", "TEXT");
    shaObj.update(message2);
    return shaObj.getHash("UINT8ARRAY");
  }
  crypto$1.sha384StringToBytes = sha384StringToBytes;
  function sha224StringToString(message2) {
    const shaObj = new jssha_1.default("SHA-224", "TEXT");
    shaObj.update(message2);
    return shaObj.getHash("HEX");
  }
  crypto$1.sha224StringToString = sha224StringToString;
  function sha224BytesToString(message2) {
    const shaObj = new jssha_1.default("SHA-224", "UINT8ARRAY");
    shaObj.update(message2);
    return shaObj.getHash("HEX");
  }
  crypto$1.sha224BytesToString = sha224BytesToString;
  function sha256BytesToBytes(message2) {
    const shaObj = new jssha_1.default("SHA-256", "UINT8ARRAY");
    shaObj.update(message2);
    return shaObj.getHash("UINT8ARRAY");
  }
  crypto$1.sha256BytesToBytes = sha256BytesToBytes;
  return crypto$1;
}
var kwilEncoding = {};
var bytes = {};
var hasRequiredBytes;
function requireBytes() {
  if (hasRequiredBytes) return bytes;
  hasRequiredBytes = 1;
  var __importDefault = bytes && bytes.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(bytes, "__esModule", { value: true });
  bytes.prefixBytesLength = bytes.numberToUint32BigEndian = bytes.numberToUint16LittleEndian = bytes.concatBytes = bytes.numberToUint64LittleEndian = bytes.uint16BigEndianToNumber = bytes.numberToUint16BigEndian = void 0;
  const long_1 = __importDefault(requireUmd());
  function numberToUint16BigEndian(num) {
    if (num < 0 || num > 65535 || !Number.isInteger(num)) {
      throw new Error("Number is out of range for uint16");
    }
    const buffer = new ArrayBuffer(2);
    const view = new DataView(buffer);
    view.setUint16(0, num, false);
    return new Uint8Array(buffer);
  }
  bytes.numberToUint16BigEndian = numberToUint16BigEndian;
  function uint16BigEndianToNumber(uint16) {
    if (uint16.length !== 2) {
      throw new Error("uint16 must be 2 bytes");
    }
    const view = new DataView(uint16.buffer);
    return view.getUint16(0, false);
  }
  bytes.uint16BigEndianToNumber = uint16BigEndianToNumber;
  function numberToUint64LittleEndian(num) {
    const longNum = long_1.default.fromNumber(num, true);
    const buffer = new ArrayBuffer(8);
    const view = new DataView(buffer);
    view.setUint32(0, longNum.low, true);
    view.setUint32(4, longNum.high, true);
    return new Uint8Array(buffer);
  }
  bytes.numberToUint64LittleEndian = numberToUint64LittleEndian;
  function concatBytes(...arrays) {
    let totalLength = 0;
    for (const arr of arrays) {
      totalLength += arr.length;
    }
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const arr of arrays) {
      result.set(arr, offset);
      offset += arr.length;
    }
    return result;
  }
  bytes.concatBytes = concatBytes;
  function numberToUint16LittleEndian(number) {
    if (number < 0 || number > 65535 || !Number.isInteger(number)) {
      throw new RangeError("The number must be an integer between 0 and 65535.");
    }
    const buffer = new ArrayBuffer(2);
    const view = new DataView(buffer);
    view.setUint16(0, number, true);
    return new Uint8Array(buffer);
  }
  bytes.numberToUint16LittleEndian = numberToUint16LittleEndian;
  function numberToUint32LittleEndian(number) {
    if (number < 0 || number > 4294967295 || !Number.isInteger(number)) {
      throw new RangeError("The number must be an integer between 0 and 4294967295.");
    }
    const buffer = new ArrayBuffer(4);
    const view = new DataView(buffer);
    view.setUint32(0, number, true);
    return new Uint8Array(buffer);
  }
  function numberToUint32BigEndian(number) {
    if (number < 0 || number > 4294967295 || !Number.isInteger(number)) {
      throw new RangeError("The number must be an integer between 0 and 4294967295.");
    }
    const buffer = new ArrayBuffer(4);
    const view = new DataView(buffer);
    view.setUint32(0, number, false);
    return new Uint8Array(buffer);
  }
  bytes.numberToUint32BigEndian = numberToUint32BigEndian;
  function prefixBytesLength(bytes2) {
    const lengthBytes = numberToUint32LittleEndian(bytes2.length);
    return concatBytes(lengthBytes, bytes2);
  }
  bytes.prefixBytesLength = prefixBytesLength;
  return bytes;
}
var uuid = {};
var cjs = {};
var max = {};
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max;
  hasRequiredMax = 1;
  Object.defineProperty(max, "__esModule", { value: true });
  max.default = "ffffffff-ffff-ffff-ffff-ffffffffffff";
  return max;
}
var nil = {};
var hasRequiredNil;
function requireNil() {
  if (hasRequiredNil) return nil;
  hasRequiredNil = 1;
  Object.defineProperty(nil, "__esModule", { value: true });
  nil.default = "00000000-0000-0000-0000-000000000000";
  return nil;
}
var parse = {};
var validate = {};
var regex = {};
var hasRequiredRegex;
function requireRegex() {
  if (hasRequiredRegex) return regex;
  hasRequiredRegex = 1;
  Object.defineProperty(regex, "__esModule", { value: true });
  regex.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
  return regex;
}
var hasRequiredValidate;
function requireValidate() {
  if (hasRequiredValidate) return validate;
  hasRequiredValidate = 1;
  Object.defineProperty(validate, "__esModule", { value: true });
  const regex_js_1 = requireRegex();
  function validate$1(uuid2) {
    return typeof uuid2 === "string" && regex_js_1.default.test(uuid2);
  }
  validate.default = validate$1;
  return validate;
}
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse;
  hasRequiredParse = 1;
  Object.defineProperty(parse, "__esModule", { value: true });
  const validate_js_1 = requireValidate();
  function parse$1(uuid2) {
    if (!(0, validate_js_1.default)(uuid2)) {
      throw TypeError("Invalid UUID");
    }
    let v;
    return Uint8Array.of((v = parseInt(uuid2.slice(0, 8), 16)) >>> 24, v >>> 16 & 255, v >>> 8 & 255, v & 255, (v = parseInt(uuid2.slice(9, 13), 16)) >>> 8, v & 255, (v = parseInt(uuid2.slice(14, 18), 16)) >>> 8, v & 255, (v = parseInt(uuid2.slice(19, 23), 16)) >>> 8, v & 255, (v = parseInt(uuid2.slice(24, 36), 16)) / 1099511627776 & 255, v / 4294967296 & 255, v >>> 24 & 255, v >>> 16 & 255, v >>> 8 & 255, v & 255);
  }
  parse.default = parse$1;
  return parse;
}
var stringify = {};
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify;
  hasRequiredStringify = 1;
  Object.defineProperty(stringify, "__esModule", { value: true });
  stringify.unsafeStringify = void 0;
  const validate_js_1 = requireValidate();
  const byteToHex = [];
  for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  }
  stringify.unsafeStringify = unsafeStringify;
  function stringify$1(arr, offset = 0) {
    const uuid2 = unsafeStringify(arr, offset);
    if (!(0, validate_js_1.default)(uuid2)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid2;
  }
  stringify.default = stringify$1;
  return stringify;
}
var v1 = {};
var rng = {};
var hasRequiredRng;
function requireRng() {
  if (hasRequiredRng) return rng;
  hasRequiredRng = 1;
  Object.defineProperty(rng, "__esModule", { value: true });
  const crypto_1 = require$$0$3;
  const rnds8Pool = new Uint8Array(256);
  let poolPtr = rnds8Pool.length;
  function rng$1() {
    if (poolPtr > rnds8Pool.length - 16) {
      (0, crypto_1.randomFillSync)(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  }
  rng.default = rng$1;
  return rng;
}
var hasRequiredV1;
function requireV1() {
  if (hasRequiredV1) return v1;
  hasRequiredV1 = 1;
  Object.defineProperty(v1, "__esModule", { value: true });
  v1.updateV1State = void 0;
  const rng_js_1 = requireRng();
  const stringify_js_1 = requireStringify();
  const _state = {};
  function v1$1(options, buf, offset) {
    let bytes2;
    const isV6 = options?._v6 ?? false;
    if (options) {
      const optionsKeys = Object.keys(options);
      if (optionsKeys.length === 1 && optionsKeys[0] === "_v6") {
        options = void 0;
      }
    }
    if (options) {
      bytes2 = v1Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.nsecs, options.clockseq, options.node, buf, offset);
    } else {
      const now = Date.now();
      const rnds = (0, rng_js_1.default)();
      updateV1State(_state, now, rnds);
      bytes2 = v1Bytes(rnds, _state.msecs, _state.nsecs, isV6 ? void 0 : _state.clockseq, isV6 ? void 0 : _state.node, buf, offset);
    }
    return buf ?? (0, stringify_js_1.unsafeStringify)(bytes2);
  }
  function updateV1State(state, now, rnds) {
    state.msecs ??= -Infinity;
    state.nsecs ??= 0;
    if (now === state.msecs) {
      state.nsecs++;
      if (state.nsecs >= 1e4) {
        state.node = void 0;
        state.nsecs = 0;
      }
    } else if (now > state.msecs) {
      state.nsecs = 0;
    } else if (now < state.msecs) {
      state.node = void 0;
    }
    if (!state.node) {
      state.node = rnds.slice(10, 16);
      state.node[0] |= 1;
      state.clockseq = (rnds[8] << 8 | rnds[9]) & 16383;
    }
    state.msecs = now;
    return state;
  }
  v1.updateV1State = updateV1State;
  function v1Bytes(rnds, msecs, nsecs, clockseq, node2, buf, offset = 0) {
    if (rnds.length < 16) {
      throw new Error("Random bytes length must be >= 16");
    }
    if (!buf) {
      buf = new Uint8Array(16);
      offset = 0;
    } else {
      if (offset < 0 || offset + 16 > buf.length) {
        throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
      }
    }
    msecs ??= Date.now();
    nsecs ??= 0;
    clockseq ??= (rnds[8] << 8 | rnds[9]) & 16383;
    node2 ??= rnds.slice(10, 16);
    msecs += 122192928e5;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    buf[offset++] = tl >>> 24 & 255;
    buf[offset++] = tl >>> 16 & 255;
    buf[offset++] = tl >>> 8 & 255;
    buf[offset++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    buf[offset++] = tmh >>> 8 & 255;
    buf[offset++] = tmh & 255;
    buf[offset++] = tmh >>> 24 & 15 | 16;
    buf[offset++] = tmh >>> 16 & 255;
    buf[offset++] = clockseq >>> 8 | 128;
    buf[offset++] = clockseq & 255;
    for (let n = 0; n < 6; ++n) {
      buf[offset++] = node2[n];
    }
    return buf;
  }
  v1.default = v1$1;
  return v1;
}
var v1ToV6 = {};
var hasRequiredV1ToV6;
function requireV1ToV6() {
  if (hasRequiredV1ToV6) return v1ToV6;
  hasRequiredV1ToV6 = 1;
  Object.defineProperty(v1ToV6, "__esModule", { value: true });
  const parse_js_1 = requireParse();
  const stringify_js_1 = requireStringify();
  function v1ToV6$1(uuid2) {
    const v1Bytes = typeof uuid2 === "string" ? (0, parse_js_1.default)(uuid2) : uuid2;
    const v6Bytes = _v1ToV6(v1Bytes);
    return typeof uuid2 === "string" ? (0, stringify_js_1.unsafeStringify)(v6Bytes) : v6Bytes;
  }
  v1ToV6.default = v1ToV6$1;
  function _v1ToV6(v1Bytes) {
    return Uint8Array.of((v1Bytes[6] & 15) << 4 | v1Bytes[7] >> 4 & 15, (v1Bytes[7] & 15) << 4 | (v1Bytes[4] & 240) >> 4, (v1Bytes[4] & 15) << 4 | (v1Bytes[5] & 240) >> 4, (v1Bytes[5] & 15) << 4 | (v1Bytes[0] & 240) >> 4, (v1Bytes[0] & 15) << 4 | (v1Bytes[1] & 240) >> 4, (v1Bytes[1] & 15) << 4 | (v1Bytes[2] & 240) >> 4, 96 | v1Bytes[2] & 15, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
  }
  return v1ToV6;
}
var v3 = {};
var md5 = {};
var hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5;
  hasRequiredMd5 = 1;
  Object.defineProperty(md5, "__esModule", { value: true });
  const crypto_1 = require$$0$3;
  function md5$1(bytes2) {
    if (Array.isArray(bytes2)) {
      bytes2 = Buffer.from(bytes2);
    } else if (typeof bytes2 === "string") {
      bytes2 = Buffer.from(bytes2, "utf8");
    }
    return (0, crypto_1.createHash)("md5").update(bytes2).digest();
  }
  md5.default = md5$1;
  return md5;
}
var v35 = {};
var hasRequiredV35;
function requireV35() {
  if (hasRequiredV35) return v35;
  hasRequiredV35 = 1;
  Object.defineProperty(v35, "__esModule", { value: true });
  v35.URL = v35.DNS = v35.stringToBytes = void 0;
  const parse_js_1 = requireParse();
  const stringify_js_1 = requireStringify();
  function stringToBytes(str) {
    str = unescape(encodeURIComponent(str));
    const bytes2 = new Uint8Array(str.length);
    for (let i = 0; i < str.length; ++i) {
      bytes2[i] = str.charCodeAt(i);
    }
    return bytes2;
  }
  v35.stringToBytes = stringToBytes;
  v35.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  v35.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  function v35$1(version2, hash2, value, namespace2, buf, offset) {
    const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
    const namespaceBytes = typeof namespace2 === "string" ? (0, parse_js_1.default)(namespace2) : namespace2;
    if (typeof namespace2 === "string") {
      namespace2 = (0, parse_js_1.default)(namespace2);
    }
    if (namespace2?.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes2 = new Uint8Array(16 + valueBytes.length);
    bytes2.set(namespaceBytes);
    bytes2.set(valueBytes, namespaceBytes.length);
    bytes2 = hash2(bytes2);
    bytes2[6] = bytes2[6] & 15 | version2;
    bytes2[8] = bytes2[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes2[i];
      }
      return buf;
    }
    return (0, stringify_js_1.unsafeStringify)(bytes2);
  }
  v35.default = v35$1;
  return v35;
}
var hasRequiredV3;
function requireV3() {
  if (hasRequiredV3) return v3;
  hasRequiredV3 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.URL = exports.DNS = void 0;
    const md5_js_1 = requireMd5();
    const v35_js_1 = requireV35();
    var v35_js_2 = requireV35();
    Object.defineProperty(exports, "DNS", { enumerable: true, get: function() {
      return v35_js_2.DNS;
    } });
    Object.defineProperty(exports, "URL", { enumerable: true, get: function() {
      return v35_js_2.URL;
    } });
    function v32(value, namespace2, buf, offset) {
      return (0, v35_js_1.default)(48, md5_js_1.default, value, namespace2, buf, offset);
    }
    v32.DNS = v35_js_1.DNS;
    v32.URL = v35_js_1.URL;
    exports.default = v32;
  })(v3);
  return v3;
}
var v4 = {};
var native = {};
var hasRequiredNative;
function requireNative() {
  if (hasRequiredNative) return native;
  hasRequiredNative = 1;
  Object.defineProperty(native, "__esModule", { value: true });
  const crypto_1 = require$$0$3;
  native.default = { randomUUID: crypto_1.randomUUID };
  return native;
}
var hasRequiredV4;
function requireV4() {
  if (hasRequiredV4) return v4;
  hasRequiredV4 = 1;
  Object.defineProperty(v4, "__esModule", { value: true });
  const native_js_1 = requireNative();
  const rng_js_1 = requireRng();
  const stringify_js_1 = requireStringify();
  function v4$1(options, buf, offset) {
    if (native_js_1.default.randomUUID && !buf && !options) {
      return native_js_1.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random ?? options.rng?.() ?? (0, rng_js_1.default)();
    if (rnds.length < 16) {
      throw new Error("Random bytes length must be >= 16");
    }
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      if (offset < 0 || offset + 16 > buf.length) {
        throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
      }
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return (0, stringify_js_1.unsafeStringify)(rnds);
  }
  v4.default = v4$1;
  return v4;
}
var v5 = {};
var sha1 = {};
var hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1;
  hasRequiredSha1 = 1;
  Object.defineProperty(sha1, "__esModule", { value: true });
  const crypto_1 = require$$0$3;
  function sha1$1(bytes2) {
    if (Array.isArray(bytes2)) {
      bytes2 = Buffer.from(bytes2);
    } else if (typeof bytes2 === "string") {
      bytes2 = Buffer.from(bytes2, "utf8");
    }
    return (0, crypto_1.createHash)("sha1").update(bytes2).digest();
  }
  sha1.default = sha1$1;
  return sha1;
}
var hasRequiredV5;
function requireV5() {
  if (hasRequiredV5) return v5;
  hasRequiredV5 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.URL = exports.DNS = void 0;
    const sha1_js_1 = requireSha1();
    const v35_js_1 = requireV35();
    var v35_js_2 = requireV35();
    Object.defineProperty(exports, "DNS", { enumerable: true, get: function() {
      return v35_js_2.DNS;
    } });
    Object.defineProperty(exports, "URL", { enumerable: true, get: function() {
      return v35_js_2.URL;
    } });
    function v52(value, namespace2, buf, offset) {
      return (0, v35_js_1.default)(80, sha1_js_1.default, value, namespace2, buf, offset);
    }
    v52.DNS = v35_js_1.DNS;
    v52.URL = v35_js_1.URL;
    exports.default = v52;
  })(v5);
  return v5;
}
var v6 = {};
var hasRequiredV6;
function requireV6() {
  if (hasRequiredV6) return v6;
  hasRequiredV6 = 1;
  Object.defineProperty(v6, "__esModule", { value: true });
  const stringify_js_1 = requireStringify();
  const v1_js_1 = requireV1();
  const v1ToV6_js_1 = requireV1ToV6();
  function v6$1(options, buf, offset) {
    options ??= {};
    offset ??= 0;
    let bytes2 = (0, v1_js_1.default)({ ...options, _v6: true }, new Uint8Array(16));
    bytes2 = (0, v1ToV6_js_1.default)(bytes2);
    if (buf) {
      for (let i = 0; i < 16; i++) {
        buf[offset + i] = bytes2[i];
      }
      return buf;
    }
    return (0, stringify_js_1.unsafeStringify)(bytes2);
  }
  v6.default = v6$1;
  return v6;
}
var v6ToV1 = {};
var hasRequiredV6ToV1;
function requireV6ToV1() {
  if (hasRequiredV6ToV1) return v6ToV1;
  hasRequiredV6ToV1 = 1;
  Object.defineProperty(v6ToV1, "__esModule", { value: true });
  const parse_js_1 = requireParse();
  const stringify_js_1 = requireStringify();
  function v6ToV1$1(uuid2) {
    const v6Bytes = typeof uuid2 === "string" ? (0, parse_js_1.default)(uuid2) : uuid2;
    const v1Bytes = _v6ToV1(v6Bytes);
    return typeof uuid2 === "string" ? (0, stringify_js_1.unsafeStringify)(v1Bytes) : v1Bytes;
  }
  v6ToV1.default = v6ToV1$1;
  function _v6ToV1(v6Bytes) {
    return Uint8Array.of((v6Bytes[3] & 15) << 4 | v6Bytes[4] >> 4 & 15, (v6Bytes[4] & 15) << 4 | (v6Bytes[5] & 240) >> 4, (v6Bytes[5] & 15) << 4 | v6Bytes[6] & 15, v6Bytes[7], (v6Bytes[1] & 15) << 4 | (v6Bytes[2] & 240) >> 4, (v6Bytes[2] & 15) << 4 | (v6Bytes[3] & 240) >> 4, 16 | (v6Bytes[0] & 240) >> 4, (v6Bytes[0] & 15) << 4 | (v6Bytes[1] & 240) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
  }
  return v6ToV1;
}
var v7 = {};
var hasRequiredV7;
function requireV7() {
  if (hasRequiredV7) return v7;
  hasRequiredV7 = 1;
  Object.defineProperty(v7, "__esModule", { value: true });
  v7.updateV7State = void 0;
  const rng_js_1 = requireRng();
  const stringify_js_1 = requireStringify();
  const _state = {};
  function v7$1(options, buf, offset) {
    let bytes2;
    if (options) {
      bytes2 = v7Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.seq, buf, offset);
    } else {
      const now = Date.now();
      const rnds = (0, rng_js_1.default)();
      updateV7State(_state, now, rnds);
      bytes2 = v7Bytes(rnds, _state.msecs, _state.seq, buf, offset);
    }
    return buf ?? (0, stringify_js_1.unsafeStringify)(bytes2);
  }
  function updateV7State(state, now, rnds) {
    state.msecs ??= -Infinity;
    state.seq ??= 0;
    if (now > state.msecs) {
      state.seq = rnds[6] << 23 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
      state.msecs = now;
    } else {
      state.seq = state.seq + 1 | 0;
      if (state.seq === 0) {
        state.msecs++;
      }
    }
    return state;
  }
  v7.updateV7State = updateV7State;
  function v7Bytes(rnds, msecs, seq, buf, offset = 0) {
    if (rnds.length < 16) {
      throw new Error("Random bytes length must be >= 16");
    }
    if (!buf) {
      buf = new Uint8Array(16);
      offset = 0;
    } else {
      if (offset < 0 || offset + 16 > buf.length) {
        throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
      }
    }
    msecs ??= Date.now();
    seq ??= rnds[6] * 127 << 24 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
    buf[offset++] = msecs / 1099511627776 & 255;
    buf[offset++] = msecs / 4294967296 & 255;
    buf[offset++] = msecs / 16777216 & 255;
    buf[offset++] = msecs / 65536 & 255;
    buf[offset++] = msecs / 256 & 255;
    buf[offset++] = msecs & 255;
    buf[offset++] = 112 | seq >>> 28 & 15;
    buf[offset++] = seq >>> 20 & 255;
    buf[offset++] = 128 | seq >>> 14 & 63;
    buf[offset++] = seq >>> 6 & 255;
    buf[offset++] = seq << 2 & 255 | rnds[10] & 3;
    buf[offset++] = rnds[11];
    buf[offset++] = rnds[12];
    buf[offset++] = rnds[13];
    buf[offset++] = rnds[14];
    buf[offset++] = rnds[15];
    return buf;
  }
  v7.default = v7$1;
  return v7;
}
var version = {};
var hasRequiredVersion;
function requireVersion() {
  if (hasRequiredVersion) return version;
  hasRequiredVersion = 1;
  Object.defineProperty(version, "__esModule", { value: true });
  const validate_js_1 = requireValidate();
  function version$1(uuid2) {
    if (!(0, validate_js_1.default)(uuid2)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid2.slice(14, 15), 16);
  }
  version.default = version$1;
  return version;
}
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs;
  hasRequiredCjs = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = exports.validate = exports.v7 = exports.v6ToV1 = exports.v6 = exports.v5 = exports.v4 = exports.v3 = exports.v1ToV6 = exports.v1 = exports.stringify = exports.parse = exports.NIL = exports.MAX = void 0;
    var max_js_1 = requireMax();
    Object.defineProperty(exports, "MAX", { enumerable: true, get: function() {
      return max_js_1.default;
    } });
    var nil_js_1 = requireNil();
    Object.defineProperty(exports, "NIL", { enumerable: true, get: function() {
      return nil_js_1.default;
    } });
    var parse_js_1 = requireParse();
    Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
      return parse_js_1.default;
    } });
    var stringify_js_1 = requireStringify();
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return stringify_js_1.default;
    } });
    var v1_js_1 = requireV1();
    Object.defineProperty(exports, "v1", { enumerable: true, get: function() {
      return v1_js_1.default;
    } });
    var v1ToV6_js_1 = requireV1ToV6();
    Object.defineProperty(exports, "v1ToV6", { enumerable: true, get: function() {
      return v1ToV6_js_1.default;
    } });
    var v3_js_1 = requireV3();
    Object.defineProperty(exports, "v3", { enumerable: true, get: function() {
      return v3_js_1.default;
    } });
    var v4_js_1 = requireV4();
    Object.defineProperty(exports, "v4", { enumerable: true, get: function() {
      return v4_js_1.default;
    } });
    var v5_js_1 = requireV5();
    Object.defineProperty(exports, "v5", { enumerable: true, get: function() {
      return v5_js_1.default;
    } });
    var v6_js_1 = requireV6();
    Object.defineProperty(exports, "v6", { enumerable: true, get: function() {
      return v6_js_1.default;
    } });
    var v6ToV1_js_1 = requireV6ToV1();
    Object.defineProperty(exports, "v6ToV1", { enumerable: true, get: function() {
      return v6ToV1_js_1.default;
    } });
    var v7_js_1 = requireV7();
    Object.defineProperty(exports, "v7", { enumerable: true, get: function() {
      return v7_js_1.default;
    } });
    var validate_js_1 = requireValidate();
    Object.defineProperty(exports, "validate", { enumerable: true, get: function() {
      return validate_js_1.default;
    } });
    var version_js_1 = requireVersion();
    Object.defineProperty(exports, "version", { enumerable: true, get: function() {
      return version_js_1.default;
    } });
  })(cjs);
  return cjs;
}
var hasRequiredUuid;
function requireUuid() {
  if (hasRequiredUuid) return uuid;
  hasRequiredUuid = 1;
  Object.defineProperty(uuid, "__esModule", { value: true });
  uuid.convertUuidToBytes = uuid.isUuid = void 0;
  const uuid_1 = /* @__PURE__ */ requireCjs();
  function isUuid(value) {
    return (0, uuid_1.validate)(value);
  }
  uuid.isUuid = isUuid;
  function convertUuidToBytes(uuid2) {
    return (0, uuid_1.parse)(uuid2);
  }
  uuid.convertUuidToBytes = convertUuidToBytes;
  return uuid;
}
var hasRequiredKwilEncoding;
function requireKwilEncoding() {
  if (hasRequiredKwilEncoding) return kwilEncoding;
  hasRequiredKwilEncoding = 1;
  Object.defineProperty(kwilEncoding, "__esModule", { value: true });
  kwilEncoding.encodeValue = kwilEncoding.encodeTransfer = kwilEncoding.encodeRawStatement = kwilEncoding.encodeActionExecution = kwilEncoding.encodeActionCall = kwilEncoding.encodeAccountId = void 0;
  const base64_1 = requireBase64();
  const bytes_1 = requireBytes();
  const serial_12 = requireSerial();
  const uuid_1 = requireUuid();
  const enums_1 = requireEnums();
  function encodeAccountId(accountId) {
    const encodedId = (0, bytes_1.prefixBytesLength)((0, serial_12.hexToBytes)(accountId.identifier));
    const encodedKeyType = (0, bytes_1.prefixBytesLength)((0, serial_12.stringToBytes)(accountId.key_type));
    return (0, bytes_1.concatBytes)(encodedId, encodedKeyType);
  }
  kwilEncoding.encodeAccountId = encodeAccountId;
  function encodeActionCall(actionCall) {
    const actionCallVersion = 0;
    const encodedVersion = (0, bytes_1.numberToUint16LittleEndian)(actionCallVersion);
    const encodedDbId = (0, bytes_1.prefixBytesLength)((0, serial_12.stringToBytes)(actionCall.dbid));
    const encodedAction = (0, bytes_1.prefixBytesLength)((0, serial_12.stringToBytes)(actionCall.action));
    const encodedNumArgs = (0, bytes_1.numberToUint16LittleEndian)(actionCall.arguments ? actionCall.arguments.length : 0);
    let actionArguments = new Uint8Array();
    actionCall.arguments?.forEach((a) => {
      const aBytes = encodeEncodedValue(a);
      const prefixedABytes = (0, bytes_1.prefixBytesLength)(aBytes);
      actionArguments = (0, bytes_1.concatBytes)(actionArguments, prefixedABytes);
    });
    const encodedActionArguments = (0, bytes_1.concatBytes)(encodedNumArgs, actionArguments);
    return (0, base64_1.bytesToBase64)((0, bytes_1.concatBytes)(encodedVersion, encodedDbId, encodedAction, encodedActionArguments));
  }
  kwilEncoding.encodeActionCall = encodeActionCall;
  function encodeActionExecution(action2) {
    const actionExecutionVersion = 0;
    const encodedVersion = (0, bytes_1.numberToUint16LittleEndian)(actionExecutionVersion);
    const encodedDbId = (0, bytes_1.prefixBytesLength)((0, serial_12.stringToBytes)(action2.dbid));
    const encodedAction = (0, bytes_1.prefixBytesLength)((0, serial_12.stringToBytes)(action2.action));
    const encodedNumArgs = (0, bytes_1.numberToUint16LittleEndian)(action2.arguments ? action2.arguments.length : 0);
    let actionArguments = new Uint8Array();
    action2.arguments?.forEach((encodedValues) => {
      const argLength = (0, bytes_1.numberToUint16LittleEndian)(encodedValues.length);
      let argBytes = new Uint8Array();
      encodedValues.forEach((value) => {
        const evBytes = encodeEncodedValue(value);
        const prefixedEvBytes = (0, bytes_1.prefixBytesLength)(evBytes);
        argBytes = (0, bytes_1.concatBytes)(argBytes, prefixedEvBytes);
      });
      actionArguments = (0, bytes_1.concatBytes)(actionArguments, argLength, argBytes);
    });
    const encodedActionArguments = (0, bytes_1.concatBytes)(encodedNumArgs, actionArguments);
    return (0, base64_1.bytesToBase64)((0, bytes_1.concatBytes)(encodedVersion, encodedDbId, encodedAction, encodedActionArguments));
  }
  kwilEncoding.encodeActionExecution = encodeActionExecution;
  function encodeRawStatement(statement) {
    const rawStatementVersion = 0;
    const encodedVersion = (0, bytes_1.numberToUint16LittleEndian)(rawStatementVersion);
    const statementBytes = (0, serial_12.stringToBytes)(statement.statement);
    const encodedStatement = (0, bytes_1.prefixBytesLength)(statementBytes);
    let encodedParameters;
    encodedParameters = (0, bytes_1.numberToUint16LittleEndian)(statement.parameters ? statement.parameters.length : 0);
    for (const param of statement.parameters) {
      const nameBytes = (0, serial_12.stringToBytes)(param.name);
      const prefixedNameBytes = (0, bytes_1.prefixBytesLength)(nameBytes);
      const valueBytes = encodeEncodedValue(param.value);
      const valueBytesPrefix = (0, bytes_1.prefixBytesLength)(valueBytes);
      encodedParameters = (0, bytes_1.concatBytes)(encodedParameters, prefixedNameBytes, valueBytesPrefix);
    }
    return (0, base64_1.bytesToBase64)((0, bytes_1.concatBytes)(encodedVersion, encodedStatement, encodedParameters));
  }
  kwilEncoding.encodeRawStatement = encodeRawStatement;
  function encodeTransfer(transfer) {
    const transferVersion = 0;
    const encodedVersion = (0, bytes_1.numberToUint16LittleEndian)(transferVersion);
    const encodedTo = (0, bytes_1.prefixBytesLength)(encodeAccountId(transfer.to));
    const encodedAmount = (0, bytes_1.concatBytes)(new Uint8Array([1]), (0, bytes_1.prefixBytesLength)((0, serial_12.stringToBytes)(transfer.amount.toString())));
    return (0, base64_1.bytesToBase64)((0, bytes_1.concatBytes)(encodedVersion, encodedTo, encodedAmount));
  }
  kwilEncoding.encodeTransfer = encodeTransfer;
  function encodeEncodedValue(ev) {
    const evVersion = 0;
    const encodedVersion = (0, bytes_1.numberToUint16LittleEndian)(evVersion);
    const dataTypeBytes = encodeDataType(ev.type);
    const encodedType = (0, bytes_1.prefixBytesLength)(dataTypeBytes);
    const dataLength = (0, bytes_1.numberToUint16LittleEndian)(ev.data.length);
    let encodedData = (0, bytes_1.concatBytes)(dataLength);
    for (const data2 of ev.data) {
      encodedData = (0, bytes_1.concatBytes)(encodedData, (0, bytes_1.prefixBytesLength)(data2));
    }
    return (0, bytes_1.concatBytes)(encodedVersion, encodedType, encodedData);
  }
  function encodeDataType(dt) {
    const dtVersion = 0;
    const versionBytes = (0, bytes_1.numberToUint16BigEndian)(dtVersion);
    const nameBytes = (0, serial_12.stringToBytes)(dt.name);
    const nameLength = (0, bytes_1.numberToUint32BigEndian)(nameBytes.length);
    const isArray = (0, serial_12.booleanToBytes)(dt.is_array);
    const metadataLength = (0, bytes_1.numberToUint16BigEndian)(dt.metadata?.[0] || 0);
    const precisionLength = (0, bytes_1.numberToUint16BigEndian)(dt.metadata?.[1] || 0);
    return (0, bytes_1.concatBytes)(versionBytes, nameLength, nameBytes, isArray, metadataLength, precisionLength);
  }
  function encodeValue(value, o) {
    if (o) {
      return overrideValue(value, o);
    }
    if (typeof value === "string" && (0, uuid_1.isUuid)(value)) {
      return encodeNotNull((0, uuid_1.convertUuidToBytes)(value));
    }
    if (value === null) {
      return encodeNull();
    }
    if (value instanceof Uint8Array) {
      return encodeNotNull(value);
    }
    if (typeof value === "number" && isDecimal(value)) {
      return encodeNotNull((0, serial_12.stringToBytes)(value.toString()));
    }
    switch (typeof value) {
      case "string":
        return encodeNotNull((0, serial_12.stringToBytes)(value));
      case "boolean":
        return encodeNotNull((0, serial_12.booleanToBytes)(value));
      case "number":
        return encodeNotNull((0, serial_12.numberToBytes)(value));
      case "undefined":
        return encodeNull();
      case "bigint":
        throw new Error("bigint not supported. convert to string.");
      default:
        throw new Error("invalid scalar value");
    }
  }
  kwilEncoding.encodeValue = encodeValue;
  function overrideValue(v, o) {
    if (v === null || v === void 0) {
      return encodeNull();
    }
    switch (o) {
      case enums_1.VarType.NULL:
        return encodeNull();
      case enums_1.VarType.TEXT:
        return encodeNotNull((0, serial_12.stringToBytes)(v));
      case enums_1.VarType.INT8:
        return encodeNotNull((0, serial_12.numberToBytes)(v));
      case enums_1.VarType.BOOL:
        return encodeNotNull((0, serial_12.booleanToBytes)(v));
      case enums_1.VarType.NUMERIC:
        return encodeNotNull((0, serial_12.stringToBytes)(v.toString()));
      case enums_1.VarType.UUID:
        return encodeNotNull((0, uuid_1.convertUuidToBytes)(v));
      case enums_1.VarType.BYTEA:
        return encodeNotNull(v);
      default:
        throw new Error("invalid scalar value");
    }
  }
  function isDecimal(n) {
    const numStr = Math.abs(n).toString();
    const decimalIdx = numStr.indexOf(".");
    return decimalIdx !== -1;
  }
  function encodeNull() {
    return new Uint8Array([0]);
  }
  function encodeNotNull(v) {
    const bytes2 = new Uint8Array(v.length + 1);
    bytes2[0] = 1;
    bytes2.set(v, 1);
    return bytes2;
  }
  return kwilEncoding;
}
var hasRequiredPayloadTx;
function requirePayloadTx() {
  if (hasRequiredPayloadTx) return payloadTx;
  hasRequiredPayloadTx = 1;
  Object.defineProperty(payloadTx, "__esModule", { value: true });
  payloadTx.PayloadTx = void 0;
  const intern_1 = requireIntern();
  const enums_1 = requireEnums();
  const signature_1 = requireSignature();
  const tx_1 = requireTx();
  const base64_1 = requireBase64();
  const crypto_1 = requireCrypto();
  const objects_1 = requireObjects();
  const serial_12 = requireSerial();
  const strings_1 = requireStrings();
  const kwilEncoding_1 = requireKwilEncoding();
  class PayloadTx {
    /**
     * Initializes a new `Payload` instance.
     *
     * @param {Kwil} kwil - The Kwil client, used to call higher-level methods on the Kwil class.
     */
    constructor(kwil2, options) {
      this.kwil = objects_1.objects.requireNonNil(kwil2, "Client is required for TxnBuilder. Please pass a valid Kwil client. This is an internal error, please create an issue.");
      this.payload = objects_1.objects.requireNonNil(options.payload, "Payload is required for TxnBuilder. Please pass a valid payload.");
      objects_1.objects.validateOptionalFields(options, [
        "payloadType",
        "signer",
        "identifier",
        "signatureType",
        "chainId",
        "description",
        "nonce"
      ]);
      this.payloadType = options.payloadType;
      this.signer = options.signer;
      this.identifier = options.identifier;
      this.signatureType = options.signatureType;
      this.chainId = options.chainId;
      this.description = options.description;
      this.nonce = options.nonce;
    }
    /**
     * Static factory method to create a new Payload instance.
     *
     * @param kwil - The Kwil client.
     * @param options - The options to configure the Payload instance.
     */
    static createTx(kwil2, options) {
      return new PayloadTx(kwil2, options);
    }
    /**
     * Build the payload structure for a transaction.
     */
    async buildTx() {
      const { signer, payloadType, identifier, signatureType, chainId } = objects_1.objects.validateFields({
        signer: this.signer,
        payloadType: this.payloadType,
        identifier: this.identifier,
        signatureType: this.signatureType,
        chainId: this.chainId
      }, (fieldName) => `${fieldName} is required to build a transaction.`);
      const preEstTxn = tx_1.Txn.create((tx2) => {
        tx2.body.payload = this.encodePayload(this.payloadType, this.payload);
        tx2.body.type = payloadType;
        tx2.sender = (0, serial_12.bytesToHex)(identifier);
      });
      const cost = await (0, intern_1.unwrap)(this.kwil)(preEstTxn);
      let nonce = this.nonce;
      if (!this.nonce) {
        const acct = await this.kwil.getAccount(identifier);
        nonce = Number(objects_1.objects.requireNonNil(acct.data?.nonce, "something went wrong retrieving your account nonce.")) + 1;
      }
      const encodedPayload = objects_1.objects.requireNonNil(preEstTxn.body.payload, "encoded payload is null. This is likely an internal error, please create an issue.");
      const postEstTxn = tx_1.Txn.copy(preEstTxn, (tx2) => {
        tx2.body.payload = (0, base64_1.base64ToBytes)(encodedPayload);
        tx2.body.fee = BigInt(strings_1.strings.requireNonNil(cost.data, "something went wrong estimating the cost of your transaction."));
        tx2.body.nonce = objects_1.objects.requireNonNil(nonce, "something went wrong retrieving your account nonce.");
        tx2.body.chain_id = chainId;
      });
      if (this.signatureType === signature_1.SignatureType.SIGNATURE_TYPE_INVALID) {
        throw new Error("Signature type is invalid.");
      }
      return PayloadTx.signTx(postEstTxn, signer, identifier, signatureType, this.description);
    }
    /**
     * Signs the payload of a transaction / request to the broadcast GRPC endpoint.
     *
     * @param {BaseTransaction} tx - The transaction to sign. See {@link BaseTransaction} for more information.
     * @param {SignerSupplier} signer - The signer to be used to sign the transaction.
     * @param {Uint8Array} identifier - The identifier (e.g. wallet address, public key, etc) for the signature, represented as bytes.
     * @param {AnySignatureType} signatureType - The signature type being used. See {@link SignatureType} for more information.
     * @param {string} description - The description to be included in the signature.
     * @returns {BaseTransaction} - A promise that resolves to the signed transaction.
     * @throws {Error} - If the the signer is not an Ethers Signer or a function that accepts and returns a Uint8Array.
     */
    static async signTx(tx2, signer, identifier, signatureType, description) {
      const digest = (0, crypto_1.sha256BytesToBytes)(tx2.body.payload).subarray(0, 20);
      const signatureMessage = `${description}

PayloadType: ${tx2.body.type}
PayloadDigest: ${(0, serial_12.bytesToHex)(digest)}
Fee: ${tx2.body.fee}
Nonce: ${tx2.body.nonce}

Kwil Chain ID: ${tx2.body.chain_id}
`;
      const signedMessage = await (0, signature_1.executeSign)((0, serial_12.stringToBytes)(signatureMessage), signer, signatureType);
      const encodedPayload = objects_1.objects.requireNonNil(tx2.body.payload, "encoded payload is null. This is likely an internal error, please create an issue.");
      return tx_1.Txn.copy(tx2, (newTx) => {
        newTx.signature = {
          // bytes must be base64 encoded for transport over GRPC
          sig: (0, base64_1.bytesToBase64)(signedMessage),
          type: signatureType.toString()
        };
        newTx.body = {
          desc: description,
          payload: (0, base64_1.bytesToBase64)(encodedPayload),
          type: newTx.body.type,
          fee: newTx.body.fee?.toString() || "",
          nonce: newTx.body.nonce,
          chain_id: newTx.body.chain_id
        };
        newTx.sender = (0, serial_12.bytesToHex)(identifier);
        newTx.serialization = enums_1.SerializationType.SIGNED_MSG_CONCAT;
      });
    }
    encodePayload(payloadType, payload) {
      switch (payloadType) {
        case enums_1.PayloadType.EXECUTE_ACTION:
          if (!("action" in payload && "arguments" in payload)) {
            throw new Error("Invalid payload type for EXECUTE_ACTION");
          }
          return (0, kwilEncoding_1.encodeActionExecution)(payload);
        case enums_1.PayloadType.TRANSFER:
          if (!("to" in payload && "amount" in payload)) {
            throw new Error("Invalid payload type for TRANSFER");
          }
          return (0, kwilEncoding_1.encodeTransfer)(payload);
        case enums_1.PayloadType.RAW_STATEMENT:
          if (!("statement" in payload && "parameters" in payload)) {
            throw new Error("Invalid payload type for RAW_STATEMENT");
          }
          return (0, kwilEncoding_1.encodeRawStatement)(payload);
        default:
          throw new Error(`Unsupported payload type: ${payloadType}`);
      }
    }
  }
  payloadTx.PayloadTx = PayloadTx;
  return payloadTx;
}
var hasRequiredFunder;
function requireFunder() {
  if (hasRequiredFunder) return funder;
  hasRequiredFunder = 1;
  Object.defineProperty(funder, "__esModule", { value: true });
  funder.Funder = void 0;
  const enums_1 = requireEnums();
  const payloadTx_1 = requirePayloadTx();
  const serial_12 = requireSerial();
  class Funder {
    constructor(kwil2, funderClient, chainId) {
      this.kwil = kwil2;
      this.funderClient = funderClient;
      this.chainId = chainId;
    }
    async transfer(payload, signer, synchronous) {
      if (!payload.keyType) {
        payload.keyType = enums_1.AccountKeyType.SECP256K1;
      }
      if (payload.to instanceof Uint8Array) {
        payload.to = (0, serial_12.bytesToHex)(payload.to);
      }
      const txPayload = {
        to: {
          identifier: payload.to,
          key_type: payload.keyType
        },
        amount: payload.amount.toString()
      };
      const transaction = await payloadTx_1.PayloadTx.createTx(this.kwil, {
        chainId: this.chainId,
        description: payload.description || "",
        payload: txPayload,
        payloadType: enums_1.PayloadType.TRANSFER,
        identifier: signer.identifier,
        signer: signer.signer,
        signatureType: signer.signatureType
      }).buildTx();
      return await this.funderClient.broadcastClient(transaction, synchronous ? enums_1.BroadcastSyncType.COMMIT : enums_1.BroadcastSyncType.SYNC);
    }
  }
  funder.Funder = Funder;
  return funder;
}
var auth$1 = {};
var auth = {};
var hasRequiredAuth$1;
function requireAuth$1() {
  if (hasRequiredAuth$1) return auth;
  hasRequiredAuth$1 = 1;
  Object.defineProperty(auth, "__esModule", { value: true });
  auth.verifyAuthProperties = auth.removeTrailingSlash = auth.generateSignatureText = auth.composeAuthMsg = void 0;
  function composeAuthMsg(authParam, domain, version2, chainId) {
    let msg = "";
    msg += `${domain} wants you to sign in with your account:
`;
    msg += `
`;
    if (authParam.statement !== "") {
      msg += `${authParam.statement}
`;
    }
    msg += "\n";
    msg += `URI: ${authParam.uri}
`;
    msg += `Version: ${version2}
`;
    msg += `Chain ID: ${chainId}
`;
    msg += `Nonce: ${authParam.nonce}
`;
    msg += `Issue At: ${authParam.issue_at}
`;
    msg += `Expiration Time: ${authParam.expiration_time}
`;
    return msg;
  }
  auth.composeAuthMsg = composeAuthMsg;
  function generateSignatureText(namespace2, action2, digest, challenge) {
    let sigText = "Kwil view call.\n";
    sigText += "\n";
    sigText += `Namespace: ${namespace2}
`;
    sigText += `Method: ${action2}
`;
    sigText += `Digest: ${digest}
`;
    sigText += `Challenge: ${challenge}
`;
    return sigText;
  }
  auth.generateSignatureText = generateSignatureText;
  function removeTrailingSlash(url) {
    if (url.endsWith("/")) {
      return url.slice(0, -1);
    }
    return url;
  }
  auth.removeTrailingSlash = removeTrailingSlash;
  function verifyAuthProperties(authParm, domain, version2, chainId) {
    if (authParm.domain && authParm.domain !== domain) {
      throw new Error(`Domain mismatch: ${authParm.domain} !== ${domain}`);
    }
    if (authParm.version && authParm.version !== version2) {
      throw new Error(`Version mismatch: ${authParm.version} !== ${version2}`);
    }
    if (authParm.chain_id && authParm.chain_id !== chainId) {
      throw new Error(`Chain ID mismatch: ${authParm.chain_id} !== ${chainId}`);
    }
  }
  auth.verifyAuthProperties = verifyAuthProperties;
  return auth;
}
var parameterEncoding = {};
var hasRequiredParameterEncoding;
function requireParameterEncoding() {
  if (hasRequiredParameterEncoding) return parameterEncoding;
  hasRequiredParameterEncoding = 1;
  Object.defineProperty(parameterEncoding, "__esModule", { value: true });
  parameterEncoding.resolveValueType = parameterEncoding.analyzeNumber = parameterEncoding.encodeValueType = parameterEncoding.encodeRawStatementParameters = parameterEncoding.encodeParameters = void 0;
  const enums_1 = requireEnums();
  const base64_1 = requireBase64();
  const kwilEncoding_1 = requireKwilEncoding();
  const uuid_1 = requireUuid();
  function encodeParameters(params) {
    const encodedParams = {};
    Object.entries(params).forEach(([key, value]) => {
      encodedParams[key] = formatEncodedValueBase64(value);
    });
    return encodedParams;
  }
  parameterEncoding.encodeParameters = encodeParameters;
  function formatEncodedValueBase64(val) {
    const base2 = formatDataType(val);
    if (Array.isArray(val)) {
      const encodedValues = [];
      for (const v of val) {
        encodedValues.push((0, base64_1.bytesToBase64)((0, kwilEncoding_1.encodeValue)(v)));
      }
      return {
        type: base2.type,
        data: encodedValues
      };
    }
    return {
      type: base2.type,
      data: [(0, base64_1.bytesToBase64)((0, kwilEncoding_1.encodeValue)(base2.data))]
    };
  }
  function encodeRawStatementParameters(params) {
    return Object.entries(params).map(([key, value]) => {
      const encodedValue = formatEncodedValue(value);
      return {
        name: key,
        value: encodedValue
      };
    });
  }
  parameterEncoding.encodeRawStatementParameters = encodeRawStatementParameters;
  function formatEncodedValue(val, o) {
    const base2 = formatDataType(val, o);
    if (Array.isArray(val)) {
      const encodedValues = [];
      for (const v of val) {
        encodedValues.push((0, kwilEncoding_1.encodeValue)(v, o?.name));
      }
      return {
        type: base2.type,
        data: encodedValues
      };
    }
    return {
      type: base2.type,
      data: [(0, kwilEncoding_1.encodeValue)(base2.data, o?.name)]
    };
  }
  function encodeValueType(values) {
    return values.map((val) => formatEncodedValue(val.v, val.o));
  }
  parameterEncoding.encodeValueType = encodeValueType;
  function formatDataType(val, o) {
    if (o) {
      return {
        type: o,
        data: val
      };
    }
    const { metadata, varType } = resolveValueType(val);
    const dataType = {
      name: varType,
      is_array: Array.isArray(val),
      metadata
    };
    return { type: dataType, data: val };
  }
  function analyzeNumber(num) {
    const numStr = Math.abs(num).toString();
    const decimalIndex = numStr.indexOf(".");
    const hasDecimal = decimalIndex !== -1;
    const precision = hasDecimal ? numStr.length - 1 : numStr.length;
    const scale = hasDecimal ? numStr.length - decimalIndex - 1 : 0;
    return {
      hasDecimal,
      precision,
      scale
    };
  }
  parameterEncoding.analyzeNumber = analyzeNumber;
  function resolveValueType(value) {
    if (Array.isArray(value)) {
      return resolveValueType(value[0]);
    }
    let metadata = [0, 0];
    let varType = enums_1.VarType.TEXT;
    switch (typeof value) {
      case "string":
        if ((0, uuid_1.isUuid)(value)) {
          varType = enums_1.VarType.UUID;
        }
        break;
      case "number":
        const numAnalysis = analyzeNumber(value);
        return {
          metadata: [numAnalysis.precision, numAnalysis.scale],
          varType: numAnalysis.hasDecimal ? enums_1.VarType.NUMERIC : enums_1.VarType.INT8
        };
      case "boolean":
        varType = enums_1.VarType.BOOL;
        break;
      case "object":
        if (value instanceof Uint8Array) {
          varType = enums_1.VarType.BYTEA;
          break;
        }
        if (value === null) {
          varType = enums_1.VarType.NULL;
          break;
        }
      case "undefined":
        varType = enums_1.VarType.NULL;
        break;
      default:
        throw new Error(`Unsupported type: ${typeof value}. If using a uuid, blob, or uint256, please convert to a JavaScript string.`);
    }
    return {
      metadata,
      varType
    };
  }
  parameterEncoding.resolveValueType = resolveValueType;
  return parameterEncoding;
}
var hasRequiredAuth;
function requireAuth() {
  if (hasRequiredAuth) return auth$1;
  hasRequiredAuth = 1;
  Object.defineProperty(auth$1, "__esModule", { value: true });
  auth$1.Auth = void 0;
  const auth_1 = requireAuth$1();
  const objects_1 = requireObjects();
  const signature_1 = requireSignature();
  const serial_12 = requireSerial();
  const base64_1 = requireBase64();
  const action_1 = requireAction$1();
  const crypto_1 = requireCrypto();
  const kwilEncoding_1 = requireKwilEncoding();
  const parameterEncoding_1 = requireParameterEncoding();
  class Auth {
    constructor(authClient, kwilProvider, chainId) {
      this.authClient = authClient;
      this.kwilProvider = kwilProvider;
      this.chainId = chainId;
    }
    /**
     * Authenticates a user with the Kwil Gateway (KGW). This is required to execute view actions with the `@kgw(authn='true')` annotation.
     *
     * This method should only be used if your Kwil Network is using the Kwil Gateway.
     *
     * @param {KwilSigner} signer - The signer for the authentication.
     * @returns A promise that resolves to the authentication success or failure.
     */
    async authenticateKGW(signer) {
      const authParam = await this.authClient.getAuthenticateClient();
      const authProperties = objects_1.objects.requireNonNil(authParam.data, "something went wrong retrieving auth info from KGW");
      const domain = (0, auth_1.removeTrailingSlash)(this.kwilProvider);
      const version2 = "1";
      (0, auth_1.verifyAuthProperties)(authProperties, domain, version2, this.chainId);
      const msg = (0, auth_1.composeAuthMsg)(authProperties, domain, version2, this.chainId);
      const signature2 = await (0, signature_1.executeSign)((0, serial_12.stringToBytes)(msg), signer.signer, signer.signatureType);
      const authBody = {
        nonce: authProperties.nonce,
        sender: (0, serial_12.bytesToHex)(signer.identifier),
        signature: {
          sig: (0, base64_1.bytesToBase64)(signature2),
          type: signer.signatureType
        }
      };
      const res = await this.authClient.postAuthenticateClient(authBody);
      return res;
    }
    /**
     * Authenticates a user in private mode.
     *
     * This method should only be used if your Kwil Network is in private mode.
     *
     * @param {KwilSigner} signer - The signer for the authentication.
     * @param {CallBody} callBody - The body of the action to send. This should use the `ActionBody` interface.
     * @returns A promise that resolves a privateSignature => privateSignature = {sig: string (Base64), type: AnySignatureType}
     */
    async authenticatePrivateMode(callBody, signer) {
      const challenge = await this.authClient.challengeClient();
      let msgChallenge = challenge.data;
      if (!msgChallenge) {
        throw new Error("Challenge data is undefined. Something went wrong.");
      }
      let inputs = {};
      if (callBody.inputs && action_1.transformActionInput.isActionInputArray(callBody.inputs)) {
        inputs = action_1.transformActionInput.toSingleEntry(callBody.inputs);
      } else if (callBody.inputs && action_1.transformPositionalParam.isPositionalParam(callBody.inputs)) {
        inputs = action_1.transformPositionalParam.toNamedParam(callBody.inputs);
      } else if (callBody.inputs) {
        inputs = callBody.inputs;
      }
      const actionValues = callBody?.inputs ? Object.values(inputs) : [];
      const value = (0, action_1.resolveParamTypes)(actionValues, callBody?.types);
      const payload = {
        dbid: callBody.namespace,
        action: callBody.name,
        arguments: (0, parameterEncoding_1.encodeValueType)(value)
      };
      const encodedPayload = (0, kwilEncoding_1.encodeActionCall)(payload);
      const uInt8ArrayPayload = (0, base64_1.base64ToBytes)(encodedPayload);
      const digest = (0, crypto_1.sha256BytesToBytes)(uInt8ArrayPayload).subarray(0, 20);
      const msg = (0, auth_1.generateSignatureText)(callBody.namespace, callBody.name, (0, serial_12.bytesToHex)(digest), msgChallenge);
      const signature2 = await (0, signature_1.executeSign)((0, serial_12.stringToBytes)(msg), signer.signer, signer.signatureType);
      const sig = (0, base64_1.bytesToBase64)(signature2);
      const byteChallenge = (0, serial_12.hexToBytes)(msgChallenge);
      const base64Challenge = (0, base64_1.bytesToBase64)(byteChallenge);
      const res = {
        signature: sig,
        challenge: base64Challenge
      };
      return res;
    }
    async logoutKGW(signer) {
      const identifier = signer?.identifier || void 0;
      return await this.authClient.logoutClient(identifier);
    }
  }
  auth$1.Auth = Auth;
  return auth$1;
}
var action$1 = {};
var payloadMsg = {};
var message = {};
var hasRequiredMessage;
function requireMessage() {
  if (hasRequiredMessage) return message;
  hasRequiredMessage = 1;
  Object.defineProperty(message, "__esModule", { value: true });
  message.Msg = message.BaseMessage = void 0;
  const signature_1 = requireSignature();
  class BaseMessage {
    constructor(data2) {
      this.data = data2 || {
        body: {
          payload: null,
          challenge: ""
        },
        auth_type: signature_1.SignatureType.SECP256K1_PERSONAL,
        sender: null,
        signature: null
      };
    }
    get body() {
      return this.data.body;
    }
    get auth_type() {
      return this.data.auth_type;
    }
    get sender() {
      return this.data.sender;
    }
    get signature() {
      return this.data.signature;
    }
  }
  message.BaseMessage = BaseMessage;
  var Msg;
  (function(Msg2) {
    function create(configure) {
      const msg = {
        body: {
          payload: null,
          challenge: ""
        },
        auth_type: signature_1.SignatureType.SECP256K1_PERSONAL,
        sender: null,
        signature: null
      };
      configure(msg);
      return new BaseMessage(msg);
    }
    Msg2.create = create;
    function copy(source, configure) {
      return Msg2.create((msg) => {
        msg.body = source.body;
        msg.auth_type = source.auth_type;
        msg.sender = source.sender;
        msg.signature = source.signature;
        configure(msg);
      });
    }
    Msg2.copy = copy;
  })(Msg || (message.Msg = Msg = {}));
  return message;
}
var hasRequiredPayloadMsg;
function requirePayloadMsg() {
  if (hasRequiredPayloadMsg) return payloadMsg;
  hasRequiredPayloadMsg = 1;
  Object.defineProperty(payloadMsg, "__esModule", { value: true });
  payloadMsg.PayloadMsg = void 0;
  const message_1 = requireMessage();
  const objects_1 = requireObjects();
  const serial_12 = requireSerial();
  const kwilEncoding_1 = requireKwilEncoding();
  class PayloadMsg {
    /**
     * Initializes a new `PayloadMsg` instance.
     *
     * @param {PayloadMsgOptions} options - Parameters interface to build a payload message.
     */
    constructor(payload, options) {
      this.payload = objects_1.objects.requireNonNil(payload, "Payload is required for Payload Msg Builder. Please pass a valid payload.");
      objects_1.objects.validateOptionalFields(options, [
        "signature",
        "challenge",
        "signer",
        "identifier",
        "signatureType"
      ]);
      this.signature = options.signature;
      this.challenge = options.challenge;
      this.signer = options.signer;
      this.identifier = options.identifier;
      this.signatureType = options.signatureType;
    }
    /**
     * Static factory method to create a new Payload instance.
     *
     * @param kwil - The Kwil client.
     * @param options - The options to configure the Payload instance.
     */
    static createMsg(payload, options) {
      return new PayloadMsg(payload, options);
    }
    /**
     * Build the payload structure for a message.
     */
    async buildMsg() {
      let msg = message_1.Msg.create((msg2) => {
        msg2.body.payload = this.payload;
        msg2.body.challenge = this.challenge;
        msg2.signature = this.signature;
      });
      if (this.signer) {
        const { identifier, signatureType } = objects_1.objects.validateFields({
          identifier: this.identifier,
          signatureType: this.signatureType
        }, (fieldName) => `${fieldName} required to build a message.`);
        if (identifier) {
          return await PayloadMsg.authMsg(msg, identifier, signatureType);
        }
      }
      return message_1.Msg.copy(msg, (msg2) => {
        msg2.body.payload = (0, kwilEncoding_1.encodeActionCall)(this.payload);
      });
    }
    /**
     * Adds the caller's sender address to the message.
     *
     * @param {Message} msg - The message to sign. See {@link Message} for more information.
     * @param {Uint8Array} identifier - The identifier (e.g. wallet address, public key, etc) for the signature, represented as bytes.
     * @param {AnySignatureType} signatureType - The signature type being used. See {@link SignatureType} for more information.
     * @param {string} description - The description to be included in the signature.
     * @returns Message - A promise that resolves to the signed message.
     * @throws {Error} - If the the signer is not an Ethers Signer or a function that accepts and returns a Uint8Array.
     */
    static async authMsg(msg, identifier, signatureType) {
      const unencodedPayload = objects_1.objects.requireNonNil(msg.body.payload, "Payload is required to sign a message. This is likely an internal error. Please create an issue.");
      return message_1.Msg.copy(msg, (msg2) => {
        msg2.body.payload = (0, kwilEncoding_1.encodeActionCall)(unencodedPayload);
        msg2.auth_type = signatureType;
        msg2.sender = (0, serial_12.bytesToHex)(identifier);
      });
    }
  }
  payloadMsg.PayloadMsg = PayloadMsg;
  return payloadMsg;
}
var hasRequiredAction;
function requireAction() {
  if (hasRequiredAction) return action$1;
  hasRequiredAction = 1;
  Object.defineProperty(action$1, "__esModule", { value: true });
  action$1.Action = void 0;
  const action_1 = requireAction$1();
  const enums_1 = requireEnums();
  const payloadTx_1 = requirePayloadTx();
  const payloadMsg_1 = requirePayloadMsg();
  const objects_1 = requireObjects();
  const parameterEncoding_1 = requireParameterEncoding();
  const TXN_BUILD_IN_PROGRESS = [];
  class Action {
    /**
     * Initializes a new `Action` instance.
     * It helps in building transactions to execute database actions on the Kwil network.
     *
     * @param {Kwil} kwil - The Kwil client, used to call higher-level methods on the Kwil class.
     */
    constructor(kwil2, options) {
      this.kwil = objects_1.objects.requireNonNil(kwil2, "Client is required for Action Builder. Please pass a valid Kwil Client.");
      objects_1.objects.validateRequiredFields(options, [
        "actionName",
        "namespace",
        "chainId",
        "description",
        "actionInputs"
      ]);
      this.actionName = options.actionName;
      this.namespace = options.namespace;
      this.chainId = options.chainId;
      this.description = options.description;
      this.actionInputs = options.actionInputs;
      objects_1.objects.validateOptionalFields(options, [
        "signer",
        "identifier",
        "actionInputs",
        "signatureType",
        "nonce",
        "types"
      ]);
      this.signer = options.signer;
      this.identifier = options.identifier;
      this.signatureType = options.signatureType;
      this.nonce = options.nonce;
      this.challenge = options.challenge;
      this.signature = options.signature;
      this.types = options.types;
    }
    /**
     * Static factory method to create a new Action instance.
     *
     * @param kwil - The Kwil client.
     * @param options - The options to configure the Action instance.
     */
    static createTx(kwil2, options) {
      return new Action(kwil2, options);
    }
    /**
     * Build the action structure for a transaction.
     */
    async buildTx(privateMode) {
      this.assertNotBuilding();
      const cachedActionInputs = this.actionInputs;
      this.actionInputs = TXN_BUILD_IN_PROGRESS;
      const payload = await this.buildTxPayload(privateMode, cachedActionInputs);
      const { signer, identifier, signatureType } = objects_1.objects.validateFields({
        signer: this.signer,
        identifier: this.identifier,
        signatureType: this.signatureType
      }, (fieldName) => `${fieldName} is required to build a transaction.`);
      return await payloadTx_1.PayloadTx.createTx(this.kwil, {
        payloadType: enums_1.PayloadType.EXECUTE_ACTION,
        payload,
        signer,
        signatureType,
        description: this.description,
        chainId: this.chainId,
        identifier,
        nonce: this.nonce
      }).buildTx().finally(() => this.actionInputs = cachedActionInputs);
    }
    /**
     * Builds the message structure for view actions. This can be provided to the `kwil.call()` api.
     */
    async buildMsg(privateMode) {
      this.assertNotBuilding();
      const cachedActionInputs = this.actionInputs;
      this.actionInputs = TXN_BUILD_IN_PROGRESS;
      const payload = await this.buildMsgPayload(privateMode, cachedActionInputs);
      let msg = payloadMsg_1.PayloadMsg.createMsg(payload, {
        challenge: this.challenge,
        signature: this.signature
      });
      if (this.signer) {
        msg.signer = this.signer;
        msg.signatureType = this.signatureType;
        msg.identifier = this.identifier;
      }
      return await msg.buildMsg().finally(() => this.actionInputs = cachedActionInputs);
    }
    /**
     * Builds the payload for the execute action.
     *
     * @param {boolean} privateMode - Whether the action is being executed in private mode.
     * @param {ActionInput[]} actionInputs - The inputs for the action.
     * @returns {UnencodedActionPayload<PayloadType.EXECUTE_ACTION>} - The payload for the execute action.
     */
    async buildTxPayload(privateMode, actionInputs) {
      const payload = {
        dbid: this.namespace,
        action: this.actionName,
        arguments: []
      };
      if (privateMode) {
        for (const actionInput of actionInputs) {
          const value = (0, action_1.resolveParamTypes)(actionInput, this.types);
          payload.arguments.push((0, parameterEncoding_1.encodeValueType)(value));
        }
        return payload;
      }
      const { actionName, encodedActionInputs, modifiers } = await this.validatedActionRequest(actionInputs);
      if (modifiers.length > 0 && modifiers.includes(enums_1.AccessModifier.VIEW)) {
        throw new Error(`Action / Procedure ${actionName} is a 'view' action. Please use kwil.call().`);
      }
      payload.arguments = encodedActionInputs;
      return payload;
    }
    /**
     * Builds the payload for the call action.
     *
     * @param {boolean} privateMode - Whether the action is being executed in private mode.
     * @param {ActionInput[]} actionInputs - The inputs for the action.
     * @returns {UnencodedActionPayload<PayloadType.CALL_ACTION>} - The payload for the call action.
     */
    async buildMsgPayload(privateMode, actionInputs) {
      const payload = {
        dbid: this.namespace,
        action: this.actionName,
        arguments: []
      };
      if (privateMode) {
        const actionValues = actionInputs.length > 0 ? Object.values(actionInputs[0]) : [];
        const value = (0, action_1.resolveParamTypes)(actionValues, this.types);
        payload.arguments = (0, parameterEncoding_1.encodeValueType)(value);
        return payload;
      }
      const { actionName, encodedActionInputs, modifiers } = await this.validatedActionRequest(actionInputs);
      if (encodedActionInputs && encodedActionInputs.length > 1) {
        throw new Error("Cannot pass more than one input to the call endpoint. Please pass only one input and try again.");
      }
      if (modifiers.length > 0 && modifiers.includes(enums_1.AccessModifier.VIEW) === false) {
        throw new Error(`Action ${actionName} is not a view only action. Please use kwil.execute().`);
      }
      payload.arguments = encodedActionInputs[0];
      return payload;
    }
    /**
     * Checks the action definition and validates the action inputs
     *
     * @param {ActionInput[]} actionInputs - An array of action inputs to be executed.
     * @returns {ValidatedAction} - An object containing the database namespace, action name, modifiers, and encoded action inputs.
     */
    async validatedActionRequest(actionInputs) {
      if ((0, action_1.isNamedParams)(actionInputs)) {
        const namespaceRequest = await this.kwil.getActions(this.namespace);
        if (namespaceRequest.status !== 200) {
          throw new Error(`Failed to retrieve actions for namespace ${this.namespace}. Status: ${namespaceRequest.status}`);
        }
        if (!namespaceRequest.data || namespaceRequest.data.length === 0) {
          throw new Error(`No actions found for the namespace '${this.namespace}'. Please verify the namespace exists and contains the '${this.actionName}' action.`);
        }
        const namespaceActions = namespaceRequest.data;
        const selectedAction = namespaceActions.find((a) => a.name === this.actionName);
        if (!selectedAction) {
          throw new Error(`Action '${this.actionName}' not found in namespace '${this.namespace}'.`);
        }
        if (!selectedAction.access_modifiers.includes(enums_1.AccessModifier.PUBLIC)) {
          throw new Error(`Action '${this.actionName}' is not a public action.`);
        }
        if (actionInputs) {
          for (const actionInput of actionInputs) {
            if (!this.validateActionInputs(selectedAction, actionInput)) {
              throw new Error(`Action inputs are invalid for action: ${selectedAction.name}.`);
            }
          }
        }
        const encodedActionInputs = [];
        for (const actionInput of actionInputs) {
          const value = (0, action_1.resolveParamTypes)(actionInput, this.types);
          encodedActionInputs.push((0, parameterEncoding_1.encodeValueType)(value));
        }
        return {
          actionName: selectedAction.name,
          modifiers: selectedAction.access_modifiers,
          encodedActionInputs
        };
      }
      let encValue = [];
      if (actionInputs.length > 0) {
        for (const a of actionInputs) {
          const value = (0, action_1.resolveParamTypes)(a, this.types);
          encValue.push((0, parameterEncoding_1.encodeValueType)(value));
        }
      }
      return {
        actionName: this.actionName,
        modifiers: [],
        encodedActionInputs: encValue
      };
    }
    /**
     * Validates that the action is not missing any inputs.
     *
     * @param {NamespaceAction} selectedAction - The schema of the action to be executed.
     * @param {ActionInput} actionInput - The values of the actions to be executed.
     * @returns {boolean} - True if the action inputs are valid, false otherwise.
     */
    validateActionInputs(selectedAction, actionInputEntries) {
      const actionInputKeys = Object.keys(actionInputEntries);
      if ((!selectedAction.parameter_names || selectedAction.parameter_names.length === 0) && Object.keys(actionInputEntries).length === 0) {
        return true;
      }
      if ((!selectedAction.parameter_names || selectedAction.parameter_names.length === 0) && actionInputEntries.length !== 0) {
        throw new Error(`No parameters found for action: ${this.actionName}.`);
      }
      if (actionInputEntries.length == 0 && selectedAction.parameter_names.length > 0) {
        throw new Error(`No action parameters have been included. Required parameters: ${selectedAction.parameter_names.join(", ")}`);
      }
      if (Object.keys(actionInputEntries).every((key) => key.startsWith("$pstn_"))) {
        return true;
      }
      const missingParameters = /* @__PURE__ */ new Set();
      selectedAction.parameter_names.forEach((parameterName) => {
        if (!actionInputKeys.includes(parameterName)) {
          missingParameters.add(parameterName);
        }
      });
      if (missingParameters.size > 0) {
        throw new Error(`Missing parameters: ${Array.from(missingParameters).join(", ")} for action '${selectedAction.name}'`);
      }
      const incorrectParameters = /* @__PURE__ */ new Set();
      actionInputKeys.forEach((actionInputKey) => {
        if (!selectedAction.parameter_names.some((parameterName) => actionInputKey === parameterName)) {
          incorrectParameters.add(actionInputKey);
        }
      });
      if (incorrectParameters.size > 0) {
        throw new Error(`Incorrect parameters: ${Array.from(incorrectParameters).join(", ")} for action '${selectedAction.name}'`);
      }
      return true;
    }
    assertNotBuilding() {
      if (this.actionInputs === TXN_BUILD_IN_PROGRESS) {
        throw new Error("Cannot modify the builder while a transaction is being built.");
      }
    }
  }
  action$1.Action = Action;
  return action$1;
}
var dbid = {};
var hasRequiredDbid;
function requireDbid() {
  if (hasRequiredDbid) return dbid;
  hasRequiredDbid = 1;
  Object.defineProperty(dbid, "__esModule", { value: true });
  dbid.generateDBID = void 0;
  const bytes_1 = requireBytes();
  const crypto_1 = requireCrypto();
  const serial_12 = requireSerial();
  function generateDBID(owner, name) {
    if (typeof owner === "string") {
      owner = (0, serial_12.hexToBytes)(owner);
    }
    return "x" + (0, crypto_1.sha224BytesToString)((0, bytes_1.concatBytes)((0, serial_12.stringToBytes)(name.toLowerCase()), owner));
  }
  dbid.generateDBID = generateDBID;
  return dbid;
}
var namespace = {};
var hasRequiredNamespace;
function requireNamespace() {
  if (hasRequiredNamespace) return namespace;
  hasRequiredNamespace = 1;
  Object.defineProperty(namespace, "__esModule", { value: true });
  namespace.resolveNamespace = namespace.validateNamespace = void 0;
  const validateNamespace = (namespace2) => {
    if (!namespace2 || typeof namespace2 !== "string") {
      return false;
    }
    if (/[';{}\\]/.test(namespace2)) {
      return false;
    }
    if (!/^[a-zA-Z0-9_]+$/.test(namespace2)) {
      return false;
    }
    return true;
  };
  namespace.validateNamespace = validateNamespace;
  const resolveNamespace = (actionBody) => {
    if (actionBody.namespace) {
      return actionBody.namespace;
    }
    if (actionBody.dbid) {
      console.warn('Warning: The "dbid" field is deprecated. Please use "namespace" instead.');
      return actionBody.dbid;
    }
    throw new Error('Either "namespace" or "dbid" must be provided');
  };
  namespace.resolveNamespace = resolveNamespace;
  return namespace;
}
var keys = {};
var hasRequiredKeys;
function requireKeys() {
  if (hasRequiredKeys) return keys;
  hasRequiredKeys = 1;
  Object.defineProperty(keys, "__esModule", { value: true });
  keys.inferKeyType = void 0;
  const serial_12 = requireSerial();
  const enums_1 = requireEnums();
  function inferKeyType(owner) {
    if (typeof owner === "string") {
      owner = (0, serial_12.hexToBytes)(owner);
    }
    if (owner.length === 32 || owner.length === 33) {
      return enums_1.AccountKeyType.ED25519;
    }
    if (owner.length === 20) {
      return enums_1.AccountKeyType.SECP256K1;
    }
    throw new Error("Cannot determine key type from owner.");
  }
  keys.inferKeyType = inferKeyType;
  return keys;
}
var hasRequiredKwil;
function requireKwil() {
  if (hasRequiredKwil) return kwil;
  hasRequiredKwil = 1;
  var __importDefault = kwil && kwil.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(kwil, "__esModule", { value: true });
  kwil.Kwil = void 0;
  const client_1 = __importDefault(requireClient());
  const enums_1 = requireEnums();
  const action_1 = requireAction$1();
  const intern_1 = requireIntern();
  const funder_1 = requireFunder();
  const auth_1 = requireAuth();
  const action_2 = requireAction();
  const parameterEncoding_1 = requireParameterEncoding();
  const dbid_1 = requireDbid();
  const payloadTx_1 = requirePayloadTx();
  const namespace_1 = requireNamespace();
  const keys_1 = requireKeys();
  const serial_12 = requireSerial();
  class Kwil extends client_1.default {
    constructor(opts) {
      super(opts);
      this.chainId = opts.chainId;
      this.autoAuthenticate = opts.autoAuthenticate ?? true;
      this.funder = new funder_1.Funder(this, {
        broadcastClient: this.broadcastClient.bind(this)
      }, this.chainId);
      this.auth = new auth_1.Auth({
        getAuthenticateClient: this.getAuthenticateClient.bind(this),
        postAuthenticateClient: this.postAuthenticateClient.bind(this),
        challengeClient: this.challengeClient.bind(this),
        logoutClient: this.logoutClient.bind(this)
      }, this.config.kwilProvider, this.chainId);
      (0, intern_1.wrap)(this, this.estimateCostClient.bind(this));
    }
    /**
     * Retrieves the actions in a database given its namespace.
     *
     * @param namespace - The namespace of the actions to retrieve.
     * @returns A promise that resolves to the actions in the database.
     */
    async getActions(namespace2) {
      if (!(0, namespace_1.validateNamespace)(namespace2)) {
        throw new Error("Please provide a valid namespace");
      }
      return await this.selectQuery("SELECT * FROM info.actions WHERE namespace = $namespace", {
        $namespace: namespace2
      });
    }
    /**
     * Retrieves an account using the owner's Ethereum wallet address.
     *
     * @param owner - The owner's identifier (e.g. Ethereum wallet address or ED25119 keys). Ethereum addresses and ED25519 public keys can be passed as a hex string (0x123...) or as bytes (Uint8Array).
     * @returns A promise that resolves to an Account object. The account object includes the account's id, balance, and nonce.
     */
    async getAccount(owner, keyType) {
      if (!keyType) {
        keyType = (0, keys_1.inferKeyType)(owner);
      }
      if (owner instanceof Uint8Array) {
        owner = (0, serial_12.bytesToHex)(owner);
      }
      return await this.getAccountClient({
        identifier: owner,
        key_type: keyType
      });
    }
    /**
     * Executes a transaction on a Kwil network. These are mutative actions that must be mined on the Kwil network's blockchain.
     *
     * @param actionBody - The body of the action to send. This should use the `ActionBody` interface.
     * @param kwilSigner - The signer for the action transactions.
     * @param synchronous - (optional) If true, the broadcast will wait for the transaction to be mined before returning. If false, the broadcast will return the transaction hash immediately, regardless of if the transaction is successful. Defaults to false.
     * @returns A promise that resolves to the receipt of the transaction.
     */
    async execute(actionBody, kwilSigner2, synchronous) {
      if (!actionBody.name) {
        throw new Error("name is required in actionBody");
      }
      await this.ensureAuthenticationMode();
      const namespace2 = (0, namespace_1.resolveNamespace)(actionBody);
      let inputs = [];
      if (actionBody.inputs && action_1.transformActionInput.isActionInputArray(actionBody.inputs)) {
        inputs = action_1.transformActionInput.toNamedParams(actionBody.inputs);
      } else {
        inputs = actionBody.inputs || [];
      }
      let tx2 = action_2.Action.createTx(this, {
        namespace: namespace2,
        actionName: actionBody.name.toLowerCase(),
        description: actionBody.description || "",
        identifier: kwilSigner2.identifier,
        chainId: this.chainId,
        signer: kwilSigner2.signer,
        signatureType: kwilSigner2.signatureType,
        nonce: actionBody.nonce,
        actionInputs: inputs,
        types: actionBody.types
      });
      const transaction = await tx2.buildTx(this.authMode === enums_1.AuthenticationMode.PRIVATE);
      return await this.broadcastClient(transaction, synchronous ? enums_1.BroadcastSyncType.COMMIT : enums_1.BroadcastSyncType.SYNC);
    }
    async selectQuery(query, params) {
      if (typeof params === "string") {
        return this.legacySelectQuery(query, params);
      }
      const encodedParams = (0, parameterEncoding_1.encodeParameters)(params || {});
      const q = {
        query,
        params: encodedParams
      };
      return await this.selectQueryClient(q);
    }
    async legacySelectQuery(dbid2, query) {
      console.warn("WARNING: selectQuery(dbid, query) is deprecated and will be removed in the next major version. Use selectQuery(query, params?) instead.");
      const q = {
        query: `{${dbid2}}${query}`,
        params: {}
      };
      return await this.selectQueryClient(q);
    }
    /**
     * Executes a mutative SQL query (INSERT, UPDATE, DELETE) on a database.
     *
     * @param query - The SQL query to execute, including the database identifier in curly braces.
     *               Use parameterized queries with @paramName placeholders for better security (recommended):
     *               '{dbname}INSERT INTO users (name) VALUES (@name)'
     *
     *               Raw queries are possible but discouraged:
     *               '{dbname}INSERT INTO users (name) VALUES ('john')'
     *
     * @param params - Object containing named parameters to bind to the query. Parameters are referenced
     *                using @paramName syntax in the query.
     * @param kwilSigner - Required signer for executing mutative queries
     * @param synchronous - (optional) If true, waits for transaction to be mined
     *
     * @example
     * // Insert with parameters
     * await kwil.execSql(
     *   '{mydb}INSERT INTO users (name, email) VALUES ($name, $email)',
     *   { $name: 'John', $email: 'john@example.com' },
     *   signer
     * );
     *
     * // Update with parameters
     * await kwil.execSql(
     *   '{mydb}UPDATE users SET status = $status WHERE id = $id',
     *   { $status: 'active', $id: 123 },
     *   signer
     * );
     *
     * // Delete with parameters
     * await kwil.execSql(
     *   '{mydb}DELETE FROM users WHERE id = $id',
     *   { $id: 123 },
     *   signer
     * );
     *
     * @returns Promise resolving to transaction receipt
     */
    async execSql(query, params, signer, synchronous) {
      const encodedParams = (0, parameterEncoding_1.encodeRawStatementParameters)(params);
      const rawStatementPayload = {
        statement: query,
        parameters: encodedParams
      };
      const transaction = await payloadTx_1.PayloadTx.createTx(this, {
        chainId: this.chainId,
        description: `Performing a mutative query`,
        payload: rawStatementPayload,
        payloadType: enums_1.PayloadType.RAW_STATEMENT,
        identifier: signer.identifier,
        signer: signer.signer,
        signatureType: signer.signatureType
      }).buildTx();
      return await this.broadcastClient(transaction, synchronous ? enums_1.BroadcastSyncType.COMMIT : enums_1.BroadcastSyncType.SYNC);
    }
    /**
     * Retrieves information about a transaction given its hash.
     *
     * @param hash - The `tx_hash` of the transaction.
     * @returns A promise that resolves to the transaction info receipt.
     */
    async txInfo(hash2) {
      return await this.txInfoClient(hash2);
    }
    /**
     * Retrieves the chain id, block height, and latest block hash of the configured network.
     *
     * Will log a warning if the returned chain id does not match the configured chain id.
     *
     * @param {ChainInfoOpts} opts - Options for the chain info request.
     * @returns {ChainInfo} - A promise that resolves to the chain info.
     */
    async chainInfo(opts) {
      const info = await this.chainInfoClient();
      if (!opts?.disableWarning && info.data?.chain_id !== this.chainId) {
        console.warn(`WARNING: Chain ID mismatch. Expected ${info.data?.chain_id}, got ${this.chainId}`);
      }
      return info;
    }
    /**
     * Pings the server and gets a response.
     *
     * @returns A promise that resolves to a string indicating the server's response.
     */
    async ping() {
      return await this.pingClient();
    }
    // DEPRECATED APIS BELOW
    /**
     * Generates a unique database identifier (DBID) from the provided owner's identifier (e.g. wallet address, public key, etc.) and a database name.
     *
     * @param owner - The owner's identifier (e.g wallet address, public key, etc.). Ethereum addresses can be passed as a hex string (0x123...) or as bytes (Uint8Array). NEAR protocol public keys can be passed as the base58 encoded public key (with "ed25519:" prefix), a hex string, or bytes (Uint8Array).
     * @param name - The name of the database. This should be a unique name to identify the database.
     * @deprecated DBID's are no longer in use.  This method will be removed in the next major version.
     * @returns A string that represents the unique identifier for the database.
     */
    getDBID(owner, name) {
      console.warn("WARNING: `getDBID()` is deprecated and will be removed in the next major version. Please use `kwil.selectQuery(query, params?)` instead.");
      return (0, dbid_1.generateDBID)(owner, name);
    }
    /**
     * Retrieves the schema of a database given its unique identifier (DBID).
     *
     * @param dbid - The unique identifier of the database. The DBID can be generated using the kwil.getDBID method.
     * @deprecated Use `kwil.selectQuery(query, params?)` instead. This method will be removed in the next major version.
     * @returns A promise that resolves to the schema of the database.
     */
    async getSchema(dbid2) {
      console.warn("WARNING: `getSchema()` is deprecated and will be removed in the next major version. Please use `kwil.selectQuery()` instead.");
      throw new Error("The `getSchema()` method is no longer supported. Please use `kwil.selectQuery(query, params?)` instead.");
    }
    /**
     * Deploys a database to the Kwil network.
     *
     * @param deployBody - The body of the database to deploy. This should use the `DeployBody` interface.
     * @param kwilSigner - The signer for the database deployment.
     * @param synchronous - (optional) If true, the broadcast will wait for the transaction to be mined before returning. If false, the broadcast will return the transaction hash immediately, regardless of if the transaction is successful. Defaults to false.
     * @deprecated Use `kwil.execSql()` instead. This method will be removed in the next major version.
     * @returns A promise that resolves to the receipt of the transaction.
     */
    async deploy(deployBody, kwilSigner2, synchronous) {
      console.warn("WARNING: `deploy()` is deprecated and will be removed in the next major version. Please use `kwil.execSql()` instead.");
      throw new Error("The `deploy()` method is no longer supported. Please use `kwil.execSql()` instead.");
    }
    /**
     * Drops a database from the Kwil network.
     *
     * @param dropBody - The body of the database to drop. This should use the `DropBody` interface.
     * @param kwilSigner - The signer for the database drop.
     * @param synchronous - (optional) If true, the broadcast will wait for the transaction to be mined before returning. If false, the broadcast will return the transaction hash immediately, regardless of if the transaction is successful. Defaults to false.
     * @deprecated Use `kwil.execSql()` instead. This method will be removed in the next major version.
     * @returns A promise that resolves to the receipt of the transaction.
     */
    async drop(dropBody, kwilSigner2, synchronous) {
      console.warn("WARNING: `drop()` is deprecated and will be removed in the next major version. Please use `kwil.execSql()` instead.");
      throw new Error("The `drop()` method is no longer supported. Please use `kwil.execSql()` instead.");
    }
    /**
     * Lists all databases owned by a particular owner.
     *
     * @param owner (optional) - Lists the databases on a network. Can pass and owner identifier to see all the databases deployed by a specific account, or leave empty to see al the databases deployed on the network. The owner's public key (Ethereum or NEAR Protocol). Ethereum keys can be passed as a hex string (0x123...) or as bytes (Uint8Array).
     * @deprecated Use `kwil.selectQuery(query, params?)` instead. This method will be removed in the next major version.
     * @returns A promise that resolves to a list of database names.
     */
    async listDatabases(owner) {
      console.warn("WARNING: `listDatabases()` is deprecated and will be removed in the next major version. Please use `kwil.selectQuery(query, params?)` instead.");
      throw new Error("The `listDatabases()` method is no longer supported. Please use `kwil.selectQuery(query, params?)` instead.");
    }
    /**
     * Calls a Kwil node. This can be used to execute read-only ('view') actions on Kwil.
     *
     * @param {CallBody} callBody - The message to send. The message can be built using the buildMsg() method in the Action class.
     * @param {KwilSigner} kwilSigner (optional) - KwilSigner should be passed if the action requires authentication OR if the action uses a `@caller` contextual variable. If `@caller` is used and authentication is not required, the user will not be prompted to authenticate; however, the user's identifier will be passed as the sender.
     * @param {(...args: any) => void} cookieHandlerCallback (optional) - the callback to handle the cookie if in the NODE environment
     * @returns A promise that resolves to the receipt of the message.
     */
    async baseCall(callBody, kwilSigner2, cookieHandlerCallback) {
      await this.ensureAuthenticationMode();
      if (this.authMode === enums_1.AuthenticationMode.OPEN) {
        if (cookieHandlerCallback) {
          cookieHandlerCallback.setCookie();
        }
        const message2 = await this.buildMessage(callBody, kwilSigner2);
        const response = await this.callClient(message2);
        if (cookieHandlerCallback) {
          cookieHandlerCallback.resetCookie();
        }
        if (response.authCode === enums_1.AuthErrorCodes.KGW_MODE && this.autoAuthenticate) {
          if (!kwilSigner2) {
            throw new Error("KGW authentication requires a KwilSigner");
          }
          const res = await this.auth.authenticateKGW(kwilSigner2);
          if (res.data && "cookie" in res.data) {
            this.cookie = res.data.cookie;
          }
          return await this.callClient(message2);
        }
        return response;
      }
      if (this.authMode === enums_1.AuthenticationMode.PRIVATE) {
        const authBody = await this.handleAuthenticatePrivate(callBody, kwilSigner2);
        const message2 = await this.buildMessage(callBody, kwilSigner2, authBody.challenge, authBody.signature);
        return await this.callClient(message2);
      }
      throw new Error("Unexpected authentication mode. If you hit this error, please report it to the Kwil team.");
    }
    /**
     * Check if authMode is already set, if not call healthModeCheckClient()
     * healthModeCheckClient => RPC call to retrieve health of blockchain and kwild mode (PRIVATE or OPEN (PUBLIC))
     *
     */
    async ensureAuthenticationMode() {
      if (!this.authMode) {
        const health = await this.healthModeCheckClient();
        this.authMode = health.data?.mode;
      }
    }
    /**
     * Builds a message with a chainId, namespace, name, and description of the action.
     * NOT INCLUDED => challenge, sender, signature
     *
     * @param callBody - The message to send. The message can be built using the buildMsg() method in the Action class.
     * @param kwilSigner (optional) - KwilSigner should be passed if the action requires authentication OR if the action uses a `@caller` contextual variable. If `@caller` is used and authentication is not required, the user will not be prompted to authenticate; however, the user's identifier will be passed as the sender.
     * @param challenge (optional) - To ensure a challenge is passed into the message before the signer in PRIVATE mode
     * @param signature (optional) - To ensure a signature is passed into the message before the signer in PRIVATE mode
     * @returns A message object that can be sent to the Kwil network.
     * @throws  Will throw an error if the action is being built or if there's an issue with the schema or account retrieval.
     * @throws  Will throw an error if the action is not a view action.
     */
    async buildMessage(callBody, kwilSigner2, challenge, signature2) {
      if (!callBody.name) {
        throw new Error("name is required in actionBody");
      }
      const namespace2 = (0, namespace_1.resolveNamespace)(callBody);
      let inputs = [];
      if (callBody.inputs && action_1.transformActionInput.isActionInputArray(callBody.inputs)) {
        inputs = [action_1.transformActionInput.toSingleEntry(callBody.inputs)];
      } else if (callBody.inputs && (0, action_1.isNamedParam)(callBody.inputs)) {
        inputs = [callBody.inputs];
      } else {
        inputs = callBody.inputs ? [callBody.inputs] : [];
      }
      let msg = action_2.Action.createTx(this, {
        chainId: this.chainId,
        namespace: namespace2,
        actionName: callBody.name,
        description: "",
        actionInputs: inputs,
        types: callBody.types
      });
      if (kwilSigner2 && this.authMode === enums_1.AuthenticationMode.OPEN) {
        this.addSignerToMessage(msg, kwilSigner2);
      }
      if (kwilSigner2 && this.authMode === enums_1.AuthenticationMode.PRIVATE) {
        if (challenge && signature2) {
          msg.challenge = challenge;
          msg.signature = signature2;
          this.addSignerToMessage(msg, kwilSigner2);
        }
      }
      return await msg.buildMsg(this.authMode === enums_1.AuthenticationMode.PRIVATE);
    }
    /**
     * Adds a signer to the message
     *
     * @param msgBuilder - The Action class that handles the building of the message
     * @param kwilSigner - KwilSigner should be passed if the action requires authentication OR if the action uses a `@caller` contextual variable. If `@caller` is used and authentication is not required, the user will not be prompted to authenticate; however, the user's identifier will be passed as the sender.
     * @returns the Action class responsible for building the view action message with the sender attached
     *
     */
    addSignerToMessage(msg, kwilSigner2) {
      msg.signer = kwilSigner2.signer;
      msg.signatureType = kwilSigner2.signatureType;
      msg.identifier = kwilSigner2.identifier;
      return msg;
    }
    /**
     * Checks authentication errors for PRIVATE mode
     * Signs message and then retries request for successful response
     *
     * @param {CallBodyNode} actionBody - The message to send. The message can be built using the buildMsg() method in the Action class.
     * @param {KwilSigner} kwilSigner (optional) - KwilSigner should be passed if the action requires authentication OR if the action uses a `@caller` contextual variable. If `@caller` is used and authentication is not required, the user will not be prompted to authenticate; however, the user's identifier will be passed as the sender.
     * @returns the authentication body that consists of the challenge and signature required for PRIVATE mode
     */
    async handleAuthenticatePrivate(actionBody, kwilSigner2) {
      if (this.autoAuthenticate) {
        try {
          if (this.authMode === enums_1.AuthenticationMode.PRIVATE) {
            if (!kwilSigner2) {
              throw new Error("Private mode authentication requires a KwilSigner.");
            }
            return await this.auth.authenticatePrivateMode(actionBody, kwilSigner2);
          }
        } catch (error) {
          throw new Error(`Authentication failed: ${error}`);
        }
      }
      throw new Error("Authentication process did not complete successfully");
    }
  }
  kwil.Kwil = Kwil;
  return kwil;
}
var hasRequiredNodeKwil;
function requireNodeKwil() {
  if (hasRequiredNodeKwil) return nodeKwil;
  hasRequiredNodeKwil = 1;
  Object.defineProperty(nodeKwil, "__esModule", { value: true });
  nodeKwil.NodeKwil = void 0;
  const kwil_1 = requireKwil();
  class NodeKwil extends kwil_1.Kwil {
    constructor(opts) {
      super(opts);
    }
    /**
     * Calls a Kwil node. This can be used to execute read-only ('view') actions on Kwil.
     * If the action requires authentication in the Kwil Gateway, the kwilSigner should be passed. If the user is not authenticated, the user will be prompted to authenticate.
     *
     * @param {CallBodyNode} actionBody - The body of the action to send. This should use the `CallBody` interface.
     * @param {KwilSigner} kwilSigner (optional) - KwilSigner should be passed if the action requires authentication OR if the action uses a `@caller` contextual variable. If `@caller` is used and authentication is not required, the user will not be prompted to authenticate; however, the user's identifier will be passed as the sender.
     * @returns An Object[] with the result of the action
     */
    async call(actionBody, kwilSigner2) {
      const setCookie = () => {
        if (actionBody.cookie) {
          this.setTemporaryCookie(actionBody.cookie);
        }
      };
      const resetCookie = () => {
        if (this.tempCookie) {
          this.resetTempCookie(this.tempCookie);
        }
      };
      const cookieHandler = {
        setCookie,
        resetCookie
      };
      return await this.baseCall(actionBody, kwilSigner2, cookieHandler);
    }
    /**
     * set the temp cookie to reset it after the call
     *
     * @param {string} cookie - The temporary cookie
     * @returns the temporary cookie to handle for Node
     */
    setTemporaryCookie(cookie) {
      this.tempCookie = this.cookie;
      this.cookie = cookie;
    }
    /**
     * Resets the temporary cookie
     *
     * @param {string} tempCookie - the temporary cookie to be reset
     */
    resetTempCookie(tempCookie) {
      this.cookie = tempCookie;
    }
  }
  nodeKwil.NodeKwil = NodeKwil;
  return nodeKwil;
}
var webKwil = {};
var hasRequiredWebKwil;
function requireWebKwil() {
  if (hasRequiredWebKwil) return webKwil;
  hasRequiredWebKwil = 1;
  Object.defineProperty(webKwil, "__esModule", { value: true });
  webKwil.WebKwil = void 0;
  const kwil_1 = requireKwil();
  class WebKwil extends kwil_1.Kwil {
    constructor(opts) {
      super(opts);
    }
    /**
     * Calls a Kwil node. This can be used to execute read-only ('view') actions on Kwil.
     * If the action requires authentication in the Kwil Gateway, the kwilSigner should be passed. If the user is not authenticated, the user will be prompted to authenticate.
     *
     * @param {CallBody} actionBody - The body of the action to send. This should use the `CallBody` interface.
     * @param {KwilSigner} kwilSigner (optional) - KwilSigner should be passed if the action requires authentication OR if the action uses a `@caller` contextual variable. If `@caller` is used and authentication is not required, the user will not be prompted to authenticate; however, the user's identifier will be passed as the sender.
     * @returns An Object[] with the result of the action or a MsgReceipt
     */
    async call(actionBody, kwilSigner2) {
      return await this.baseCall(actionBody, kwilSigner2);
    }
  }
  webKwil.WebKwil = WebKwil;
  return webKwil;
}
var database = {};
var hasRequiredDatabase;
function requireDatabase() {
  if (hasRequiredDatabase) return database;
  hasRequiredDatabase = 1;
  Object.defineProperty(database, "__esModule", { value: true });
  database.DataType = void 0;
  const enums_1 = requireEnums();
  var DataType2;
  (function(DataType3) {
    DataType3.Uuid = {
      name: enums_1.VarType.UUID,
      is_array: false,
      metadata: [0, 0]
    };
    DataType3.UuidArray = {
      name: enums_1.VarType.UUID,
      is_array: true,
      metadata: [0, 0]
    };
    DataType3.Text = {
      name: enums_1.VarType.TEXT,
      is_array: false,
      metadata: [0, 0]
    };
    DataType3.TextArray = {
      name: enums_1.VarType.TEXT,
      is_array: true,
      metadata: [0, 0]
    };
    DataType3.Int = {
      name: enums_1.VarType.INT8,
      is_array: false,
      metadata: [0, 0]
    };
    DataType3.IntArray = {
      name: enums_1.VarType.INT8,
      is_array: true,
      metadata: [0, 0]
    };
    DataType3.Boolean = {
      name: enums_1.VarType.BOOL,
      is_array: false,
      metadata: [0, 0]
    };
    DataType3.BooleanArray = {
      name: enums_1.VarType.BOOL,
      is_array: true,
      metadata: [0, 0]
    };
    DataType3.Numeric = (precision, scale) => ({
      name: enums_1.VarType.NUMERIC,
      is_array: false,
      metadata: [precision, scale]
    });
    DataType3.NumericArray = (precision, scale) => ({
      name: enums_1.VarType.NUMERIC,
      is_array: true,
      metadata: [precision, scale]
    });
    DataType3.Null = {
      name: enums_1.VarType.NULL,
      is_array: false,
      metadata: [0, 0]
    };
    DataType3.NullArray = {
      name: enums_1.VarType.NULL,
      is_array: true,
      metadata: [0, 0]
    };
    DataType3.Bytea = {
      name: enums_1.VarType.BYTEA,
      is_array: false,
      metadata: [0, 0]
    };
    DataType3.ByteaArray = {
      name: enums_1.VarType.BYTEA,
      is_array: true,
      metadata: [0, 0]
    };
  })(DataType2 || (database.DataType = DataType2 = {}));
  return database;
}
var kwilSigner = {};
var hasRequiredKwilSigner;
function requireKwilSigner() {
  if (hasRequiredKwilSigner) return kwilSigner;
  hasRequiredKwilSigner = 1;
  Object.defineProperty(kwilSigner, "__esModule", { value: true });
  kwilSigner.KwilSigner = void 0;
  const serial_12 = requireSerial();
  const signature_1 = requireSignature();
  class KwilSigner {
    /**
     * Actual implementation of the KwilSigner constructor.
     *
     * @param {SignerSupplier} signer - Either an instance of EthSigner or CustomSigner.
     * @param {HexString | Uint8Array} identifier - The identifier associated with the signer (e.g. wallet address, public key, etc). Can be a hex string or bytes (Uint8Array).
     * @param {AnySignatureType} signatureType - (Optional) The type of the signature. If not provided,
     *                        the signature type is determined from the signer.
     */
    constructor(signer, identifier, signatureType) {
      this.signer = signer;
      if (typeof identifier === "string") {
        this.identifier = (0, serial_12.hexToBytes)(identifier);
      } else {
        this.identifier = identifier;
      }
      if (signatureType) {
        this.signatureType = signatureType;
      } else {
        this.signatureType = (0, signature_1.getSignatureType)(signer);
        if (this.signatureType === signature_1.SignatureType.SIGNATURE_TYPE_INVALID) {
          throw new Error("Could not determine signature type from signer. Please pass a signature type to the KwilSigner constructor.");
        }
      }
    }
  }
  kwilSigner.KwilSigner = KwilSigner;
  return kwilSigner;
}
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  (function(exports) {
    var __importDefault = dist && dist.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Client = exports.Utils = exports.KwilSigner = exports.WebKwil = exports.NodeKwil = void 0;
    const nodeKwil_1 = requireNodeKwil();
    Object.defineProperty(exports, "NodeKwil", { enumerable: true, get: function() {
      return nodeKwil_1.NodeKwil;
    } });
    const webKwil_1 = requireWebKwil();
    Object.defineProperty(exports, "WebKwil", { enumerable: true, get: function() {
      return webKwil_1.WebKwil;
    } });
    const dbid_1 = requireDbid();
    const action_1 = requireAction$1();
    const database_1 = requireDatabase();
    const kwilSigner_1 = requireKwilSigner();
    Object.defineProperty(exports, "KwilSigner", { enumerable: true, get: function() {
      return kwilSigner_1.KwilSigner;
    } });
    const client_1 = __importDefault(requireClient());
    exports.Client = client_1.default;
    var Utils;
    (function(Utils2) {
      Utils2.ActionInput = action_1.ActionInput;
      Utils2.generateDBID = dbid_1.generateDBID;
      Utils2.DataType = database_1.DataType;
    })(Utils || (exports.Utils = Utils = {}));
  })(dist);
  return dist;
}
var distExports = requireDist();
function identity(x) {
  return x;
}
function negate(func) {
  return (...args) => !func(...args);
}
function isPrimitive(value) {
  return value == null || typeof value !== "object" && typeof value !== "function";
}
function isTypedArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}
function getSymbols(object) {
  return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
}
function getTag(value) {
  if (value == null) {
    return value === void 0 ? "[object Undefined]" : "[object Null]";
  }
  return Object.prototype.toString.call(value);
}
const regexpTag = "[object RegExp]";
const stringTag = "[object String]";
const numberTag = "[object Number]";
const booleanTag = "[object Boolean]";
const argumentsTag = "[object Arguments]";
const symbolTag = "[object Symbol]";
const dateTag = "[object Date]";
const mapTag = "[object Map]";
const setTag = "[object Set]";
const arrayTag = "[object Array]";
const arrayBufferTag = "[object ArrayBuffer]";
const objectTag = "[object Object]";
const dataViewTag = "[object DataView]";
const uint8ArrayTag = "[object Uint8Array]";
const uint8ClampedArrayTag = "[object Uint8ClampedArray]";
const uint16ArrayTag = "[object Uint16Array]";
const uint32ArrayTag = "[object Uint32Array]";
const int8ArrayTag = "[object Int8Array]";
const int16ArrayTag = "[object Int16Array]";
const int32ArrayTag = "[object Int32Array]";
const float32ArrayTag = "[object Float32Array]";
const float64ArrayTag = "[object Float64Array]";
function cloneDeepWith$1(obj, cloneValue) {
  return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), cloneValue);
}
function cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack = /* @__PURE__ */ new Map(), cloneValue = void 0) {
  const cloned = cloneValue?.(valueToClone, keyToClone, objectToClone, stack);
  if (cloned != null) {
    return cloned;
  }
  if (isPrimitive(valueToClone)) {
    return valueToClone;
  }
  if (stack.has(valueToClone)) {
    return stack.get(valueToClone);
  }
  if (Array.isArray(valueToClone)) {
    const result = new Array(valueToClone.length);
    stack.set(valueToClone, result);
    for (let i = 0; i < valueToClone.length; i++) {
      result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);
    }
    if (Object.hasOwn(valueToClone, "index")) {
      result.index = valueToClone.index;
    }
    if (Object.hasOwn(valueToClone, "input")) {
      result.input = valueToClone.input;
    }
    return result;
  }
  if (valueToClone instanceof Date) {
    return new Date(valueToClone.getTime());
  }
  if (valueToClone instanceof RegExp) {
    const result = new RegExp(valueToClone.source, valueToClone.flags);
    result.lastIndex = valueToClone.lastIndex;
    return result;
  }
  if (valueToClone instanceof Map) {
    const result = /* @__PURE__ */ new Map();
    stack.set(valueToClone, result);
    for (const [key, value] of valueToClone) {
      result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack, cloneValue));
    }
    return result;
  }
  if (valueToClone instanceof Set) {
    const result = /* @__PURE__ */ new Set();
    stack.set(valueToClone, result);
    for (const value of valueToClone) {
      result.add(cloneDeepWithImpl(value, void 0, objectToClone, stack, cloneValue));
    }
    return result;
  }
  if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) {
    return valueToClone.subarray();
  }
  if (isTypedArray(valueToClone)) {
    const result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
    stack.set(valueToClone, result);
    for (let i = 0; i < valueToClone.length; i++) {
      result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);
    }
    return result;
  }
  if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) {
    return valueToClone.slice(0);
  }
  if (valueToClone instanceof DataView) {
    const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
    stack.set(valueToClone, result);
    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
    return result;
  }
  if (typeof File !== "undefined" && valueToClone instanceof File) {
    const result = new File([valueToClone], valueToClone.name, {
      type: valueToClone.type
    });
    stack.set(valueToClone, result);
    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
    return result;
  }
  if (valueToClone instanceof Blob) {
    const result = new Blob([valueToClone], { type: valueToClone.type });
    stack.set(valueToClone, result);
    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
    return result;
  }
  if (valueToClone instanceof Error) {
    const result = new valueToClone.constructor();
    stack.set(valueToClone, result);
    result.message = valueToClone.message;
    result.name = valueToClone.name;
    result.stack = valueToClone.stack;
    result.cause = valueToClone.cause;
    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
    return result;
  }
  if (typeof valueToClone === "object" && isCloneableObject(valueToClone)) {
    const result = Object.create(Object.getPrototypeOf(valueToClone));
    stack.set(valueToClone, result);
    copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
    return result;
  }
  return valueToClone;
}
function copyProperties(target, source, objectToClone = target, stack, cloneValue) {
  const keys2 = [...Object.keys(source), ...getSymbols(source)];
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    const descriptor = Object.getOwnPropertyDescriptor(target, key);
    if (descriptor == null || descriptor.writable) {
      target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue);
    }
  }
}
function isCloneableObject(object) {
  switch (getTag(object)) {
    case argumentsTag:
    case arrayTag:
    case arrayBufferTag:
    case dataViewTag:
    case booleanTag:
    case dateTag:
    case float32ArrayTag:
    case float64ArrayTag:
    case int8ArrayTag:
    case int16ArrayTag:
    case int32ArrayTag:
    case mapTag:
    case numberTag:
    case objectTag:
    case regexpTag:
    case setTag:
    case stringTag:
    case symbolTag:
    case uint8ArrayTag:
    case uint8ClampedArrayTag:
    case uint16ArrayTag:
    case uint32ArrayTag: {
      return true;
    }
    default: {
      return false;
    }
  }
}
function cloneDeep$1(obj) {
  return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);
}
function eq(value, other) {
  return value === other || Number.isNaN(value) && Number.isNaN(other);
}
function isLength(value) {
  return Number.isSafeInteger(value) && value >= 0;
}
function isArrayLike$2(value) {
  return value != null && typeof value !== "function" && isLength(value.length);
}
function isDeepKey(key) {
  switch (typeof key) {
    case "number":
    case "symbol": {
      return false;
    }
    case "string": {
      return key.includes(".") || key.includes("[") || key.includes("]");
    }
  }
}
function toKey(value) {
  if (typeof value === "string" || typeof value === "symbol") {
    return value;
  }
  if (Object.is(value?.valueOf?.(), -0)) {
    return "-0";
  }
  return String(value);
}
function toPath(deepKey) {
  const result = [];
  const length = deepKey.length;
  if (length === 0) {
    return result;
  }
  let index = 0;
  let key = "";
  let quoteChar = "";
  let bracket = false;
  if (deepKey.charCodeAt(0) === 46) {
    result.push("");
    index++;
  }
  while (index < length) {
    const char = deepKey[index];
    if (quoteChar) {
      if (char === "\\" && index + 1 < length) {
        index++;
        key += deepKey[index];
      } else if (char === quoteChar) {
        quoteChar = "";
      } else {
        key += char;
      }
    } else if (bracket) {
      if (char === '"' || char === "'") {
        quoteChar = char;
      } else if (char === "]") {
        bracket = false;
        result.push(key);
        key = "";
      } else {
        key += char;
      }
    } else {
      if (char === "[") {
        bracket = true;
        if (key) {
          result.push(key);
          key = "";
        }
      } else if (char === ".") {
        if (key) {
          result.push(key);
          key = "";
        }
      } else {
        key += char;
      }
    }
    index++;
  }
  if (key) {
    result.push(key);
  }
  return result;
}
function get(object, path, defaultValue) {
  if (object == null) {
    return defaultValue;
  }
  switch (typeof path) {
    case "string": {
      const result = object[path];
      if (result === void 0) {
        if (isDeepKey(path)) {
          return get(object, toPath(path), defaultValue);
        } else {
          return defaultValue;
        }
      }
      return result;
    }
    case "number":
    case "symbol": {
      if (typeof path === "number") {
        path = toKey(path);
      }
      const result = object[path];
      if (result === void 0) {
        return defaultValue;
      }
      return result;
    }
    default: {
      if (Array.isArray(path)) {
        return getWithPath(object, path, defaultValue);
      }
      if (Object.is(path?.valueOf(), -0)) {
        path = "-0";
      } else {
        path = String(path);
      }
      const result = object[path];
      if (result === void 0) {
        return defaultValue;
      }
      return result;
    }
  }
}
function getWithPath(object, path, defaultValue) {
  if (path.length === 0) {
    return defaultValue;
  }
  let current = object;
  for (let index = 0; index < path.length; index++) {
    if (current == null) {
      return defaultValue;
    }
    current = current[path[index]];
  }
  if (current === void 0) {
    return defaultValue;
  }
  return current;
}
function property(path) {
  return function(object) {
    return get(object, path);
  };
}
function isObject(value) {
  return value !== null && (typeof value === "object" || typeof value === "function");
}
function isMatchWith(target, source, compare) {
  compare = typeof compare === "function" ? compare : void 0;
  return isMatchWithInternal(target, source, function doesMatch(objValue, srcValue, key, object, source2, stack) {
    const isEqual = compare?.(objValue, srcValue, key, object, source2, stack);
    if (isEqual !== void 0) {
      return Boolean(isEqual);
    }
    return isMatchWithInternal(objValue, srcValue, doesMatch, stack);
  }, /* @__PURE__ */ new Map());
}
function isMatchWithInternal(target, source, compare, stack) {
  if (source === target) {
    return true;
  }
  switch (typeof source) {
    case "object": {
      return isObjectMatch(target, source, compare, stack);
    }
    case "function": {
      const sourceKeys = Object.keys(source);
      if (sourceKeys.length > 0) {
        return isMatchWithInternal(target, { ...source }, compare, stack);
      }
      return eq(target, source);
    }
    default: {
      if (!isObject(target)) {
        return eq(target, source);
      }
      if (typeof source === "string") {
        return source === "";
      }
      return true;
    }
  }
}
function isObjectMatch(target, source, compare, stack) {
  if (source == null) {
    return true;
  }
  if (Array.isArray(source)) {
    return isArrayMatch(target, source, compare, stack);
  }
  if (source instanceof Map) {
    return isMapMatch(target, source, compare, stack);
  }
  if (source instanceof Set) {
    return isSetMatch(target, source, compare, stack);
  }
  const keys2 = Object.keys(source);
  if (target == null) {
    return keys2.length === 0;
  }
  if (keys2.length === 0) {
    return true;
  }
  if (stack && stack.has(source)) {
    return stack.get(source) === target;
  }
  if (stack) {
    stack.set(source, target);
  }
  try {
    for (let i = 0; i < keys2.length; i++) {
      const key = keys2[i];
      if (!isPrimitive(target) && !(key in target)) {
        return false;
      }
      if (source[key] === void 0 && target[key] !== void 0) {
        return false;
      }
      if (source[key] === null && target[key] !== null) {
        return false;
      }
      const isEqual = compare(target[key], source[key], key, target, source, stack);
      if (!isEqual) {
        return false;
      }
    }
    return true;
  } finally {
    if (stack) {
      stack.delete(source);
    }
  }
}
function isMapMatch(target, source, compare, stack) {
  if (source.size === 0) {
    return true;
  }
  if (!(target instanceof Map)) {
    return false;
  }
  for (const [key, sourceValue] of source.entries()) {
    const targetValue = target.get(key);
    const isEqual = compare(targetValue, sourceValue, key, target, source, stack);
    if (isEqual === false) {
      return false;
    }
  }
  return true;
}
function isArrayMatch(target, source, compare, stack) {
  if (source.length === 0) {
    return true;
  }
  if (!Array.isArray(target)) {
    return false;
  }
  const countedIndex = /* @__PURE__ */ new Set();
  for (let i = 0; i < source.length; i++) {
    const sourceItem = source[i];
    let found = false;
    for (let j = 0; j < target.length; j++) {
      if (countedIndex.has(j)) {
        continue;
      }
      const targetItem = target[j];
      let matches2 = false;
      const isEqual = compare(targetItem, sourceItem, i, target, source, stack);
      if (isEqual) {
        matches2 = true;
      }
      if (matches2) {
        countedIndex.add(j);
        found = true;
        break;
      }
    }
    if (!found) {
      return false;
    }
  }
  return true;
}
function isSetMatch(target, source, compare, stack) {
  if (source.size === 0) {
    return true;
  }
  if (!(target instanceof Set)) {
    return false;
  }
  return isArrayMatch([...target], [...source], compare, stack);
}
function isMatch(target, source) {
  return isMatchWith(target, source);
}
function matches(source) {
  source = cloneDeep$1(source);
  return (target) => {
    return isMatch(target, source);
  };
}
function cloneDeepWith(obj, cloneValue) {
  return cloneDeepWith$1(obj, (value, key, object, stack) => {
    if (typeof obj !== "object") {
      return void 0;
    }
    switch (Object.prototype.toString.call(obj)) {
      case numberTag:
      case stringTag:
      case booleanTag: {
        const result = new obj.constructor(obj?.valueOf());
        copyProperties(result, obj);
        return result;
      }
      case argumentsTag: {
        const result = {};
        copyProperties(result, obj);
        result.length = obj.length;
        result[Symbol.iterator] = obj[Symbol.iterator];
        return result;
      }
      default: {
        return void 0;
      }
    }
  });
}
function cloneDeep(obj) {
  return cloneDeepWith(obj);
}
const IS_UNSIGNED_INTEGER = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length = Number.MAX_SAFE_INTEGER) {
  switch (typeof value) {
    case "number": {
      return Number.isInteger(value) && value >= 0 && value < length;
    }
    case "symbol": {
      return false;
    }
    case "string": {
      return IS_UNSIGNED_INTEGER.test(value);
    }
  }
}
function isArguments(value) {
  return value !== null && typeof value === "object" && getTag(value) === "[object Arguments]";
}
function has(object, path) {
  let resolvedPath;
  if (Array.isArray(path)) {
    resolvedPath = path;
  } else if (typeof path === "string" && isDeepKey(path) && object?.[path] == null) {
    resolvedPath = toPath(path);
  } else {
    resolvedPath = [path];
  }
  if (resolvedPath.length === 0) {
    return false;
  }
  let current = object;
  for (let i = 0; i < resolvedPath.length; i++) {
    const key = resolvedPath[i];
    if (current == null || !Object.hasOwn(current, key)) {
      const isSparseIndex = (Array.isArray(current) || isArguments(current)) && isIndex(key) && key < current.length;
      if (!isSparseIndex) {
        return false;
      }
    }
    current = current[key];
  }
  return true;
}
function matchesProperty(property2, source) {
  switch (typeof property2) {
    case "object": {
      if (Object.is(property2?.valueOf(), -0)) {
        property2 = "-0";
      }
      break;
    }
    case "number": {
      property2 = toKey(property2);
      break;
    }
  }
  source = cloneDeep(source);
  return function(target) {
    const result = get(target, property2);
    if (result === void 0) {
      return has(target, property2);
    }
    if (source === void 0) {
      return result === void 0;
    }
    return isMatch(result, source);
  };
}
function every(source, doesMatch, guard) {
  if (!source) {
    return true;
  }
  if (!doesMatch) {
    doesMatch = identity;
  }
  let predicate;
  switch (typeof doesMatch) {
    case "function": {
      predicate = doesMatch;
      break;
    }
    case "object": {
      if (Array.isArray(doesMatch) && doesMatch.length === 2) {
        const key = doesMatch[0];
        const value = doesMatch[1];
        predicate = matchesProperty(key, value);
      } else {
        predicate = matches(doesMatch);
      }
      break;
    }
    case "symbol":
    case "number":
    case "string": {
      predicate = property(doesMatch);
    }
  }
  if (!isArrayLike$2(source)) {
    const keys2 = Object.keys(source);
    for (let i = 0; i < keys2.length; i++) {
      const key = keys2[i];
      const value = source[key];
      if (!predicate(value, key, source)) {
        return false;
      }
    }
    return true;
  }
  for (let i = 0; i < source.length; i++) {
    if (!predicate(source[i], i, source)) {
      return false;
    }
  }
  return true;
}
var __create$1 = Object.create;
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$1 = Object.getOwnPropertyNames;
var __getProtoOf$1 = Object.getPrototypeOf;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __commonJS$1 = (cb, mod$1) => function() {
  return mod$1 || (0, cb[__getOwnPropNames$1(cb)[0]])((mod$1 = { exports: {} }).exports, mod$1), mod$1.exports;
};
var __copyProps$1 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") for (var keys2 = __getOwnPropNames$1(from), i = 0, n = keys2.length, key; i < n; i++) {
    key = keys2[i];
    if (!__hasOwnProp$1.call(to, key) && key !== except) __defProp$1(to, key, {
      get: ((k) => from[k]).bind(null, key),
      enumerable: !(desc = __getOwnPropDesc$1(from, key)) || desc.enumerable
    });
  }
  return to;
};
var __toESM$1 = (mod$1, isNodeMode, target) => (target = mod$1 != null ? __create$1(__getProtoOf$1(mod$1)) : {}, __copyProps$1(__defProp$1(target, "default", {
  value: mod$1,
  enumerable: true
}), mod$1));
var __require$1 = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, { get: (a, b) => (typeof require !== "undefined" ? require : a)[b] }) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Calling `require` for "' + x + "\" in an environment that doesn't expose the `require` function.");
});
function encodeNibble$1(b) {
  let result = b + 48;
  result += 9 - b >>> 8 & 7;
  return String.fromCharCode(result);
}
function encodeNibbleLower$1(b) {
  let result = b + 48;
  result += 9 - b >>> 8 & 39;
  return String.fromCharCode(result);
}
function encode$2$1(data2, lowerCase = false) {
  const enc = lowerCase ? encodeNibbleLower$1 : encodeNibble$1;
  let s = "";
  for (let i = 0; i < data2.length; i++) {
    s += enc(data2[i] >>> 4);
    s += enc(data2[i] & 15);
  }
  return s;
}
function writeUint16BE$1(value, out = new Uint8Array(2), offset = 0) {
  out[offset + 0] = value >>> 8;
  out[offset + 1] = value >>> 0;
  return out;
}
function readUint32BE$1(array, offset = 0) {
  return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
}
function writeUint32BE$1(value, out = new Uint8Array(4), offset = 0) {
  out[offset + 0] = value >>> 24;
  out[offset + 1] = value >>> 16;
  out[offset + 2] = value >>> 8;
  out[offset + 3] = value >>> 0;
  return out;
}
function wipe$1(array) {
  for (let i = 0; i < array.length; i++) array[i] = 0;
  return array;
}
const DIGEST_LENGTH$1 = 32;
const BLOCK_SIZE$1 = 64;
var SHA256$1$1 = class SHA256$1 {
  /** Length of hash output */
  digestLength = DIGEST_LENGTH$1;
  /** Block size */
  blockSize = BLOCK_SIZE$1;
  _state = new Int32Array(8);
  _temp = new Int32Array(64);
  _buffer = new Uint8Array(128);
  _bufferLength = 0;
  _bytesHashed = 0;
  _finished = false;
  constructor() {
    this.reset();
  }
  _initState() {
    this._state[0] = 1779033703;
    this._state[1] = 3144134277;
    this._state[2] = 1013904242;
    this._state[3] = 2773480762;
    this._state[4] = 1359893119;
    this._state[5] = 2600822924;
    this._state[6] = 528734635;
    this._state[7] = 1541459225;
  }
  /**
  * Resets hash state making it possible
  * to re-use this instance to hash other data.
  */
  reset() {
    this._initState();
    this._bufferLength = 0;
    this._bytesHashed = 0;
    this._finished = false;
    return this;
  }
  /**
  * Cleans internal buffers and resets hash state.
  */
  clean() {
    wipe$1(this._buffer);
    wipe$1(this._temp);
    this.reset();
  }
  /**
  * Updates hash state with the given data.
  *
  * Throws error when trying to update already finalized hash:
  * instance must be reset to update it again.
  */
  update(data2, dataLength = data2.length) {
    if (this._finished) throw new Error("SHA256: can't update because hash was finished.");
    let dataPos = 0;
    this._bytesHashed += dataLength;
    if (this._bufferLength > 0) {
      while (this._bufferLength < this.blockSize && dataLength > 0) {
        this._buffer[this._bufferLength++] = data2[dataPos++];
        dataLength--;
      }
      if (this._bufferLength === this.blockSize) {
        hashBlocks$1(this._temp, this._state, this._buffer, 0, this.blockSize);
        this._bufferLength = 0;
      }
    }
    if (dataLength >= this.blockSize) {
      dataPos = hashBlocks$1(this._temp, this._state, data2, dataPos, dataLength);
      dataLength %= this.blockSize;
    }
    while (dataLength > 0) {
      this._buffer[this._bufferLength++] = data2[dataPos++];
      dataLength--;
    }
    return this;
  }
  /**
  * Finalizes hash state and puts hash into out.
  * If hash was already finalized, puts the same value.
  */
  finish(out) {
    if (!this._finished) {
      const bytesHashed = this._bytesHashed;
      const left = this._bufferLength;
      const bitLenHi = bytesHashed / 536870912 | 0;
      const bitLenLo = bytesHashed << 3;
      const padLength = bytesHashed % 64 < 56 ? 64 : 128;
      this._buffer[left] = 128;
      for (let i = left + 1; i < padLength - 8; i++) this._buffer[i] = 0;
      writeUint32BE$1(bitLenHi, this._buffer, padLength - 8);
      writeUint32BE$1(bitLenLo, this._buffer, padLength - 4);
      hashBlocks$1(this._temp, this._state, this._buffer, 0, padLength);
      this._finished = true;
    }
    for (let i = 0; i < this.digestLength / 4; i++) writeUint32BE$1(this._state[i], out, i * 4);
    return this;
  }
  /**
  * Returns the final hash digest.
  */
  digest() {
    const out = new Uint8Array(this.digestLength);
    this.finish(out);
    return out;
  }
  /**
  * Function useful for HMAC/PBKDF2 optimization.
  * Returns hash state to be used with restoreState().
  * Only chain value is saved, not buffers or other
  * state variables.
  */
  saveState() {
    if (this._finished) throw new Error("SHA256: cannot save finished state");
    return {
      state: new Int32Array(this._state),
      buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
      bufferLength: this._bufferLength,
      bytesHashed: this._bytesHashed
    };
  }
  /**
  * Function useful for HMAC/PBKDF2 optimization.
  * Restores state saved by saveState() and sets bytesHashed
  * to the given value.
  */
  restoreState(savedState) {
    this._state.set(savedState.state);
    this._bufferLength = savedState.bufferLength;
    if (savedState.buffer) this._buffer.set(savedState.buffer);
    this._bytesHashed = savedState.bytesHashed;
    this._finished = false;
    return this;
  }
  /**
  * Cleans state returned by saveState().
  */
  cleanSavedState(savedState) {
    wipe$1(savedState.state);
    if (savedState.buffer) wipe$1(savedState.buffer);
    savedState.bufferLength = 0;
    savedState.bytesHashed = 0;
  }
};
const K$1 = new Int32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
function hashBlocks$1(w, v, p, pos, len) {
  while (len >= 64) {
    let a = v[0];
    let b = v[1];
    let c = v[2];
    let d = v[3];
    let e = v[4];
    let f = v[5];
    let g = v[6];
    let h = v[7];
    for (let i = 0; i < 16; i++) {
      let j = pos + i * 4;
      w[i] = readUint32BE$1(p, j);
    }
    for (let i = 16; i < 64; i++) {
      let u = w[i - 2];
      let t1 = (u >>> 17 | u << 15) ^ (u >>> 19 | u << 13) ^ u >>> 10;
      u = w[i - 15];
      let t2 = (u >>> 7 | u << 25) ^ (u >>> 18 | u << 14) ^ u >>> 3;
      w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);
    }
    for (let i = 0; i < 64; i++) {
      let t1 = (((e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7)) + (e & f ^ ~e & g) | 0) + (h + (K$1[i] + w[i] | 0) | 0) | 0;
      let t2 = ((a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10)) + (a & b ^ a & c ^ b & c) | 0;
      h = g;
      g = f;
      f = e;
      e = d + t1 | 0;
      d = c;
      c = b;
      b = a;
      a = t1 + t2 | 0;
    }
    v[0] += a;
    v[1] += b;
    v[2] += c;
    v[3] += d;
    v[4] += e;
    v[5] += f;
    v[6] += g;
    v[7] += h;
    pos += 64;
    len -= 64;
  }
  return pos;
}
function hash$1(data2) {
  const h = new SHA256$1$1();
  h.update(data2);
  const digest = h.digest();
  h.clean();
  return digest;
}
const INVALID_UTF16$1 = "utf8: invalid string";
const INVALID_UTF8$1 = "utf8: invalid source encoding";
function encode$1$1(s) {
  const arr = new Uint8Array(encodedLength$1(s));
  let pos = 0;
  for (let i = 0; i < s.length; i++) {
    let c = s.charCodeAt(i);
    if (c >= 55296 && c <= 56319) c = (c - 55296 << 10) + (s.charCodeAt(++i) - 56320) + 65536;
    if (c < 128) arr[pos++] = c;
    else if (c < 2048) {
      arr[pos++] = 192 | c >> 6;
      arr[pos++] = 128 | c & 63;
    } else if (c < 65536) {
      arr[pos++] = 224 | c >> 12;
      arr[pos++] = 128 | c >> 6 & 63;
      arr[pos++] = 128 | c & 63;
    } else {
      arr[pos++] = 240 | c >> 18;
      arr[pos++] = 128 | c >> 12 & 63;
      arr[pos++] = 128 | c >> 6 & 63;
      arr[pos++] = 128 | c & 63;
    }
  }
  return arr;
}
function encodedLength$1(s) {
  let result = 0;
  for (let i = 0; i < s.length; i++) {
    let c = s.charCodeAt(i);
    if (c >= 55296 && c <= 56319) {
      if (i === s.length - 1) throw new Error(INVALID_UTF16$1);
      i++;
      const c2 = s.charCodeAt(i);
      if (c2 < 56320 || c2 > 57343) throw new Error(INVALID_UTF16$1);
      c = (c - 55296 << 10) + (c2 - 56320) + 65536;
    }
    if (c < 128) result += 1;
    else if (c < 2048) result += 2;
    else if (c < 65536) result += 3;
    else result += 4;
  }
  return result;
}
function decode$1$1(arr) {
  const chars = [];
  for (let i = 0; i < arr.length; i++) {
    let b = arr[i];
    if (b & 128) {
      let min2;
      if (b < 224) {
        if (i >= arr.length) throw new Error(INVALID_UTF8$1);
        const n1 = arr[++i];
        if ((n1 & 192) !== 128) throw new Error(INVALID_UTF8$1);
        b = (b & 31) << 6 | n1 & 63;
        min2 = 128;
      } else if (b < 240) {
        if (i >= arr.length - 1) throw new Error(INVALID_UTF8$1);
        const n1 = arr[++i];
        const n2 = arr[++i];
        if ((n1 & 192) !== 128 || (n2 & 192) !== 128) throw new Error(INVALID_UTF8$1);
        b = (b & 15) << 12 | (n1 & 63) << 6 | n2 & 63;
        min2 = 2048;
      } else if (b < 248) {
        if (i >= arr.length - 2) throw new Error(INVALID_UTF8$1);
        const n1 = arr[++i];
        const n2 = arr[++i];
        const n3 = arr[++i];
        if ((n1 & 192) !== 128 || (n2 & 192) !== 128 || (n3 & 192) !== 128) throw new Error(INVALID_UTF8$1);
        b = (b & 15) << 18 | (n1 & 63) << 12 | (n2 & 63) << 6 | n3 & 63;
        min2 = 65536;
      } else throw new Error(INVALID_UTF8$1);
      if (b < min2 || b >= 55296 && b <= 57343) throw new Error(INVALID_UTF8$1);
      if (b >= 65536) {
        if (b > 1114111) throw new Error(INVALID_UTF8$1);
        b -= 65536;
        chars.push(String.fromCharCode(55296 | b >> 10));
        b = 56320 | b & 1023;
      }
    }
    chars.push(String.fromCharCode(b));
  }
  return chars.join("");
}
function base$1(ALPHABET$12) {
  if (ALPHABET$12.length >= 255) throw new TypeError("Alphabet too long");
  const BASE_MAP = new Uint8Array(256);
  for (let j = 0; j < BASE_MAP.length; j++) BASE_MAP[j] = 255;
  for (let i = 0; i < ALPHABET$12.length; i++) {
    const x = ALPHABET$12.charAt(i);
    const xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) throw new TypeError(x + " is ambiguous");
    BASE_MAP[xc] = i;
  }
  const BASE = ALPHABET$12.length;
  const LEADER = ALPHABET$12.charAt(0);
  const FACTOR = Math.log(BASE) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE);
  function encode$5(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    else if (Array.isArray(source)) source = Uint8Array.from(source);
    if (!(source instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (source.length === 0) return "";
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i = 0;
      for (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) throw new Error("Non-zero carry");
      length = i;
      pbegin++;
    }
    let it2 = size - length;
    while (it2 !== size && b58[it2] === 0) it2++;
    let str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) str += ALPHABET$12.charAt(b58[it2]);
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") throw new TypeError("Expected String");
    if (source.length === 0) return new Uint8Array();
    let psz = 0;
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size);
    while (source[psz]) {
      let carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) return;
      let i = 0;
      for (let it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) throw new Error("Non-zero carry");
      length = i;
      psz++;
    }
    let it4 = size - length;
    while (it4 !== size && b256[it4] === 0) it4++;
    const vch = new Uint8Array(zeroes + (size - it4));
    let j = zeroes;
    while (it4 !== size) vch[j++] = b256[it4++];
    return vch;
  }
  function decode$5(string) {
    const buffer = decodeUnsafe(string);
    if (buffer) return buffer;
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode: encode$5,
    decodeUnsafe,
    decode: decode$5
  };
}
var esm_default$1$1 = base$1;
var ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default$2 = esm_default$1$1(ALPHABET$1);
const INVALID_BYTE$1 = 256;
var Coder$1 = class Coder {
  _paddingCharacter;
  constructor(_paddingCharacter = "=") {
    this._paddingCharacter = _paddingCharacter;
  }
  encodedLength(length) {
    if (!this._paddingCharacter) return (length * 8 + 5) / 6 | 0;
    return (length + 2) / 3 * 4 | 0;
  }
  encode(data2) {
    let out = "";
    let i = 0;
    for (; i < data2.length - 2; i += 3) {
      let c = data2[i] << 16 | data2[i + 1] << 8 | data2[i + 2];
      out += this._encodeByte(c >>> 3 * 6 & 63);
      out += this._encodeByte(c >>> 2 * 6 & 63);
      out += this._encodeByte(c >>> 1 * 6 & 63);
      out += this._encodeByte(c >>> 0 & 63);
    }
    const left = data2.length - i;
    if (left > 0) {
      let c = data2[i] << 16 | (left === 2 ? data2[i + 1] << 8 : 0);
      out += this._encodeByte(c >>> 3 * 6 & 63);
      out += this._encodeByte(c >>> 2 * 6 & 63);
      if (left === 2) out += this._encodeByte(c >>> 1 * 6 & 63);
      else out += this._paddingCharacter || "";
      out += this._paddingCharacter || "";
    }
    return out;
  }
  maxDecodedLength(length) {
    if (!this._paddingCharacter) return (length * 6 + 7) / 8 | 0;
    return length / 4 * 3 | 0;
  }
  decodedLength(s) {
    return this.maxDecodedLength(s.length - this._getPaddingLength(s));
  }
  decode(s) {
    if (s.length === 0) return new Uint8Array(0);
    const paddingLength = this._getPaddingLength(s);
    const length = s.length - paddingLength;
    const out = new Uint8Array(this.maxDecodedLength(length));
    let op = 0;
    let i = 0;
    let haveBad = 0;
    let v0 = 0, v12 = 0, v2 = 0, v32 = 0;
    for (; i < length - 4; i += 4) {
      v0 = this._decodeChar(s.charCodeAt(i + 0));
      v12 = this._decodeChar(s.charCodeAt(i + 1));
      v2 = this._decodeChar(s.charCodeAt(i + 2));
      v32 = this._decodeChar(s.charCodeAt(i + 3));
      out[op++] = v0 << 2 | v12 >>> 4;
      out[op++] = v12 << 4 | v2 >>> 2;
      out[op++] = v2 << 6 | v32;
      haveBad |= v0 & INVALID_BYTE$1;
      haveBad |= v12 & INVALID_BYTE$1;
      haveBad |= v2 & INVALID_BYTE$1;
      haveBad |= v32 & INVALID_BYTE$1;
    }
    if (i < length - 1) {
      v0 = this._decodeChar(s.charCodeAt(i));
      v12 = this._decodeChar(s.charCodeAt(i + 1));
      out[op++] = v0 << 2 | v12 >>> 4;
      haveBad |= v0 & INVALID_BYTE$1;
      haveBad |= v12 & INVALID_BYTE$1;
    }
    if (i < length - 2) {
      v2 = this._decodeChar(s.charCodeAt(i + 2));
      out[op++] = v12 << 4 | v2 >>> 2;
      haveBad |= v2 & INVALID_BYTE$1;
    }
    if (i < length - 3) {
      v32 = this._decodeChar(s.charCodeAt(i + 3));
      out[op++] = v2 << 6 | v32;
      haveBad |= v32 & INVALID_BYTE$1;
    }
    if (haveBad !== 0) throw new Error("Base64Coder: incorrect characters for decoding");
    return out;
  }
  _encodeByte(b) {
    let result = b;
    result += 65;
    result += 25 - b >>> 8 & 6;
    result += 51 - b >>> 8 & -75;
    result += 61 - b >>> 8 & -15;
    result += 62 - b >>> 8 & 3;
    return String.fromCharCode(result);
  }
  _decodeChar(c) {
    let result = INVALID_BYTE$1;
    result += (42 - c & c - 44) >>> 8 & -256 + c - 43 + 62;
    result += (46 - c & c - 48) >>> 8 & -256 + c - 47 + 63;
    result += (47 - c & c - 58) >>> 8 & -256 + c - 48 + 52;
    result += (64 - c & c - 91) >>> 8 & -256 + c - 65 + 0;
    result += (96 - c & c - 123) >>> 8 & -256 + c - 97 + 26;
    return result;
  }
  _getPaddingLength(s) {
    let paddingLength = 0;
    if (this._paddingCharacter) {
      for (let i = s.length - 1; i >= 0; i--) {
        if (s[i] !== this._paddingCharacter) break;
        paddingLength++;
      }
      if (s.length < 4 || paddingLength > 2) throw new Error("Base64Coder: incorrect padding");
    }
    return paddingLength;
  }
};
const stdCoder$1 = new Coder$1();
function encode$3(data2) {
  return stdCoder$1.encode(data2);
}
function decode$3(s) {
  return stdCoder$1.decode(s);
}
function concat$1(...arrays) {
  let totalLength = 0;
  for (let i = 0; i < arrays.length; i++) totalLength += arrays[i].length;
  const result = new Uint8Array(totalLength);
  let offset = 0;
  for (let i = 0; i < arrays.length; i++) {
    const arg = arrays[i];
    result.set(arg, offset);
    offset += arg.length;
  }
  return result;
}
var integers$1 = [
  "u8",
  "u16",
  "u32",
  "u64",
  "u128",
  "i8",
  "i16",
  "i32",
  "i64",
  "i128",
  "f32",
  "f64"
];
var EncodeBuffer$1 = function() {
  function EncodeBuffer$12() {
    this.offset = 0;
    this.buffer_size = 256;
    this.buffer = new ArrayBuffer(this.buffer_size);
    this.view = new DataView(this.buffer);
  }
  EncodeBuffer$12.prototype.resize_if_necessary = function(needed_space) {
    if (this.buffer_size - this.offset < needed_space) {
      this.buffer_size = Math.max(this.buffer_size * 2, this.buffer_size + needed_space);
      var new_buffer = new ArrayBuffer(this.buffer_size);
      new Uint8Array(new_buffer).set(new Uint8Array(this.buffer));
      this.buffer = new_buffer;
      this.view = new DataView(new_buffer);
    }
  };
  EncodeBuffer$12.prototype.get_used_buffer = function() {
    return new Uint8Array(this.buffer).slice(0, this.offset);
  };
  EncodeBuffer$12.prototype.store_value = function(value, type2) {
    var bSize = type2.substring(1);
    var size = parseInt(bSize) / 8;
    this.resize_if_necessary(size);
    var toCall = type2[0] === "f" ? "setFloat".concat(bSize) : type2[0] === "i" ? "setInt".concat(bSize) : "setUint".concat(bSize);
    this.view[toCall](this.offset, value, true);
    this.offset += size;
  };
  EncodeBuffer$12.prototype.store_bytes = function(from) {
    this.resize_if_necessary(from.length);
    new Uint8Array(this.buffer).set(new Uint8Array(from), this.offset);
    this.offset += from.length;
  };
  return EncodeBuffer$12;
}();
var __extends$1 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$1, b$1) {
      d$1.__proto__ = b$1;
    } || function(d$1, b$1) {
      for (var p in b$1) if (Object.prototype.hasOwnProperty.call(b$1, p)) d$1[p] = b$1[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
function isArrayLike$1(value) {
  return Array.isArray(value) || !!value && typeof value === "object" && "length" in value && typeof value.length === "number" && (value.length === 0 || value.length > 0 && value.length - 1 in value);
}
function expect_type$1(value, type2, fieldPath) {
  if (typeof value !== type2) throw new Error("Expected ".concat(type2, " not ").concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
}
function expect_bigint$1(value, fieldPath) {
  var basicType = [
    "number",
    "string",
    "bigint",
    "boolean"
  ].includes(typeof value);
  var strObject = typeof value === "object" && value !== null && "toString" in value;
  if (!basicType && !strObject) throw new Error("Expected bigint, number, boolean or string not ".concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
}
function expect_same_size$1(length, expected, fieldPath) {
  if (length !== expected) throw new Error("Array length ".concat(length, " does not match schema length ").concat(expected, " at ").concat(fieldPath.join(".")));
}
function expect_enum$1(value, fieldPath) {
  if (typeof value !== "object" || value === null) throw new Error("Expected object not ".concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
}
var VALID_STRING_TYPES$1 = integers$1.concat(["bool", "string"]);
var VALID_OBJECT_KEYS$1 = [
  "option",
  "enum",
  "array",
  "set",
  "map",
  "struct"
];
var ErrorSchema$1 = function(_super) {
  __extends$1(ErrorSchema$12, _super);
  function ErrorSchema$12(schema, expected) {
    var message2 = "Invalid schema: ".concat(JSON.stringify(schema), " expected ").concat(expected);
    return _super.call(this, message2) || this;
  }
  return ErrorSchema$12;
}(Error);
function validate_schema$1(schema) {
  if (typeof schema === "string" && VALID_STRING_TYPES$1.includes(schema)) return;
  if (schema && typeof schema === "object") {
    var keys2 = Object.keys(schema);
    if (keys2.length === 1 && VALID_OBJECT_KEYS$1.includes(keys2[0])) {
      var key = keys2[0];
      if (key === "option") return validate_schema$1(schema[key]);
      if (key === "enum") return validate_enum_schema$1(schema[key]);
      if (key === "array") return validate_array_schema$1(schema[key]);
      if (key === "set") return validate_schema$1(schema[key]);
      if (key === "map") return validate_map_schema$1(schema[key]);
      if (key === "struct") return validate_struct_schema$1(schema[key]);
    }
  }
  throw new ErrorSchema$1(schema, VALID_OBJECT_KEYS$1.join(", ") + " or " + VALID_STRING_TYPES$1.join(", "));
}
function validate_enum_schema$1(schema) {
  if (!Array.isArray(schema)) throw new ErrorSchema$1(schema, "Array");
  for (var _i = 0, schema_1 = schema; _i < schema_1.length; _i++) {
    var sch = schema_1[_i];
    if (typeof sch !== "object" || !("struct" in sch)) throw new Error('Missing "struct" key in enum schema');
    if (typeof sch.struct !== "object" || Object.keys(sch.struct).length !== 1) throw new Error('The "struct" in each enum must have a single key');
    validate_schema$1({ struct: sch.struct });
  }
}
function validate_array_schema$1(schema) {
  if (typeof schema !== "object") throw new ErrorSchema$1(schema, "{ type, len? }");
  if (schema.len && typeof schema.len !== "number") throw new Error("Invalid schema: ".concat(schema));
  if ("type" in schema) return validate_schema$1(schema.type);
  throw new ErrorSchema$1(schema, "{ type, len? }");
}
function validate_map_schema$1(schema) {
  if (typeof schema === "object" && "key" in schema && "value" in schema) {
    validate_schema$1(schema.key);
    validate_schema$1(schema.value);
  } else throw new ErrorSchema$1(schema, "{ key, value }");
}
function validate_struct_schema$1(schema) {
  if (typeof schema !== "object") throw new ErrorSchema$1(schema, "object");
  for (var key in schema) validate_schema$1(schema[key]);
}
var BorshSerializer$1 = function() {
  function BorshSerializer$12(checkTypes) {
    this.encoded = new EncodeBuffer$1();
    this.fieldPath = ["value"];
    this.checkTypes = checkTypes;
  }
  BorshSerializer$12.prototype.encode = function(value, schema) {
    this.encode_value(value, schema);
    return this.encoded.get_used_buffer();
  };
  BorshSerializer$12.prototype.encode_value = function(value, schema) {
    if (typeof schema === "string") {
      if (integers$1.includes(schema)) return this.encode_integer(value, schema);
      if (schema === "string") return this.encode_string(value);
      if (schema === "bool") return this.encode_boolean(value);
    }
    if (typeof schema === "object") {
      if ("option" in schema) return this.encode_option(value, schema);
      if ("enum" in schema) return this.encode_enum(value, schema);
      if ("array" in schema) return this.encode_array(value, schema);
      if ("set" in schema) return this.encode_set(value, schema);
      if ("map" in schema) return this.encode_map(value, schema);
      if ("struct" in schema) return this.encode_struct(value, schema);
    }
  };
  BorshSerializer$12.prototype.encode_integer = function(value, schema) {
    var size = parseInt(schema.substring(1));
    if (size <= 32 || schema == "f64") {
      this.checkTypes && expect_type$1(value, "number", this.fieldPath);
      this.encoded.store_value(value, schema);
    } else {
      this.checkTypes && expect_bigint$1(value, this.fieldPath);
      this.encode_bigint(BigInt(value), size);
    }
  };
  BorshSerializer$12.prototype.encode_bigint = function(value, size) {
    var buffer_len = size / 8;
    var buffer = new Uint8Array(buffer_len);
    for (var i = 0; i < buffer_len; i++) {
      buffer[i] = Number(value & BigInt(255));
      value = value >> BigInt(8);
    }
    this.encoded.store_bytes(new Uint8Array(buffer));
  };
  BorshSerializer$12.prototype.encode_string = function(value) {
    this.checkTypes && expect_type$1(value, "string", this.fieldPath);
    var _value = value;
    var utf8Bytes = [];
    for (var i = 0; i < _value.length; i++) {
      var charCode = _value.charCodeAt(i);
      if (charCode < 128) utf8Bytes.push(charCode);
      else if (charCode < 2048) utf8Bytes.push(192 | charCode >> 6, 128 | charCode & 63);
      else if (charCode < 55296 || charCode >= 57344) utf8Bytes.push(224 | charCode >> 12, 128 | charCode >> 6 & 63, 128 | charCode & 63);
      else {
        i++;
        charCode = 65536 + ((charCode & 1023) << 10 | _value.charCodeAt(i) & 1023);
        utf8Bytes.push(240 | charCode >> 18, 128 | charCode >> 12 & 63, 128 | charCode >> 6 & 63, 128 | charCode & 63);
      }
    }
    this.encoded.store_value(utf8Bytes.length, "u32");
    this.encoded.store_bytes(new Uint8Array(utf8Bytes));
  };
  BorshSerializer$12.prototype.encode_boolean = function(value) {
    this.checkTypes && expect_type$1(value, "boolean", this.fieldPath);
    this.encoded.store_value(value ? 1 : 0, "u8");
  };
  BorshSerializer$12.prototype.encode_option = function(value, schema) {
    if (value === null || value === void 0) this.encoded.store_value(0, "u8");
    else {
      this.encoded.store_value(1, "u8");
      this.encode_value(value, schema.option);
    }
  };
  BorshSerializer$12.prototype.encode_enum = function(value, schema) {
    this.checkTypes && expect_enum$1(value, this.fieldPath);
    var valueKey = Object.keys(value)[0];
    for (var i = 0; i < schema["enum"].length; i++) {
      var valueSchema = schema["enum"][i];
      if (valueKey === Object.keys(valueSchema.struct)[0]) {
        this.encoded.store_value(i, "u8");
        return this.encode_struct(value, valueSchema);
      }
    }
    throw new Error("Enum key (".concat(valueKey, ") not found in enum schema: ").concat(JSON.stringify(schema), " at ").concat(this.fieldPath.join(".")));
  };
  BorshSerializer$12.prototype.encode_array = function(value, schema) {
    if (isArrayLike$1(value)) return this.encode_arraylike(value, schema);
    if (value instanceof ArrayBuffer) return this.encode_buffer(value, schema);
    throw new Error("Expected Array-like not ".concat(typeof value, "(").concat(value, ") at ").concat(this.fieldPath.join(".")));
  };
  BorshSerializer$12.prototype.encode_arraylike = function(value, schema) {
    if (schema.array.len) expect_same_size$1(value.length, schema.array.len, this.fieldPath);
    else this.encoded.store_value(value.length, "u32");
    for (var i = 0; i < value.length; i++) this.encode_value(value[i], schema.array.type);
  };
  BorshSerializer$12.prototype.encode_buffer = function(value, schema) {
    if (schema.array.len) expect_same_size$1(value.byteLength, schema.array.len, this.fieldPath);
    else this.encoded.store_value(value.byteLength, "u32");
    this.encoded.store_bytes(new Uint8Array(value));
  };
  BorshSerializer$12.prototype.encode_set = function(value, schema) {
    this.checkTypes && expect_type$1(value, "object", this.fieldPath);
    var isSet = value instanceof Set;
    var values = isSet ? Array.from(value.values()) : Object.values(value);
    this.encoded.store_value(values.length, "u32");
    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
      var value_1 = values_1[_i];
      this.encode_value(value_1, schema.set);
    }
  };
  BorshSerializer$12.prototype.encode_map = function(value, schema) {
    this.checkTypes && expect_type$1(value, "object", this.fieldPath);
    var isMap = value instanceof Map;
    var keys2 = isMap ? Array.from(value.keys()) : Object.keys(value);
    this.encoded.store_value(keys2.length, "u32");
    for (var _i = 0, keys_1 = keys2; _i < keys_1.length; _i++) {
      var key = keys_1[_i];
      this.encode_value(key, schema.map.key);
      this.encode_value(isMap ? value.get(key) : value[key], schema.map.value);
    }
  };
  BorshSerializer$12.prototype.encode_struct = function(value, schema) {
    this.checkTypes && expect_type$1(value, "object", this.fieldPath);
    for (var _i = 0, _a = Object.keys(schema.struct); _i < _a.length; _i++) {
      var key = _a[_i];
      this.fieldPath.push(key);
      this.encode_value(value[key], schema.struct[key]);
      this.fieldPath.pop();
    }
  };
  return BorshSerializer$12;
}();
function serialize$1(schema, value, validate$1) {
  if (validate$1 === void 0) validate$1 = true;
  if (validate$1) validate_schema$1(schema);
  var serializer = new BorshSerializer$1(validate$1);
  return serializer.encode(value, schema);
}
function hexEncodeSha256Hash$1(data2) {
  return encode$2$1(hash$1(data2), true);
}
function bs58Decode$1(data2) {
  return esm_default$2.decode(data2);
}
async function getAttributes(kwilClient) {
  return kwilClient.call({
    name: "get_attributes",
    inputs: {}
  });
}
async function createAttribute(kwilClient, attribute) {
  await kwilClient.execute({
    name: "add_attribute",
    description: "Create a new attribute in your idOS profile",
    inputs: attribute
  });
  return attribute;
}
async function getSharedCredential$2(kwilClient, id) {
  const [credential] = await kwilClient.call({
    name: "get_credential_shared",
    inputs: { id }
  });
  return credential;
}
async function getCredentialOwned(kwilClient, id) {
  const [credential] = await kwilClient.call({
    name: "get_credential_owned",
    inputs: { id }
  });
  return credential;
}
async function getAllCredentials(kwilClient) {
  return kwilClient.call({
    name: "get_credentials",
    inputs: {}
  });
}
async function removeCredential(kwilClient, id) {
  await kwilClient.execute({
    name: "remove_credential",
    description: "Remove a credential from your idOS profile",
    inputs: { id }
  });
  return { id };
}
async function getCredentialById(kwilClient, id) {
  const response = await kwilClient.call({
    name: "get_credential_owned",
    inputs: { id }
  });
  return response.find((r) => r.id === id);
}
async function shareCredential(kwilClient, credential) {
  await kwilClient.execute({
    name: "share_credential",
    description: "Share a credential with another user on idOS",
    inputs: credential
  });
  return credential;
}
async function createCredentialCopy(kwilClient, params) {
  await kwilClient.execute({
    name: "create_credential_copy",
    description: "Share a credential with another user on idOS",
    inputs: params
  });
  return params;
}
async function getGrantsCount$1(kwilClient, params = { user_id: null }) {
  const [{ count }] = await kwilClient.call({
    name: "get_access_grants_granted_count",
    inputs: params
  });
  return count;
}
const GET_GRANTS_DEFAULT_RECORDS_PER_PAGE$1 = 10;
async function getGrants$1(kwilClient, params = {
  page: 1,
  size: GET_GRANTS_DEFAULT_RECORDS_PER_PAGE$1,
  user_id: null
}) {
  return kwilClient.call({
    name: "get_access_grants_granted",
    inputs: {
      page: params.page ?? 1,
      size: params.size ?? 10,
      user_id: params.user_id ?? null
    }
  });
}
async function revokeAccessGrant(kwilClient, id) {
  await kwilClient.execute({
    name: "revoke_access_grant",
    description: "Revoke an Access Grant from idOS",
    inputs: { id }
  });
  return { id };
}
async function getAccessGrantsOwned(kwilClient) {
  return kwilClient.call({
    name: "get_access_grants_owned",
    inputs: {}
  });
}
async function requestDAGMessage(kwilClient, params) {
  const [{ message: message2 }] = await kwilClient.call({
    name: "dag_message",
    inputs: params
  });
  return message2;
}
async function requestDWGMessage(kwilClient, params) {
  const [{ message: message2 }] = await kwilClient.call({
    name: "dwg_message",
    inputs: params
  });
  return message2;
}
async function hasProfile(kwilClient, address) {
  const [{ has_profile }] = await kwilClient.call({
    name: "has_profile",
    inputs: { address }
  }, void 0);
  return has_profile;
}
async function getUserProfile(kwilClient) {
  const [user] = await kwilClient.call({
    name: "get_user",
    inputs: {}
  });
  return user;
}
async function addWallet(kwilClient, params) {
  await kwilClient.execute({
    name: "add_wallet",
    description: "Add a wallet to idOS",
    inputs: params
  });
  return params;
}
async function addWallets(kwilClient, params) {
  await Promise.all(params.map((param) => kwilClient.execute({
    name: "add_wallet",
    description: "Add a wallet to idOS",
    inputs: param
  })));
  return params;
}
async function getWallets(kwilClient) {
  return kwilClient.call({
    name: "get_wallets",
    inputs: {}
  });
}
async function removeWallet(kwilClient, id) {
  await kwilClient.execute({
    name: "remove_wallet",
    description: "Remove a wallet from idOS",
    inputs: { id }
  });
  return { id };
}
async function removeWallets(kwilClient, ids) {
  await Promise.all(ids.map((id) => kwilClient.execute({
    name: "remove_wallet",
    description: "Remove a wallet from idOS",
    inputs: { id }
  })));
  return ids;
}
const DataType$1 = distExports.Utils.DataType;
const actionSchema$1 = {
  add_user_as_inserter: [{
    name: "id",
    type: DataType$1.Uuid
  }, {
    name: "recipient_encryption_public_key",
    type: DataType$1.Text
  }],
  update_user_pub_key_as_inserter: [{
    name: "id",
    type: DataType$1.Uuid
  }, {
    name: "recipient_encryption_public_key",
    type: DataType$1.Text
  }],
  get_user: [],
  get_user_as_inserter: [{
    name: "id",
    type: DataType$1.Uuid
  }],
  upsert_wallet_as_inserter: [
    {
      name: "id",
      type: DataType$1.Uuid
    },
    {
      name: "user_id",
      type: DataType$1.Uuid
    },
    {
      name: "address",
      type: DataType$1.Text
    },
    {
      name: "public_key",
      type: DataType$1.Text
    },
    {
      name: "wallet_type",
      type: DataType$1.Text
    },
    {
      name: "message",
      type: DataType$1.Text
    },
    {
      name: "signature",
      type: DataType$1.Text
    }
  ],
  add_wallet: [
    {
      name: "id",
      type: DataType$1.Uuid
    },
    {
      name: "address",
      type: DataType$1.Text
    },
    {
      name: "public_key",
      type: DataType$1.Text
    },
    {
      name: "message",
      type: DataType$1.Text
    },
    {
      name: "signature",
      type: DataType$1.Text
    }
  ],
  get_wallets: [],
  remove_wallet: [{
    name: "id",
    type: DataType$1.Uuid
  }],
  upsert_credential_as_inserter: [
    {
      name: "id",
      type: DataType$1.Uuid
    },
    {
      name: "user_id",
      type: DataType$1.Uuid
    },
    {
      name: "issuer_auth_public_key",
      type: DataType$1.Text
    },
    {
      name: "encryptor_public_key",
      type: DataType$1.Text
    },
    {
      name: "content",
      type: DataType$1.Text
    },
    {
      name: "public_notes",
      type: DataType$1.Text
    },
    {
      name: "public_notes_signature",
      type: DataType$1.Text
    },
    {
      name: "broader_signature",
      type: DataType$1.Text
    }
  ],
  add_credential: [
    {
      name: "id",
      type: DataType$1.Uuid
    },
    {
      name: "issuer_auth_public_key",
      type: DataType$1.Text
    },
    {
      name: "encryptor_public_key",
      type: DataType$1.Text
    },
    {
      name: "content",
      type: DataType$1.Text
    },
    {
      name: "public_notes",
      type: DataType$1.Text
    },
    {
      name: "public_notes_signature",
      type: DataType$1.Text
    },
    {
      name: "broader_signature",
      type: DataType$1.Text
    }
  ],
  get_credentials: [],
  get_credentials_shared_by_user: [{
    name: "user_id",
    type: DataType$1.Uuid
  }, {
    name: "issuer_auth_public_key",
    type: DataType$1.Text
  }],
  edit_public_notes_as_issuer: [{
    name: "public_notes_id",
    type: DataType$1.Text
  }, {
    name: "public_notes",
    type: DataType$1.Text
  }],
  remove_credential: [{
    name: "id",
    type: DataType$1.Uuid
  }],
  share_credential: [
    {
      name: "id",
      type: DataType$1.Uuid
    },
    {
      name: "original_credential_id",
      type: DataType$1.Uuid
    },
    {
      name: "public_notes",
      type: DataType$1.Text
    },
    {
      name: "public_notes_signature",
      type: DataType$1.Text
    },
    {
      name: "broader_signature",
      type: DataType$1.Text
    },
    {
      name: "content",
      type: DataType$1.Text
    },
    {
      name: "content_hash",
      type: DataType$1.Text
    },
    {
      name: "encryptor_public_key",
      type: DataType$1.Text
    },
    {
      name: "issuer_auth_public_key",
      type: DataType$1.Text
    },
    {
      name: "grantee_wallet_identifier",
      type: DataType$1.Text
    },
    {
      name: "locked_until",
      type: DataType$1.Int
    }
  ],
  create_credential_copy: [
    {
      name: "id",
      type: DataType$1.Uuid
    },
    {
      name: "original_credential_id",
      type: DataType$1.Uuid
    },
    {
      name: "public_notes",
      type: DataType$1.Text
    },
    {
      name: "public_notes_signature",
      type: DataType$1.Text
    },
    {
      name: "broader_signature",
      type: DataType$1.Text
    },
    {
      name: "content",
      type: DataType$1.Text
    },
    {
      name: "encryptor_public_key",
      type: DataType$1.Text
    },
    {
      name: "issuer_auth_public_key",
      type: DataType$1.Text
    }
  ],
  share_credential_through_dag: [
    {
      name: "id",
      type: DataType$1.Uuid
    },
    {
      name: "user_id",
      type: DataType$1.Uuid
    },
    {
      name: "issuer_auth_public_key",
      type: DataType$1.Text
    },
    {
      name: "encryptor_public_key",
      type: DataType$1.Text
    },
    {
      name: "content",
      type: DataType$1.Text
    },
    {
      name: "content_hash",
      type: DataType$1.Text
    },
    {
      name: "public_notes",
      type: DataType$1.Text
    },
    {
      name: "public_notes_signature",
      type: DataType$1.Text
    },
    {
      name: "broader_signature",
      type: DataType$1.Text
    },
    {
      name: "original_credential_id",
      type: DataType$1.Uuid
    },
    {
      name: "dag_owner_wallet_identifier",
      type: DataType$1.Text
    },
    {
      name: "dag_grantee_wallet_identifier",
      type: DataType$1.Text
    },
    {
      name: "dag_locked_until",
      type: DataType$1.Int
    },
    {
      name: "dag_signature",
      type: DataType$1.Text
    }
  ],
  create_credentials_by_dwg: [
    {
      name: "issuer_auth_public_key",
      type: DataType$1.Text
    },
    {
      name: "original_encryptor_public_key",
      type: DataType$1.Text
    },
    {
      name: "original_credential_id",
      type: DataType$1.Uuid
    },
    {
      name: "original_content",
      type: DataType$1.Text
    },
    {
      name: "original_public_notes",
      type: DataType$1.Text
    },
    {
      name: "original_public_notes_signature",
      type: DataType$1.Text
    },
    {
      name: "original_broader_signature",
      type: DataType$1.Text
    },
    {
      name: "copy_encryptor_public_key",
      type: DataType$1.Text
    },
    {
      name: "copy_credential_id",
      type: DataType$1.Uuid
    },
    {
      name: "copy_content",
      type: DataType$1.Text
    },
    {
      name: "copy_public_notes_signature",
      type: DataType$1.Text
    },
    {
      name: "copy_broader_signature",
      type: DataType$1.Text
    },
    {
      name: "content_hash",
      type: DataType$1.Text
    },
    {
      name: "dwg_owner",
      type: DataType$1.Text
    },
    {
      name: "dwg_grantee",
      type: DataType$1.Text
    },
    {
      name: "dwg_issuer_public_key",
      type: DataType$1.Text
    },
    {
      name: "dwg_id",
      type: DataType$1.Uuid
    },
    {
      name: "dwg_access_grant_timelock",
      type: DataType$1.Text
    },
    {
      name: "dwg_not_before",
      type: DataType$1.Text
    },
    {
      name: "dwg_not_after",
      type: DataType$1.Text
    },
    {
      name: "dwg_signature",
      type: DataType$1.Text
    }
  ],
  get_credential_owned: [{
    name: "id",
    type: DataType$1.Uuid
  }],
  get_credential_shared: [{
    name: "id",
    type: DataType$1.Uuid
  }],
  get_sibling_credential_id: [{
    name: "content_hash",
    type: DataType$1.Text
  }],
  add_attribute: [
    {
      name: "id",
      type: DataType$1.Uuid
    },
    {
      name: "attribute_key",
      type: DataType$1.Text
    },
    {
      name: "value",
      type: DataType$1.Text
    }
  ],
  get_attributes: [],
  edit_attribute: [
    {
      name: "id",
      type: DataType$1.Uuid
    },
    {
      name: "attribute_key",
      type: DataType$1.Text
    },
    {
      name: "value",
      type: DataType$1.Text
    }
  ],
  remove_attribute: [{
    name: "id",
    type: DataType$1.Uuid
  }],
  share_attribute: [
    {
      name: "id",
      type: DataType$1.Uuid
    },
    {
      name: "original_attribute_id",
      type: DataType$1.Uuid
    },
    {
      name: "attribute_key",
      type: DataType$1.Text
    },
    {
      name: "value",
      type: DataType$1.Text
    }
  ],
  dwg_message: [
    {
      name: "owner_wallet_identifier",
      type: DataType$1.Text
    },
    {
      name: "grantee_wallet_identifier",
      type: DataType$1.Text
    },
    {
      name: "issuer_public_key",
      type: DataType$1.Text
    },
    {
      name: "id",
      type: DataType$1.Uuid
    },
    {
      name: "access_grant_timelock",
      type: DataType$1.Text
    },
    {
      name: "not_usable_before",
      type: DataType$1.Text
    },
    {
      name: "not_usable_after",
      type: DataType$1.Text
    }
  ],
  revoke_access_grant: [{
    name: "id",
    type: DataType$1.Uuid
  }],
  get_access_grants_owned: [],
  get_access_grants_granted: [
    {
      name: "user_id",
      type: DataType$1.Uuid
    },
    {
      name: "page",
      type: DataType$1.Int
    },
    {
      name: "size",
      type: DataType$1.Int
    }
  ],
  get_access_grants_granted_count: [{
    name: "user_id",
    type: DataType$1.Uuid
  }],
  has_locked_access_grants: [{
    name: "id",
    type: DataType$1.Uuid
  }],
  dag_message: [
    {
      name: "dag_owner_wallet_identifier",
      type: DataType$1.Text
    },
    {
      name: "dag_grantee_wallet_identifier",
      type: DataType$1.Text
    },
    {
      name: "dag_data_id",
      type: DataType$1.Uuid
    },
    {
      name: "dag_locked_until",
      type: DataType$1.Int
    },
    {
      name: "dag_content_hash",
      type: DataType$1.Text
    }
  ],
  create_ag_by_dag_for_copy: [
    {
      name: "dag_owner_wallet_identifier",
      type: DataType$1.Text
    },
    {
      name: "dag_grantee_wallet_identifier",
      type: DataType$1.Text
    },
    {
      name: "dag_data_id",
      type: DataType$1.Uuid
    },
    {
      name: "dag_locked_until",
      type: DataType$1.Int
    },
    {
      name: "dag_content_hash",
      type: DataType$1.Text
    },
    {
      name: "dag_signature",
      type: DataType$1.Text
    }
  ],
  get_access_grants_for_credential: [{
    name: "credential_id",
    type: DataType$1.Uuid
  }],
  has_profile: [{
    name: "address",
    type: DataType$1.Text
  }],
  get_passporting_peers: [],
  get_caller: []
};
var prefix$1 = "Invariant failed";
function invariant$1(condition, message2) {
  if (condition) return;
  var provided = typeof message2 === "function" ? message2() : message2;
  var value = provided ? "".concat(prefix$1, ": ").concat(provided) : prefix$1;
  throw new Error(value);
}
var KwilActionClient$1 = class KwilActionClient {
  signer;
  client;
  constructor(client2) {
    this.client = client2;
  }
  #createActionInputs(actionName, params = {}) {
    if (!params || !Object.keys(params).length) return [];
    const args = actionSchema$1[actionName];
    return args.map(({ name }) => {
      const value = params[name];
      if (value === "" || value === 0) return value;
      return value ?? null;
    });
  }
  #actionTypes(actionName) {
    const args = actionSchema$1[actionName];
    return args.map((arg) => arg.type);
  }
  /**
  * Calls an action on the kwil nodes. This similar to `GET` like request.
  */
  async call(params, signer = this.signer) {
    const action2 = {
      name: params.name,
      namespace: "main",
      inputs: this.#createActionInputs(params.name, params.inputs),
      types: this.#actionTypes(params.name)
    };
    const response = await this.client.call(action2, signer);
    return response?.data?.result;
  }
  /**
  * Executes an action on the kwil nodes. This similar to `POST` like request.
  */
  async execute(params, signer = this.signer, synchronous = true) {
    invariant$1(signer, "Signer is not set, you must set it before executing an action");
    const action2 = {
      name: params.name,
      namespace: "main",
      description: params.description,
      inputs: [this.#createActionInputs(params.name, params.inputs)],
      types: this.#actionTypes(params.name)
    };
    const response = await this.client.execute(action2, signer, synchronous);
    return response.data?.tx_hash;
  }
  setSigner(signer) {
    this.signer = signer;
  }
};
const DEFAULT_TIMEOUT$1 = 3e4;
const createKwilClient$1 = (Cls) => async ({ nodeUrl: kwilProvider, chainId }) => {
  const _kwil = new Cls({
    kwilProvider,
    chainId: ""
  });
  chainId ||= (await _kwil.chainInfo({ disableWarning: true })).data?.chain_id;
  invariant$1(chainId, "Can't discover `chainId`. You must pass it explicitly.");
  return new KwilActionClient$1(new Cls({
    kwilProvider,
    chainId,
    timeout: DEFAULT_TIMEOUT$1
  }));
};
const createWebKwilClient = createKwilClient$1(distExports.WebKwil);
var require_crypto = __commonJS$1({ "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/crypto.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.crypto = void 0;
  exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
} });
var require_utils$10 = __commonJS$1({ "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js"(exports) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
  exports.isBytes = isBytes$1;
  exports.anumber = anumber$1;
  exports.abytes = abytes$1;
  exports.ahash = ahash;
  exports.aexists = aexists;
  exports.aoutput = aoutput;
  exports.u8 = u8;
  exports.u32 = u32;
  exports.clean = clean;
  exports.createView = createView;
  exports.rotr = rotr;
  exports.rotl = rotl;
  exports.byteSwap = byteSwap;
  exports.byteSwap32 = byteSwap32;
  exports.bytesToHex = bytesToHex$1;
  exports.hexToBytes = hexToBytes$1;
  exports.asyncLoop = asyncLoop;
  exports.utf8ToBytes = utf8ToBytes;
  exports.bytesToUtf8 = bytesToUtf8;
  exports.toBytes = toBytes;
  exports.kdfInputToBytes = kdfInputToBytes;
  exports.concatBytes = concatBytes;
  exports.checkOpts = checkOpts;
  exports.createHasher = createHasher$1;
  exports.createOptHasher = createOptHasher;
  exports.createXOFer = createXOFer;
  exports.randomBytes = randomBytes;
  const crypto_1 = require_crypto();
  function isBytes$1(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function anumber$1(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error("positive integer expected, got " + n);
  }
  function abytes$1(b, ...lengths) {
    if (!isBytes$1(b)) throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
  }
  function ahash(h) {
    if (typeof h !== "function" || typeof h.create !== "function") throw new Error("Hash should be wrapped by utils.createHasher");
    anumber$1(h.outputLen);
    anumber$1(h.blockLen);
  }
  function aexists(instance, checkFinished = true) {
    if (instance.destroyed) throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished) throw new Error("Hash#digest() has already been called");
  }
  function aoutput(out, instance) {
    abytes$1(out);
    const min2 = instance.outputLen;
    if (out.length < min2) throw new Error("digestInto() expects output buffer of length at least " + min2);
  }
  function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  }
  function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) arrays[i].fill(0);
  }
  function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function rotr(word, shift) {
    return word << 32 - shift | word >>> shift;
  }
  function rotl(word, shift) {
    return word << shift | word >>> 32 - shift >>> 0;
  }
  exports.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
  function byteSwap(word) {
    return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
  }
  exports.swap8IfBE = exports.isLE ? (n) => n : (n) => byteSwap(n);
  exports.byteSwapIfBE = exports.swap8IfBE;
  function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) arr[i] = byteSwap(arr[i]);
    return arr;
  }
  exports.swap32IfBE = exports.isLE ? (u) => u : byteSwap32;
  const hasHexBuiltin$1 = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
  const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex$1(bytes$1) {
    abytes$1(bytes$1);
    if (hasHexBuiltin$1) return bytes$1.toHex();
    let hex = "";
    for (let i = 0; i < bytes$1.length; i++) hex += hexes[bytes$1[i]];
    return hex;
  }
  const asciis = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
  };
  function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0;
    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10);
    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10);
    return;
  }
  function hexToBytes$1(hex) {
    if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
    if (hasHexBuiltin$1) return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw new Error("hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
      const n1 = asciiToBase16(hex.charCodeAt(hi));
      const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
      if (n1 === void 0 || n2 === void 0) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array[ai] = n1 * 16 + n2;
    }
    return array;
  }
  const nextTick = async () => {
  };
  exports.nextTick = nextTick;
  async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
      cb(i);
      const diff = Date.now() - ts;
      if (diff >= 0 && diff < tick) continue;
      await (0, exports.nextTick)();
      ts += diff;
    }
  }
  function utf8ToBytes(str) {
    if (typeof str !== "string") throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function bytesToUtf8(bytes$1) {
    return new TextDecoder().decode(bytes$1);
  }
  function toBytes(data2) {
    if (typeof data2 === "string") data2 = utf8ToBytes(data2);
    abytes$1(data2);
    return data2;
  }
  function kdfInputToBytes(data2) {
    if (typeof data2 === "string") data2 = utf8ToBytes(data2);
    abytes$1(data2);
    return data2;
  }
  function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      abytes$1(a);
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad);
      pad += a.length;
    }
    return res;
  }
  function checkOpts(defaults, opts) {
    if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]") throw new Error("options should be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
  }
  var Hash$1 = class {
  };
  exports.Hash = Hash$1;
  function createHasher$1(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function createOptHasher(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  function createXOFer(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  exports.wrapConstructor = createHasher$1;
  exports.wrapConstructorWithOpts = createOptHasher;
  exports.wrapXOFConstructorWithOpts = createXOFer;
  function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
    throw new Error("crypto.getRandomValues must be defined");
  }
} });
var require_shared$1 = __commonJS$1({ "../../node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/utils/shared.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.equal = exports.concat = exports.HEX_REGEX = void 0;
  const utils_1$58 = require_utils$10();
  exports.HEX_REGEX = /^[A-F0-9]*$/iu;
  function concat$12(views) {
    return (0, utils_1$58.concatBytes)(...views);
  }
  exports.concat = concat$12;
  function equal$1(buf1, buf2) {
    if (buf1.byteLength !== buf2.byteLength) return false;
    const dv1 = new Int8Array(buf1);
    const dv2 = new Int8Array(buf2);
    for (let i = 0; i !== buf1.byteLength; i++) if (dv1[i] !== dv2[i]) return false;
    return true;
  }
  exports.equal = equal$1;
} });
var require_browser$4 = __commonJS$1({ "../../node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/utils/browser.js"(exports) {
  var __createBinding$10 = Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
      enumerable: true,
      get: function() {
        return m[k];
      }
    };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  };
  var __exportStar$7 = function(m, exports$1) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding$10(exports$1, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomBytes = exports.stringToHex = exports.hexToString = exports.hexToBytes = exports.bytesToHex = void 0;
  const utils_1$57 = require_utils$10();
  const shared_1 = require_shared$1();
  const bytesToHex = (bytes$1) => {
    const hex = (0, utils_1$57.bytesToHex)(bytes$1 instanceof Uint8Array ? bytes$1 : Uint8Array.from(bytes$1));
    return hex.toUpperCase();
  };
  exports.bytesToHex = bytesToHex;
  const hexToBytes = (hex) => {
    const len = hex.length;
    const array = new Uint8Array(len / 2);
    if (!shared_1.HEX_REGEX.test(hex)) throw new Error("Invalid hex string");
    for (let i = 0; i < array.length; i++) {
      const j = i * 2;
      const hexByte = hex.slice(j, j + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0) throw new Error("Invalid byte sequence");
      array[i] = byte;
    }
    return array;
  };
  exports.hexToBytes = hexToBytes;
  const hexToString = (hex, encoding = "utf8") => {
    return new TextDecoder(encoding).decode((0, exports.hexToBytes)(hex));
  };
  exports.hexToString = hexToString;
  const stringToHex = (string) => {
    return (0, exports.bytesToHex)(new TextEncoder().encode(string));
  };
  exports.stringToHex = stringToHex;
  exports.randomBytes = utils_1$57.randomBytes;
  __exportStar$7(require_shared$1(), exports);
} });
var require_lib$1 = __commonJS$1({ "../../node_modules/.pnpm/@scure+base@1.2.6/node_modules/@scure/base/lib/index.js"(exports) {
  /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.createBase58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64nopad = exports.base64 = exports.base32crockford = exports.base32hexnopad = exports.base32hex = exports.base32nopad = exports.base32 = exports.base16 = exports.utils = void 0;
  function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function abytes(b, ...lengths) {
    if (!isBytes(b)) throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
  }
  function isArrayOf(isString$1, arr) {
    if (!Array.isArray(arr)) return false;
    if (arr.length === 0) return true;
    if (isString$1) return arr.every((item) => typeof item === "string");
    else return arr.every((item) => Number.isSafeInteger(item));
  }
  function afn(input) {
    if (typeof input !== "function") throw new Error("function expected");
    return true;
  }
  function astr(label, input) {
    if (typeof input !== "string") throw new Error(`${label}: string expected`);
    return true;
  }
  function anumber(n) {
    if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);
  }
  function aArr(input) {
    if (!Array.isArray(input)) throw new Error("array expected");
  }
  function astrArr(label, input) {
    if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);
  }
  function anumArr(label, input) {
    if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);
  }
  // @__NO_SIDE_EFFECTS__
  function chain(...args) {
    const id = (a) => a;
    const wrap = (a, b) => (c) => a(b(c));
    const encode$5 = args.map((x) => x.encode).reduceRight(wrap, id);
    const decode$5 = args.map((x) => x.decode).reduce(wrap, id);
    return {
      encode: encode$5,
      decode: decode$5
    };
  }
  // @__NO_SIDE_EFFECTS__
  function alphabet(letters) {
    const lettersA = typeof letters === "string" ? letters.split("") : letters;
    const len = lettersA.length;
    astrArr("alphabet", lettersA);
    const indexes = new Map(lettersA.map((l, i) => [l, i]));
    return {
      encode: (digits) => {
        aArr(digits);
        return digits.map((i) => {
          if (!Number.isSafeInteger(i) || i < 0 || i >= len) throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
          return lettersA[i];
        });
      },
      decode: (input) => {
        aArr(input);
        return input.map((letter) => {
          astr("alphabet.decode", letter);
          const i = indexes.get(letter);
          if (i === void 0) throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
          return i;
        });
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function join(separator = "") {
    astr("join", separator);
    return {
      encode: (from) => {
        astrArr("join.decode", from);
        return from.join(separator);
      },
      decode: (to) => {
        astr("join.decode", to);
        return to.split(separator);
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function padding(bits, chr = "=") {
    anumber(bits);
    astr("padding", chr);
    return {
      encode(data2) {
        astrArr("padding.encode", data2);
        while (data2.length * bits % 8) data2.push(chr);
        return data2;
      },
      decode(input) {
        astrArr("padding.decode", input);
        let end = input.length;
        if (end * bits % 8) throw new Error("padding: invalid, string should have whole number of bytes");
        for (; end > 0 && input[end - 1] === chr; end--) {
          const last = end - 1;
          const byte = last * bits;
          if (byte % 8 === 0) throw new Error("padding: invalid, string has too much padding");
        }
        return input.slice(0, end);
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function normalize$1(fn) {
    afn(fn);
    return {
      encode: (from) => from,
      decode: (to) => fn(to)
    };
  }
  function convertRadix(data2, from, to) {
    if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
    if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
    aArr(data2);
    if (!data2.length) return [];
    let pos = 0;
    const res = [];
    const digits = Array.from(data2, (d) => {
      anumber(d);
      if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);
      return d;
    });
    const dlen = digits.length;
    while (true) {
      let carry = 0;
      let done = true;
      for (let i = pos; i < dlen; i++) {
        const digit = digits[i];
        const fromCarry = from * carry;
        const digitBase = fromCarry + digit;
        if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) throw new Error("convertRadix: carry overflow");
        const div = digitBase / to;
        carry = digitBase % to;
        const rounded = Math.floor(div);
        digits[i] = rounded;
        if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error("convertRadix: carry overflow");
        if (!done) continue;
        else if (!rounded) pos = i;
        else done = false;
      }
      res.push(carry);
      if (done) break;
    }
    for (let i = 0; i < data2.length - 1 && data2[i] === 0; i++) res.push(0);
    return res.reverse();
  }
  const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
  const radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));
  const powers = /* @__PURE__ */ (() => {
    let res = [];
    for (let i = 0; i < 40; i++) res.push(2 ** i);
    return res;
  })();
  function convertRadix2(data2, from, to, padding$1) {
    aArr(data2);
    if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);
    if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);
    if (/* @__PURE__ */ radix2carry(from, to) > 32) throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${/* @__PURE__ */ radix2carry(from, to)}`);
    let carry = 0;
    let pos = 0;
    const max2 = powers[from];
    const mask$2 = powers[to] - 1;
    const res = [];
    for (const n of data2) {
      anumber(n);
      if (n >= max2) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
      carry = carry << from | n;
      if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
      pos += from;
      for (; pos >= to; pos -= to) res.push((carry >> pos - to & mask$2) >>> 0);
      const pow$1 = powers[pos];
      if (pow$1 === void 0) throw new Error("invalid carry");
      carry &= pow$1 - 1;
    }
    carry = carry << to - pos & mask$2;
    if (!padding$1 && pos >= from) throw new Error("Excess padding");
    if (!padding$1 && carry > 0) throw new Error(`Non-zero padding: ${carry}`);
    if (padding$1 && pos > 0) res.push(carry >>> 0);
    return res;
  }
  // @__NO_SIDE_EFFECTS__
  function radix(num$1) {
    anumber(num$1);
    const _256 = 2 ** 8;
    return {
      encode: (bytes$1) => {
        if (!isBytes(bytes$1)) throw new Error("radix.encode input should be Uint8Array");
        return convertRadix(Array.from(bytes$1), _256, num$1);
      },
      decode: (digits) => {
        anumArr("radix.decode", digits);
        return Uint8Array.from(convertRadix(digits, num$1, _256));
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function radix2(bits, revPadding = false) {
    anumber(bits);
    if (bits <= 0 || bits > 32) throw new Error("radix2: bits should be in (0..32]");
    if (/* @__PURE__ */ radix2carry(8, bits) > 32 || /* @__PURE__ */ radix2carry(bits, 8) > 32) throw new Error("radix2: carry overflow");
    return {
      encode: (bytes$1) => {
        if (!isBytes(bytes$1)) throw new Error("radix2.encode input should be Uint8Array");
        return convertRadix2(Array.from(bytes$1), 8, bits, !revPadding);
      },
      decode: (digits) => {
        anumArr("radix2.decode", digits);
        return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
      }
    };
  }
  function unsafeWrapper(fn) {
    afn(fn);
    return function(...args) {
      try {
        return fn.apply(null, args);
      } catch (e) {
      }
    };
  }
  function checksum(len, fn) {
    anumber(len);
    afn(fn);
    return {
      encode(data2) {
        if (!isBytes(data2)) throw new Error("checksum.encode: input should be Uint8Array");
        const sum = fn(data2).slice(0, len);
        const res = new Uint8Array(data2.length + len);
        res.set(data2);
        res.set(sum, data2.length);
        return res;
      },
      decode(data2) {
        if (!isBytes(data2)) throw new Error("checksum.decode: input should be Uint8Array");
        const payload = data2.slice(0, -len);
        const oldChecksum = data2.slice(-len);
        const newChecksum = fn(payload).slice(0, len);
        for (let i = 0; i < len; i++) if (newChecksum[i] !== oldChecksum[i]) throw new Error("Invalid checksum");
        return payload;
      }
    };
  }
  exports.utils = {
    alphabet,
    chain,
    checksum,
    convertRadix,
    convertRadix2,
    radix,
    radix2,
    join,
    padding
  };
  exports.base16 = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(4), /* @__PURE__ */ alphabet("0123456789ABCDEF"), /* @__PURE__ */ join(""));
  exports.base32 = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ padding(5), /* @__PURE__ */ join(""));
  exports.base32nopad = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ join(""));
  exports.base32hex = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ padding(5), /* @__PURE__ */ join(""));
  exports.base32hexnopad = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ join(""));
  exports.base32crockford = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), /* @__PURE__ */ join(""), /* @__PURE__ */ normalize$1((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
  const hasBase64Builtin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
  const decodeBase64Builtin = (s, isUrl) => {
    astr("base64", s);
    const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
    const alphabet$1 = isUrl ? "base64url" : "base64";
    if (s.length > 0 && !re.test(s)) throw new Error("invalid base64");
    return Uint8Array.fromBase64(s, {
      alphabet: alphabet$1,
      lastChunkHandling: "strict"
    });
  };
  exports.base64 = hasBase64Builtin ? {
    encode(b) {
      abytes(b);
      return b.toBase64();
    },
    decode(s) {
      return decodeBase64Builtin(s, false);
    }
  } : /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ padding(6), /* @__PURE__ */ join(""));
  exports.base64nopad = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ join(""));
  exports.base64url = hasBase64Builtin ? {
    encode(b) {
      abytes(b);
      return b.toBase64({ alphabet: "base64url" });
    },
    decode(s) {
      return decodeBase64Builtin(s, true);
    }
  } : /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ padding(6), /* @__PURE__ */ join(""));
  exports.base64urlnopad = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ join(""));
  const genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => /* @__PURE__ */ chain(/* @__PURE__ */ radix(58), /* @__PURE__ */ alphabet(abc), /* @__PURE__ */ join(""));
  exports.base58 = /* @__PURE__ */ genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
  exports.base58flickr = /* @__PURE__ */ genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
  exports.base58xrp = /* @__PURE__ */ genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
  const XMR_BLOCK_LEN = [
    0,
    2,
    3,
    5,
    6,
    7,
    9,
    10,
    11
  ];
  exports.base58xmr = {
    encode(data2) {
      let res = "";
      for (let i = 0; i < data2.length; i += 8) {
        const block = data2.subarray(i, i + 8);
        res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
      }
      return res;
    },
    decode(str) {
      let res = [];
      for (let i = 0; i < str.length; i += 11) {
        const slice = str.slice(i, i + 11);
        const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
        const block = exports.base58.decode(slice);
        for (let j = 0; j < block.length - blockLen; j++) if (block[j] !== 0) throw new Error("base58xmr: wrong padding");
        res = res.concat(Array.from(block.slice(block.length - blockLen)));
      }
      return Uint8Array.from(res);
    }
  };
  const createBase58check = (sha256) => /* @__PURE__ */ chain(checksum(4, (data2) => sha256(sha256(data2))), exports.base58);
  exports.createBase58check = createBase58check;
  exports.base58check = exports.createBase58check;
  const BECH_ALPHABET = /* @__PURE__ */ chain(/* @__PURE__ */ alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ join(""));
  const POLYMOD_GENERATORS = [
    996825010,
    642813549,
    513874426,
    1027748829,
    705979059
  ];
  function bech32Polymod(pre) {
    const b = pre >> 25;
    let chk = (pre & 33554431) << 5;
    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];
    return chk;
  }
  function bechChecksum(prefix$2, words, encodingConst = 1) {
    const len = prefix$2.length;
    let chk = 1;
    for (let i = 0; i < len; i++) {
      const c = prefix$2.charCodeAt(i);
      if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix$2})`);
      chk = bech32Polymod(chk) ^ c >> 5;
    }
    chk = bech32Polymod(chk);
    for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ prefix$2.charCodeAt(i) & 31;
    for (let v of words) chk = bech32Polymod(chk) ^ v;
    for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);
    chk ^= encodingConst;
    return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
  }
  // @__NO_SIDE_EFFECTS__
  function genBech32(encoding) {
    const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
    const _words = /* @__PURE__ */ radix2(5);
    const fromWords = _words.decode;
    const toWords = _words.encode;
    const fromWordsUnsafe = unsafeWrapper(fromWords);
    function encode$5(prefix$2, words, limit = 90) {
      astr("bech32.encode prefix", prefix$2);
      if (isBytes(words)) words = Array.from(words);
      anumArr("bech32.encode", words);
      const plen = prefix$2.length;
      if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);
      const actualLength = plen + 7 + words.length;
      if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
      const lowered = prefix$2.toLowerCase();
      const sum = bechChecksum(lowered, words, ENCODING_CONST);
      return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
    }
    function decode$5(str, limit = 90) {
      astr("bech32.decode input", str);
      const slen = str.length;
      if (slen < 8 || limit !== false && slen > limit) throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
      const lowered = str.toLowerCase();
      if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);
      const sepIndex = lowered.lastIndexOf("1");
      if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter "1" must be present between prefix and data only`);
      const prefix$2 = lowered.slice(0, sepIndex);
      const data2 = lowered.slice(sepIndex + 1);
      if (data2.length < 6) throw new Error("Data must be at least 6 characters long");
      const words = BECH_ALPHABET.decode(data2).slice(0, -6);
      const sum = bechChecksum(prefix$2, words, ENCODING_CONST);
      if (!data2.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
      return {
        prefix: prefix$2,
        words
      };
    }
    const decodeUnsafe = unsafeWrapper(decode$5);
    function decodeToBytes(str) {
      const { prefix: prefix$2, words } = decode$5(str, false);
      return {
        prefix: prefix$2,
        words,
        bytes: fromWords(words)
      };
    }
    function encodeFromBytes(prefix$2, bytes$1) {
      return encode$5(prefix$2, toWords(bytes$1));
    }
    return {
      encode: encode$5,
      decode: decode$5,
      encodeFromBytes,
      decodeToBytes,
      decodeUnsafe,
      fromWords,
      fromWordsUnsafe,
      toWords
    };
  }
  exports.bech32 = /* @__PURE__ */ genBech32("bech32");
  exports.bech32m = /* @__PURE__ */ genBech32("bech32m");
  exports.utf8 = {
    encode: (data2) => new TextDecoder().decode(data2),
    decode: (str) => new TextEncoder().encode(str)
  };
  const hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
  const hexBuiltin = {
    encode(data2) {
      abytes(data2);
      return data2.toHex();
    },
    decode(s) {
      astr("hex", s);
      return Uint8Array.fromHex(s);
    }
  };
  exports.hex = hasHexBuiltin ? hexBuiltin : /* @__PURE__ */ chain(/* @__PURE__ */ radix2(4), /* @__PURE__ */ alphabet("0123456789abcdef"), /* @__PURE__ */ join(""), /* @__PURE__ */ normalize$1((s) => {
    if (typeof s !== "string" || s.length % 2 !== 0) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
    return s.toLowerCase();
  }));
  const CODERS = {
    utf8: exports.utf8,
    hex: exports.hex,
    base16: exports.base16,
    base32: exports.base32,
    base64: exports.base64,
    base64url: exports.base64url,
    base58: exports.base58,
    base58xmr: exports.base58xmr
  };
  const coderTypeError = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr";
  const bytesToString = (type2, bytes$1) => {
    if (typeof type2 !== "string" || !CODERS.hasOwnProperty(type2)) throw new TypeError(coderTypeError);
    if (!isBytes(bytes$1)) throw new TypeError("bytesToString() expects Uint8Array");
    return CODERS[type2].encode(bytes$1);
  };
  exports.bytesToString = bytesToString;
  exports.str = exports.bytesToString;
  const stringToBytes = (type2, str) => {
    if (!CODERS.hasOwnProperty(type2)) throw new TypeError(coderTypeError);
    if (typeof str !== "string") throw new TypeError("stringToBytes() expects string");
    return CODERS[type2].decode(str);
  };
  exports.stringToBytes = stringToBytes;
  exports.bytes = exports.stringToBytes;
} });
var require__md$1 = __commonJS$1({ "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_md.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;
  exports.setBigUint64 = setBigUint64;
  exports.Chi = Chi;
  exports.Maj = Maj;
  const utils_ts_1$12 = require_utils$10();
  function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === "function") return view.setBigUint64(byteOffset, value, isLE);
    const _32n$1 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n$1 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
  }
  function Chi(a, b, c) {
    return a & b ^ ~a & c;
  }
  function Maj(a, b, c) {
    return a & b ^ a & c ^ b & c;
  }
  var HashMD = class extends utils_ts_1$12.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
      super();
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE;
      this.buffer = new Uint8Array(blockLen);
      this.view = (0, utils_ts_1$12.createView)(this.buffer);
    }
    update(data2) {
      (0, utils_ts_1$12.aexists)(this);
      data2 = (0, utils_ts_1$12.toBytes)(data2);
      (0, utils_ts_1$12.abytes)(data2);
      const { view, buffer, blockLen } = this;
      const len = data2.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = (0, utils_ts_1$12.createView)(data2);
          for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);
          continue;
        }
        buffer.set(data2.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data2.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      (0, utils_ts_1$12.aexists)(this);
      (0, utils_ts_1$12.aoutput)(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      (0, utils_ts_1$12.clean)(this.buffer.subarray(pos));
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++) buffer[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
      this.process(view, 0);
      const oview = (0, utils_ts_1$12.createView)(out);
      const len = this.outputLen;
      if (len % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length) throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.destroyed = destroyed;
      to.finished = finished;
      to.length = length;
      to.pos = pos;
      if (length % blockLen) to.buffer.set(buffer);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
  };
  exports.HashMD = HashMD;
  exports.SHA256_IV = Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  exports.SHA224_IV = Uint32Array.from([
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ]);
  exports.SHA384_IV = Uint32Array.from([
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ]);
  exports.SHA512_IV = Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ]);
} });
var require__u64$1 = __commonJS$1({ "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_u64.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
  exports.add = add;
  exports.fromBig = fromBig;
  exports.split = split;
  const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  const _32n = /* @__PURE__ */ BigInt(32);
  function fromBig(n, le = false) {
    if (le) return {
      h: Number(n & U32_MASK64),
      l: Number(n >> _32n & U32_MASK64)
    };
    return {
      h: Number(n >> _32n & U32_MASK64) | 0,
      l: Number(n & U32_MASK64) | 0
    };
  }
  function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i = 0; i < len; i++) {
      const { h, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  const toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
  exports.toBig = toBig;
  const shrSH = (h, _l, s) => h >>> s;
  exports.shrSH = shrSH;
  const shrSL = (h, l, s) => h << 32 - s | l >>> s;
  exports.shrSL = shrSL;
  const rotrSH = (h, l, s) => h >>> s | l << 32 - s;
  exports.rotrSH = rotrSH;
  const rotrSL = (h, l, s) => h << 32 - s | l >>> s;
  exports.rotrSL = rotrSL;
  const rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
  exports.rotrBH = rotrBH;
  const rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
  exports.rotrBL = rotrBL;
  const rotr32H = (_h, l) => l;
  exports.rotr32H = rotr32H;
  const rotr32L = (h, _l) => h;
  exports.rotr32L = rotr32L;
  const rotlSH = (h, l, s) => h << s | l >>> 32 - s;
  exports.rotlSH = rotlSH;
  const rotlSL = (h, l, s) => l << s | h >>> 32 - s;
  exports.rotlSL = rotlSL;
  const rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
  exports.rotlBH = rotlBH;
  const rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
  exports.rotlBL = rotlBL;
  function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return {
      h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
      l: l | 0
    };
  }
  const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  exports.add3L = add3L;
  const add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  exports.add3H = add3H;
  const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  exports.add4L = add4L;
  const add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  exports.add4H = add4H;
  const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  exports.add5L = add5L;
  const add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  exports.add5H = add5H;
  const u64$1 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
  };
  exports.default = u64$1;
} });
var require_sha2$1 = __commonJS$1({ "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;
  const _md_ts_1$1 = require__md$1();
  const u64 = require__u64$1();
  const utils_ts_1$11 = require_utils$10();
  const SHA256_K = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  var SHA256 = class extends _md_ts_1$1.HashMD {
    constructor(outputLen = 32) {
      super(64, outputLen, 8, false);
      this.A = _md_ts_1$1.SHA256_IV[0] | 0;
      this.B = _md_ts_1$1.SHA256_IV[1] | 0;
      this.C = _md_ts_1$1.SHA256_IV[2] | 0;
      this.D = _md_ts_1$1.SHA256_IV[3] | 0;
      this.E = _md_ts_1$1.SHA256_IV[4] | 0;
      this.F = _md_ts_1$1.SHA256_IV[5] | 0;
      this.G = _md_ts_1$1.SHA256_IV[6] | 0;
      this.H = _md_ts_1$1.SHA256_IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [
        A,
        B,
        C,
        D,
        E,
        F,
        G,
        H
      ];
    }
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);
      for (let i = 16; i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = (0, utils_ts_1$11.rotr)(W15, 7) ^ (0, utils_ts_1$11.rotr)(W15, 18) ^ W15 >>> 3;
        const s1 = (0, utils_ts_1$11.rotr)(W2, 17) ^ (0, utils_ts_1$11.rotr)(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0; i < 64; i++) {
        const sigma1 = (0, utils_ts_1$11.rotr)(E, 6) ^ (0, utils_ts_1$11.rotr)(E, 11) ^ (0, utils_ts_1$11.rotr)(E, 25);
        const T1 = H + sigma1 + (0, _md_ts_1$1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = (0, utils_ts_1$11.rotr)(A, 2) ^ (0, utils_ts_1$11.rotr)(A, 13) ^ (0, utils_ts_1$11.rotr)(A, 22);
        const T2 = sigma0 + (0, _md_ts_1$1.Maj)(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      (0, utils_ts_1$11.clean)(SHA256_W);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      (0, utils_ts_1$11.clean)(this.buffer);
    }
  };
  exports.SHA256 = SHA256;
  var SHA224 = class extends SHA256 {
    constructor() {
      super(28);
      this.A = _md_ts_1$1.SHA224_IV[0] | 0;
      this.B = _md_ts_1$1.SHA224_IV[1] | 0;
      this.C = _md_ts_1$1.SHA224_IV[2] | 0;
      this.D = _md_ts_1$1.SHA224_IV[3] | 0;
      this.E = _md_ts_1$1.SHA224_IV[4] | 0;
      this.F = _md_ts_1$1.SHA224_IV[5] | 0;
      this.G = _md_ts_1$1.SHA224_IV[6] | 0;
      this.H = _md_ts_1$1.SHA224_IV[7] | 0;
    }
  };
  exports.SHA224 = SHA224;
  const K512 = /* @__PURE__ */ (() => u64.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n) => BigInt(n))))();
  const SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
  const SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
  const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
  const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
  var SHA512 = class extends _md_ts_1$1.HashMD {
    constructor(outputLen = 64) {
      super(128, outputLen, 16, false);
      this.Ah = _md_ts_1$1.SHA512_IV[0] | 0;
      this.Al = _md_ts_1$1.SHA512_IV[1] | 0;
      this.Bh = _md_ts_1$1.SHA512_IV[2] | 0;
      this.Bl = _md_ts_1$1.SHA512_IV[3] | 0;
      this.Ch = _md_ts_1$1.SHA512_IV[4] | 0;
      this.Cl = _md_ts_1$1.SHA512_IV[5] | 0;
      this.Dh = _md_ts_1$1.SHA512_IV[6] | 0;
      this.Dl = _md_ts_1$1.SHA512_IV[7] | 0;
      this.Eh = _md_ts_1$1.SHA512_IV[8] | 0;
      this.El = _md_ts_1$1.SHA512_IV[9] | 0;
      this.Fh = _md_ts_1$1.SHA512_IV[10] | 0;
      this.Fl = _md_ts_1$1.SHA512_IV[11] | 0;
      this.Gh = _md_ts_1$1.SHA512_IV[12] | 0;
      this.Gl = _md_ts_1$1.SHA512_IV[13] | 0;
      this.Hh = _md_ts_1$1.SHA512_IV[14] | 0;
      this.Hl = _md_ts_1$1.SHA512_IV[15] | 0;
    }
    get() {
      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [
        Ah,
        Al,
        Bh,
        Bl,
        Ch,
        Cl,
        Dh,
        Dl,
        Eh,
        El,
        Fh,
        Fl,
        Gh,
        Gl,
        Hh,
        Hl
      ];
    }
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4) {
        SHA512_W_H[i] = view.getUint32(offset);
        SHA512_W_L[i] = view.getUint32(offset += 4);
      }
      for (let i = 16; i < 80; i++) {
        const W15h = SHA512_W_H[i - 15] | 0;
        const W15l = SHA512_W_L[i - 15] | 0;
        const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
        const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H[i - 2] | 0;
        const W2l = SHA512_W_L[i - 2] | 0;
        const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
        const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
        const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
        const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
        SHA512_W_H[i] = SUMh | 0;
        SHA512_W_L[i] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i = 0; i < 80; i++) {
        const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
        const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
        const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
        const T1l = T1ll | 0;
        const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
        const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        const All = u64.add3L(T1l, sigma0l, MAJl);
        Ah = u64.add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
      ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      (0, utils_ts_1$11.clean)(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
      (0, utils_ts_1$11.clean)(this.buffer);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  exports.SHA512 = SHA512;
  var SHA384 = class extends SHA512 {
    constructor() {
      super(48);
      this.Ah = _md_ts_1$1.SHA384_IV[0] | 0;
      this.Al = _md_ts_1$1.SHA384_IV[1] | 0;
      this.Bh = _md_ts_1$1.SHA384_IV[2] | 0;
      this.Bl = _md_ts_1$1.SHA384_IV[3] | 0;
      this.Ch = _md_ts_1$1.SHA384_IV[4] | 0;
      this.Cl = _md_ts_1$1.SHA384_IV[5] | 0;
      this.Dh = _md_ts_1$1.SHA384_IV[6] | 0;
      this.Dl = _md_ts_1$1.SHA384_IV[7] | 0;
      this.Eh = _md_ts_1$1.SHA384_IV[8] | 0;
      this.El = _md_ts_1$1.SHA384_IV[9] | 0;
      this.Fh = _md_ts_1$1.SHA384_IV[10] | 0;
      this.Fl = _md_ts_1$1.SHA384_IV[11] | 0;
      this.Gh = _md_ts_1$1.SHA384_IV[12] | 0;
      this.Gl = _md_ts_1$1.SHA384_IV[13] | 0;
      this.Hh = _md_ts_1$1.SHA384_IV[14] | 0;
      this.Hl = _md_ts_1$1.SHA384_IV[15] | 0;
    }
  };
  exports.SHA384 = SHA384;
  const T224_IV = /* @__PURE__ */ Uint32Array.from([
    2352822216,
    424955298,
    1944164710,
    2312950998,
    502970286,
    855612546,
    1738396948,
    1479516111,
    258812777,
    2077511080,
    2011393907,
    79989058,
    1067287976,
    1780299464,
    286451373,
    2446758561
  ]);
  const T256_IV = /* @__PURE__ */ Uint32Array.from([
    573645204,
    4230739756,
    2673172387,
    3360449730,
    596883563,
    1867755857,
    2520282905,
    1497426621,
    2519219938,
    2827943907,
    3193839141,
    1401305490,
    721525244,
    746961066,
    246885852,
    2177182882
  ]);
  var SHA512_224 = class extends SHA512 {
    constructor() {
      super(28);
      this.Ah = T224_IV[0] | 0;
      this.Al = T224_IV[1] | 0;
      this.Bh = T224_IV[2] | 0;
      this.Bl = T224_IV[3] | 0;
      this.Ch = T224_IV[4] | 0;
      this.Cl = T224_IV[5] | 0;
      this.Dh = T224_IV[6] | 0;
      this.Dl = T224_IV[7] | 0;
      this.Eh = T224_IV[8] | 0;
      this.El = T224_IV[9] | 0;
      this.Fh = T224_IV[10] | 0;
      this.Fl = T224_IV[11] | 0;
      this.Gh = T224_IV[12] | 0;
      this.Gl = T224_IV[13] | 0;
      this.Hh = T224_IV[14] | 0;
      this.Hl = T224_IV[15] | 0;
    }
  };
  exports.SHA512_224 = SHA512_224;
  var SHA512_256 = class extends SHA512 {
    constructor() {
      super(32);
      this.Ah = T256_IV[0] | 0;
      this.Al = T256_IV[1] | 0;
      this.Bh = T256_IV[2] | 0;
      this.Bl = T256_IV[3] | 0;
      this.Ch = T256_IV[4] | 0;
      this.Cl = T256_IV[5] | 0;
      this.Dh = T256_IV[6] | 0;
      this.Dl = T256_IV[7] | 0;
      this.Eh = T256_IV[8] | 0;
      this.El = T256_IV[9] | 0;
      this.Fh = T256_IV[10] | 0;
      this.Fl = T256_IV[11] | 0;
      this.Gh = T256_IV[12] | 0;
      this.Gl = T256_IV[13] | 0;
      this.Hh = T256_IV[14] | 0;
      this.Hl = T256_IV[15] | 0;
    }
  };
  exports.SHA512_256 = SHA512_256;
  exports.sha256 = (0, utils_ts_1$11.createHasher)(() => new SHA256());
  exports.sha224 = (0, utils_ts_1$11.createHasher)(() => new SHA224());
  exports.sha512 = (0, utils_ts_1$11.createHasher)(() => new SHA512());
  exports.sha384 = (0, utils_ts_1$11.createHasher)(() => new SHA384());
  exports.sha512_256 = (0, utils_ts_1$11.createHasher)(() => new SHA512_256());
  exports.sha512_224 = (0, utils_ts_1$11.createHasher)(() => new SHA512_224());
} });
var require_sha256$1 = __commonJS$1({ "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha256.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sha224 = exports.SHA224 = exports.sha256 = exports.SHA256 = void 0;
  const sha2_ts_1$1 = require_sha2$1();
  exports.SHA256 = sha2_ts_1$1.SHA256;
  exports.sha256 = sha2_ts_1$1.sha256;
  exports.SHA224 = sha2_ts_1$1.SHA224;
  exports.sha224 = sha2_ts_1$1.sha224;
} });
var require_normalizeInput$1 = __commonJS$1({ "../../node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/internal/normalizeInput.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  function normalizeInput(input) {
    return Array.isArray(input) ? new Uint8Array(input) : input;
  }
  exports.default = normalizeInput;
} });
var require_wrapNoble = __commonJS$1({ "../../node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/internal/wrapNoble.js"(exports) {
  var __importDefault$30 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const normalizeInput_1 = __importDefault$30(require_normalizeInput$1());
  function wrapNoble(chash) {
    function wrapped(input) {
      return chash((0, normalizeInput_1.default)(input));
    }
    wrapped.create = () => {
      const hash$12 = chash.create();
      return {
        update(input) {
          hash$12.update((0, normalizeInput_1.default)(input));
          return this;
        },
        digest() {
          return hash$12.digest();
        }
      };
    };
    return wrapped;
  }
  exports.default = wrapNoble;
} });
var require_browser$3 = __commonJS$1({ "../../node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/sha256/browser.js"(exports) {
  var __importDefault$29 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sha256 = void 0;
  const sha256_1$2 = require_sha256$1();
  const wrapNoble_1$2 = __importDefault$29(require_wrapNoble());
  exports.sha256 = (0, wrapNoble_1$2.default)(sha256_1$2.sha256);
} });
var require_utils$9 = __commonJS$1({ "../../node_modules/.pnpm/ripple-address-codec@5.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-address-codec/dist/utils.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatArgs = exports.arrayEqual = void 0;
  function arrayEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) return false;
    return arr1.every((value, index) => value === arr2[index]);
  }
  exports.arrayEqual = arrayEqual;
  function isScalar(val) {
    return typeof val === "number";
  }
  function concatArgs(...args) {
    return args.flatMap((arg) => {
      return isScalar(arg) ? [arg] : Array.from(arg);
    });
  }
  exports.concatArgs = concatArgs;
} });
var require_xrp_codec$1 = __commonJS$1({ "../../node_modules/.pnpm/ripple-address-codec@5.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-address-codec/dist/xrp-codec.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.encodeNodePublic = exports.decodeNodePublic = exports.decodeAddress = exports.decodeAccountID = exports.encodeAddress = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;
  const base_1$2 = require_lib$1();
  const sha256_1$1 = require_browser$3();
  const utils_1$56 = require_utils$9();
  var Codec = class {
    constructor(options) {
      this._sha256 = options.sha256;
      this._codec = base_1$2.base58xrp;
    }
    /**
    * Encoder.
    *
    * @param bytes - Uint8Array of data to encode.
    * @param opts - Options object including the version bytes and the expected length of the data to encode.
    */
    encode(bytes$1, opts) {
      const versions = opts.versions;
      return this._encodeVersioned(bytes$1, versions, opts.expectedLength);
    }
    /**
    * Decoder.
    *
    * @param base58string - Base58Check-encoded string to decode.
    * @param opts - Options object including the version byte(s) and the expected length of the data after decoding.
    */
    decode(base58string, opts) {
      var _a;
      const versions = opts.versions;
      const types$1 = opts.versionTypes;
      const withoutSum = this.decodeChecked(base58string);
      if (versions.length > 1 && !opts.expectedLength) throw new Error("expectedLength is required because there are >= 2 possible versions");
      const versionLengthGuess = typeof versions[0] === "number" ? 1 : versions[0].length;
      const payloadLength = (_a = opts.expectedLength) !== null && _a !== void 0 ? _a : withoutSum.length - versionLengthGuess;
      const versionBytes = withoutSum.slice(0, -payloadLength);
      const payload = withoutSum.slice(-payloadLength);
      for (let i = 0; i < versions.length; i++) {
        const version2 = Array.isArray(versions[i]) ? versions[i] : [versions[i]];
        if ((0, utils_1$56.arrayEqual)(versionBytes, version2)) return {
          version: version2,
          bytes: payload,
          type: types$1 ? types$1[i] : null
        };
      }
      throw new Error("version_invalid: version bytes do not match any of the provided version(s)");
    }
    encodeChecked(bytes$1) {
      const check = this._sha256(this._sha256(bytes$1)).slice(0, 4);
      return this._encodeRaw(Uint8Array.from((0, utils_1$56.concatArgs)(bytes$1, check)));
    }
    decodeChecked(base58string) {
      const intArray = this._decodeRaw(base58string);
      if (intArray.byteLength < 5) throw new Error("invalid_input_size: decoded data must have length >= 5");
      if (!this._verifyCheckSum(intArray)) throw new Error("checksum_invalid");
      return intArray.slice(0, -4);
    }
    _encodeVersioned(bytes$1, versions, expectedLength) {
      if (!checkByteLength(bytes$1, expectedLength)) throw new Error("unexpected_payload_length: bytes.length does not match expectedLength. Ensure that the bytes are a Uint8Array.");
      return this.encodeChecked((0, utils_1$56.concatArgs)(versions, bytes$1));
    }
    _encodeRaw(bytes$1) {
      return this._codec.encode(Uint8Array.from(bytes$1));
    }
    _decodeRaw(base58string) {
      return this._codec.decode(base58string);
    }
    _verifyCheckSum(bytes$1) {
      const computed = this._sha256(this._sha256(bytes$1.slice(0, -4))).slice(0, 4);
      const checksum$1 = bytes$1.slice(-4);
      return (0, utils_1$56.arrayEqual)(computed, checksum$1);
    }
  };
  const ACCOUNT_ID = 0;
  const ACCOUNT_PUBLIC_KEY = 35;
  const FAMILY_SEED = 33;
  const NODE_PUBLIC = 28;
  const ED25519_SEED = [
    1,
    225,
    75
  ];
  const codecOptions = { sha256: sha256_1$1.sha256 };
  const codecWithXrpAlphabet = new Codec(codecOptions);
  exports.codec = codecWithXrpAlphabet;
  function encodeSeed(entropy, type2) {
    if (!checkByteLength(entropy, 16)) throw new Error("entropy must have length 16");
    const opts = {
      expectedLength: 16,
      versions: type2 === "ed25519" ? ED25519_SEED : [FAMILY_SEED]
    };
    return codecWithXrpAlphabet.encode(entropy, opts);
  }
  exports.encodeSeed = encodeSeed;
  function decodeSeed(seed, opts = {
    versionTypes: ["ed25519", "secp256k1"],
    versions: [ED25519_SEED, FAMILY_SEED],
    expectedLength: 16
  }) {
    return codecWithXrpAlphabet.decode(seed, opts);
  }
  exports.decodeSeed = decodeSeed;
  function encodeAccountID(bytes$1) {
    const opts = {
      versions: [ACCOUNT_ID],
      expectedLength: 20
    };
    return codecWithXrpAlphabet.encode(bytes$1, opts);
  }
  exports.encodeAccountID = encodeAccountID;
  exports.encodeAddress = encodeAccountID;
  function decodeAccountID(accountId) {
    const opts = {
      versions: [ACCOUNT_ID],
      expectedLength: 20
    };
    return codecWithXrpAlphabet.decode(accountId, opts).bytes;
  }
  exports.decodeAccountID = decodeAccountID;
  exports.decodeAddress = decodeAccountID;
  function decodeNodePublic(base58string) {
    const opts = {
      versions: [NODE_PUBLIC],
      expectedLength: 33
    };
    return codecWithXrpAlphabet.decode(base58string, opts).bytes;
  }
  exports.decodeNodePublic = decodeNodePublic;
  function encodeNodePublic(bytes$1) {
    const opts = {
      versions: [NODE_PUBLIC],
      expectedLength: 33
    };
    return codecWithXrpAlphabet.encode(bytes$1, opts);
  }
  exports.encodeNodePublic = encodeNodePublic;
  function encodeAccountPublic(bytes$1) {
    const opts = {
      versions: [ACCOUNT_PUBLIC_KEY],
      expectedLength: 33
    };
    return codecWithXrpAlphabet.encode(bytes$1, opts);
  }
  exports.encodeAccountPublic = encodeAccountPublic;
  function decodeAccountPublic(base58string) {
    const opts = {
      versions: [ACCOUNT_PUBLIC_KEY],
      expectedLength: 33
    };
    return codecWithXrpAlphabet.decode(base58string, opts).bytes;
  }
  exports.decodeAccountPublic = decodeAccountPublic;
  function isValidClassicAddress(address) {
    try {
      decodeAccountID(address);
    } catch (_error) {
      return false;
    }
    return true;
  }
  exports.isValidClassicAddress = isValidClassicAddress;
  function checkByteLength(bytes$1, expectedLength) {
    return "byteLength" in bytes$1 ? bytes$1.byteLength === expectedLength : bytes$1.length === expectedLength;
  }
} });
var require_dist$3 = __commonJS$1({ "../../node_modules/.pnpm/ripple-address-codec@5.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-address-codec/dist/index.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isValidXAddress = exports.decodeXAddress = exports.xAddressToClassicAddress = exports.encodeXAddress = exports.classicAddressToXAddress = exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.decodeNodePublic = exports.encodeNodePublic = exports.decodeAccountID = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;
  const utils_1$55 = require_browser$4();
  const xrp_codec_1 = require_xrp_codec$1();
  Object.defineProperty(exports, "codec", {
    enumerable: true,
    get: function() {
      return xrp_codec_1.codec;
    }
  });
  Object.defineProperty(exports, "encodeSeed", {
    enumerable: true,
    get: function() {
      return xrp_codec_1.encodeSeed;
    }
  });
  Object.defineProperty(exports, "decodeSeed", {
    enumerable: true,
    get: function() {
      return xrp_codec_1.decodeSeed;
    }
  });
  Object.defineProperty(exports, "encodeAccountID", {
    enumerable: true,
    get: function() {
      return xrp_codec_1.encodeAccountID;
    }
  });
  Object.defineProperty(exports, "decodeAccountID", {
    enumerable: true,
    get: function() {
      return xrp_codec_1.decodeAccountID;
    }
  });
  Object.defineProperty(exports, "encodeNodePublic", {
    enumerable: true,
    get: function() {
      return xrp_codec_1.encodeNodePublic;
    }
  });
  Object.defineProperty(exports, "decodeNodePublic", {
    enumerable: true,
    get: function() {
      return xrp_codec_1.decodeNodePublic;
    }
  });
  Object.defineProperty(exports, "encodeAccountPublic", {
    enumerable: true,
    get: function() {
      return xrp_codec_1.encodeAccountPublic;
    }
  });
  Object.defineProperty(exports, "decodeAccountPublic", {
    enumerable: true,
    get: function() {
      return xrp_codec_1.decodeAccountPublic;
    }
  });
  Object.defineProperty(exports, "isValidClassicAddress", {
    enumerable: true,
    get: function() {
      return xrp_codec_1.isValidClassicAddress;
    }
  });
  const PREFIX_BYTES = {
    main: Uint8Array.from([5, 68]),
    test: Uint8Array.from([4, 147])
  };
  const MAX_32_BIT_UNSIGNED_INT = 4294967295;
  function classicAddressToXAddress(classicAddress, tag, test) {
    const accountId = (0, xrp_codec_1.decodeAccountID)(classicAddress);
    return encodeXAddress(accountId, tag, test);
  }
  exports.classicAddressToXAddress = classicAddressToXAddress;
  function encodeXAddress(accountId, tag, test) {
    if (accountId.length !== 20) throw new Error("Account ID must be 20 bytes");
    if (tag !== false && tag > MAX_32_BIT_UNSIGNED_INT) throw new Error("Invalid tag");
    const theTag = tag || 0;
    const flag = tag === false || tag == null ? 0 : 1;
    const bytes$1 = (0, utils_1$55.concat)([
      test ? PREFIX_BYTES.test : PREFIX_BYTES.main,
      accountId,
      Uint8Array.from([
        flag,
        theTag & 255,
        theTag >> 8 & 255,
        theTag >> 16 & 255,
        theTag >> 24 & 255,
        0,
        0,
        0,
        0
      ])
    ]);
    return xrp_codec_1.codec.encodeChecked(bytes$1);
  }
  exports.encodeXAddress = encodeXAddress;
  function xAddressToClassicAddress(xAddress) {
    const { accountId, tag, test } = decodeXAddress(xAddress);
    const classicAddress = (0, xrp_codec_1.encodeAccountID)(accountId);
    return {
      classicAddress,
      tag,
      test
    };
  }
  exports.xAddressToClassicAddress = xAddressToClassicAddress;
  function decodeXAddress(xAddress) {
    const decoded = xrp_codec_1.codec.decodeChecked(xAddress);
    const test = isUint8ArrayForTestAddress(decoded);
    const accountId = decoded.slice(2, 22);
    const tag = tagFromUint8Array(decoded);
    return {
      accountId,
      tag,
      test
    };
  }
  exports.decodeXAddress = decodeXAddress;
  function isUint8ArrayForTestAddress(buf) {
    const decodedPrefix = buf.slice(0, 2);
    if ((0, utils_1$55.equal)(PREFIX_BYTES.main, decodedPrefix)) return false;
    if ((0, utils_1$55.equal)(PREFIX_BYTES.test, decodedPrefix)) return true;
    throw new Error("Invalid X-address: bad prefix");
  }
  function tagFromUint8Array(buf) {
    const flag = buf[22];
    if (flag >= 2) throw new Error("Unsupported X-address");
    if (flag === 1) return buf[23] + buf[24] * 256 + buf[25] * 65536 + buf[26] * 16777216;
    if (flag !== 0) throw new Error("flag must be zero to indicate no tag");
    if (!(0, utils_1$55.equal)((0, utils_1$55.hexToBytes)("0000000000000000"), buf.slice(23, 31))) throw new Error("remaining bytes must be zero");
    return false;
  }
  function isValidXAddress(xAddress) {
    try {
      decodeXAddress(xAddress);
    } catch (_error) {
      return false;
    }
    return true;
  }
  exports.isValidXAddress = isValidXAddress;
} });
var require_legacy = __commonJS$1({ "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/legacy.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ripemd160 = exports.RIPEMD160 = exports.md5 = exports.MD5 = exports.sha1 = exports.SHA1 = void 0;
  const _md_ts_1 = require__md$1();
  const utils_ts_1$10 = require_utils$10();
  const SHA1_IV = /* @__PURE__ */ Uint32Array.from([
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ]);
  const SHA1_W = /* @__PURE__ */ new Uint32Array(80);
  var SHA1 = class extends _md_ts_1.HashMD {
    constructor() {
      super(64, 20, 8, false);
      this.A = SHA1_IV[0] | 0;
      this.B = SHA1_IV[1] | 0;
      this.C = SHA1_IV[2] | 0;
      this.D = SHA1_IV[3] | 0;
      this.E = SHA1_IV[4] | 0;
    }
    get() {
      const { A, B, C, D, E } = this;
      return [
        A,
        B,
        C,
        D,
        E
      ];
    }
    set(A, B, C, D, E) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4) SHA1_W[i] = view.getUint32(offset, false);
      for (let i = 16; i < 80; i++) SHA1_W[i] = (0, utils_ts_1$10.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
      let { A, B, C, D, E } = this;
      for (let i = 0; i < 80; i++) {
        let F, K$2;
        if (i < 20) {
          F = (0, _md_ts_1.Chi)(B, C, D);
          K$2 = 1518500249;
        } else if (i < 40) {
          F = B ^ C ^ D;
          K$2 = 1859775393;
        } else if (i < 60) {
          F = (0, _md_ts_1.Maj)(B, C, D);
          K$2 = 2400959708;
        } else {
          F = B ^ C ^ D;
          K$2 = 3395469782;
        }
        const T = (0, utils_ts_1$10.rotl)(A, 5) + F + E + K$2 + SHA1_W[i] | 0;
        E = D;
        D = C;
        C = (0, utils_ts_1$10.rotl)(B, 30);
        B = A;
        A = T;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      this.set(A, B, C, D, E);
    }
    roundClean() {
      (0, utils_ts_1$10.clean)(SHA1_W);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0);
      (0, utils_ts_1$10.clean)(this.buffer);
    }
  };
  exports.SHA1 = SHA1;
  exports.sha1 = (0, utils_ts_1$10.createHasher)(() => new SHA1());
  const p32 = /* @__PURE__ */ Math.pow(2, 32);
  const K2 = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));
  const MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);
  const MD5_W = /* @__PURE__ */ new Uint32Array(16);
  var MD5 = class extends _md_ts_1.HashMD {
    constructor() {
      super(64, 16, 8, true);
      this.A = MD5_IV[0] | 0;
      this.B = MD5_IV[1] | 0;
      this.C = MD5_IV[2] | 0;
      this.D = MD5_IV[3] | 0;
    }
    get() {
      const { A, B, C, D } = this;
      return [
        A,
        B,
        C,
        D
      ];
    }
    set(A, B, C, D) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4) MD5_W[i] = view.getUint32(offset, true);
      let { A, B, C, D } = this;
      for (let i = 0; i < 64; i++) {
        let F, g, s;
        if (i < 16) {
          F = (0, _md_ts_1.Chi)(B, C, D);
          g = i;
          s = [
            7,
            12,
            17,
            22
          ];
        } else if (i < 32) {
          F = (0, _md_ts_1.Chi)(D, B, C);
          g = (5 * i + 1) % 16;
          s = [
            5,
            9,
            14,
            20
          ];
        } else if (i < 48) {
          F = B ^ C ^ D;
          g = (3 * i + 5) % 16;
          s = [
            4,
            11,
            16,
            23
          ];
        } else {
          F = C ^ (B | ~D);
          g = 7 * i % 16;
          s = [
            6,
            10,
            15,
            21
          ];
        }
        F = F + A + K2[i] + MD5_W[g];
        A = D;
        D = C;
        C = B;
        B = B + (0, utils_ts_1$10.rotl)(F, s[i % 4]);
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      this.set(A, B, C, D);
    }
    roundClean() {
      (0, utils_ts_1$10.clean)(MD5_W);
    }
    destroy() {
      this.set(0, 0, 0, 0);
      (0, utils_ts_1$10.clean)(this.buffer);
    }
  };
  exports.MD5 = MD5;
  exports.md5 = (0, utils_ts_1$10.createHasher)(() => new MD5());
  const Rho160 = /* @__PURE__ */ Uint8Array.from([
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8
  ]);
  const Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();
  const Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();
  const idxLR = /* @__PURE__ */ (() => {
    const L = [Id160];
    const R = [Pi160];
    const res = [L, R];
    for (let i = 0; i < 4; i++) for (let j of res) j.push(j[i].map((k) => Rho160[k]));
    return res;
  })();
  const idxL = /* @__PURE__ */ (() => idxLR[0])();
  const idxR = /* @__PURE__ */ (() => idxLR[1])();
  const shifts160 = /* @__PURE__ */ [
    [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8
    ],
    [
      12,
      13,
      11,
      15,
      6,
      9,
      9,
      7,
      12,
      15,
      11,
      13,
      7,
      8,
      7,
      7
    ],
    [
      13,
      15,
      14,
      11,
      7,
      7,
      6,
      8,
      13,
      14,
      13,
      12,
      5,
      5,
      6,
      9
    ],
    [
      14,
      11,
      12,
      14,
      8,
      6,
      5,
      5,
      15,
      12,
      15,
      14,
      9,
      9,
      8,
      6
    ],
    [
      15,
      12,
      13,
      13,
      9,
      5,
      8,
      6,
      14,
      11,
      12,
      11,
      8,
      6,
      5,
      5
    ]
  ].map((i) => Uint8Array.from(i));
  const shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));
  const shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));
  const Kl160 = /* @__PURE__ */ Uint32Array.from([
    0,
    1518500249,
    1859775393,
    2400959708,
    2840853838
  ]);
  const Kr160 = /* @__PURE__ */ Uint32Array.from([
    1352829926,
    1548603684,
    1836072691,
    2053994217,
    0
  ]);
  function ripemd_f(group, x, y, z2) {
    if (group === 0) return x ^ y ^ z2;
    if (group === 1) return x & y | ~x & z2;
    if (group === 2) return (x | ~y) ^ z2;
    if (group === 3) return x & z2 | y & ~z2;
    return x ^ (y | ~z2);
  }
  const BUF_160 = /* @__PURE__ */ new Uint32Array(16);
  var RIPEMD160 = class extends _md_ts_1.HashMD {
    constructor() {
      super(64, 20, 8, true);
      this.h0 = 1732584193;
      this.h1 = -271733879;
      this.h2 = -1732584194;
      this.h3 = 271733878;
      this.h4 = -1009589776;
    }
    get() {
      const { h0, h1, h2, h3, h4 } = this;
      return [
        h0,
        h1,
        h2,
        h3,
        h4
      ];
    }
    set(h0, h1, h2, h3, h4) {
      this.h0 = h0 | 0;
      this.h1 = h1 | 0;
      this.h2 = h2 | 0;
      this.h3 = h3 | 0;
      this.h4 = h4 | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4) BUF_160[i] = view.getUint32(offset, true);
      let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
      for (let group = 0; group < 5; group++) {
        const rGroup = 4 - group;
        const hbl = Kl160[group], hbr = Kr160[group];
        const rl = idxL[group], rr = idxR[group];
        const sl = shiftsL160[group], sr = shiftsR160[group];
        for (let i = 0; i < 16; i++) {
          const tl = (0, utils_ts_1$10.rotl)(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;
          al = el, el = dl, dl = (0, utils_ts_1$10.rotl)(cl, 10) | 0, cl = bl, bl = tl;
        }
        for (let i = 0; i < 16; i++) {
          const tr = (0, utils_ts_1$10.rotl)(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;
          ar = er, er = dr, dr = (0, utils_ts_1$10.rotl)(cr, 10) | 0, cr = br, br = tr;
        }
      }
      this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
    }
    roundClean() {
      (0, utils_ts_1$10.clean)(BUF_160);
    }
    destroy() {
      this.destroyed = true;
      (0, utils_ts_1$10.clean)(this.buffer);
      this.set(0, 0, 0, 0, 0);
    }
  };
  exports.RIPEMD160 = RIPEMD160;
  exports.ripemd160 = (0, utils_ts_1$10.createHasher)(() => new RIPEMD160());
} });
var require_ripemd160$1 = __commonJS$1({ "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/ripemd160.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ripemd160 = exports.RIPEMD160 = void 0;
  const legacy_ts_1 = require_legacy();
  exports.RIPEMD160 = legacy_ts_1.RIPEMD160;
  exports.ripemd160 = legacy_ts_1.ripemd160;
} });
var require_browser$2 = __commonJS$1({ "../../node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/ripemd160/browser.js"(exports) {
  var __importDefault$28 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ripemd160 = void 0;
  const ripemd160_1$1 = require_ripemd160$1();
  const wrapNoble_1$1 = __importDefault$28(require_wrapNoble());
  exports.ripemd160 = (0, wrapNoble_1$1.default)(ripemd160_1$1.ripemd160);
} });
var require_hmac$1 = __commonJS$1({ "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/hmac.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hmac = exports.HMAC = void 0;
  const utils_ts_1$9 = require_utils$10();
  var HMAC = class extends utils_ts_1$9.Hash {
    constructor(hash$12, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      (0, utils_ts_1$9.ahash)(hash$12);
      const key = (0, utils_ts_1$9.toBytes)(_key);
      this.iHash = hash$12.create();
      if (typeof this.iHash.update !== "function") throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > blockLen ? hash$12.create().update(key).digest() : key);
      for (let i = 0; i < pad.length; i++) pad[i] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash$12.create();
      for (let i = 0; i < pad.length; i++) pad[i] ^= 106;
      this.oHash.update(pad);
      (0, utils_ts_1$9.clean)(pad);
    }
    update(buf) {
      (0, utils_ts_1$9.aexists)(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      (0, utils_ts_1$9.aexists)(this);
      (0, utils_ts_1$9.abytes)(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  exports.HMAC = HMAC;
  const hmac = (hash$12, key, message2) => new HMAC(hash$12, key).update(message2).digest();
  exports.hmac = hmac;
  exports.hmac.create = (hash$12, key) => new HMAC(hash$12, key);
} });
var require_utils$8 = __commonJS$1({ "../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;
  exports.abool = abool;
  exports.numberToHexUnpadded = numberToHexUnpadded;
  exports.hexToNumber = hexToNumber;
  exports.bytesToNumberBE = bytesToNumberBE;
  exports.bytesToNumberLE = bytesToNumberLE;
  exports.numberToBytesBE = numberToBytesBE;
  exports.numberToBytesLE = numberToBytesLE;
  exports.numberToVarBytesBE = numberToVarBytesBE;
  exports.ensureBytes = ensureBytes;
  exports.equalBytes = equalBytes;
  exports.inRange = inRange;
  exports.aInRange = aInRange;
  exports.bitLen = bitLen;
  exports.bitGet = bitGet;
  exports.bitSet = bitSet;
  exports.createHmacDrbg = createHmacDrbg;
  exports.validateObject = validateObject;
  exports.isHash = isHash;
  exports._validateObject = _validateObject;
  exports.memoized = memoized;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const utils_js_1$2 = require_utils$10();
  var utils_js_2 = require_utils$10();
  Object.defineProperty(exports, "abytes", {
    enumerable: true,
    get: function() {
      return utils_js_2.abytes;
    }
  });
  Object.defineProperty(exports, "anumber", {
    enumerable: true,
    get: function() {
      return utils_js_2.anumber;
    }
  });
  Object.defineProperty(exports, "bytesToHex", {
    enumerable: true,
    get: function() {
      return utils_js_2.bytesToHex;
    }
  });
  Object.defineProperty(exports, "bytesToUtf8", {
    enumerable: true,
    get: function() {
      return utils_js_2.bytesToUtf8;
    }
  });
  Object.defineProperty(exports, "concatBytes", {
    enumerable: true,
    get: function() {
      return utils_js_2.concatBytes;
    }
  });
  Object.defineProperty(exports, "hexToBytes", {
    enumerable: true,
    get: function() {
      return utils_js_2.hexToBytes;
    }
  });
  Object.defineProperty(exports, "isBytes", {
    enumerable: true,
    get: function() {
      return utils_js_2.isBytes;
    }
  });
  Object.defineProperty(exports, "randomBytes", {
    enumerable: true,
    get: function() {
      return utils_js_2.randomBytes;
    }
  });
  Object.defineProperty(exports, "utf8ToBytes", {
    enumerable: true,
    get: function() {
      return utils_js_2.utf8ToBytes;
    }
  });
  const _0n$7 = /* @__PURE__ */ BigInt(0);
  const _1n$7 = /* @__PURE__ */ BigInt(1);
  function abool(title, value) {
    if (typeof value !== "boolean") throw new Error(title + " boolean expected, got " + value);
  }
  function numberToHexUnpadded(num$1) {
    const hex = num$1.toString(16);
    return hex.length & 1 ? "0" + hex : hex;
  }
  function hexToNumber(hex) {
    if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
    return hex === "" ? _0n$7 : BigInt("0x" + hex);
  }
  function bytesToNumberBE(bytes$1) {
    return hexToNumber((0, utils_js_1$2.bytesToHex)(bytes$1));
  }
  function bytesToNumberLE(bytes$1) {
    (0, utils_js_1$2.abytes)(bytes$1);
    return hexToNumber((0, utils_js_1$2.bytesToHex)(Uint8Array.from(bytes$1).reverse()));
  }
  function numberToBytesBE(n, len) {
    return (0, utils_js_1$2.hexToBytes)(n.toString(16).padStart(len * 2, "0"));
  }
  function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
  }
  function numberToVarBytesBE(n) {
    return (0, utils_js_1$2.hexToBytes)(numberToHexUnpadded(n));
  }
  function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") try {
      res = (0, utils_js_1$2.hexToBytes)(hex);
    } catch (e) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
    }
    else if ((0, utils_js_1$2.isBytes)(hex)) res = Uint8Array.from(hex);
    else throw new Error(title + " must be hex string or Uint8Array");
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength) throw new Error(title + " of length " + expectedLength + " expected, got " + len);
    return res;
  }
  function equalBytes(a, b) {
    if (a.length !== b.length) return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];
    return diff === 0;
  }
  const isPosBig = (n) => typeof n === "bigint" && _0n$7 <= n;
  function inRange(n, min2, max2) {
    return isPosBig(n) && isPosBig(min2) && isPosBig(max2) && min2 <= n && n < max2;
  }
  function aInRange(title, n, min2, max2) {
    if (!inRange(n, min2, max2)) throw new Error("expected valid " + title + ": " + min2 + " <= n < " + max2 + ", got " + n);
  }
  function bitLen(n) {
    let len;
    for (len = 0; n > _0n$7; n >>= _1n$7, len += 1) ;
    return len;
  }
  function bitGet(n, pos) {
    return n >> BigInt(pos) & _1n$7;
  }
  function bitSet(n, pos, value) {
    return n | (value ? _1n$7 : _0n$7) << BigInt(pos);
  }
  const bitMask = (n) => (_1n$7 << BigInt(n)) - _1n$7;
  exports.bitMask = bitMask;
  function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2) throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2) throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function") throw new Error("hmacFn must be a function");
    const u8n = (len) => new Uint8Array(len);
    const u8of = (byte) => Uint8Array.of(byte);
    let v = u8n(hashLen);
    let k = u8n(hashLen);
    let i = 0;
    const reset = () => {
      v.fill(1);
      k.fill(0);
      i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b);
    const reseed = (seed = u8n(0)) => {
      k = h(u8of(0), seed);
      v = h();
      if (seed.length === 0) return;
      k = h(u8of(1), seed);
      v = h();
    };
    const gen = () => {
      if (i++ >= 1e3) throw new Error("drbg: tried 1000 values");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v = h();
        const sl = v.slice();
        out.push(sl);
        len += v.length;
      }
      return (0, utils_js_1$2.concatBytes)(...out);
    };
    const genUntil = (seed, pred) => {
      reset();
      reseed(seed);
      let res = void 0;
      while (!(res = pred(gen()))) reseed();
      reset();
      return res;
    };
    return genUntil;
  }
  const validatorFns = {
    bigint: (val) => typeof val === "bigint",
    function: (val) => typeof val === "function",
    boolean: (val) => typeof val === "boolean",
    string: (val) => typeof val === "string",
    stringOrUint8Array: (val) => typeof val === "string" || (0, utils_js_1$2.isBytes)(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
  };
  function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type2, isOptional) => {
      const checkVal = validatorFns[type2];
      if (typeof checkVal !== "function") throw new Error("invalid validator function");
      const val = object[fieldName];
      if (isOptional && val === void 0) return;
      if (!checkVal(val, object)) throw new Error("param " + String(fieldName) + " is invalid. Expected " + type2 + ", got " + val);
    };
    for (const [fieldName, type2] of Object.entries(validators)) checkField(fieldName, type2, false);
    for (const [fieldName, type2] of Object.entries(optValidators)) checkField(fieldName, type2, true);
    return object;
  }
  function isHash(val) {
    return typeof val === "function" && Number.isSafeInteger(val.outputLen);
  }
  function _validateObject(object, fields, optFields = {}) {
    if (!object || typeof object !== "object") throw new Error("expected valid options object");
    function checkField(fieldName, expectedType, isOpt) {
      const val = object[fieldName];
      if (isOpt && val === void 0) return;
      const current = typeof val;
      if (current !== expectedType || val === null) throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
    }
    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
  }
  const notImplemented = () => {
    throw new Error("not implemented");
  };
  exports.notImplemented = notImplemented;
  function memoized(fn) {
    const map = /* @__PURE__ */ new WeakMap();
    return (arg, ...args) => {
      const val = map.get(arg);
      if (val !== void 0) return val;
      const computed = fn(arg, ...args);
      map.set(arg, computed);
      return computed;
    };
  }
} });
var require_modular$1 = __commonJS$1({ "../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isNegativeLE = void 0;
  exports.mod = mod;
  exports.pow = pow2;
  exports.pow2 = pow22;
  exports.invert = invert;
  exports.tonelliShanks = tonelliShanks;
  exports.FpSqrt = FpSqrt;
  exports.validateField = validateField;
  exports.FpPow = FpPow;
  exports.FpInvertBatch = FpInvertBatch;
  exports.FpDiv = FpDiv;
  exports.FpLegendre = FpLegendre;
  exports.FpIsSquare = FpIsSquare;
  exports.nLength = nLength;
  exports.Field = Field$1;
  exports.FpSqrtOdd = FpSqrtOdd;
  exports.FpSqrtEven = FpSqrtEven;
  exports.hashToPrivateScalar = hashToPrivateScalar;
  exports.getFieldBytesLength = getFieldBytesLength;
  exports.getMinHashLength = getMinHashLength;
  exports.mapHashToField = mapHashToField;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const utils_ts_1$8 = require_utils$8();
  const _0n$6 = BigInt(0), _1n$6 = BigInt(1), _2n$5 = /* @__PURE__ */ BigInt(2), _3n$2 = /* @__PURE__ */ BigInt(3);
  const _4n$1 = /* @__PURE__ */ BigInt(4), _5n$1 = /* @__PURE__ */ BigInt(5);
  const _8n$2 = /* @__PURE__ */ BigInt(8);
  function mod(a, b) {
    const result = a % b;
    return result >= _0n$6 ? result : b + result;
  }
  function pow2(num$1, power, modulo) {
    return FpPow(Field$1(modulo), num$1, power);
  }
  function pow22(x, power, modulo) {
    let res = x;
    while (power-- > _0n$6) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert(number, modulo) {
    if (number === _0n$6) throw new Error("invert: expected non-zero number");
    if (modulo <= _0n$6) throw new Error("invert: expected positive modulus, got " + modulo);
    let a = mod(number, modulo);
    let b = modulo;
    let x = _0n$6, u = _1n$6;
    while (a !== _0n$6) {
      const q = b / a;
      const r = b % a;
      const m = x - u * q;
      b = a, a = r, x = u, u = m;
    }
    const gcd$1 = b;
    if (gcd$1 !== _1n$6) throw new Error("invert: does not exist");
    return mod(x, modulo);
  }
  function sqrt3mod4(Fp$1, n) {
    const p1div4 = (Fp$1.ORDER + _1n$6) / _4n$1;
    const root2 = Fp$1.pow(n, p1div4);
    if (!Fp$1.eql(Fp$1.sqr(root2), n)) throw new Error("Cannot find square root");
    return root2;
  }
  function sqrt5mod8(Fp$1, n) {
    const p5div8 = (Fp$1.ORDER - _5n$1) / _8n$2;
    const n2 = Fp$1.mul(n, _2n$5);
    const v = Fp$1.pow(n2, p5div8);
    const nv = Fp$1.mul(n, v);
    const i = Fp$1.mul(Fp$1.mul(nv, _2n$5), v);
    const root2 = Fp$1.mul(nv, Fp$1.sub(i, Fp$1.ONE));
    if (!Fp$1.eql(Fp$1.sqr(root2), n)) throw new Error("Cannot find square root");
    return root2;
  }
  function tonelliShanks(P) {
    if (P < BigInt(3)) throw new Error("sqrt is not defined for small field");
    let Q = P - _1n$6;
    let S = 0;
    while (Q % _2n$5 === _0n$6) {
      Q /= _2n$5;
      S++;
    }
    let Z = _2n$5;
    const _Fp = Field$1(P);
    while (FpLegendre(_Fp, Z) === 1) if (Z++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
    if (S === 1) return sqrt3mod4;
    let cc = _Fp.pow(Z, Q);
    const Q1div2 = (Q + _1n$6) / _2n$5;
    return function tonelliSlow(Fp$1, n) {
      if (Fp$1.is0(n)) return n;
      if (FpLegendre(Fp$1, n) !== 1) throw new Error("Cannot find square root");
      let M = S;
      let c = Fp$1.mul(Fp$1.ONE, cc);
      let t = Fp$1.pow(n, Q);
      let R = Fp$1.pow(n, Q1div2);
      while (!Fp$1.eql(t, Fp$1.ONE)) {
        if (Fp$1.is0(t)) return Fp$1.ZERO;
        let i = 1;
        let t_tmp = Fp$1.sqr(t);
        while (!Fp$1.eql(t_tmp, Fp$1.ONE)) {
          i++;
          t_tmp = Fp$1.sqr(t_tmp);
          if (i === M) throw new Error("Cannot find square root");
        }
        const exponent = _1n$6 << BigInt(M - i - 1);
        const b = Fp$1.pow(c, exponent);
        M = i;
        c = Fp$1.sqr(b);
        t = Fp$1.mul(t, c);
        R = Fp$1.mul(R, b);
      }
      return R;
    };
  }
  function FpSqrt(P) {
    if (P % _4n$1 === _3n$2) return sqrt3mod4;
    if (P % _8n$2 === _5n$1) return sqrt5mod8;
    return tonelliShanks(P);
  }
  const isNegativeLE = (num$1, modulo) => (mod(num$1, modulo) & _1n$6) === _1n$6;
  exports.isNegativeLE = isNegativeLE;
  const FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  function validateField(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "number",
      BITS: "number"
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
      map[val] = "function";
      return map;
    }, initial);
    (0, utils_ts_1$8._validateObject)(field, opts);
    return field;
  }
  function FpPow(Fp$1, num$1, power) {
    if (power < _0n$6) throw new Error("invalid exponent, negatives unsupported");
    if (power === _0n$6) return Fp$1.ONE;
    if (power === _1n$6) return num$1;
    let p = Fp$1.ONE;
    let d = num$1;
    while (power > _0n$6) {
      if (power & _1n$6) p = Fp$1.mul(p, d);
      d = Fp$1.sqr(d);
      power >>= _1n$6;
    }
    return p;
  }
  function FpInvertBatch(Fp$1, nums, passZero = false) {
    const inverted = new Array(nums.length).fill(passZero ? Fp$1.ZERO : void 0);
    const multipliedAcc = nums.reduce((acc, num$1, i) => {
      if (Fp$1.is0(num$1)) return acc;
      inverted[i] = acc;
      return Fp$1.mul(acc, num$1);
    }, Fp$1.ONE);
    const invertedAcc = Fp$1.inv(multipliedAcc);
    nums.reduceRight((acc, num$1, i) => {
      if (Fp$1.is0(num$1)) return acc;
      inverted[i] = Fp$1.mul(acc, inverted[i]);
      return Fp$1.mul(acc, num$1);
    }, invertedAcc);
    return inverted;
  }
  function FpDiv(Fp$1, lhs, rhs) {
    return Fp$1.mul(lhs, typeof rhs === "bigint" ? invert(rhs, Fp$1.ORDER) : Fp$1.inv(rhs));
  }
  function FpLegendre(Fp$1, n) {
    const p1mod2 = (Fp$1.ORDER - _1n$6) / _2n$5;
    const powered = Fp$1.pow(n, p1mod2);
    const yes = Fp$1.eql(powered, Fp$1.ONE);
    const zero = Fp$1.eql(powered, Fp$1.ZERO);
    const no = Fp$1.eql(powered, Fp$1.neg(Fp$1.ONE));
    if (!yes && !zero && !no) throw new Error("invalid Legendre symbol result");
    return yes ? 1 : zero ? 0 : -1;
  }
  function FpIsSquare(Fp$1, n) {
    const l = FpLegendre(Fp$1, n);
    return l === 1;
  }
  function nLength(n, nBitLength) {
    if (nBitLength !== void 0) (0, utils_ts_1$8.anumber)(nBitLength);
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return {
      nBitLength: _nBitLength,
      nByteLength
    };
  }
  function Field$1(ORDER, bitLenOrOpts, isLE = false, opts = {}) {
    if (ORDER <= _0n$6) throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
    let _nbitLength = void 0;
    let _sqrt = void 0;
    if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
      if (opts.sqrt || isLE) throw new Error("cannot specify opts in two arguments");
      const _opts = bitLenOrOpts;
      if (_opts.BITS) _nbitLength = _opts.BITS;
      if (_opts.sqrt) _sqrt = _opts.sqrt;
      if (typeof _opts.isLE === "boolean") isLE = _opts.isLE;
    } else {
      if (typeof bitLenOrOpts === "number") _nbitLength = bitLenOrOpts;
      if (opts.sqrt) _sqrt = opts.sqrt;
    }
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
    if (BYTES > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let sqrtP;
    const f = Object.freeze({
      ORDER,
      isLE,
      BITS,
      BYTES,
      MASK: (0, utils_ts_1$8.bitMask)(BITS),
      ZERO: _0n$6,
      ONE: _1n$6,
      create: (num$1) => mod(num$1, ORDER),
      isValid: (num$1) => {
        if (typeof num$1 !== "bigint") throw new Error("invalid field element: expected bigint, got " + typeof num$1);
        return _0n$6 <= num$1 && num$1 < ORDER;
      },
      is0: (num$1) => num$1 === _0n$6,
      isValidNot0: (num$1) => !f.is0(num$1) && f.isValid(num$1),
      isOdd: (num$1) => (num$1 & _1n$6) === _1n$6,
      neg: (num$1) => mod(-num$1, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num$1) => mod(num$1 * num$1, ORDER),
      add: (lhs, rhs) => mod(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
      pow: (num$1, power) => FpPow(f, num$1, power),
      div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
      sqrN: (num$1) => num$1 * num$1,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num$1) => invert(num$1, ORDER),
      sqrt: _sqrt || ((n) => {
        if (!sqrtP) sqrtP = FpSqrt(ORDER);
        return sqrtP(f, n);
      }),
      toBytes: (num$1) => isLE ? (0, utils_ts_1$8.numberToBytesLE)(num$1, BYTES) : (0, utils_ts_1$8.numberToBytesBE)(num$1, BYTES),
      fromBytes: (bytes$1) => {
        if (bytes$1.length !== BYTES) throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes$1.length);
        return isLE ? (0, utils_ts_1$8.bytesToNumberLE)(bytes$1) : (0, utils_ts_1$8.bytesToNumberBE)(bytes$1);
      },
      invertBatch: (lst) => FpInvertBatch(f, lst),
      cmov: (a, b, c) => c ? b : a
    });
    return Object.freeze(f);
  }
  function FpSqrtOdd(Fp$1, elm) {
    if (!Fp$1.isOdd) throw new Error("Field doesn't have isOdd");
    const root2 = Fp$1.sqrt(elm);
    return Fp$1.isOdd(root2) ? root2 : Fp$1.neg(root2);
  }
  function FpSqrtEven(Fp$1, elm) {
    if (!Fp$1.isOdd) throw new Error("Field doesn't have isOdd");
    const root2 = Fp$1.sqrt(elm);
    return Fp$1.isOdd(root2) ? Fp$1.neg(root2) : root2;
  }
  function hashToPrivateScalar(hash$12, groupOrder, isLE = false) {
    hash$12 = (0, utils_ts_1$8.ensureBytes)("privateHash", hash$12);
    const hashLen = hash$12.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error("hashToPrivateScalar: expected " + minLen + "-1024 bytes of input, got " + hashLen);
    const num$1 = isLE ? (0, utils_ts_1$8.bytesToNumberLE)(hash$12) : (0, utils_ts_1$8.bytesToNumberBE)(hash$12);
    return mod(num$1, groupOrder - _1n$6) + _1n$6;
  }
  function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== "bigint") throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
  }
  function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
  }
  function mapHashToField(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    if (len < 16 || len < minLen || len > 1024) throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
    const num$1 = isLE ? (0, utils_ts_1$8.bytesToNumberLE)(key) : (0, utils_ts_1$8.bytesToNumberBE)(key);
    const reduced = mod(num$1, fieldOrder - _1n$6) + _1n$6;
    return isLE ? (0, utils_ts_1$8.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1$8.numberToBytesBE)(reduced, fieldLen);
  }
} });
var require_curve$1 = __commonJS$1({ "../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/curve.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.negateCt = negateCt;
  exports.normalizeZ = normalizeZ;
  exports.wNAF = wNAF;
  exports.mulEndoUnsafe = mulEndoUnsafe;
  exports.pippenger = pippenger;
  exports.precomputeMSMUnsafe = precomputeMSMUnsafe;
  exports.validateBasic = validateBasic;
  exports._createCurveFields = _createCurveFields;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const utils_ts_1$7 = require_utils$8();
  const modular_ts_1$6 = require_modular$1();
  const _0n$5 = BigInt(0);
  const _1n$5 = BigInt(1);
  function negateCt(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
  }
  function normalizeZ(c, property2, points) {
    const getz = property2 === "pz" ? (p) => p.pz : (p) => p.ez;
    const toInv = (0, modular_ts_1$6.FpInvertBatch)(c.Fp, points.map(getz));
    const affined = points.map((p, i) => p.toAffine(toInv[i]));
    return affined.map(c.fromAffine);
  }
  function validateW(W, bits) {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
  }
  function calcWOpts(W, scalarBits) {
    validateW(W, scalarBits);
    const windows = Math.ceil(scalarBits / W) + 1;
    const windowSize = 2 ** (W - 1);
    const maxNumber = 2 ** W;
    const mask$2 = (0, utils_ts_1$7.bitMask)(W);
    const shiftBy = BigInt(W);
    return {
      windows,
      windowSize,
      mask: mask$2,
      maxNumber,
      shiftBy
    };
  }
  function calcOffsets(n, window$1, wOpts) {
    const { windowSize, mask: mask$2, maxNumber, shiftBy } = wOpts;
    let wbits = Number(n & mask$2);
    let nextN = n >> shiftBy;
    if (wbits > windowSize) {
      wbits -= maxNumber;
      nextN += _1n$5;
    }
    const offsetStart = window$1 * windowSize;
    const offset = offsetStart + Math.abs(wbits) - 1;
    const isZero = wbits === 0;
    const isNeg = wbits < 0;
    const isNegF = window$1 % 2 !== 0;
    const offsetF = offsetStart;
    return {
      nextN,
      offset,
      isZero,
      isNeg,
      isNegF,
      offsetF
    };
  }
  function validateMSMPoints(points, c) {
    if (!Array.isArray(points)) throw new Error("array expected");
    points.forEach((p, i) => {
      if (!(p instanceof c)) throw new Error("invalid point at index " + i);
    });
  }
  function validateMSMScalars(scalars, field) {
    if (!Array.isArray(scalars)) throw new Error("array of scalars expected");
    scalars.forEach((s, i) => {
      if (!field.isValid(s)) throw new Error("invalid scalar at index " + i);
    });
  }
  const pointPrecomputes = /* @__PURE__ */ new WeakMap();
  const pointWindowSizes = /* @__PURE__ */ new WeakMap();
  function getW(P) {
    return pointWindowSizes.get(P) || 1;
  }
  function assert0(n) {
    if (n !== _0n$5) throw new Error("invalid wNAF");
  }
  function wNAF(c, bits) {
    return {
      constTimeNegate: negateCt,
      hasPrecomputes(elm) {
        return getW(elm) !== 1;
      },
      unsafeLadder(elm, n, p = c.ZERO) {
        let d = elm;
        while (n > _0n$5) {
          if (n & _1n$5) p = p.add(d);
          d = d.double();
          n >>= _1n$5;
        }
        return p;
      },
      precomputeWindow(elm, W) {
        const { windows, windowSize } = calcWOpts(W, bits);
        const points = [];
        let p = elm;
        let base$12 = p;
        for (let window$1 = 0; window$1 < windows; window$1++) {
          base$12 = p;
          points.push(base$12);
          for (let i = 1; i < windowSize; i++) {
            base$12 = base$12.add(p);
            points.push(base$12);
          }
          p = base$12.double();
        }
        return points;
      },
      wNAF(W, precomputes, n) {
        let p = c.ZERO;
        let f = c.BASE;
        const wo = calcWOpts(W, bits);
        for (let window$1 = 0; window$1 < wo.windows; window$1++) {
          const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window$1, wo);
          n = nextN;
          if (isZero) f = f.add(negateCt(isNegF, precomputes[offsetF]));
          else p = p.add(negateCt(isNeg, precomputes[offset]));
        }
        assert0(n);
        return {
          p,
          f
        };
      },
      wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {
        const wo = calcWOpts(W, bits);
        for (let window$1 = 0; window$1 < wo.windows; window$1++) {
          if (n === _0n$5) break;
          const { nextN, offset, isZero, isNeg } = calcOffsets(n, window$1, wo);
          n = nextN;
          if (isZero) continue;
          else {
            const item = precomputes[offset];
            acc = acc.add(isNeg ? item.negate() : item);
          }
        }
        assert0(n);
        return acc;
      },
      getPrecomputes(W, P, transform) {
        let comp = pointPrecomputes.get(P);
        if (!comp) {
          comp = this.precomputeWindow(P, W);
          if (W !== 1) {
            if (typeof transform === "function") comp = transform(comp);
            pointPrecomputes.set(P, comp);
          }
        }
        return comp;
      },
      wNAFCached(P, n, transform) {
        const W = getW(P);
        return this.wNAF(W, this.getPrecomputes(W, P, transform), n);
      },
      wNAFCachedUnsafe(P, n, transform, prev) {
        const W = getW(P);
        if (W === 1) return this.unsafeLadder(P, n, prev);
        return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);
      },
      setWindowSize(P, W) {
        validateW(W, bits);
        pointWindowSizes.set(P, W);
        pointPrecomputes.delete(P);
      }
    };
  }
  function mulEndoUnsafe(c, point, k1, k2) {
    let acc = point;
    let p1 = c.ZERO;
    let p2 = c.ZERO;
    while (k1 > _0n$5 || k2 > _0n$5) {
      if (k1 & _1n$5) p1 = p1.add(acc);
      if (k2 & _1n$5) p2 = p2.add(acc);
      acc = acc.double();
      k1 >>= _1n$5;
      k2 >>= _1n$5;
    }
    return {
      p1,
      p2
    };
  }
  function pippenger(c, fieldN, points, scalars) {
    validateMSMPoints(points, c);
    validateMSMScalars(scalars, fieldN);
    const plength = points.length;
    const slength = scalars.length;
    if (plength !== slength) throw new Error("arrays of points and scalars must have equal length");
    const zero = c.ZERO;
    const wbits = (0, utils_ts_1$7.bitLen)(BigInt(plength));
    let windowSize = 1;
    if (wbits > 12) windowSize = wbits - 3;
    else if (wbits > 4) windowSize = wbits - 2;
    else if (wbits > 0) windowSize = 2;
    const MASK$1 = (0, utils_ts_1$7.bitMask)(windowSize);
    const buckets = new Array(Number(MASK$1) + 1).fill(zero);
    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
    let sum = zero;
    for (let i = lastBits; i >= 0; i -= windowSize) {
      buckets.fill(zero);
      for (let j = 0; j < slength; j++) {
        const scalar = scalars[j];
        const wbits$1 = Number(scalar >> BigInt(i) & MASK$1);
        buckets[wbits$1] = buckets[wbits$1].add(points[j]);
      }
      let resI = zero;
      for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
        sumI = sumI.add(buckets[j]);
        resI = resI.add(sumI);
      }
      sum = sum.add(resI);
      if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();
    }
    return sum;
  }
  function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
    validateW(windowSize, fieldN.BITS);
    validateMSMPoints(points, c);
    const zero = c.ZERO;
    const tableSize = 2 ** windowSize - 1;
    const chunks = Math.ceil(fieldN.BITS / windowSize);
    const MASK$1 = (0, utils_ts_1$7.bitMask)(windowSize);
    const tables = points.map((p) => {
      const res = [];
      for (let i = 0, acc = p; i < tableSize; i++) {
        res.push(acc);
        acc = acc.add(p);
      }
      return res;
    });
    return (scalars) => {
      validateMSMScalars(scalars, fieldN);
      if (scalars.length > points.length) throw new Error("array of scalars must be smaller than array of points");
      let res = zero;
      for (let i = 0; i < chunks; i++) {
        if (res !== zero) for (let j = 0; j < windowSize; j++) res = res.double();
        const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);
        for (let j = 0; j < scalars.length; j++) {
          const n = scalars[j];
          const curr = Number(n >> shiftBy & MASK$1);
          if (!curr) continue;
          res = res.add(tables[j][curr - 1]);
        }
      }
      return res;
    };
  }
  function validateBasic(curve) {
    (0, modular_ts_1$6.validateField)(curve.Fp);
    (0, utils_ts_1$7.validateObject)(curve, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    });
    return Object.freeze({
      ...(0, modular_ts_1$6.nLength)(curve.n, curve.nBitLength),
      ...curve,
      p: curve.Fp.ORDER
    });
  }
  function createField(order, field) {
    if (field) {
      if (field.ORDER !== order) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
      (0, modular_ts_1$6.validateField)(field);
      return field;
    } else return (0, modular_ts_1$6.Field)(order);
  }
  function _createCurveFields(type2, CURVE, curveOpts = {}) {
    if (!CURVE || typeof CURVE !== "object") throw new Error(`expected valid ${type2} CURVE object`);
    for (const p of [
      "p",
      "n",
      "h"
    ]) {
      const val = CURVE[p];
      if (!(typeof val === "bigint" && val > _0n$5)) throw new Error(`CURVE.${p} must be positive bigint`);
    }
    const Fp$1 = createField(CURVE.p, curveOpts.Fp);
    const Fn = createField(CURVE.n, curveOpts.Fn);
    const _b = type2 === "weierstrass" ? "b" : "d";
    const params = [
      "Gx",
      "Gy",
      "a",
      _b
    ];
    for (const p of params) if (!Fp$1.isValid(CURVE[p])) throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
    return {
      Fp: Fp$1,
      Fn
    };
  }
} });
var require_weierstrass$1 = __commonJS$1({ "../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DER = exports.DERErr = void 0;
  exports._legacyHelperEquat = _legacyHelperEquat;
  exports._legacyHelperNormPriv = _legacyHelperNormPriv;
  exports.weierstrassN = weierstrassN;
  exports.weierstrassPoints = weierstrassPoints;
  exports.ecdsa = ecdsa;
  exports.weierstrass = weierstrass;
  exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
  exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const hmac_js_1 = require_hmac$1();
  const utils_ts_1$6 = require_utils$8();
  const curve_ts_1$2 = require_curve$1();
  const modular_ts_1$5 = require_modular$1();
  function validateSigVerOpts(opts) {
    if (opts.lowS !== void 0) (0, utils_ts_1$6.abool)("lowS", opts.lowS);
    if (opts.prehash !== void 0) (0, utils_ts_1$6.abool)("prehash", opts.prehash);
  }
  var DERErr = class extends Error {
    constructor(m = "") {
      super(m);
    }
  };
  exports.DERErr = DERErr;
  exports.DER = {
    Err: DERErr,
    _tlv: {
      encode: (tag, data2) => {
        const { Err: E } = exports.DER;
        if (tag < 0 || tag > 256) throw new E("tlv.encode: wrong tag");
        if (data2.length & 1) throw new E("tlv.encode: unpadded data");
        const dataLen = data2.length / 2;
        const len = (0, utils_ts_1$6.numberToHexUnpadded)(dataLen);
        if (len.length / 2 & 128) throw new E("tlv.encode: long form length too big");
        const lenLen = dataLen > 127 ? (0, utils_ts_1$6.numberToHexUnpadded)(len.length / 2 | 128) : "";
        const t = (0, utils_ts_1$6.numberToHexUnpadded)(tag);
        return t + lenLen + len + data2;
      },
      decode(tag, data2) {
        const { Err: E } = exports.DER;
        let pos = 0;
        if (tag < 0 || tag > 256) throw new E("tlv.encode: wrong tag");
        if (data2.length < 2 || data2[pos++] !== tag) throw new E("tlv.decode: wrong tlv");
        const first = data2[pos++];
        const isLong = !!(first & 128);
        let length = 0;
        if (!isLong) length = first;
        else {
          const lenLen = first & 127;
          if (!lenLen) throw new E("tlv.decode(long): indefinite length not supported");
          if (lenLen > 4) throw new E("tlv.decode(long): byte length is too big");
          const lengthBytes = data2.subarray(pos, pos + lenLen);
          if (lengthBytes.length !== lenLen) throw new E("tlv.decode: length bytes not complete");
          if (lengthBytes[0] === 0) throw new E("tlv.decode(long): zero leftmost byte");
          for (const b of lengthBytes) length = length << 8 | b;
          pos += lenLen;
          if (length < 128) throw new E("tlv.decode(long): not minimal encoding");
        }
        const v = data2.subarray(pos, pos + length);
        if (v.length !== length) throw new E("tlv.decode: wrong value length");
        return {
          v,
          l: data2.subarray(pos + length)
        };
      }
    },
    _int: {
      encode(num$1) {
        const { Err: E } = exports.DER;
        if (num$1 < _0n$4) throw new E("integer: negative integers are not allowed");
        let hex = (0, utils_ts_1$6.numberToHexUnpadded)(num$1);
        if (Number.parseInt(hex[0], 16) & 8) hex = "00" + hex;
        if (hex.length & 1) throw new E("unexpected DER parsing assertion: unpadded hex");
        return hex;
      },
      decode(data2) {
        const { Err: E } = exports.DER;
        if (data2[0] & 128) throw new E("invalid signature integer: negative");
        if (data2[0] === 0 && !(data2[1] & 128)) throw new E("invalid signature integer: unnecessary leading zero");
        return (0, utils_ts_1$6.bytesToNumberBE)(data2);
      }
    },
    toSig(hex) {
      const { Err: E, _int: int, _tlv: tlv } = exports.DER;
      const data2 = (0, utils_ts_1$6.ensureBytes)("signature", hex);
      const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data2);
      if (seqLeftBytes.length) throw new E("invalid signature: left bytes after parsing");
      const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
      const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
      if (sLeftBytes.length) throw new E("invalid signature: left bytes after parsing");
      return {
        r: int.decode(rBytes),
        s: int.decode(sBytes)
      };
    },
    hexFromSig(sig) {
      const { _tlv: tlv, _int: int } = exports.DER;
      const rs = tlv.encode(2, int.encode(sig.r));
      const ss = tlv.encode(2, int.encode(sig.s));
      const seq = rs + ss;
      return tlv.encode(48, seq);
    }
  };
  const _0n$4 = BigInt(0), _1n$4 = BigInt(1), _2n$4 = BigInt(2), _3n$1 = BigInt(3), _4n = BigInt(4);
  function _legacyHelperEquat(Fp$1, a, b) {
    function weierstrassEquation(x) {
      const x2 = Fp$1.sqr(x);
      const x3 = Fp$1.mul(x2, x);
      return Fp$1.add(Fp$1.add(x3, Fp$1.mul(x, a)), b);
    }
    return weierstrassEquation;
  }
  function _legacyHelperNormPriv(Fn, allowedPrivateKeyLengths, wrapPrivateKey) {
    const { BYTES: expected } = Fn;
    function normPrivateKeyToScalar(key) {
      let num$1;
      if (typeof key === "bigint") num$1 = key;
      else {
        let bytes$1 = (0, utils_ts_1$6.ensureBytes)("private key", key);
        if (allowedPrivateKeyLengths) {
          if (!allowedPrivateKeyLengths.includes(bytes$1.length * 2)) throw new Error("invalid private key");
          const padded = new Uint8Array(expected);
          padded.set(bytes$1, padded.length - bytes$1.length);
          bytes$1 = padded;
        }
        try {
          num$1 = Fn.fromBytes(bytes$1);
        } catch (error) {
          throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
        }
      }
      if (wrapPrivateKey) num$1 = Fn.create(num$1);
      if (!Fn.isValidNot0(num$1)) throw new Error("invalid private key: out of range [1..N-1]");
      return num$1;
    }
    return normPrivateKeyToScalar;
  }
  function weierstrassN(CURVE, curveOpts = {}) {
    const { Fp: Fp$1, Fn } = (0, curve_ts_1$2._createCurveFields)("weierstrass", CURVE, curveOpts);
    const { h: cofactor, n: CURVE_ORDER } = CURVE;
    (0, utils_ts_1$6._validateObject)(curveOpts, {}, {
      allowInfinityPoint: "boolean",
      clearCofactor: "function",
      isTorsionFree: "function",
      fromBytes: "function",
      toBytes: "function",
      endo: "object",
      wrapPrivateKey: "boolean"
    });
    const { endo } = curveOpts;
    if (endo) {
      if (!Fp$1.is0(CURVE.a) || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
    }
    function assertCompressionIsSupported() {
      if (!Fp$1.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
    }
    function pointToBytes$1(_c, point, isCompressed) {
      const { x, y } = point.toAffine();
      const bx = Fp$1.toBytes(x);
      (0, utils_ts_1$6.abool)("isCompressed", isCompressed);
      if (isCompressed) {
        assertCompressionIsSupported();
        const hasEvenY = !Fp$1.isOdd(y);
        return (0, utils_ts_1$6.concatBytes)(pprefix(hasEvenY), bx);
      } else return (0, utils_ts_1$6.concatBytes)(Uint8Array.of(4), bx, Fp$1.toBytes(y));
    }
    function pointFromBytes(bytes$1) {
      (0, utils_ts_1$6.abytes)(bytes$1);
      const L = Fp$1.BYTES;
      const LC2 = L + 1;
      const LU2 = 2 * L + 1;
      const length = bytes$1.length;
      const head = bytes$1[0];
      const tail = bytes$1.subarray(1);
      if (length === LC2 && (head === 2 || head === 3)) {
        const x = Fp$1.fromBytes(tail);
        if (!Fp$1.isValid(x)) throw new Error("bad point: is not on curve, wrong x");
        const y2 = weierstrassEquation(x);
        let y;
        try {
          y = Fp$1.sqrt(y2);
        } catch (sqrtError) {
          const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("bad point: is not on curve, sqrt error" + err);
        }
        assertCompressionIsSupported();
        const isYOdd = Fp$1.isOdd(y);
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd) y = Fp$1.neg(y);
        return {
          x,
          y
        };
      } else if (length === LU2 && head === 4) {
        const x = Fp$1.fromBytes(tail.subarray(L * 0, L * 1));
        const y = Fp$1.fromBytes(tail.subarray(L * 1, L * 2));
        if (!isValidXY(x, y)) throw new Error("bad point: is not on curve");
        return {
          x,
          y
        };
      } else throw new Error(`bad point: got length ${length}, expected compressed=${LC2} or uncompressed=${LU2}`);
    }
    const toBytes$1 = curveOpts.toBytes || pointToBytes$1;
    const fromBytes = curveOpts.fromBytes || pointFromBytes;
    const weierstrassEquation = _legacyHelperEquat(Fp$1, CURVE.a, CURVE.b);
    function isValidXY(x, y) {
      const left = Fp$1.sqr(y);
      const right = weierstrassEquation(x);
      return Fp$1.eql(left, right);
    }
    if (!isValidXY(CURVE.Gx, CURVE.Gy)) throw new Error("bad curve params: generator point");
    const _4a3 = Fp$1.mul(Fp$1.pow(CURVE.a, _3n$1), _4n);
    const _27b2 = Fp$1.mul(Fp$1.sqr(CURVE.b), BigInt(27));
    if (Fp$1.is0(Fp$1.add(_4a3, _27b2))) throw new Error("bad curve params: a or b");
    function acoord(title, n, banZero = false) {
      if (!Fp$1.isValid(n) || banZero && Fp$1.is0(n)) throw new Error(`bad point coordinate ${title}`);
      return n;
    }
    function aprjpoint(other) {
      if (!(other instanceof Point$2)) throw new Error("ProjectivePoint expected");
    }
    const toAffineMemo = (0, utils_ts_1$6.memoized)((p, iz) => {
      const { px: x, py: y, pz: z2 } = p;
      if (Fp$1.eql(z2, Fp$1.ONE)) return {
        x,
        y
      };
      const is0 = p.is0();
      if (iz == null) iz = is0 ? Fp$1.ONE : Fp$1.inv(z2);
      const ax = Fp$1.mul(x, iz);
      const ay = Fp$1.mul(y, iz);
      const zz = Fp$1.mul(z2, iz);
      if (is0) return {
        x: Fp$1.ZERO,
        y: Fp$1.ZERO
      };
      if (!Fp$1.eql(zz, Fp$1.ONE)) throw new Error("invZ was invalid");
      return {
        x: ax,
        y: ay
      };
    });
    const assertValidMemo = (0, utils_ts_1$6.memoized)((p) => {
      if (p.is0()) {
        if (curveOpts.allowInfinityPoint && !Fp$1.is0(p.py)) return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = p.toAffine();
      if (!Fp$1.isValid(x) || !Fp$1.isValid(y)) throw new Error("bad point: x or y not field elements");
      if (!isValidXY(x, y)) throw new Error("bad point: equation left != right");
      if (!p.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
      return true;
    });
    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
      k2p = new Point$2(Fp$1.mul(k2p.px, endoBeta), k2p.py, k2p.pz);
      k1p = (0, curve_ts_1$2.negateCt)(k1neg, k1p);
      k2p = (0, curve_ts_1$2.negateCt)(k2neg, k2p);
      return k1p.add(k2p);
    }
    class Point$2 {
      /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
      constructor(px, py, pz) {
        this.px = acoord("x", px);
        this.py = acoord("y", py, true);
        this.pz = acoord("z", pz);
        Object.freeze(this);
      }
      /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
      static fromAffine(p) {
        const { x, y } = p || {};
        if (!p || !Fp$1.isValid(x) || !Fp$1.isValid(y)) throw new Error("invalid affine point");
        if (p instanceof Point$2) throw new Error("projective point not allowed");
        if (Fp$1.is0(x) && Fp$1.is0(y)) return Point$2.ZERO;
        return new Point$2(x, y, Fp$1.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(points) {
        return (0, curve_ts_1$2.normalizeZ)(Point$2, "pz", points);
      }
      static fromBytes(bytes$1) {
        (0, utils_ts_1$6.abytes)(bytes$1);
        return Point$2.fromHex(bytes$1);
      }
      /** Converts hash string or Uint8Array to Point. */
      static fromHex(hex) {
        const P = Point$2.fromAffine(fromBytes((0, utils_ts_1$6.ensureBytes)("pointHex", hex)));
        P.assertValidity();
        return P;
      }
      /** Multiplies generator point by privateKey. */
      static fromPrivateKey(privateKey) {
        const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
        return Point$2.BASE.multiply(normPrivateKeyToScalar(privateKey));
      }
      /** Multiscalar Multiplication */
      static msm(points, scalars) {
        return (0, curve_ts_1$2.pippenger)(Point$2, Fn, points, scalars);
      }
      /**
      *
      * @param windowSize
      * @param isLazy true will defer table computation until the first multiplication
      * @returns
      */
      precompute(windowSize = 8, isLazy = true) {
        wnaf.setWindowSize(this, windowSize);
        if (!isLazy) this.multiply(_3n$1);
        return this;
      }
      /** "Private method", don't use it directly */
      _setWindowSize(windowSize) {
        this.precompute(windowSize);
      }
      /** A point on curve is valid if it conforms to equation. */
      assertValidity() {
        assertValidMemo(this);
      }
      hasEvenY() {
        const { y } = this.toAffine();
        if (!Fp$1.isOdd) throw new Error("Field doesn't support isOdd");
        return !Fp$1.isOdd(y);
      }
      /** Compare one point to another. */
      equals(other) {
        aprjpoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        const U1 = Fp$1.eql(Fp$1.mul(X1, Z2), Fp$1.mul(X2, Z1));
        const U2 = Fp$1.eql(Fp$1.mul(Y1, Z2), Fp$1.mul(Y2, Z1));
        return U1 && U2;
      }
      /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
      negate() {
        return new Point$2(this.px, Fp$1.neg(this.py), this.pz);
      }
      double() {
        const { a, b } = CURVE;
        const b3 = Fp$1.mul(b, _3n$1);
        const { px: X1, py: Y1, pz: Z1 } = this;
        let X3 = Fp$1.ZERO, Y3 = Fp$1.ZERO, Z3 = Fp$1.ZERO;
        let t0 = Fp$1.mul(X1, X1);
        let t1 = Fp$1.mul(Y1, Y1);
        let t2 = Fp$1.mul(Z1, Z1);
        let t3 = Fp$1.mul(X1, Y1);
        t3 = Fp$1.add(t3, t3);
        Z3 = Fp$1.mul(X1, Z1);
        Z3 = Fp$1.add(Z3, Z3);
        X3 = Fp$1.mul(a, Z3);
        Y3 = Fp$1.mul(b3, t2);
        Y3 = Fp$1.add(X3, Y3);
        X3 = Fp$1.sub(t1, Y3);
        Y3 = Fp$1.add(t1, Y3);
        Y3 = Fp$1.mul(X3, Y3);
        X3 = Fp$1.mul(t3, X3);
        Z3 = Fp$1.mul(b3, Z3);
        t2 = Fp$1.mul(a, t2);
        t3 = Fp$1.sub(t0, t2);
        t3 = Fp$1.mul(a, t3);
        t3 = Fp$1.add(t3, Z3);
        Z3 = Fp$1.add(t0, t0);
        t0 = Fp$1.add(Z3, t0);
        t0 = Fp$1.add(t0, t2);
        t0 = Fp$1.mul(t0, t3);
        Y3 = Fp$1.add(Y3, t0);
        t2 = Fp$1.mul(Y1, Z1);
        t2 = Fp$1.add(t2, t2);
        t0 = Fp$1.mul(t2, t3);
        X3 = Fp$1.sub(X3, t0);
        Z3 = Fp$1.mul(t2, t1);
        Z3 = Fp$1.add(Z3, Z3);
        Z3 = Fp$1.add(Z3, Z3);
        return new Point$2(X3, Y3, Z3);
      }
      add(other) {
        aprjpoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        let X3 = Fp$1.ZERO, Y3 = Fp$1.ZERO, Z3 = Fp$1.ZERO;
        const a = CURVE.a;
        const b3 = Fp$1.mul(CURVE.b, _3n$1);
        let t0 = Fp$1.mul(X1, X2);
        let t1 = Fp$1.mul(Y1, Y2);
        let t2 = Fp$1.mul(Z1, Z2);
        let t3 = Fp$1.add(X1, Y1);
        let t4 = Fp$1.add(X2, Y2);
        t3 = Fp$1.mul(t3, t4);
        t4 = Fp$1.add(t0, t1);
        t3 = Fp$1.sub(t3, t4);
        t4 = Fp$1.add(X1, Z1);
        let t5 = Fp$1.add(X2, Z2);
        t4 = Fp$1.mul(t4, t5);
        t5 = Fp$1.add(t0, t2);
        t4 = Fp$1.sub(t4, t5);
        t5 = Fp$1.add(Y1, Z1);
        X3 = Fp$1.add(Y2, Z2);
        t5 = Fp$1.mul(t5, X3);
        X3 = Fp$1.add(t1, t2);
        t5 = Fp$1.sub(t5, X3);
        Z3 = Fp$1.mul(a, t4);
        X3 = Fp$1.mul(b3, t2);
        Z3 = Fp$1.add(X3, Z3);
        X3 = Fp$1.sub(t1, Z3);
        Z3 = Fp$1.add(t1, Z3);
        Y3 = Fp$1.mul(X3, Z3);
        t1 = Fp$1.add(t0, t0);
        t1 = Fp$1.add(t1, t0);
        t2 = Fp$1.mul(a, t2);
        t4 = Fp$1.mul(b3, t4);
        t1 = Fp$1.add(t1, t2);
        t2 = Fp$1.sub(t0, t2);
        t2 = Fp$1.mul(a, t2);
        t4 = Fp$1.add(t4, t2);
        t0 = Fp$1.mul(t1, t4);
        Y3 = Fp$1.add(Y3, t0);
        t0 = Fp$1.mul(t5, t4);
        X3 = Fp$1.mul(t3, X3);
        X3 = Fp$1.sub(X3, t0);
        t0 = Fp$1.mul(t3, t1);
        Z3 = Fp$1.mul(t5, Z3);
        Z3 = Fp$1.add(Z3, t0);
        return new Point$2(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point$2.ZERO);
      }
      /**
      * Constant time multiplication.
      * Uses wNAF method. Windowed method may be 10% faster,
      * but takes 2x longer to generate and consumes 2x memory.
      * Uses precomputes when available.
      * Uses endomorphism for Koblitz curves.
      * @param scalar by which the point would be multiplied
      * @returns New point
      */
      multiply(scalar) {
        const { endo: endo$1 } = curveOpts;
        if (!Fn.isValidNot0(scalar)) throw new Error("invalid scalar: out of range");
        let point, fake;
        const mul = (n) => wnaf.wNAFCached(this, n, Point$2.normalizeZ);
        if (endo$1) {
          const { k1neg, k1, k2neg, k2 } = endo$1.splitScalar(scalar);
          const { p: k1p, f: k1f } = mul(k1);
          const { p: k2p, f: k2f } = mul(k2);
          fake = k1f.add(k2f);
          point = finishEndo(endo$1.beta, k1p, k2p, k1neg, k2neg);
        } else {
          const { p, f } = mul(scalar);
          point = p;
          fake = f;
        }
        return Point$2.normalizeZ([point, fake])[0];
      }
      /**
      * Non-constant-time multiplication. Uses double-and-add algorithm.
      * It's faster, but should only be used when you don't care about
      * an exposed private key e.g. sig verification, which works over *public* keys.
      */
      multiplyUnsafe(sc) {
        const { endo: endo$1 } = curveOpts;
        const p = this;
        if (!Fn.isValid(sc)) throw new Error("invalid scalar: out of range");
        if (sc === _0n$4 || p.is0()) return Point$2.ZERO;
        if (sc === _1n$4) return p;
        if (wnaf.hasPrecomputes(this)) return this.multiply(sc);
        if (endo$1) {
          const { k1neg, k1, k2neg, k2 } = endo$1.splitScalar(sc);
          const { p1, p2 } = (0, curve_ts_1$2.mulEndoUnsafe)(Point$2, p, k1, k2);
          return finishEndo(endo$1.beta, p1, p2, k1neg, k2neg);
        } else return wnaf.wNAFCachedUnsafe(p, sc);
      }
      multiplyAndAddUnsafe(Q, a, b) {
        const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
        return sum.is0() ? void 0 : sum;
      }
      /**
      * Converts Projective point to affine (x, y) coordinates.
      * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
      */
      toAffine(invertedZ) {
        return toAffineMemo(this, invertedZ);
      }
      /**
      * Checks whether Point is free of torsion elements (is in prime subgroup).
      * Always torsion-free for cofactor=1 curves.
      */
      isTorsionFree() {
        const { isTorsionFree } = curveOpts;
        if (cofactor === _1n$4) return true;
        if (isTorsionFree) return isTorsionFree(Point$2, this);
        return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
      }
      clearCofactor() {
        const { clearCofactor } = curveOpts;
        if (cofactor === _1n$4) return this;
        if (clearCofactor) return clearCofactor(Point$2, this);
        return this.multiplyUnsafe(cofactor);
      }
      toBytes(isCompressed = true) {
        (0, utils_ts_1$6.abool)("isCompressed", isCompressed);
        this.assertValidity();
        return toBytes$1(Point$2, this, isCompressed);
      }
      /** @deprecated use `toBytes` */
      toRawBytes(isCompressed = true) {
        return this.toBytes(isCompressed);
      }
      toHex(isCompressed = true) {
        return (0, utils_ts_1$6.bytesToHex)(this.toBytes(isCompressed));
      }
      toString() {
        return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
      }
    }
    Point$2.BASE = new Point$2(CURVE.Gx, CURVE.Gy, Fp$1.ONE);
    Point$2.ZERO = new Point$2(Fp$1.ZERO, Fp$1.ONE, Fp$1.ZERO);
    Point$2.Fp = Fp$1;
    Point$2.Fn = Fn;
    const bits = Fn.BITS;
    const wnaf = (0, curve_ts_1$2.wNAF)(Point$2, curveOpts.endo ? Math.ceil(bits / 2) : bits);
    return Point$2;
  }
  function weierstrassPoints(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const Point$2 = weierstrassN(CURVE, curveOpts);
    return _weierstrass_new_output_to_legacy(c, Point$2);
  }
  function pprefix(hasEvenY) {
    return Uint8Array.of(hasEvenY ? 2 : 3);
  }
  function ecdsa(Point$2, ecdsaOpts, curveOpts = {}) {
    (0, utils_ts_1$6._validateObject)(ecdsaOpts, { hash: "function" }, {
      hmac: "function",
      lowS: "boolean",
      randomBytes: "function",
      bits2int: "function",
      bits2int_modN: "function"
    });
    const randomBytes_ = ecdsaOpts.randomBytes || utils_ts_1$6.randomBytes;
    const hmac_ = ecdsaOpts.hmac || ((key, ...msgs) => (0, hmac_js_1.hmac)(ecdsaOpts.hash, key, (0, utils_ts_1$6.concatBytes)(...msgs)));
    const { Fp: Fp$1, Fn } = Point$2;
    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
    function isBiggerThanHalfOrder(number) {
      const HALF = CURVE_ORDER >> _1n$4;
      return number > HALF;
    }
    function normalizeS(s) {
      return isBiggerThanHalfOrder(s) ? Fn.neg(s) : s;
    }
    function aValidRS(title, num$1) {
      if (!Fn.isValidNot0(num$1)) throw new Error(`invalid signature ${title}: out of range 1..CURVE.n`);
    }
    class Signature {
      constructor(r, s, recovery) {
        aValidRS("r", r);
        aValidRS("s", s);
        this.r = r;
        this.s = s;
        if (recovery != null) this.recovery = recovery;
        Object.freeze(this);
      }
      static fromCompact(hex) {
        const L = Fn.BYTES;
        const b = (0, utils_ts_1$6.ensureBytes)("compactSignature", hex, L * 2);
        return new Signature(Fn.fromBytes(b.subarray(0, L)), Fn.fromBytes(b.subarray(L, L * 2)));
      }
      static fromDER(hex) {
        const { r, s } = exports.DER.toSig((0, utils_ts_1$6.ensureBytes)("DER", hex));
        return new Signature(r, s);
      }
      /**
      * @todo remove
      * @deprecated
      */
      assertValidity() {
      }
      addRecoveryBit(recovery) {
        return new Signature(this.r, this.s, recovery);
      }
      recoverPublicKey(msgHash) {
        const FIELD_ORDER = Fp$1.ORDER;
        const { r, s, recovery: rec } = this;
        if (rec == null || ![
          0,
          1,
          2,
          3
        ].includes(rec)) throw new Error("recovery id invalid");
        const hasCofactor = CURVE_ORDER * _2n$4 < FIELD_ORDER;
        if (hasCofactor && rec > 1) throw new Error("recovery id is ambiguous for h>1 curve");
        const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
        if (!Fp$1.isValid(radj)) throw new Error("recovery id 2 or 3 invalid");
        const x = Fp$1.toBytes(radj);
        const R = Point$2.fromHex((0, utils_ts_1$6.concatBytes)(pprefix((rec & 1) === 0), x));
        const ir = Fn.inv(radj);
        const h = bits2int_modN((0, utils_ts_1$6.ensureBytes)("msgHash", msgHash));
        const u1 = Fn.create(-h * ir);
        const u2 = Fn.create(s * ir);
        const Q = Point$2.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
        if (Q.is0()) throw new Error("point at infinify");
        Q.assertValidity();
        return Q;
      }
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;
      }
      toBytes(format) {
        if (format === "compact") return (0, utils_ts_1$6.concatBytes)(Fn.toBytes(this.r), Fn.toBytes(this.s));
        if (format === "der") return (0, utils_ts_1$6.hexToBytes)(exports.DER.hexFromSig(this));
        throw new Error("invalid format");
      }
      toDERRawBytes() {
        return this.toBytes("der");
      }
      toDERHex() {
        return (0, utils_ts_1$6.bytesToHex)(this.toBytes("der"));
      }
      toCompactRawBytes() {
        return this.toBytes("compact");
      }
      toCompactHex() {
        return (0, utils_ts_1$6.bytesToHex)(this.toBytes("compact"));
      }
    }
    const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
    const utils2 = {
      isValidPrivateKey(privateKey) {
        try {
          normPrivateKeyToScalar(privateKey);
          return true;
        } catch (error) {
          return false;
        }
      },
      normPrivateKeyToScalar,
      randomPrivateKey: () => {
        const n = CURVE_ORDER;
        return (0, modular_ts_1$5.mapHashToField)(randomBytes_((0, modular_ts_1$5.getMinHashLength)(n)), n);
      },
      precompute(windowSize = 8, point = Point$2.BASE) {
        return point.precompute(windowSize, false);
      }
    };
    function getPublicKey(privateKey, isCompressed = true) {
      return Point$2.fromPrivateKey(privateKey).toBytes(isCompressed);
    }
    function isProbPub(item) {
      if (typeof item === "bigint") return false;
      if (item instanceof Point$2) return true;
      const arr = (0, utils_ts_1$6.ensureBytes)("key", item);
      const length = arr.length;
      const L = Fp$1.BYTES;
      const LC2 = L + 1;
      const LU2 = 2 * L + 1;
      if (curveOpts.allowedPrivateKeyLengths || Fn.BYTES === LC2) return void 0;
      else return length === LC2 || length === LU2;
    }
    function getSharedSecret(privateA, publicB, isCompressed = true) {
      if (isProbPub(privateA) === true) throw new Error("first arg must be private key");
      if (isProbPub(publicB) === false) throw new Error("second arg must be public key");
      const b = Point$2.fromHex(publicB);
      return b.multiply(normPrivateKeyToScalar(privateA)).toBytes(isCompressed);
    }
    const bits2int = ecdsaOpts.bits2int || function(bytes$1) {
      if (bytes$1.length > 8192) throw new Error("input is too large");
      const num$1 = (0, utils_ts_1$6.bytesToNumberBE)(bytes$1);
      const delta = bytes$1.length * 8 - fnBits;
      return delta > 0 ? num$1 >> BigInt(delta) : num$1;
    };
    const bits2int_modN = ecdsaOpts.bits2int_modN || function(bytes$1) {
      return Fn.create(bits2int(bytes$1));
    };
    const ORDER_MASK = (0, utils_ts_1$6.bitMask)(fnBits);
    function int2octets(num$1) {
      (0, utils_ts_1$6.aInRange)("num < 2^" + fnBits, num$1, _0n$4, ORDER_MASK);
      return Fn.toBytes(num$1);
    }
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
      if (["recovered", "canonical"].some((k) => k in opts)) throw new Error("sign() legacy options not supported");
      const { hash: hash$12 } = ecdsaOpts;
      let { lowS, prehash, extraEntropy: ent } = opts;
      if (lowS == null) lowS = true;
      msgHash = (0, utils_ts_1$6.ensureBytes)("msgHash", msgHash);
      validateSigVerOpts(opts);
      if (prehash) msgHash = (0, utils_ts_1$6.ensureBytes)("prehashed msgHash", hash$12(msgHash));
      const h1int = bits2int_modN(msgHash);
      const d = normPrivateKeyToScalar(privateKey);
      const seedArgs = [int2octets(d), int2octets(h1int)];
      if (ent != null && ent !== false) {
        const e = ent === true ? randomBytes_(Fp$1.BYTES) : ent;
        seedArgs.push((0, utils_ts_1$6.ensureBytes)("extraEntropy", e));
      }
      const seed = (0, utils_ts_1$6.concatBytes)(...seedArgs);
      const m = h1int;
      function k2sig(kBytes) {
        const k = bits2int(kBytes);
        if (!Fn.isValidNot0(k)) return;
        const ik = Fn.inv(k);
        const q = Point$2.BASE.multiply(k).toAffine();
        const r = Fn.create(q.x);
        if (r === _0n$4) return;
        const s = Fn.create(ik * Fn.create(m + r * d));
        if (s === _0n$4) return;
        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n$4);
        let normS = s;
        if (lowS && isBiggerThanHalfOrder(s)) {
          normS = normalizeS(s);
          recovery ^= 1;
        }
        return new Signature(r, normS, recovery);
      }
      return {
        seed,
        k2sig
      };
    }
    const defaultSigOpts = {
      lowS: ecdsaOpts.lowS,
      prehash: false
    };
    const defaultVerOpts = {
      lowS: ecdsaOpts.lowS,
      prehash: false
    };
    function sign$1(msgHash, privKey, opts = defaultSigOpts) {
      const { seed, k2sig } = prepSig(msgHash, privKey, opts);
      const drbg = (0, utils_ts_1$6.createHmacDrbg)(ecdsaOpts.hash.outputLen, Fn.BYTES, hmac_);
      return drbg(seed, k2sig);
    }
    Point$2.BASE.precompute(8);
    function verify$1(signature2, msgHash, publicKey, opts = defaultVerOpts) {
      const sg = signature2;
      msgHash = (0, utils_ts_1$6.ensureBytes)("msgHash", msgHash);
      publicKey = (0, utils_ts_1$6.ensureBytes)("publicKey", publicKey);
      validateSigVerOpts(opts);
      const { lowS, prehash, format } = opts;
      if ("strict" in opts) throw new Error("options.strict was renamed to lowS");
      if (format !== void 0 && ![
        "compact",
        "der",
        "js"
      ].includes(format)) throw new Error('format must be "compact", "der" or "js"');
      const isHex$2 = typeof sg === "string" || (0, utils_ts_1$6.isBytes)(sg);
      const isObj = !isHex$2 && !format && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
      if (!isHex$2 && !isObj) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
      let _sig = void 0;
      let P;
      try {
        if (isObj) if (format === void 0 || format === "js") _sig = new Signature(sg.r, sg.s);
        else throw new Error("invalid format");
        if (isHex$2) {
          try {
            if (format !== "compact") _sig = Signature.fromDER(sg);
          } catch (derError) {
            if (!(derError instanceof exports.DER.Err)) throw derError;
          }
          if (!_sig && format !== "der") _sig = Signature.fromCompact(sg);
        }
        P = Point$2.fromHex(publicKey);
      } catch (error) {
        return false;
      }
      if (!_sig) return false;
      if (lowS && _sig.hasHighS()) return false;
      if (prehash) msgHash = ecdsaOpts.hash(msgHash);
      const { r, s } = _sig;
      const h = bits2int_modN(msgHash);
      const is = Fn.inv(s);
      const u1 = Fn.create(h * is);
      const u2 = Fn.create(r * is);
      const R = Point$2.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
      if (R.is0()) return false;
      const v = Fn.create(R.x);
      return v === r;
    }
    return Object.freeze({
      getPublicKey,
      getSharedSecret,
      sign: sign$1,
      verify: verify$1,
      utils: utils2,
      Point: Point$2,
      Signature
    });
  }
  function _weierstrass_legacy_opts_to_new(c) {
    const CURVE = {
      a: c.a,
      b: c.b,
      p: c.Fp.ORDER,
      n: c.n,
      h: c.h,
      Gx: c.Gx,
      Gy: c.Gy
    };
    const Fp$1 = c.Fp;
    const Fn = (0, modular_ts_1$5.Field)(CURVE.n, c.nBitLength);
    const curveOpts = {
      Fp: Fp$1,
      Fn,
      allowedPrivateKeyLengths: c.allowedPrivateKeyLengths,
      allowInfinityPoint: c.allowInfinityPoint,
      endo: c.endo,
      wrapPrivateKey: c.wrapPrivateKey,
      isTorsionFree: c.isTorsionFree,
      clearCofactor: c.clearCofactor,
      fromBytes: c.fromBytes,
      toBytes: c.toBytes
    };
    return {
      CURVE,
      curveOpts
    };
  }
  function _ecdsa_legacy_opts_to_new(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const ecdsaOpts = {
      hash: c.hash,
      hmac: c.hmac,
      randomBytes: c.randomBytes,
      lowS: c.lowS,
      bits2int: c.bits2int,
      bits2int_modN: c.bits2int_modN
    };
    return {
      CURVE,
      curveOpts,
      ecdsaOpts
    };
  }
  function _weierstrass_new_output_to_legacy(c, Point$2) {
    const { Fp: Fp$1, Fn } = Point$2;
    function isWithinCurveOrder(num$1) {
      return (0, utils_ts_1$6.inRange)(num$1, _1n$4, Fn.ORDER);
    }
    const weierstrassEquation = _legacyHelperEquat(Fp$1, c.a, c.b);
    const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, c.allowedPrivateKeyLengths, c.wrapPrivateKey);
    return Object.assign({}, {
      CURVE: c,
      Point: Point$2,
      ProjectivePoint: Point$2,
      normPrivateKeyToScalar,
      weierstrassEquation,
      isWithinCurveOrder
    });
  }
  function _ecdsa_new_output_to_legacy(c, ecdsa$1) {
    return Object.assign({}, ecdsa$1, {
      ProjectivePoint: ecdsa$1.Point,
      CURVE: c
    });
  }
  function weierstrass(c) {
    const { CURVE, curveOpts, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
    const Point$2 = weierstrassN(CURVE, curveOpts);
    const signs = ecdsa(Point$2, ecdsaOpts, curveOpts);
    return _ecdsa_new_output_to_legacy(c, signs);
  }
  function SWUFpSqrtRatio(Fp$1, Z) {
    const q = Fp$1.ORDER;
    let l = _0n$4;
    for (let o = q - _1n$4; o % _2n$4 === _0n$4; o /= _2n$4) l += _1n$4;
    const c1 = l;
    const _2n_pow_c1_1 = _2n$4 << c1 - _1n$4 - _1n$4;
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n$4;
    const c2 = (q - _1n$4) / _2n_pow_c1;
    const c3 = (c2 - _1n$4) / _2n$4;
    const c4 = _2n_pow_c1 - _1n$4;
    const c5 = _2n_pow_c1_1;
    const c6 = Fp$1.pow(Z, c2);
    const c7 = Fp$1.pow(Z, (c2 + _1n$4) / _2n$4);
    let sqrtRatio = (u, v) => {
      let tv1 = c6;
      let tv2 = Fp$1.pow(v, c4);
      let tv3 = Fp$1.sqr(tv2);
      tv3 = Fp$1.mul(tv3, v);
      let tv5 = Fp$1.mul(u, tv3);
      tv5 = Fp$1.pow(tv5, c3);
      tv5 = Fp$1.mul(tv5, tv2);
      tv2 = Fp$1.mul(tv5, v);
      tv3 = Fp$1.mul(tv5, u);
      let tv4 = Fp$1.mul(tv3, tv2);
      tv5 = Fp$1.pow(tv4, c5);
      let isQR = Fp$1.eql(tv5, Fp$1.ONE);
      tv2 = Fp$1.mul(tv3, c7);
      tv5 = Fp$1.mul(tv4, tv1);
      tv3 = Fp$1.cmov(tv2, tv3, isQR);
      tv4 = Fp$1.cmov(tv5, tv4, isQR);
      for (let i = c1; i > _1n$4; i--) {
        let tv5$1 = i - _2n$4;
        tv5$1 = _2n$4 << tv5$1 - _1n$4;
        let tvv5 = Fp$1.pow(tv4, tv5$1);
        const e1 = Fp$1.eql(tvv5, Fp$1.ONE);
        tv2 = Fp$1.mul(tv3, tv1);
        tv1 = Fp$1.mul(tv1, tv1);
        tvv5 = Fp$1.mul(tv4, tv1);
        tv3 = Fp$1.cmov(tv2, tv3, e1);
        tv4 = Fp$1.cmov(tvv5, tv4, e1);
      }
      return {
        isValid: isQR,
        value: tv3
      };
    };
    if (Fp$1.ORDER % _4n === _3n$1) {
      const c1$1 = (Fp$1.ORDER - _3n$1) / _4n;
      const c2$1 = Fp$1.sqrt(Fp$1.neg(Z));
      sqrtRatio = (u, v) => {
        let tv1 = Fp$1.sqr(v);
        const tv2 = Fp$1.mul(u, v);
        tv1 = Fp$1.mul(tv1, tv2);
        let y1 = Fp$1.pow(tv1, c1$1);
        y1 = Fp$1.mul(y1, tv2);
        const y2 = Fp$1.mul(y1, c2$1);
        const tv3 = Fp$1.mul(Fp$1.sqr(y1), v);
        const isQR = Fp$1.eql(tv3, u);
        let y = Fp$1.cmov(y2, y1, isQR);
        return {
          isValid: isQR,
          value: y
        };
      };
    }
    return sqrtRatio;
  }
  function mapToCurveSimpleSWU(Fp$1, opts) {
    (0, modular_ts_1$5.validateField)(Fp$1);
    const { A, B, Z } = opts;
    if (!Fp$1.isValid(A) || !Fp$1.isValid(B) || !Fp$1.isValid(Z)) throw new Error("mapToCurveSimpleSWU: invalid opts");
    const sqrtRatio = SWUFpSqrtRatio(Fp$1, Z);
    if (!Fp$1.isOdd) throw new Error("Field does not have .isOdd()");
    return (u) => {
      let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
      tv1 = Fp$1.sqr(u);
      tv1 = Fp$1.mul(tv1, Z);
      tv2 = Fp$1.sqr(tv1);
      tv2 = Fp$1.add(tv2, tv1);
      tv3 = Fp$1.add(tv2, Fp$1.ONE);
      tv3 = Fp$1.mul(tv3, B);
      tv4 = Fp$1.cmov(Z, Fp$1.neg(tv2), !Fp$1.eql(tv2, Fp$1.ZERO));
      tv4 = Fp$1.mul(tv4, A);
      tv2 = Fp$1.sqr(tv3);
      tv6 = Fp$1.sqr(tv4);
      tv5 = Fp$1.mul(tv6, A);
      tv2 = Fp$1.add(tv2, tv5);
      tv2 = Fp$1.mul(tv2, tv3);
      tv6 = Fp$1.mul(tv6, tv4);
      tv5 = Fp$1.mul(tv6, B);
      tv2 = Fp$1.add(tv2, tv5);
      x = Fp$1.mul(tv1, tv3);
      const { isValid, value } = sqrtRatio(tv2, tv6);
      y = Fp$1.mul(tv1, u);
      y = Fp$1.mul(y, value);
      x = Fp$1.cmov(x, tv3, isValid);
      y = Fp$1.cmov(y, value, isValid);
      const e1 = Fp$1.isOdd(u) === Fp$1.isOdd(y);
      y = Fp$1.cmov(Fp$1.neg(y), y, e1);
      const tv4_inv = (0, modular_ts_1$5.FpInvertBatch)(Fp$1, [tv4], true)[0];
      x = Fp$1.mul(x, tv4_inv);
      return {
        x,
        y
      };
    };
  }
} });
var require__shortw_utils$1 = __commonJS$1({ "../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/_shortw_utils.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getHash = getHash;
  exports.createCurve = createCurve;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const weierstrass_ts_1$1 = require_weierstrass$1();
  function getHash(hash$12) {
    return { hash: hash$12 };
  }
  function createCurve(curveDef, defHash) {
    const create = (hash$12) => (0, weierstrass_ts_1$1.weierstrass)({
      ...curveDef,
      hash: hash$12
    });
    return {
      ...create(defHash),
      create
    };
  }
} });
var require_hash_to_curve$1 = __commonJS$1({ "../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/hash-to-curve.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.expand_message_xmd = expand_message_xmd;
  exports.expand_message_xof = expand_message_xof;
  exports.hash_to_field = hash_to_field;
  exports.isogenyMap = isogenyMap;
  exports.createHasher = createHasher;
  const utils_ts_1$5 = require_utils$8();
  const modular_ts_1$4 = require_modular$1();
  const os2ip = utils_ts_1$5.bytesToNumberBE;
  function i2osp(value, length) {
    anum(value);
    anum(length);
    if (value < 0 || value >= 1 << 8 * length) throw new Error("invalid I2OSP input: " + value);
    const res = Array.from({ length }).fill(0);
    for (let i = length - 1; i >= 0; i--) {
      res[i] = value & 255;
      value >>>= 8;
    }
    return new Uint8Array(res);
  }
  function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for (let i = 0; i < a.length; i++) arr[i] = a[i] ^ b[i];
    return arr;
  }
  function anum(item) {
    if (!Number.isSafeInteger(item)) throw new Error("number expected");
  }
  function expand_message_xmd(msg, DST, lenInBytes, H) {
    (0, utils_ts_1$5.abytes)(msg);
    (0, utils_ts_1$5.abytes)(DST);
    anum(lenInBytes);
    if (DST.length > 255) DST = H((0, utils_ts_1$5.concatBytes)((0, utils_ts_1$5.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (lenInBytes > 65535 || ell > 255) throw new Error("expand_message_xmd: invalid lenInBytes");
    const DST_prime = (0, utils_ts_1$5.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2);
    const b = new Array(ell);
    const b_0 = H((0, utils_ts_1$5.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_ts_1$5.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for (let i = 1; i <= ell; i++) {
      const args = [
        strxor(b_0, b[i - 1]),
        i2osp(i + 1, 1),
        DST_prime
      ];
      b[i] = H((0, utils_ts_1$5.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, utils_ts_1$5.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
  }
  function expand_message_xof(msg, DST, lenInBytes, k, H) {
    (0, utils_ts_1$5.abytes)(msg);
    (0, utils_ts_1$5.abytes)(DST);
    anum(lenInBytes);
    if (DST.length > 255) {
      const dkLen = Math.ceil(2 * k / 8);
      DST = H.create({ dkLen }).update((0, utils_ts_1$5.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255) throw new Error("expand_message_xof: invalid lenInBytes");
    return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
  }
  function hash_to_field(msg, count, options) {
    (0, utils_ts_1$5._validateObject)(options, {
      p: "bigint",
      m: "number",
      k: "number",
      hash: "function"
    });
    const { p, k, m, hash: hash$12, expand, DST: _DST } = options;
    if (!(0, utils_ts_1$5.isBytes)(_DST) && typeof _DST !== "string") throw new Error("DST must be string or uint8array");
    if (!(0, utils_ts_1$5.isHash)(options.hash)) throw new Error("expected valid hash");
    (0, utils_ts_1$5.abytes)(msg);
    anum(count);
    const DST = typeof _DST === "string" ? (0, utils_ts_1$5.utf8ToBytes)(_DST) : _DST;
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8);
    const len_in_bytes = count * m * L;
    let prb;
    if (expand === "xmd") prb = expand_message_xmd(msg, DST, len_in_bytes, hash$12);
    else if (expand === "xof") prb = expand_message_xof(msg, DST, len_in_bytes, k, hash$12);
    else if (expand === "_internal_pass") prb = msg;
    else throw new Error('expand must be "xmd" or "xof"');
    const u = new Array(count);
    for (let i = 0; i < count; i++) {
      const e = new Array(m);
      for (let j = 0; j < m; j++) {
        const elm_offset = L * (j + i * m);
        const tv = prb.subarray(elm_offset, elm_offset + L);
        e[j] = (0, modular_ts_1$4.mod)(os2ip(tv), p);
      }
      u[i] = e;
    }
    return u;
  }
  function isogenyMap(field, map) {
    const coeff = map.map((i) => Array.from(i).reverse());
    return (x, y) => {
      const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
      const [xd_inv, yd_inv] = (0, modular_ts_1$4.FpInvertBatch)(field, [xd, yd], true);
      x = field.mul(xn, xd_inv);
      y = field.mul(y, field.mul(yn, yd_inv));
      return {
        x,
        y
      };
    };
  }
  function createHasher(Point$2, mapToCurve, defaults) {
    if (typeof mapToCurve !== "function") throw new Error("mapToCurve() must be defined");
    function map(num$1) {
      return Point$2.fromAffine(mapToCurve(num$1));
    }
    function clear(initial) {
      const P = initial.clearCofactor();
      if (P.equals(Point$2.ZERO)) return Point$2.ZERO;
      P.assertValidity();
      return P;
    }
    return {
      defaults,
      hashToCurve(msg, options) {
        const dst = defaults.DST ? defaults.DST : {};
        const opts = Object.assign({}, defaults, dst, options);
        const u = hash_to_field(msg, 2, opts);
        const u0 = map(u[0]);
        const u1 = map(u[1]);
        return clear(u0.add(u1));
      },
      encodeToCurve(msg, options) {
        const dst = defaults.encodeDST ? defaults.encodeDST : {};
        const opts = Object.assign({}, defaults, dst, options);
        const u = hash_to_field(msg, 1, opts);
        return clear(map(u[0]));
      },
      mapToCurve(scalars) {
        if (!Array.isArray(scalars)) throw new Error("expected array of bigints");
        for (const i of scalars) if (typeof i !== "bigint") throw new Error("expected array of bigints");
        return clear(map(scalars));
      }
    };
  }
} });
var require_secp256k1$1$1 = __commonJS$1({ "../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/secp256k1.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodeToCurve = exports.hashToCurve = exports.secp256k1_hasher = exports.schnorr = exports.secp256k1 = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const sha2_js_1$1 = require_sha2$1();
  const utils_js_1$1 = require_utils$10();
  const _shortw_utils_ts_1 = require__shortw_utils$1();
  const hash_to_curve_ts_1$1 = require_hash_to_curve$1();
  const modular_ts_1$3 = require_modular$1();
  const weierstrass_ts_1 = require_weierstrass$1();
  const utils_ts_1$4 = require_utils$8();
  const secp256k1_CURVE = {
    p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
    Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
  };
  const _0n$3 = BigInt(0);
  const _1n$3 = BigInt(1);
  const _2n$3 = BigInt(2);
  const divNearest = (a, b) => (a + b / _2n$3) / b;
  function sqrtMod(y) {
    const P = secp256k1_CURVE.p;
    const _3n$3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P;
    const b3 = b2 * b2 * y % P;
    const b6 = (0, modular_ts_1$3.pow2)(b3, _3n$3, P) * b3 % P;
    const b9 = (0, modular_ts_1$3.pow2)(b6, _3n$3, P) * b3 % P;
    const b11 = (0, modular_ts_1$3.pow2)(b9, _2n$3, P) * b2 % P;
    const b22 = (0, modular_ts_1$3.pow2)(b11, _11n, P) * b11 % P;
    const b44 = (0, modular_ts_1$3.pow2)(b22, _22n, P) * b22 % P;
    const b88 = (0, modular_ts_1$3.pow2)(b44, _44n, P) * b44 % P;
    const b176 = (0, modular_ts_1$3.pow2)(b88, _88n, P) * b88 % P;
    const b220 = (0, modular_ts_1$3.pow2)(b176, _44n, P) * b44 % P;
    const b223 = (0, modular_ts_1$3.pow2)(b220, _3n$3, P) * b3 % P;
    const t1 = (0, modular_ts_1$3.pow2)(b223, _23n, P) * b22 % P;
    const t2 = (0, modular_ts_1$3.pow2)(t1, _6n, P) * b2 % P;
    const root2 = (0, modular_ts_1$3.pow2)(t2, _2n$3, P);
    if (!Fpk1.eql(Fpk1.sqr(root2), y)) throw new Error("Cannot find square root");
    return root2;
  }
  const Fpk1 = (0, modular_ts_1$3.Field)(secp256k1_CURVE.p, void 0, void 0, { sqrt: sqrtMod });
  exports.secp256k1 = (0, _shortw_utils_ts_1.createCurve)({
    ...secp256k1_CURVE,
    Fp: Fpk1,
    lowS: true,
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (k) => {
        const n = secp256k1_CURVE.n;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n$3 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b2 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = (0, modular_ts_1$3.mod)(k - c1 * a1 - c2 * a2, n);
        let k2 = (0, modular_ts_1$3.mod)(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg) k1 = n - k1;
        if (k2neg) k2 = n - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128) throw new Error("splitScalar: Endomorphism failed, k=" + k);
        return {
          k1neg,
          k1,
          k2neg,
          k2
        };
      }
    }
  }, sha2_js_1$1.sha256);
  const TAGGED_HASH_PREFIXES = {};
  function taggedHash(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = (0, sha2_js_1$1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = (0, utils_ts_1$4.concatBytes)(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return (0, sha2_js_1$1.sha256)((0, utils_ts_1$4.concatBytes)(tagP, ...messages));
  }
  const pointToBytes = (point) => point.toBytes(true).slice(1);
  const numTo32b = (n) => (0, utils_ts_1$4.numberToBytesBE)(n, 32);
  const modP = (x) => (0, modular_ts_1$3.mod)(x, secp256k1_CURVE.p);
  const modN = (x) => (0, modular_ts_1$3.mod)(x, secp256k1_CURVE.n);
  const Point$1 = /* @__PURE__ */ (() => exports.secp256k1.Point)();
  const hasEven = (y) => y % _2n$3 === _0n$3;
  function schnorrGetExtPubKey(priv) {
    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv);
    let p = Point$1.fromPrivateKey(d_);
    const scalar = hasEven(p.y) ? d_ : modN(-d_);
    return {
      scalar,
      bytes: pointToBytes(p)
    };
  }
  function lift_x(x) {
    (0, utils_ts_1$4.aInRange)("x", x, _1n$3, secp256k1_CURVE.p);
    const xx = modP(x * x);
    const c = modP(xx * x + BigInt(7));
    let y = sqrtMod(c);
    if (!hasEven(y)) y = modP(-y);
    const p = Point$1.fromAffine({
      x,
      y
    });
    p.assertValidity();
    return p;
  }
  const num = utils_ts_1$4.bytesToNumberBE;
  function challenge(...args) {
    return modN(num(taggedHash("BIP0340/challenge", ...args)));
  }
  function schnorrGetPublicKey(privateKey) {
    return schnorrGetExtPubKey(privateKey).bytes;
  }
  function schnorrSign(message2, privateKey, auxRand = (0, utils_js_1$1.randomBytes)(32)) {
    const m = (0, utils_ts_1$4.ensureBytes)("message", message2);
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
    const a = (0, utils_ts_1$4.ensureBytes)("auxRand", auxRand, 32);
    const t = numTo32b(d ^ num(taggedHash("BIP0340/aux", a)));
    const rand = taggedHash("BIP0340/nonce", t, px, m);
    const k_ = modN(num(rand));
    if (k_ === _0n$3) throw new Error("sign failed: k is zero");
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
    const e = challenge(rx, px, m);
    const sig = new Uint8Array(64);
    sig.set(rx, 0);
    sig.set(numTo32b(modN(k + e * d)), 32);
    if (!schnorrVerify(sig, m, px)) throw new Error("sign: Invalid signature produced");
    return sig;
  }
  function schnorrVerify(signature2, message2, publicKey) {
    const sig = (0, utils_ts_1$4.ensureBytes)("signature", signature2, 64);
    const m = (0, utils_ts_1$4.ensureBytes)("message", message2);
    const pub = (0, utils_ts_1$4.ensureBytes)("publicKey", publicKey, 32);
    try {
      const P = lift_x(num(pub));
      const r = num(sig.subarray(0, 32));
      if (!(0, utils_ts_1$4.inRange)(r, _1n$3, secp256k1_CURVE.p)) return false;
      const s = num(sig.subarray(32, 64));
      if (!(0, utils_ts_1$4.inRange)(s, _1n$3, secp256k1_CURVE.n)) return false;
      const e = challenge(numTo32b(r), pointToBytes(P), m);
      const R = Point$1.BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(modN(-e)));
      const { x, y } = R.toAffine();
      if (R.is0() || !hasEven(y) || x !== r) return false;
      return true;
    } catch (error) {
      return false;
    }
  }
  exports.schnorr = (() => ({
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    utils: {
      randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
      lift_x,
      pointToBytes,
      numberToBytesBE: utils_ts_1$4.numberToBytesBE,
      bytesToNumberBE: utils_ts_1$4.bytesToNumberBE,
      taggedHash,
      mod: modular_ts_1$3.mod
    }
  }))();
  const isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_ts_1$1.isogenyMap)(Fpk1, [
    [
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
      "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
      "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
    ],
    [
      "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
      "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
    ],
    [
      "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
      "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
      "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
      "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
    ],
    [
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
      "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
      "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
    ]
  ].map((i) => i.map((j) => BigInt(j)))))();
  const mapSWU = /* @__PURE__ */ (() => (0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fpk1, {
    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
    B: BigInt("1771"),
    Z: Fpk1.create(BigInt("-11"))
  }))();
  exports.secp256k1_hasher = (() => (0, hash_to_curve_ts_1$1.createHasher)(exports.secp256k1.Point, (scalars) => {
    const { x, y } = mapSWU(Fpk1.create(scalars[0]));
    return isoMap(x, y);
  }, {
    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
    p: Fpk1.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: sha2_js_1$1.sha256
  }))();
  exports.hashToCurve = (() => exports.secp256k1_hasher.hashToCurve)();
  exports.encodeToCurve = (() => exports.secp256k1_hasher.encodeToCurve)();
} });
var require_sha512$1 = __commonJS$1({ "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha512.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sha512_256 = exports.SHA512_256 = exports.sha512_224 = exports.SHA512_224 = exports.sha384 = exports.SHA384 = exports.sha512 = exports.SHA512 = void 0;
  const sha2_ts_1 = require_sha2$1();
  exports.SHA512 = sha2_ts_1.SHA512;
  exports.sha512 = sha2_ts_1.sha512;
  exports.SHA384 = sha2_ts_1.SHA384;
  exports.sha384 = sha2_ts_1.sha384;
  exports.SHA512_224 = sha2_ts_1.SHA512_224;
  exports.sha512_224 = sha2_ts_1.sha512_224;
  exports.SHA512_256 = sha2_ts_1.SHA512_256;
  exports.sha512_256 = sha2_ts_1.sha512_256;
} });
var require_browser$1 = __commonJS$1({ "../../node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/sha512/browser.js"(exports) {
  var __importDefault$27 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sha512 = void 0;
  const sha512_1$3 = require_sha512$1();
  const wrapNoble_1 = __importDefault$27(require_wrapNoble());
  exports.sha512 = (0, wrapNoble_1.default)(sha512_1$3.sha512);
} });
var require_utils$7 = __commonJS$1({ "../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/utils.js"(exports) {
  var __createBinding$9 = Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
      enumerable: true,
      get: function() {
        return m[k];
      }
    };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  };
  var __exportStar$6 = function(m, exports$1) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding$9(exports$1, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar$6(require_utils$8(), exports);
} });
var require_Sha512$1 = __commonJS$1({ "../../node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/utils/Sha512.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const sha512_1$2 = require_browser$1();
  const utils_1$54 = require_utils$7();
  var Sha512 = class Sha5122 {
    constructor() {
      this.hash = sha512_1$2.sha512.create();
    }
    static half(input) {
      return new Sha5122().add(input).first256();
    }
    add(bytes$1) {
      this.hash.update(bytes$1);
      return this;
    }
    addU32(i) {
      const buffer = new Uint8Array(4);
      new DataView(buffer.buffer).setUint32(0, i);
      return this.add(buffer);
    }
    finish() {
      return this.hash.digest();
    }
    first256() {
      return this.finish().slice(0, 32);
    }
    first256BigInt() {
      return (0, utils_1$54.bytesToNumberBE)(this.first256());
    }
  };
  exports.default = Sha512;
} });
var require_utils$6 = __commonJS$1({ "../../node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/utils.js"(exports) {
  var __importDefault$26 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.accountPublicFromPublicGenerator = exports.derivePrivateKey = void 0;
  const secp256k1_1$3 = require_secp256k1$1$1();
  const Sha512_1$3 = __importDefault$26(require_Sha512$1());
  const ZERO = BigInt(0);
  function deriveScalar(bytes$1, discrim) {
    const order = secp256k1_1$3.secp256k1.CURVE.n;
    for (let i = 0; i <= 4294967295; i++) {
      const hasher = new Sha512_1$3.default().add(bytes$1);
      if (discrim !== void 0) hasher.addU32(discrim);
      hasher.addU32(i);
      const key = hasher.first256BigInt();
      if (key > ZERO && key < order) return key;
    }
    throw new Error("impossible unicorn ;)");
  }
  function derivePrivateKey(seed, opts = {}) {
    const root2 = opts.validator;
    const order = secp256k1_1$3.secp256k1.CURVE.n;
    const privateGen = deriveScalar(seed);
    if (root2) return privateGen;
    const publicGen = secp256k1_1$3.secp256k1.ProjectivePoint.BASE.multiply(privateGen).toRawBytes(true);
    const accountIndex = opts.accountIndex || 0;
    return (deriveScalar(publicGen, accountIndex) + privateGen) % order;
  }
  exports.derivePrivateKey = derivePrivateKey;
  function accountPublicFromPublicGenerator(publicGenBytes) {
    const rootPubPoint = secp256k1_1$3.secp256k1.ProjectivePoint.fromHex(publicGenBytes);
    const scalar = deriveScalar(publicGenBytes, 0);
    const point = secp256k1_1$3.secp256k1.ProjectivePoint.BASE.multiply(scalar);
    const offset = rootPubPoint.add(point);
    return offset.toRawBytes(true);
  }
  exports.accountPublicFromPublicGenerator = accountPublicFromPublicGenerator;
} });
var require_assert$1 = __commonJS$1({ "../../node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/utils/assert.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const assertHelper = { ok(cond, message2) {
    if (!cond) throw new Error(message2);
  } };
  exports.default = assertHelper;
} });
var require_getAlgorithmFromKey$1 = __commonJS$1({ "../../node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/utils/getAlgorithmFromKey.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getAlgorithmFromPrivateKey = exports.getAlgorithmFromPublicKey = exports.getAlgorithmFromKey = void 0;
  var Prefix;
  (function(Prefix$1) {
    Prefix$1[Prefix$1["NONE"] = -1] = "NONE";
    Prefix$1[Prefix$1["ED25519"] = 237] = "ED25519";
    Prefix$1[Prefix$1["SECP256K1_PUB_X"] = 2] = "SECP256K1_PUB_X";
    Prefix$1[Prefix$1["SECP256K1_PUB_X_ODD_Y"] = 3] = "SECP256K1_PUB_X_ODD_Y";
    Prefix$1[Prefix$1["SECP256K1_PUB_XY"] = 4] = "SECP256K1_PUB_XY";
    Prefix$1[Prefix$1["SECP256K1_PRIVATE"] = 0] = "SECP256K1_PRIVATE";
  })(Prefix || (Prefix = {}));
  const KEY_TYPES = {
    [`private_${Prefix.NONE}_32`]: "ecdsa-secp256k1",
    [`private_${Prefix.SECP256K1_PRIVATE}_33`]: "ecdsa-secp256k1",
    [`private_${Prefix.ED25519}_33`]: "ed25519",
    [`public_${Prefix.ED25519}_33`]: "ed25519",
    [`public_${Prefix.SECP256K1_PUB_X}_33`]: "ecdsa-secp256k1",
    [`public_${Prefix.SECP256K1_PUB_X_ODD_Y}_33`]: "ecdsa-secp256k1",
    [`public_${Prefix.SECP256K1_PUB_XY}_65`]: "ecdsa-secp256k1"
  };
  function getKeyInfo(key) {
    return {
      prefix: key.length < 2 ? Prefix.NONE : parseInt(key.slice(0, 2), 16),
      len: key.length / 2
    };
  }
  function prefixRepr(prefix$2) {
    return prefix$2 === Prefix.NONE ? "None" : `0x${prefix$2.toString(16).padStart(2, "0")}`;
  }
  function getValidFormatsTable(type2) {
    const padding$1 = 2;
    const colWidth = {
      algorithm: 15 + padding$1,
      prefix: 4 + padding$1
    };
    return Object.entries(KEY_TYPES).filter(([key]) => key.startsWith(type2)).map(([key, algorithm]) => {
      const [, prefix$2, length] = key.split("_");
      const paddedAlgo = algorithm.padEnd(colWidth.algorithm);
      const paddedPrefix = prefixRepr(Number(prefix$2)).padEnd(colWidth.prefix);
      return `${paddedAlgo} - Prefix: ${paddedPrefix} Length: ${length} bytes`;
    }).join("\n");
  }
  function keyError({ key, type: type2, prefix: prefix$2, len }) {
    const validFormats = getValidFormatsTable(type2);
    return `invalid_key:

Type: ${type2}
Key: ${key}
Prefix: ${prefixRepr(prefix$2)} 
Length: ${len} bytes

Acceptable ${type2} formats are:
${validFormats}
`;
  }
  function getAlgorithmFromKey(key, type2) {
    const { prefix: prefix$2, len } = getKeyInfo(key);
    const usedPrefix = type2 === "private" && len === 32 ? Prefix.NONE : prefix$2;
    const algorithm = KEY_TYPES[`${type2}_${usedPrefix}_${len}`];
    if (!algorithm) throw new Error(keyError({
      key,
      type: type2,
      len,
      prefix: usedPrefix
    }));
    return algorithm;
  }
  exports.getAlgorithmFromKey = getAlgorithmFromKey;
  function getAlgorithmFromPublicKey(key) {
    return getAlgorithmFromKey(key, "public");
  }
  exports.getAlgorithmFromPublicKey = getAlgorithmFromPublicKey;
  function getAlgorithmFromPrivateKey(key) {
    return getAlgorithmFromKey(key, "private");
  }
  exports.getAlgorithmFromPrivateKey = getAlgorithmFromPrivateKey;
} });
var require_secp256k1$2 = __commonJS$1({ "../../node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/index.js"(exports) {
  var __importDefault$25 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const utils_1$53 = require_utils$7();
  const secp256k1_1$2 = require_secp256k1$1$1();
  const utils_2$8 = require_browser$4();
  const utils_3$1 = require_utils$6();
  const assert_1$2 = __importDefault$25(require_assert$1());
  const Sha512_1$2 = __importDefault$25(require_Sha512$1());
  const SECP256K1_PREFIX = "00";
  const secp256k1 = {
    deriveKeypair(entropy, options) {
      const derived = (0, utils_3$1.derivePrivateKey)(entropy, options);
      const privateKey = SECP256K1_PREFIX + (0, utils_2$8.bytesToHex)((0, utils_1$53.numberToBytesBE)(derived, 32));
      const publicKey = (0, utils_2$8.bytesToHex)(secp256k1_1$2.secp256k1.getPublicKey(derived, true));
      return {
        privateKey,
        publicKey
      };
    },
    sign(message2, privateKey) {
      assert_1$2.default.ok(privateKey.length === 66 && privateKey.startsWith(SECP256K1_PREFIX) || privateKey.length === 64);
      const normedPrivateKey = privateKey.length === 66 ? privateKey.slice(2) : privateKey;
      return secp256k1_1$2.secp256k1.sign(Sha512_1$2.default.half(message2), normedPrivateKey, {
        lowS: true,
        extraEntropy: void 0
      }).toDERHex(true).toUpperCase();
    },
    verify(message2, signature2, publicKey) {
      const decoded = secp256k1_1$2.secp256k1.Signature.fromDER(signature2);
      return secp256k1_1$2.secp256k1.verify(decoded, Sha512_1$2.default.half(message2), publicKey);
    }
  };
  exports.default = secp256k1;
} });
var require_edwards$1 = __commonJS$1({ "../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/edwards.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.edwards = edwards;
  exports.eddsa = eddsa;
  exports.twistedEdwards = twistedEdwards;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const utils_ts_1$3 = require_utils$8();
  const curve_ts_1$1 = require_curve$1();
  const modular_ts_1$2 = require_modular$1();
  const _0n$2 = BigInt(0), _1n$2 = BigInt(1), _2n$2 = BigInt(2), _8n$1 = BigInt(8);
  const VERIFY_DEFAULT = { zip215: true };
  function isEdValidXY(Fp$1, CURVE, x, y) {
    const x2 = Fp$1.sqr(x);
    const y2 = Fp$1.sqr(y);
    const left = Fp$1.add(Fp$1.mul(CURVE.a, x2), y2);
    const right = Fp$1.add(Fp$1.ONE, Fp$1.mul(CURVE.d, Fp$1.mul(x2, y2)));
    return Fp$1.eql(left, right);
  }
  function edwards(CURVE, curveOpts = {}) {
    const { Fp: Fp$1, Fn } = (0, curve_ts_1$1._createCurveFields)("edwards", CURVE, curveOpts);
    const { h: cofactor, n: CURVE_ORDER } = CURVE;
    (0, utils_ts_1$3._validateObject)(curveOpts, {}, { uvRatio: "function" });
    const MASK$1 = _2n$2 << BigInt(Fn.BYTES * 8) - _1n$2;
    const modP$1 = (n) => Fp$1.create(n);
    const uvRatio$1 = curveOpts.uvRatio || ((u, v) => {
      try {
        return {
          isValid: true,
          value: Fp$1.sqrt(Fp$1.div(u, v))
        };
      } catch (e) {
        return {
          isValid: false,
          value: _0n$2
        };
      }
    });
    if (!isEdValidXY(Fp$1, CURVE, CURVE.Gx, CURVE.Gy)) throw new Error("bad curve params: generator point");
    function acoord(title, n, banZero = false) {
      const min2 = banZero ? _1n$2 : _0n$2;
      (0, utils_ts_1$3.aInRange)("coordinate " + title, n, min2, MASK$1);
      return n;
    }
    function aextpoint(other) {
      if (!(other instanceof Point$2)) throw new Error("ExtendedPoint expected");
    }
    const toAffineMemo = (0, utils_ts_1$3.memoized)((p, iz) => {
      const { ex: x, ey: y, ez: z2 } = p;
      const is0 = p.is0();
      if (iz == null) iz = is0 ? _8n$1 : Fp$1.inv(z2);
      const ax = modP$1(x * iz);
      const ay = modP$1(y * iz);
      const zz = modP$1(z2 * iz);
      if (is0) return {
        x: _0n$2,
        y: _1n$2
      };
      if (zz !== _1n$2) throw new Error("invZ was invalid");
      return {
        x: ax,
        y: ay
      };
    });
    const assertValidMemo = (0, utils_ts_1$3.memoized)((p) => {
      const { a, d } = CURVE;
      if (p.is0()) throw new Error("bad point: ZERO");
      const { ex: X, ey: Y, ez: Z, et: T } = p;
      const X2 = modP$1(X * X);
      const Y2 = modP$1(Y * Y);
      const Z2 = modP$1(Z * Z);
      const Z4 = modP$1(Z2 * Z2);
      const aX2 = modP$1(X2 * a);
      const left = modP$1(Z2 * modP$1(aX2 + Y2));
      const right = modP$1(Z4 + modP$1(d * modP$1(X2 * Y2)));
      if (left !== right) throw new Error("bad point: equation left != right (1)");
      const XY = modP$1(X * Y);
      const ZT = modP$1(Z * T);
      if (XY !== ZT) throw new Error("bad point: equation left != right (2)");
      return true;
    });
    class Point$2 {
      constructor(ex, ey, ez, et) {
        this.ex = acoord("x", ex);
        this.ey = acoord("y", ey);
        this.ez = acoord("z", ez, true);
        this.et = acoord("t", et);
        Object.freeze(this);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static fromAffine(p) {
        if (p instanceof Point$2) throw new Error("extended point not allowed");
        const { x, y } = p || {};
        acoord("x", x);
        acoord("y", y);
        return new Point$2(x, y, _1n$2, modP$1(x * y));
      }
      static normalizeZ(points) {
        return (0, curve_ts_1$1.normalizeZ)(Point$2, "ez", points);
      }
      static msm(points, scalars) {
        return (0, curve_ts_1$1.pippenger)(Point$2, Fn, points, scalars);
      }
      _setWindowSize(windowSize) {
        this.precompute(windowSize);
      }
      precompute(windowSize = 8, isLazy = true) {
        wnaf.setWindowSize(this, windowSize);
        if (!isLazy) this.multiply(_2n$2);
        return this;
      }
      assertValidity() {
        assertValidMemo(this);
      }
      equals(other) {
        aextpoint(other);
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const { ex: X2, ey: Y2, ez: Z2 } = other;
        const X1Z2 = modP$1(X1 * Z2);
        const X2Z1 = modP$1(X2 * Z1);
        const Y1Z2 = modP$1(Y1 * Z2);
        const Y2Z1 = modP$1(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
      is0() {
        return this.equals(Point$2.ZERO);
      }
      negate() {
        return new Point$2(modP$1(-this.ex), this.ey, this.ez, modP$1(-this.et));
      }
      double() {
        const { a } = CURVE;
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const A = modP$1(X1 * X1);
        const B = modP$1(Y1 * Y1);
        const C = modP$1(_2n$2 * modP$1(Z1 * Z1));
        const D = modP$1(a * A);
        const x1y1 = X1 + Y1;
        const E = modP$1(modP$1(x1y1 * x1y1) - A - B);
        const G = D + B;
        const F = G - C;
        const H = D - B;
        const X3 = modP$1(E * F);
        const Y3 = modP$1(G * H);
        const T3 = modP$1(E * H);
        const Z3 = modP$1(F * G);
        return new Point$2(X3, Y3, Z3, T3);
      }
      add(other) {
        aextpoint(other);
        const { a, d } = CURVE;
        const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
        const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
        const A = modP$1(X1 * X2);
        const B = modP$1(Y1 * Y2);
        const C = modP$1(T1 * d * T2);
        const D = modP$1(Z1 * Z2);
        const E = modP$1((X1 + Y1) * (X2 + Y2) - A - B);
        const F = D - C;
        const G = D + C;
        const H = modP$1(B - a * A);
        const X3 = modP$1(E * F);
        const Y3 = modP$1(G * H);
        const T3 = modP$1(E * H);
        const Z3 = modP$1(F * G);
        return new Point$2(X3, Y3, Z3, T3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      multiply(scalar) {
        const n = scalar;
        (0, utils_ts_1$3.aInRange)("scalar", n, _1n$2, CURVE_ORDER);
        const { p, f } = wnaf.wNAFCached(this, n, Point$2.normalizeZ);
        return Point$2.normalizeZ([p, f])[0];
      }
      multiplyUnsafe(scalar, acc = Point$2.ZERO) {
        const n = scalar;
        (0, utils_ts_1$3.aInRange)("scalar", n, _0n$2, CURVE_ORDER);
        if (n === _0n$2) return Point$2.ZERO;
        if (this.is0() || n === _1n$2) return this;
        return wnaf.wNAFCachedUnsafe(this, n, Point$2.normalizeZ, acc);
      }
      isSmallOrder() {
        return this.multiplyUnsafe(cofactor).is0();
      }
      isTorsionFree() {
        return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
      }
      toAffine(invertedZ) {
        return toAffineMemo(this, invertedZ);
      }
      clearCofactor() {
        if (cofactor === _1n$2) return this;
        return this.multiplyUnsafe(cofactor);
      }
      static fromBytes(bytes$1, zip215 = false) {
        (0, utils_ts_1$3.abytes)(bytes$1);
        return this.fromHex(bytes$1, zip215);
      }
      static fromHex(hex, zip215 = false) {
        const { d, a } = CURVE;
        const len = Fp$1.BYTES;
        hex = (0, utils_ts_1$3.ensureBytes)("pointHex", hex, len);
        (0, utils_ts_1$3.abool)("zip215", zip215);
        const normed = hex.slice();
        const lastByte = hex[len - 1];
        normed[len - 1] = lastByte & -129;
        const y = (0, utils_ts_1$3.bytesToNumberLE)(normed);
        const max2 = zip215 ? MASK$1 : Fp$1.ORDER;
        (0, utils_ts_1$3.aInRange)("pointHex.y", y, _0n$2, max2);
        const y2 = modP$1(y * y);
        const u = modP$1(y2 - _1n$2);
        const v = modP$1(d * y2 - a);
        let { isValid, value: x } = uvRatio$1(u, v);
        if (!isValid) throw new Error("Point.fromHex: invalid y coordinate");
        const isXOdd = (x & _1n$2) === _1n$2;
        const isLastByteOdd = (lastByte & 128) !== 0;
        if (!zip215 && x === _0n$2 && isLastByteOdd) throw new Error("Point.fromHex: x=0 and x_0=1");
        if (isLastByteOdd !== isXOdd) x = modP$1(-x);
        return Point$2.fromAffine({
          x,
          y
        });
      }
      static fromPrivateScalar(scalar) {
        return Point$2.BASE.multiply(scalar);
      }
      toBytes() {
        const { x, y } = this.toAffine();
        const bytes$1 = (0, utils_ts_1$3.numberToBytesLE)(y, Fp$1.BYTES);
        bytes$1[bytes$1.length - 1] |= x & _1n$2 ? 128 : 0;
        return bytes$1;
      }
      /** @deprecated use `toBytes` */
      toRawBytes() {
        return this.toBytes();
      }
      toHex() {
        return (0, utils_ts_1$3.bytesToHex)(this.toBytes());
      }
      toString() {
        return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
      }
    }
    Point$2.BASE = new Point$2(CURVE.Gx, CURVE.Gy, _1n$2, modP$1(CURVE.Gx * CURVE.Gy));
    Point$2.ZERO = new Point$2(_0n$2, _1n$2, _1n$2, _0n$2);
    Point$2.Fp = Fp$1;
    Point$2.Fn = Fn;
    const wnaf = (0, curve_ts_1$1.wNAF)(Point$2, Fn.BYTES * 8);
    return Point$2;
  }
  function eddsa(Point$2, eddsaOpts) {
    (0, utils_ts_1$3._validateObject)(eddsaOpts, { hash: "function" }, {
      adjustScalarBytes: "function",
      randomBytes: "function",
      domain: "function",
      prehash: "function",
      mapToCurve: "function"
    });
    const { prehash, hash: cHash } = eddsaOpts;
    const { BASE: G, Fp: Fp$1, Fn } = Point$2;
    const CURVE_ORDER = Fn.ORDER;
    const randomBytes_ = eddsaOpts.randomBytes || utils_ts_1$3.randomBytes;
    const adjustScalarBytes$1 = eddsaOpts.adjustScalarBytes || ((bytes$1) => bytes$1);
    const domain = eddsaOpts.domain || ((data2, ctx, phflag) => {
      (0, utils_ts_1$3.abool)("phflag", phflag);
      if (ctx.length || phflag) throw new Error("Contexts/pre-hash are not supported");
      return data2;
    });
    function modN$1(a) {
      return Fn.create(a);
    }
    function modN_LE(hash$12) {
      return modN$1((0, utils_ts_1$3.bytesToNumberLE)(hash$12));
    }
    function getPrivateScalar(key) {
      const len = Fp$1.BYTES;
      key = (0, utils_ts_1$3.ensureBytes)("private key", key, len);
      const hashed = (0, utils_ts_1$3.ensureBytes)("hashed private key", cHash(key), 2 * len);
      const head = adjustScalarBytes$1(hashed.slice(0, len));
      const prefix$2 = hashed.slice(len, 2 * len);
      const scalar = modN_LE(head);
      return {
        head,
        prefix: prefix$2,
        scalar
      };
    }
    function getExtendedPublicKey(key) {
      const { head, prefix: prefix$2, scalar } = getPrivateScalar(key);
      const point = G.multiply(scalar);
      const pointBytes = point.toBytes();
      return {
        head,
        prefix: prefix$2,
        scalar,
        point,
        pointBytes
      };
    }
    function getPublicKey(privKey) {
      return getExtendedPublicKey(privKey).pointBytes;
    }
    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
      const msg = (0, utils_ts_1$3.concatBytes)(...msgs);
      return modN_LE(cHash(domain(msg, (0, utils_ts_1$3.ensureBytes)("context", context), !!prehash)));
    }
    function sign$1(msg, privKey, options = {}) {
      msg = (0, utils_ts_1$3.ensureBytes)("message", msg);
      if (prehash) msg = prehash(msg);
      const { prefix: prefix$2, scalar, pointBytes } = getExtendedPublicKey(privKey);
      const r = hashDomainToScalar(options.context, prefix$2, msg);
      const R = G.multiply(r).toBytes();
      const k = hashDomainToScalar(options.context, R, pointBytes, msg);
      const s = modN$1(r + k * scalar);
      (0, utils_ts_1$3.aInRange)("signature.s", s, _0n$2, CURVE_ORDER);
      const L = Fp$1.BYTES;
      const res = (0, utils_ts_1$3.concatBytes)(R, (0, utils_ts_1$3.numberToBytesLE)(s, L));
      return (0, utils_ts_1$3.ensureBytes)("result", res, L * 2);
    }
    const verifyOpts = VERIFY_DEFAULT;
    function verify$1(sig, msg, publicKey, options = verifyOpts) {
      const { context, zip215 } = options;
      const len = Fp$1.BYTES;
      sig = (0, utils_ts_1$3.ensureBytes)("signature", sig, 2 * len);
      msg = (0, utils_ts_1$3.ensureBytes)("message", msg);
      publicKey = (0, utils_ts_1$3.ensureBytes)("publicKey", publicKey, len);
      if (zip215 !== void 0) (0, utils_ts_1$3.abool)("zip215", zip215);
      if (prehash) msg = prehash(msg);
      const s = (0, utils_ts_1$3.bytesToNumberLE)(sig.slice(len, 2 * len));
      let A, R, SB2;
      try {
        A = Point$2.fromHex(publicKey, zip215);
        R = Point$2.fromHex(sig.slice(0, len), zip215);
        SB2 = G.multiplyUnsafe(s);
      } catch (error) {
        return false;
      }
      if (!zip215 && A.isSmallOrder()) return false;
      const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
      const RkA = R.add(A.multiplyUnsafe(k));
      return RkA.subtract(SB2).clearCofactor().is0();
    }
    G.precompute(8);
    const utils2 = {
      getExtendedPublicKey,
      randomPrivateKey: () => randomBytes_(Fp$1.BYTES),
      precompute(windowSize = 8, point = Point$2.BASE) {
        return point.precompute(windowSize, false);
      }
    };
    return {
      getPublicKey,
      sign: sign$1,
      verify: verify$1,
      utils: utils2,
      Point: Point$2
    };
  }
  function _eddsa_legacy_opts_to_new(c) {
    const CURVE = {
      a: c.a,
      d: c.d,
      p: c.Fp.ORDER,
      n: c.n,
      h: c.h,
      Gx: c.Gx,
      Gy: c.Gy
    };
    const Fp$1 = c.Fp;
    const Fn = (0, modular_ts_1$2.Field)(CURVE.n, c.nBitLength, true);
    const curveOpts = {
      Fp: Fp$1,
      Fn,
      uvRatio: c.uvRatio
    };
    const eddsaOpts = {
      hash: c.hash,
      randomBytes: c.randomBytes,
      adjustScalarBytes: c.adjustScalarBytes,
      domain: c.domain,
      prehash: c.prehash,
      mapToCurve: c.mapToCurve
    };
    return {
      CURVE,
      curveOpts,
      eddsaOpts
    };
  }
  function _eddsa_new_output_to_legacy(c, eddsa$1) {
    const legacy = Object.assign({}, eddsa$1, {
      ExtendedPoint: eddsa$1.Point,
      CURVE: c
    });
    return legacy;
  }
  function twistedEdwards(c) {
    const { CURVE, curveOpts, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
    const Point$2 = edwards(CURVE, curveOpts);
    const EDDSA = eddsa(Point$2, eddsaOpts);
    return _eddsa_new_output_to_legacy(c, EDDSA);
  }
} });
var require_montgomery$1 = __commonJS$1({ "../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/montgomery.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.montgomery = montgomery;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const utils_ts_1$2 = require_utils$8();
  const modular_ts_1$1 = require_modular$1();
  const _0n$1 = BigInt(0);
  const _1n$1 = BigInt(1);
  const _2n$1 = BigInt(2);
  function validateOpts(curve) {
    (0, utils_ts_1$2._validateObject)(curve, {
      adjustScalarBytes: "function",
      powPminus2: "function"
    });
    return Object.freeze({ ...curve });
  }
  function montgomery(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { P, type: type2, adjustScalarBytes: adjustScalarBytes$1, powPminus2, randomBytes: rand } = CURVE;
    const is25519 = type2 === "x25519";
    if (!is25519 && type2 !== "x448") throw new Error("invalid type");
    const randomBytes_ = rand || utils_ts_1$2.randomBytes;
    const montgomeryBits = is25519 ? 255 : 448;
    const fieldLen = is25519 ? 32 : 56;
    const Gu = is25519 ? BigInt(9) : BigInt(5);
    const a24 = is25519 ? BigInt(121665) : BigInt(39081);
    const minScalar = is25519 ? _2n$1 ** BigInt(254) : _2n$1 ** BigInt(447);
    const maxAdded = is25519 ? BigInt(8) * _2n$1 ** BigInt(251) - _1n$1 : BigInt(4) * _2n$1 ** BigInt(445) - _1n$1;
    const maxScalar = minScalar + maxAdded + _1n$1;
    const modP$1 = (n) => (0, modular_ts_1$1.mod)(n, P);
    const GuBytes = encodeU(Gu);
    function encodeU(u) {
      return (0, utils_ts_1$2.numberToBytesLE)(modP$1(u), fieldLen);
    }
    function decodeU(u) {
      const _u = (0, utils_ts_1$2.ensureBytes)("u coordinate", u, fieldLen);
      if (is25519) _u[31] &= 127;
      return modP$1((0, utils_ts_1$2.bytesToNumberLE)(_u));
    }
    function decodeScalar(scalar) {
      return (0, utils_ts_1$2.bytesToNumberLE)(adjustScalarBytes$1((0, utils_ts_1$2.ensureBytes)("scalar", scalar, fieldLen)));
    }
    function scalarMult(scalar, u) {
      const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
      if (pu === _0n$1) throw new Error("invalid private or public key received");
      return encodeU(pu);
    }
    function scalarMultBase(scalar) {
      return scalarMult(scalar, GuBytes);
    }
    function cswap(swap$1, x_2, x_3) {
      const dummy = modP$1(swap$1 * (x_2 - x_3));
      x_2 = modP$1(x_2 - dummy);
      x_3 = modP$1(x_3 + dummy);
      return {
        x_2,
        x_3
      };
    }
    function montgomeryLadder(u, scalar) {
      (0, utils_ts_1$2.aInRange)("u", u, _0n$1, P);
      (0, utils_ts_1$2.aInRange)("scalar", scalar, minScalar, maxScalar);
      const k = scalar;
      const x_1 = u;
      let x_2 = _1n$1;
      let z_2 = _0n$1;
      let x_3 = u;
      let z_3 = _1n$1;
      let swap$1 = _0n$1;
      for (let t = BigInt(montgomeryBits - 1); t >= _0n$1; t--) {
        const k_t = k >> t & _1n$1;
        swap$1 ^= k_t;
        ({ x_2, x_3 } = cswap(swap$1, x_2, x_3));
        ({ x_2: z_2, x_3: z_3 } = cswap(swap$1, z_2, z_3));
        swap$1 = k_t;
        const A = x_2 + z_2;
        const AA = modP$1(A * A);
        const B = x_2 - z_2;
        const BB2 = modP$1(B * B);
        const E = AA - BB2;
        const C = x_3 + z_3;
        const D = x_3 - z_3;
        const DA = modP$1(D * A);
        const CB = modP$1(C * B);
        const dacb = DA + CB;
        const da_cb = DA - CB;
        x_3 = modP$1(dacb * dacb);
        z_3 = modP$1(x_1 * modP$1(da_cb * da_cb));
        x_2 = modP$1(AA * BB2);
        z_2 = modP$1(E * (AA + modP$1(a24 * E)));
      }
      ({ x_2, x_3 } = cswap(swap$1, x_2, x_3));
      ({ x_2: z_2, x_3: z_3 } = cswap(swap$1, z_2, z_3));
      const z2 = powPminus2(z_2);
      return modP$1(x_2 * z2);
    }
    return {
      scalarMult,
      scalarMultBase,
      getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
      getPublicKey: (privateKey) => scalarMultBase(privateKey),
      utils: { randomPrivateKey: () => randomBytes_(fieldLen) },
      GuBytes: GuBytes.slice()
    };
  }
} });
var require_ed25519$1$1 = __commonJS$1({ "../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/ed25519.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hash_to_ristretto255 = exports.hashToRistretto255 = exports.RistrettoPoint = exports.encodeToCurve = exports.hashToCurve = exports.ed25519_hasher = exports.edwardsToMontgomery = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = exports.ED25519_TORSION_SUBGROUP = void 0;
  exports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
  exports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const sha2_js_1 = require_sha2$1();
  const utils_js_1 = require_utils$10();
  const curve_ts_1 = require_curve$1();
  const edwards_ts_1 = require_edwards$1();
  const hash_to_curve_ts_1 = require_hash_to_curve$1();
  const modular_ts_1 = require_modular$1();
  const montgomery_ts_1 = require_montgomery$1();
  const utils_ts_1$1 = require_utils$8();
  const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
  const _5n = BigInt(5), _8n = BigInt(8);
  const ed25519_CURVE = {
    p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),
    n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
    h: _8n,
    a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
    d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
    Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
    Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
  };
  function ed25519_pow_2_252_3(x) {
    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
    const P = ed25519_CURVE.p;
    const x2 = x * x % P;
    const b2 = x2 * x % P;
    const b4 = (0, modular_ts_1.pow2)(b2, _2n, P) * b2 % P;
    const b5 = (0, modular_ts_1.pow2)(b4, _1n, P) * x % P;
    const b10 = (0, modular_ts_1.pow2)(b5, _5n, P) * b5 % P;
    const b20 = (0, modular_ts_1.pow2)(b10, _10n, P) * b10 % P;
    const b40 = (0, modular_ts_1.pow2)(b20, _20n, P) * b20 % P;
    const b80 = (0, modular_ts_1.pow2)(b40, _40n, P) * b40 % P;
    const b160 = (0, modular_ts_1.pow2)(b80, _80n, P) * b80 % P;
    const b240 = (0, modular_ts_1.pow2)(b160, _80n, P) * b80 % P;
    const b250 = (0, modular_ts_1.pow2)(b240, _10n, P) * b10 % P;
    const pow_p_5_8 = (0, modular_ts_1.pow2)(b250, _2n, P) * x % P;
    return {
      pow_p_5_8,
      b2
    };
  }
  function adjustScalarBytes(bytes$1) {
    bytes$1[0] &= 248;
    bytes$1[31] &= 127;
    bytes$1[31] |= 64;
    return bytes$1;
  }
  const ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
  function uvRatio(u, v) {
    const P = ed25519_CURVE.p;
    const v32 = (0, modular_ts_1.mod)(v * v * v, P);
    const v72 = (0, modular_ts_1.mod)(v32 * v32 * v, P);
    const pow$1 = ed25519_pow_2_252_3(u * v72).pow_p_5_8;
    let x = (0, modular_ts_1.mod)(u * v32 * pow$1, P);
    const vx2 = (0, modular_ts_1.mod)(v * x * x, P);
    const root1 = x;
    const root2 = (0, modular_ts_1.mod)(x * ED25519_SQRT_M1, P);
    const useRoot1 = vx2 === u;
    const useRoot2 = vx2 === (0, modular_ts_1.mod)(-u, P);
    const noRoot = vx2 === (0, modular_ts_1.mod)(-u * ED25519_SQRT_M1, P);
    if (useRoot1) x = root1;
    if (useRoot2 || noRoot) x = root2;
    if ((0, modular_ts_1.isNegativeLE)(x, P)) x = (0, modular_ts_1.mod)(-x, P);
    return {
      isValid: useRoot1 || useRoot2,
      value: x
    };
  }
  exports.ED25519_TORSION_SUBGROUP = [
    "0100000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
    "0000000000000000000000000000000000000000000000000000000000000080",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
    "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
  ];
  const Fp = /* @__PURE__ */ (() => (0, modular_ts_1.Field)(ed25519_CURVE.p, void 0, true))();
  const ed25519Defaults = /* @__PURE__ */ (() => ({
    ...ed25519_CURVE,
    Fp,
    hash: sha2_js_1.sha512,
    adjustScalarBytes,
    uvRatio
  }))();
  exports.ed25519 = (() => (0, edwards_ts_1.twistedEdwards)(ed25519Defaults))();
  function ed25519_domain(data2, ctx, phflag) {
    if (ctx.length > 255) throw new Error("Context is too big");
    return (0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data2);
  }
  exports.ed25519ctx = (() => (0, edwards_ts_1.twistedEdwards)({
    ...ed25519Defaults,
    domain: ed25519_domain
  }))();
  exports.ed25519ph = (() => (0, edwards_ts_1.twistedEdwards)(Object.assign({}, ed25519Defaults, {
    domain: ed25519_domain,
    prehash: sha2_js_1.sha512
  })))();
  exports.x25519 = (() => {
    const P = ed25519_CURVE.p;
    return (0, montgomery_ts_1.montgomery)({
      P,
      type: "x25519",
      powPminus2: (x) => {
        const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
        return (0, modular_ts_1.mod)((0, modular_ts_1.pow2)(pow_p_5_8, _3n, P) * b2, P);
      },
      adjustScalarBytes
    });
  })();
  function edwardsToMontgomeryPub(edwardsPub) {
    const bpub = (0, utils_ts_1$1.ensureBytes)("pub", edwardsPub);
    const { y } = exports.ed25519.Point.fromHex(bpub);
    const _1n$8 = BigInt(1);
    return Fp.toBytes(Fp.create((_1n$8 + y) * Fp.inv(_1n$8 - y)));
  }
  exports.edwardsToMontgomery = edwardsToMontgomeryPub;
  function edwardsToMontgomeryPriv(edwardsPriv) {
    const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));
    return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);
  }
  const ELL2_C1 = /* @__PURE__ */ (() => (Fp.ORDER + _3n) / _8n)();
  const ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))();
  const ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
  function map_to_curve_elligator2_curve25519(u) {
    const ELL2_C4 = (Fp.ORDER - _5n) / _8n;
    const ELL2_J = BigInt(486662);
    let tv1 = Fp.sqr(u);
    tv1 = Fp.mul(tv1, _2n);
    let xd = Fp.add(tv1, Fp.ONE);
    let x1n = Fp.neg(ELL2_J);
    let tv2 = Fp.sqr(xd);
    let gxd = Fp.mul(tv2, xd);
    let gx1 = Fp.mul(tv1, ELL2_J);
    gx1 = Fp.mul(gx1, x1n);
    gx1 = Fp.add(gx1, tv2);
    gx1 = Fp.mul(gx1, x1n);
    let tv3 = Fp.sqr(gxd);
    tv2 = Fp.sqr(tv3);
    tv3 = Fp.mul(tv3, gxd);
    tv3 = Fp.mul(tv3, gx1);
    tv2 = Fp.mul(tv2, tv3);
    let y11 = Fp.pow(tv2, ELL2_C4);
    y11 = Fp.mul(y11, tv3);
    let y12 = Fp.mul(y11, ELL2_C3);
    tv2 = Fp.sqr(y11);
    tv2 = Fp.mul(tv2, gxd);
    let e1 = Fp.eql(tv2, gx1);
    let y1 = Fp.cmov(y12, y11, e1);
    let x2n = Fp.mul(x1n, tv1);
    let y21 = Fp.mul(y11, u);
    y21 = Fp.mul(y21, ELL2_C2);
    let y22 = Fp.mul(y21, ELL2_C3);
    let gx2 = Fp.mul(gx1, tv1);
    tv2 = Fp.sqr(y21);
    tv2 = Fp.mul(tv2, gxd);
    let e2 = Fp.eql(tv2, gx2);
    let y2 = Fp.cmov(y22, y21, e2);
    tv2 = Fp.sqr(y1);
    tv2 = Fp.mul(tv2, gxd);
    let e3 = Fp.eql(tv2, gx1);
    let xn = Fp.cmov(x2n, x1n, e3);
    let y = Fp.cmov(y2, y1, e3);
    let e4 = Fp.isOdd(y);
    y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
    return {
      xMn: xn,
      xMd: xd,
      yMn: y,
      yMd: _1n
    };
  }
  const ELL2_C1_EDWARDS = /* @__PURE__ */ (() => (0, modular_ts_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))();
  function map_to_curve_elligator2_edwards25519(u) {
    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
    let xn = Fp.mul(xMn, yMd);
    xn = Fp.mul(xn, ELL2_C1_EDWARDS);
    let xd = Fp.mul(xMd, yMn);
    let yn = Fp.sub(xMn, xMd);
    let yd = Fp.add(xMn, xMd);
    let tv1 = Fp.mul(xd, yd);
    let e = Fp.eql(tv1, Fp.ZERO);
    xn = Fp.cmov(xn, Fp.ZERO, e);
    xd = Fp.cmov(xd, Fp.ONE, e);
    yn = Fp.cmov(yn, Fp.ONE, e);
    yd = Fp.cmov(yd, Fp.ONE, e);
    const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(Fp, [xd, yd], true);
    return {
      x: Fp.mul(xn, xd_inv),
      y: Fp.mul(yn, yd_inv)
    };
  }
  exports.ed25519_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.ed25519.Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
    DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
    encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
    p: Fp.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: sha2_js_1.sha512
  }))();
  exports.hashToCurve = (() => exports.ed25519_hasher.hashToCurve)();
  exports.encodeToCurve = (() => exports.ed25519_hasher.encodeToCurve)();
  function aristp(other) {
    if (!(other instanceof RistPoint)) throw new Error("RistrettoPoint expected");
  }
  const SQRT_M1 = ED25519_SQRT_M1;
  const SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
  const INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
  const ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
  const D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
  const invertSqrt = (number) => uvRatio(_1n, number);
  const MAX_255B = /* @__PURE__ */ BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  const bytes255ToNumberLE = (bytes$1) => exports.ed25519.CURVE.Fp.create((0, utils_ts_1$1.bytesToNumberLE)(bytes$1) & MAX_255B);
  function calcElligatorRistrettoMap(r0) {
    const { d } = exports.ed25519.CURVE;
    const P = exports.ed25519.CURVE.Fp.ORDER;
    const mod$1 = exports.ed25519.CURVE.Fp.create;
    const r = mod$1(SQRT_M1 * r0 * r0);
    const Ns = mod$1((r + _1n) * ONE_MINUS_D_SQ);
    let c = BigInt(-1);
    const D = mod$1((c - d * r) * mod$1(r + d));
    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
    let s_ = mod$1(s * r0);
    if (!(0, modular_ts_1.isNegativeLE)(s_, P)) s_ = mod$1(-s_);
    if (!Ns_D_is_sq) s = s_;
    if (!Ns_D_is_sq) c = r;
    const Nt = mod$1(c * (r - _1n) * D_MINUS_ONE_SQ - D);
    const s2 = s * s;
    const W0 = mod$1((s + s) * D);
    const W1 = mod$1(Nt * SQRT_AD_MINUS_ONE);
    const W2 = mod$1(_1n - s2);
    const W3 = mod$1(_1n + s2);
    return new exports.ed25519.Point(mod$1(W0 * W3), mod$1(W2 * W1), mod$1(W1 * W3), mod$1(W0 * W2));
  }
  var RistPoint = class RistPoint2 {
    constructor(ep) {
      this.ep = ep;
    }
    static fromAffine(ap) {
      return new RistPoint2(exports.ed25519.Point.fromAffine(ap));
    }
    /**
    * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
    * The hash-to-group operation applies Elligator twice and adds the results.
    * **Note:** this is one-way map, there is no conversion from point to hash.
    * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on
    * the [website](https://ristretto.group/formulas/elligator.html).
    * @param hex 64-byte output of a hash function
    */
    static hashToCurve(hex) {
      hex = (0, utils_ts_1$1.ensureBytes)("ristrettoHash", hex, 64);
      const r1 = bytes255ToNumberLE(hex.slice(0, 32));
      const R1 = calcElligatorRistrettoMap(r1);
      const r2 = bytes255ToNumberLE(hex.slice(32, 64));
      const R2 = calcElligatorRistrettoMap(r2);
      return new RistPoint2(R1.add(R2));
    }
    static fromBytes(bytes$1) {
      (0, utils_js_1.abytes)(bytes$1);
      return this.fromHex(bytes$1);
    }
    /**
    * Converts ristretto-encoded string to ristretto point.
    * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
    * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
    */
    static fromHex(hex) {
      hex = (0, utils_ts_1$1.ensureBytes)("ristrettoHex", hex, 32);
      const { a, d } = exports.ed25519.CURVE;
      const P = Fp.ORDER;
      const mod$1 = Fp.create;
      const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
      const s = bytes255ToNumberLE(hex);
      if (!(0, utils_ts_1$1.equalBytes)((0, utils_ts_1$1.numberToBytesLE)(s, 32), hex) || (0, modular_ts_1.isNegativeLE)(s, P)) throw new Error(emsg);
      const s2 = mod$1(s * s);
      const u1 = mod$1(_1n + a * s2);
      const u2 = mod$1(_1n - a * s2);
      const u1_2 = mod$1(u1 * u1);
      const u2_2 = mod$1(u2 * u2);
      const v = mod$1(a * d * u1_2 - u2_2);
      const { isValid, value: I } = invertSqrt(mod$1(v * u2_2));
      const Dx = mod$1(I * u2);
      const Dy = mod$1(I * Dx * v);
      let x = mod$1((s + s) * Dx);
      if ((0, modular_ts_1.isNegativeLE)(x, P)) x = mod$1(-x);
      const y = mod$1(u1 * Dy);
      const t = mod$1(x * y);
      if (!isValid || (0, modular_ts_1.isNegativeLE)(t, P) || y === _0n) throw new Error(emsg);
      return new RistPoint2(new exports.ed25519.Point(x, y, _1n, t));
    }
    static msm(points, scalars) {
      const Fn = (0, modular_ts_1.Field)(exports.ed25519.CURVE.n, exports.ed25519.CURVE.nBitLength);
      return (0, curve_ts_1.pippenger)(RistPoint2, Fn, points, scalars);
    }
    /**
    * Encodes ristretto point to Uint8Array.
    * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
    */
    toBytes() {
      let { ex: x, ey: y, ez: z2, et: t } = this.ep;
      const P = Fp.ORDER;
      const mod$1 = Fp.create;
      const u1 = mod$1(mod$1(z2 + y) * mod$1(z2 - y));
      const u2 = mod$1(x * y);
      const u2sq = mod$1(u2 * u2);
      const { value: invsqrt } = invertSqrt(mod$1(u1 * u2sq));
      const D1 = mod$1(invsqrt * u1);
      const D2 = mod$1(invsqrt * u2);
      const zInv = mod$1(D1 * D2 * t);
      let D;
      if ((0, modular_ts_1.isNegativeLE)(t * zInv, P)) {
        let _x = mod$1(y * SQRT_M1);
        let _y = mod$1(x * SQRT_M1);
        x = _x;
        y = _y;
        D = mod$1(D1 * INVSQRT_A_MINUS_D);
      } else D = D2;
      if ((0, modular_ts_1.isNegativeLE)(x * zInv, P)) y = mod$1(-y);
      let s = mod$1((z2 - y) * D);
      if ((0, modular_ts_1.isNegativeLE)(s, P)) s = mod$1(-s);
      return (0, utils_ts_1$1.numberToBytesLE)(s, 32);
    }
    /** @deprecated use `toBytes` */
    toRawBytes() {
      return this.toBytes();
    }
    toHex() {
      return (0, utils_ts_1$1.bytesToHex)(this.toBytes());
    }
    toString() {
      return this.toHex();
    }
    /**
    * Compares two Ristretto points.
    * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
    */
    equals(other) {
      aristp(other);
      const { ex: X1, ey: Y1 } = this.ep;
      const { ex: X2, ey: Y2 } = other.ep;
      const mod$1 = Fp.create;
      const one = mod$1(X1 * Y2) === mod$1(Y1 * X2);
      const two = mod$1(Y1 * Y2) === mod$1(X1 * X2);
      return one || two;
    }
    add(other) {
      aristp(other);
      return new RistPoint2(this.ep.add(other.ep));
    }
    subtract(other) {
      aristp(other);
      return new RistPoint2(this.ep.subtract(other.ep));
    }
    multiply(scalar) {
      return new RistPoint2(this.ep.multiply(scalar));
    }
    multiplyUnsafe(scalar) {
      return new RistPoint2(this.ep.multiplyUnsafe(scalar));
    }
    double() {
      return new RistPoint2(this.ep.double());
    }
    negate() {
      return new RistPoint2(this.ep.negate());
    }
  };
  exports.RistrettoPoint = (() => {
    if (!RistPoint.BASE) RistPoint.BASE = new RistPoint(exports.ed25519.Point.BASE);
    if (!RistPoint.ZERO) RistPoint.ZERO = new RistPoint(exports.ed25519.Point.ZERO);
    return RistPoint;
  })();
  const hashToRistretto255 = (msg, options) => {
    const d = options.DST;
    const DST = typeof d === "string" ? (0, utils_js_1.utf8ToBytes)(d) : d;
    const uniform_bytes = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, DST, 64, sha2_js_1.sha512);
    const P = RistPoint.hashToCurve(uniform_bytes);
    return P;
  };
  exports.hashToRistretto255 = hashToRistretto255;
  exports.hash_to_ristretto255 = exports.hashToRistretto255;
} });
var require_ed25519$2 = __commonJS$1({ "../../node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/signing-schemes/ed25519/index.js"(exports) {
  var __importDefault$24 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const ed25519_1$1 = require_ed25519$1$1();
  const utils_1$52 = require_browser$4();
  const assert_1$1 = __importDefault$24(require_assert$1());
  const Sha512_1$1 = __importDefault$24(require_Sha512$1());
  const ED_PREFIX = "ED";
  const ed25519 = {
    deriveKeypair(entropy) {
      const rawPrivateKey = Sha512_1$1.default.half(entropy);
      const privateKey = ED_PREFIX + (0, utils_1$52.bytesToHex)(rawPrivateKey);
      const publicKey = ED_PREFIX + (0, utils_1$52.bytesToHex)(ed25519_1$1.ed25519.getPublicKey(rawPrivateKey));
      return {
        privateKey,
        publicKey
      };
    },
    sign(message2, privateKey) {
      assert_1$1.default.ok(message2 instanceof Uint8Array, "message must be array of octets");
      assert_1$1.default.ok(privateKey.length === 66, "private key must be 33 bytes including prefix");
      return (0, utils_1$52.bytesToHex)(ed25519_1$1.ed25519.sign(message2, privateKey.slice(2)));
    },
    verify(message2, signature2, publicKey) {
      assert_1$1.default.ok(publicKey.length === 66, "public key must be 33 bytes including prefix");
      return ed25519_1$1.ed25519.verify(signature2, message2, publicKey.slice(2), { zip215: false });
    }
  };
  exports.default = ed25519;
} });
var require_dist$2 = __commonJS$1({ "../../node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/index.js"(exports) {
  var __importDefault$23 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeSeed = exports.deriveNodeAddress = exports.deriveAddress = exports.verify = exports.sign = exports.deriveKeypair = exports.generateSeed = void 0;
  const ripple_address_codec_1$12 = require_dist$3();
  Object.defineProperty(exports, "decodeSeed", {
    enumerable: true,
    get: function() {
      return ripple_address_codec_1$12.decodeSeed;
    }
  });
  const ripemd160_1 = require_browser$2();
  const sha256_1 = require_browser$3();
  const utils_1$51 = require_browser$4();
  const utils_2$7 = require_utils$6();
  const Sha512_1 = __importDefault$23(require_Sha512$1());
  const assert_1 = __importDefault$23(require_assert$1());
  const getAlgorithmFromKey_1 = require_getAlgorithmFromKey$1();
  const secp256k1_1$1 = __importDefault$23(require_secp256k1$2());
  const ed25519_1 = __importDefault$23(require_ed25519$2());
  function getSigningScheme(algorithm) {
    const schemes = {
      "ecdsa-secp256k1": secp256k1_1$1.default,
      ed25519: ed25519_1.default
    };
    return schemes[algorithm];
  }
  function generateSeed(options = {}) {
    assert_1.default.ok(!options.entropy || options.entropy.length >= 16, "entropy too short");
    const entropy = options.entropy ? options.entropy.slice(0, 16) : (0, utils_1$51.randomBytes)(16);
    const type2 = options.algorithm === "ed25519" ? "ed25519" : "secp256k1";
    return (0, ripple_address_codec_1$12.encodeSeed)(entropy, type2);
  }
  exports.generateSeed = generateSeed;
  function deriveKeypair(seed, options) {
    var _a;
    const decoded = (0, ripple_address_codec_1$12.decodeSeed)(seed);
    const proposedAlgorithm = (_a = options === null || options === void 0 ? void 0 : options.algorithm) !== null && _a !== void 0 ? _a : decoded.type;
    const algorithm = proposedAlgorithm === "ed25519" ? "ed25519" : "ecdsa-secp256k1";
    const scheme = getSigningScheme(algorithm);
    const keypair = scheme.deriveKeypair(decoded.bytes, options);
    const messageToVerify = Sha512_1.default.half("This test message should verify.");
    const signature2 = scheme.sign(messageToVerify, keypair.privateKey);
    if (!scheme.verify(messageToVerify, signature2, keypair.publicKey)) throw new Error("derived keypair did not generate verifiable signature");
    return keypair;
  }
  exports.deriveKeypair = deriveKeypair;
  function sign2(messageHex, privateKey) {
    const algorithm = (0, getAlgorithmFromKey_1.getAlgorithmFromPrivateKey)(privateKey);
    return getSigningScheme(algorithm).sign((0, utils_1$51.hexToBytes)(messageHex), privateKey);
  }
  exports.sign = sign2;
  function verify(messageHex, signature2, publicKey) {
    const algorithm = (0, getAlgorithmFromKey_1.getAlgorithmFromPublicKey)(publicKey);
    return getSigningScheme(algorithm).verify((0, utils_1$51.hexToBytes)(messageHex), signature2, publicKey);
  }
  exports.verify = verify;
  function computePublicKeyHash(publicKeyBytes) {
    return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(publicKeyBytes));
  }
  function deriveAddressFromBytes(publicKeyBytes) {
    return (0, ripple_address_codec_1$12.encodeAccountID)(computePublicKeyHash(publicKeyBytes));
  }
  function deriveAddress(publicKey) {
    return deriveAddressFromBytes((0, utils_1$51.hexToBytes)(publicKey));
  }
  exports.deriveAddress = deriveAddress;
  function deriveNodeAddress(publicKey) {
    const generatorBytes = (0, ripple_address_codec_1$12.decodeNodePublic)(publicKey);
    const accountPublicBytes = (0, utils_2$7.accountPublicFromPublicGenerator)(generatorBytes);
    return deriveAddressFromBytes(accountPublicBytes);
  }
  exports.deriveNodeAddress = deriveNodeAddress;
} });
var require_tweetnacl = __commonJS$1({ "../../node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl"() {
} });
var require_nacl_fast = __commonJS$1({ "../../node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"(exports, module) {
  (function(nacl$2) {
    var gf = function(init) {
      var i, r = new Float64Array(16);
      if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
      return r;
    };
    var randombytes = function() {
      throw new Error("no PRNG");
    };
    var _0 = new Uint8Array(16);
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]), D2 = gf([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]), X = gf([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]), Y = gf([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]), I = gf([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function ts64(x, i, h, l) {
      x[i] = h >> 24 & 255;
      x[i + 1] = h >> 16 & 255;
      x[i + 2] = h >> 8 & 255;
      x[i + 3] = h & 255;
      x[i + 4] = l >> 24 & 255;
      x[i + 5] = l >> 16 & 255;
      x[i + 6] = l >> 8 & 255;
      x[i + 7] = l & 255;
    }
    function vn(x, xi, y, yi, n) {
      var i, d = 0;
      for (i = 0; i < n; i++) d |= x[xi + i] ^ y[yi + i];
      return (1 & d - 1 >>> 8) - 1;
    }
    function crypto_verify_16(x, xi, y, yi) {
      return vn(x, xi, y, yi, 16);
    }
    function crypto_verify_32(x, xi, y, yi) {
      return vn(x, xi, y, yi, 32);
    }
    function core_salsa20(o, p, k, c) {
      var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0; i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 25;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 23;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 19;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 14;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 25;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 23;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 19;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 14;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 25;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 23;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 19;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 14;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 25;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 23;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 19;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 14;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 25;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 23;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 19;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 14;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 25;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 23;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 19;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 14;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 25;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 23;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 19;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 14;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 25;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 23;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 19;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 14;
      }
      x0 = x0 + j0 | 0;
      x1 = x1 + j1 | 0;
      x2 = x2 + j2 | 0;
      x3 = x3 + j3 | 0;
      x4 = x4 + j4 | 0;
      x5 = x5 + j5 | 0;
      x6 = x6 + j6 | 0;
      x7 = x7 + j7 | 0;
      x8 = x8 + j8 | 0;
      x9 = x9 + j9 | 0;
      x10 = x10 + j10 | 0;
      x11 = x11 + j11 | 0;
      x12 = x12 + j12 | 0;
      x13 = x13 + j13 | 0;
      x14 = x14 + j14 | 0;
      x15 = x15 + j15 | 0;
      o[0] = x0 >>> 0 & 255;
      o[1] = x0 >>> 8 & 255;
      o[2] = x0 >>> 16 & 255;
      o[3] = x0 >>> 24 & 255;
      o[4] = x1 >>> 0 & 255;
      o[5] = x1 >>> 8 & 255;
      o[6] = x1 >>> 16 & 255;
      o[7] = x1 >>> 24 & 255;
      o[8] = x2 >>> 0 & 255;
      o[9] = x2 >>> 8 & 255;
      o[10] = x2 >>> 16 & 255;
      o[11] = x2 >>> 24 & 255;
      o[12] = x3 >>> 0 & 255;
      o[13] = x3 >>> 8 & 255;
      o[14] = x3 >>> 16 & 255;
      o[15] = x3 >>> 24 & 255;
      o[16] = x4 >>> 0 & 255;
      o[17] = x4 >>> 8 & 255;
      o[18] = x4 >>> 16 & 255;
      o[19] = x4 >>> 24 & 255;
      o[20] = x5 >>> 0 & 255;
      o[21] = x5 >>> 8 & 255;
      o[22] = x5 >>> 16 & 255;
      o[23] = x5 >>> 24 & 255;
      o[24] = x6 >>> 0 & 255;
      o[25] = x6 >>> 8 & 255;
      o[26] = x6 >>> 16 & 255;
      o[27] = x6 >>> 24 & 255;
      o[28] = x7 >>> 0 & 255;
      o[29] = x7 >>> 8 & 255;
      o[30] = x7 >>> 16 & 255;
      o[31] = x7 >>> 24 & 255;
      o[32] = x8 >>> 0 & 255;
      o[33] = x8 >>> 8 & 255;
      o[34] = x8 >>> 16 & 255;
      o[35] = x8 >>> 24 & 255;
      o[36] = x9 >>> 0 & 255;
      o[37] = x9 >>> 8 & 255;
      o[38] = x9 >>> 16 & 255;
      o[39] = x9 >>> 24 & 255;
      o[40] = x10 >>> 0 & 255;
      o[41] = x10 >>> 8 & 255;
      o[42] = x10 >>> 16 & 255;
      o[43] = x10 >>> 24 & 255;
      o[44] = x11 >>> 0 & 255;
      o[45] = x11 >>> 8 & 255;
      o[46] = x11 >>> 16 & 255;
      o[47] = x11 >>> 24 & 255;
      o[48] = x12 >>> 0 & 255;
      o[49] = x12 >>> 8 & 255;
      o[50] = x12 >>> 16 & 255;
      o[51] = x12 >>> 24 & 255;
      o[52] = x13 >>> 0 & 255;
      o[53] = x13 >>> 8 & 255;
      o[54] = x13 >>> 16 & 255;
      o[55] = x13 >>> 24 & 255;
      o[56] = x14 >>> 0 & 255;
      o[57] = x14 >>> 8 & 255;
      o[58] = x14 >>> 16 & 255;
      o[59] = x14 >>> 24 & 255;
      o[60] = x15 >>> 0 & 255;
      o[61] = x15 >>> 8 & 255;
      o[62] = x15 >>> 16 & 255;
      o[63] = x15 >>> 24 & 255;
    }
    function core_hsalsa20(o, p, k, c) {
      var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0; i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 25;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 23;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 19;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 14;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 25;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 23;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 19;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 14;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 25;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 23;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 19;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 14;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 25;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 23;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 19;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 14;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 25;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 23;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 19;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 14;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 25;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 23;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 19;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 14;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 25;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 23;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 19;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 14;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 25;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 23;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 19;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 14;
      }
      o[0] = x0 >>> 0 & 255;
      o[1] = x0 >>> 8 & 255;
      o[2] = x0 >>> 16 & 255;
      o[3] = x0 >>> 24 & 255;
      o[4] = x5 >>> 0 & 255;
      o[5] = x5 >>> 8 & 255;
      o[6] = x5 >>> 16 & 255;
      o[7] = x5 >>> 24 & 255;
      o[8] = x10 >>> 0 & 255;
      o[9] = x10 >>> 8 & 255;
      o[10] = x10 >>> 16 & 255;
      o[11] = x10 >>> 24 & 255;
      o[12] = x15 >>> 0 & 255;
      o[13] = x15 >>> 8 & 255;
      o[14] = x15 >>> 16 & 255;
      o[15] = x15 >>> 24 & 255;
      o[16] = x6 >>> 0 & 255;
      o[17] = x6 >>> 8 & 255;
      o[18] = x6 >>> 16 & 255;
      o[19] = x6 >>> 24 & 255;
      o[20] = x7 >>> 0 & 255;
      o[21] = x7 >>> 8 & 255;
      o[22] = x7 >>> 16 & 255;
      o[23] = x7 >>> 24 & 255;
      o[24] = x8 >>> 0 & 255;
      o[25] = x8 >>> 8 & 255;
      o[26] = x8 >>> 16 & 255;
      o[27] = x8 >>> 24 & 255;
      o[28] = x9 >>> 0 & 255;
      o[29] = x9 >>> 8 & 255;
      o[30] = x9 >>> 16 & 255;
      o[31] = x9 >>> 24 & 255;
    }
    function crypto_core_salsa20(out, inp, k, c) {
      core_salsa20(out, inp, k, c);
    }
    function crypto_core_hsalsa20(out, inp, k, c) {
      core_hsalsa20(out, inp, k, c);
    }
    var sigma = new Uint8Array([
      101,
      120,
      112,
      97,
      110,
      100,
      32,
      51,
      50,
      45,
      98,
      121,
      116,
      101,
      32,
      107
    ]);
    function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
      var z2 = new Uint8Array(16), x = new Uint8Array(64);
      var u, i;
      for (i = 0; i < 16; i++) z2[i] = 0;
      for (i = 0; i < 8; i++) z2[i] = n[i];
      while (b >= 64) {
        crypto_core_salsa20(x, z2, k, sigma);
        for (i = 0; i < 64; i++) c[cpos + i] = m[mpos + i] ^ x[i];
        u = 1;
        for (i = 8; i < 16; i++) {
          u = u + (z2[i] & 255) | 0;
          z2[i] = u & 255;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
        mpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x, z2, k, sigma);
        for (i = 0; i < b; i++) c[cpos + i] = m[mpos + i] ^ x[i];
      }
      return 0;
    }
    function crypto_stream_salsa20(c, cpos, b, n, k) {
      var z2 = new Uint8Array(16), x = new Uint8Array(64);
      var u, i;
      for (i = 0; i < 16; i++) z2[i] = 0;
      for (i = 0; i < 8; i++) z2[i] = n[i];
      while (b >= 64) {
        crypto_core_salsa20(x, z2, k, sigma);
        for (i = 0; i < 64; i++) c[cpos + i] = x[i];
        u = 1;
        for (i = 8; i < 16; i++) {
          u = u + (z2[i] & 255) | 0;
          z2[i] = u & 255;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x, z2, k, sigma);
        for (i = 0; i < b; i++) c[cpos + i] = x[i];
      }
      return 0;
    }
    function crypto_stream(c, cpos, d, n, k) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s, n, k, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
      return crypto_stream_salsa20(c, cpos, d, sn, s);
    }
    function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s, n, k, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
      return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
    }
    var poly1305 = function(key) {
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.leftover = 0;
      this.fin = 0;
      var t0, t1, t2, t3, t4, t5, t6, t7;
      t0 = key[0] & 255 | (key[1] & 255) << 8;
      this.r[0] = t0 & 8191;
      t1 = key[2] & 255 | (key[3] & 255) << 8;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      t2 = key[4] & 255 | (key[5] & 255) << 8;
      this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      t3 = key[6] & 255 | (key[7] & 255) << 8;
      this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      t4 = key[8] & 255 | (key[9] & 255) << 8;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this.r[5] = t4 >>> 1 & 8190;
      t5 = key[10] & 255 | (key[11] & 255) << 8;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      t6 = key[12] & 255 | (key[13] & 255) << 8;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      t7 = key[14] & 255 | (key[15] & 255) << 8;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
      this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
      this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
      this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
      this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
      this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
      this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
      this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
    };
    poly1305.prototype.blocks = function(m, mpos, bytes$1) {
      var hibit = this.fin ? 0 : 2048;
      var t0, t1, t2, t3, t4, t5, t6, t7, c;
      var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
      var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
      var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
      while (bytes$1 >= 16) {
        t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
        h0 += t0 & 8191;
        t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
        h1 += (t0 >>> 13 | t1 << 3) & 8191;
        t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
        h2 += (t1 >>> 10 | t2 << 6) & 8191;
        t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
        h3 += (t2 >>> 7 | t3 << 9) & 8191;
        t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
        h4 += (t3 >>> 4 | t4 << 12) & 8191;
        h5 += t4 >>> 1 & 8191;
        t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
        h6 += (t4 >>> 14 | t5 << 2) & 8191;
        t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
        h7 += (t5 >>> 11 | t6 << 5) & 8191;
        t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
        h8 += (t6 >>> 8 | t7 << 8) & 8191;
        h9 += t7 >>> 5 | hibit;
        c = 0;
        d0 = c;
        d0 += h0 * r0;
        d0 += h1 * (5 * r9);
        d0 += h2 * (5 * r8);
        d0 += h3 * (5 * r7);
        d0 += h4 * (5 * r6);
        c = d0 >>> 13;
        d0 &= 8191;
        d0 += h5 * (5 * r5);
        d0 += h6 * (5 * r4);
        d0 += h7 * (5 * r3);
        d0 += h8 * (5 * r2);
        d0 += h9 * (5 * r1);
        c += d0 >>> 13;
        d0 &= 8191;
        d1 = c;
        d1 += h0 * r1;
        d1 += h1 * r0;
        d1 += h2 * (5 * r9);
        d1 += h3 * (5 * r8);
        d1 += h4 * (5 * r7);
        c = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6);
        d1 += h6 * (5 * r5);
        d1 += h7 * (5 * r4);
        d1 += h8 * (5 * r3);
        d1 += h9 * (5 * r2);
        c += d1 >>> 13;
        d1 &= 8191;
        d2 = c;
        d2 += h0 * r2;
        d2 += h1 * r1;
        d2 += h2 * r0;
        d2 += h3 * (5 * r9);
        d2 += h4 * (5 * r8);
        c = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7);
        d2 += h6 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h8 * (5 * r4);
        d2 += h9 * (5 * r3);
        c += d2 >>> 13;
        d2 &= 8191;
        d3 = c;
        d3 += h0 * r3;
        d3 += h1 * r2;
        d3 += h2 * r1;
        d3 += h3 * r0;
        d3 += h4 * (5 * r9);
        c = d3 >>> 13;
        d3 &= 8191;
        d3 += h5 * (5 * r8);
        d3 += h6 * (5 * r7);
        d3 += h7 * (5 * r6);
        d3 += h8 * (5 * r5);
        d3 += h9 * (5 * r4);
        c += d3 >>> 13;
        d3 &= 8191;
        d4 = c;
        d4 += h0 * r4;
        d4 += h1 * r3;
        d4 += h2 * r2;
        d4 += h3 * r1;
        d4 += h4 * r0;
        c = d4 >>> 13;
        d4 &= 8191;
        d4 += h5 * (5 * r9);
        d4 += h6 * (5 * r8);
        d4 += h7 * (5 * r7);
        d4 += h8 * (5 * r6);
        d4 += h9 * (5 * r5);
        c += d4 >>> 13;
        d4 &= 8191;
        d5 = c;
        d5 += h0 * r5;
        d5 += h1 * r4;
        d5 += h2 * r3;
        d5 += h3 * r2;
        d5 += h4 * r1;
        c = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r0;
        d5 += h6 * (5 * r9);
        d5 += h7 * (5 * r8);
        d5 += h8 * (5 * r7);
        d5 += h9 * (5 * r6);
        c += d5 >>> 13;
        d5 &= 8191;
        d6 = c;
        d6 += h0 * r6;
        d6 += h1 * r5;
        d6 += h2 * r4;
        d6 += h3 * r3;
        d6 += h4 * r2;
        c = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1;
        d6 += h6 * r0;
        d6 += h7 * (5 * r9);
        d6 += h8 * (5 * r8);
        d6 += h9 * (5 * r7);
        c += d6 >>> 13;
        d6 &= 8191;
        d7 = c;
        d7 += h0 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h3 * r4;
        d7 += h4 * r3;
        c = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r2;
        d7 += h6 * r1;
        d7 += h7 * r0;
        d7 += h8 * (5 * r9);
        d7 += h9 * (5 * r8);
        c += d7 >>> 13;
        d7 &= 8191;
        d8 = c;
        d8 += h0 * r8;
        d8 += h1 * r7;
        d8 += h2 * r6;
        d8 += h3 * r5;
        d8 += h4 * r4;
        c = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3;
        d8 += h6 * r2;
        d8 += h7 * r1;
        d8 += h8 * r0;
        d8 += h9 * (5 * r9);
        c += d8 >>> 13;
        d8 &= 8191;
        d9 = c;
        d9 += h0 * r9;
        d9 += h1 * r8;
        d9 += h2 * r7;
        d9 += h3 * r6;
        d9 += h4 * r5;
        c = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r4;
        d9 += h6 * r3;
        d9 += h7 * r2;
        d9 += h8 * r1;
        d9 += h9 * r0;
        c += d9 >>> 13;
        d9 &= 8191;
        c = (c << 2) + c | 0;
        c = c + d0 | 0;
        d0 = c & 8191;
        c = c >>> 13;
        d1 += c;
        h0 = d0;
        h1 = d1;
        h2 = d2;
        h3 = d3;
        h4 = d4;
        h5 = d5;
        h6 = d6;
        h7 = d7;
        h8 = d8;
        h9 = d9;
        mpos += 16;
        bytes$1 -= 16;
      }
      this.h[0] = h0;
      this.h[1] = h1;
      this.h[2] = h2;
      this.h[3] = h3;
      this.h[4] = h4;
      this.h[5] = h5;
      this.h[6] = h6;
      this.h[7] = h7;
      this.h[8] = h8;
      this.h[9] = h9;
    };
    poly1305.prototype.finish = function(mac, macpos) {
      var g = new Uint16Array(10);
      var c, mask$2, f, i;
      if (this.leftover) {
        i = this.leftover;
        this.buffer[i++] = 1;
        for (; i < 16; i++) this.buffer[i] = 0;
        this.fin = 1;
        this.blocks(this.buffer, 0, 16);
      }
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      for (i = 2; i < 10; i++) {
        this.h[i] += c;
        c = this.h[i] >>> 13;
        this.h[i] &= 8191;
      }
      this.h[0] += c * 5;
      c = this.h[0] >>> 13;
      this.h[0] &= 8191;
      this.h[1] += c;
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      this.h[2] += c;
      g[0] = this.h[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 8191;
      for (i = 1; i < 10; i++) {
        g[i] = this.h[i] + c;
        c = g[i] >>> 13;
        g[i] &= 8191;
      }
      g[9] -= 8192;
      mask$2 = (c ^ 1) - 1;
      for (i = 0; i < 10; i++) g[i] &= mask$2;
      mask$2 = ~mask$2;
      for (i = 0; i < 10; i++) this.h[i] = this.h[i] & mask$2 | g[i];
      this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
      this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
      this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
      this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
      this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
      this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
      this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
      this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
      f = this.h[0] + this.pad[0];
      this.h[0] = f & 65535;
      for (i = 1; i < 8; i++) {
        f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
        this.h[i] = f & 65535;
      }
      mac[macpos + 0] = this.h[0] >>> 0 & 255;
      mac[macpos + 1] = this.h[0] >>> 8 & 255;
      mac[macpos + 2] = this.h[1] >>> 0 & 255;
      mac[macpos + 3] = this.h[1] >>> 8 & 255;
      mac[macpos + 4] = this.h[2] >>> 0 & 255;
      mac[macpos + 5] = this.h[2] >>> 8 & 255;
      mac[macpos + 6] = this.h[3] >>> 0 & 255;
      mac[macpos + 7] = this.h[3] >>> 8 & 255;
      mac[macpos + 8] = this.h[4] >>> 0 & 255;
      mac[macpos + 9] = this.h[4] >>> 8 & 255;
      mac[macpos + 10] = this.h[5] >>> 0 & 255;
      mac[macpos + 11] = this.h[5] >>> 8 & 255;
      mac[macpos + 12] = this.h[6] >>> 0 & 255;
      mac[macpos + 13] = this.h[6] >>> 8 & 255;
      mac[macpos + 14] = this.h[7] >>> 0 & 255;
      mac[macpos + 15] = this.h[7] >>> 8 & 255;
    };
    poly1305.prototype.update = function(m, mpos, bytes$1) {
      var i, want;
      if (this.leftover) {
        want = 16 - this.leftover;
        if (want > bytes$1) want = bytes$1;
        for (i = 0; i < want; i++) this.buffer[this.leftover + i] = m[mpos + i];
        bytes$1 -= want;
        mpos += want;
        this.leftover += want;
        if (this.leftover < 16) return;
        this.blocks(this.buffer, 0, 16);
        this.leftover = 0;
      }
      if (bytes$1 >= 16) {
        want = bytes$1 - bytes$1 % 16;
        this.blocks(m, mpos, want);
        mpos += want;
        bytes$1 -= want;
      }
      if (bytes$1) {
        for (i = 0; i < bytes$1; i++) this.buffer[this.leftover + i] = m[mpos + i];
        this.leftover += bytes$1;
      }
    };
    function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
      var s = new poly1305(k);
      s.update(m, mpos, n);
      s.finish(out, outpos);
      return 0;
    }
    function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
      var x = new Uint8Array(16);
      crypto_onetimeauth(x, 0, m, mpos, n, k);
      return crypto_verify_16(h, hpos, x, 0);
    }
    function crypto_secretbox(c, m, d, n, k) {
      var i;
      if (d < 32) return -1;
      crypto_stream_xor(c, 0, m, 0, d, n, k);
      crypto_onetimeauth(c, 16, c, 32, d - 32, c);
      for (i = 0; i < 16; i++) c[i] = 0;
      return 0;
    }
    function crypto_secretbox_open(m, c, d, n, k) {
      var i;
      var x = new Uint8Array(32);
      if (d < 32) return -1;
      crypto_stream(x, 0, 32, n, k);
      if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;
      crypto_stream_xor(m, 0, c, 0, d, n, k);
      for (i = 0; i < 32; i++) m[i] = 0;
      return 0;
    }
    function set25519(r, a) {
      var i;
      for (i = 0; i < 16; i++) r[i] = a[i] | 0;
    }
    function car25519(o) {
      var i, v, c = 1;
      for (i = 0; i < 16; i++) {
        v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p, q, b) {
      var t, c = ~(b - 1);
      for (var i = 0; i < 16; i++) {
        t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
      }
    }
    function pack25519(o, n) {
      var i, j, b;
      var m = gf(), t = gf();
      for (i = 0; i < 16; i++) t[i] = n[i];
      car25519(t);
      car25519(t);
      car25519(t);
      for (j = 0; j < 2; j++) {
        m[0] = t[0] - 65517;
        for (i = 1; i < 15; i++) {
          m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        b = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b);
      }
      for (i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 255;
        o[2 * i + 1] = t[i] >> 8;
      }
    }
    function neq25519(a, b) {
      var c = new Uint8Array(32), d = new Uint8Array(32);
      pack25519(c, a);
      pack25519(d, b);
      return crypto_verify_32(c, 0, d, 0);
    }
    function par25519(a) {
      var d = new Uint8Array(32);
      pack25519(d, a);
      return d[0] & 1;
    }
    function unpack25519(o, n) {
      var i;
      for (i = 0; i < 16; i++) o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      o[15] &= 32767;
    }
    function A(o, a, b) {
      for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
    }
    function Z(o, a, b) {
      for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
    }
    function M(o, a, b) {
      var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function S(o, a) {
      M(o, a, a);
    }
    function inv25519(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; a++) c[a] = i[a];
      for (a = 253; a >= 0; a--) {
        S(c, c);
        if (a !== 2 && a !== 4) M(c, c, i);
      }
      for (a = 0; a < 16; a++) o[a] = c[a];
    }
    function pow2523(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; a++) c[a] = i[a];
      for (a = 250; a >= 0; a--) {
        S(c, c);
        if (a !== 1) M(c, c, i);
      }
      for (a = 0; a < 16; a++) o[a] = c[a];
    }
    function crypto_scalarmult(q, n, p) {
      var z2 = new Uint8Array(32);
      var x = new Float64Array(80), r, i;
      var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
      for (i = 0; i < 31; i++) z2[i] = n[i];
      z2[31] = n[31] & 127 | 64;
      z2[0] &= 248;
      unpack25519(x, p);
      for (i = 0; i < 16; i++) {
        b[i] = x[i];
        d[i] = a[i] = c[i] = 0;
      }
      a[0] = d[0] = 1;
      for (i = 254; i >= 0; --i) {
        r = z2[i >>> 3] >>> (i & 7) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        A(e, a, c);
        Z(a, a, c);
        A(c, b, d);
        Z(b, b, d);
        S(d, e);
        S(f, a);
        M(a, c, a);
        M(c, b, e);
        A(e, a, c);
        Z(a, a, c);
        S(b, a);
        Z(c, d, f);
        M(a, c, _121665);
        A(a, a, d);
        M(c, c, a);
        M(a, d, f);
        M(d, b, x);
        S(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
      }
      for (i = 0; i < 16; i++) {
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d[i];
      }
      var x32 = x.subarray(32);
      var x16 = x.subarray(16);
      inv25519(x32, x32);
      M(x16, x16, x32);
      pack25519(q, x16);
      return 0;
    }
    function crypto_scalarmult_base(q, n) {
      return crypto_scalarmult(q, n, _9);
    }
    function crypto_box_keypair(y, x) {
      randombytes(x, 32);
      return crypto_scalarmult_base(y, x);
    }
    function crypto_box_beforenm(k, y, x) {
      var s = new Uint8Array(32);
      crypto_scalarmult(s, x, y);
      return crypto_core_hsalsa20(k, _0, s, sigma);
    }
    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;
    function crypto_box(c, m, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_afternm(c, m, d, n, k);
    }
    function crypto_box_open(m, c, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_open_afternm(m, c, d, n, k);
    }
    var K$2 = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function crypto_hashblocks_hl(hh, hl, m, n) {
      var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
      var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var pos = 0;
      while (n >= 128) {
        for (i = 0; i < 16; i++) {
          j = 8 * i + pos;
          wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
          wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
        }
        for (i = 0; i < 80; i++) {
          bh0 = ah0;
          bh1 = ah1;
          bh2 = ah2;
          bh3 = ah3;
          bh4 = ah4;
          bh5 = ah5;
          bh6 = ah6;
          bh7 = ah7;
          bl0 = al0;
          bl1 = al1;
          bl2 = al2;
          bl3 = al3;
          bl4 = al4;
          bl5 = al5;
          bl6 = al6;
          bl7 = al7;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = (ah4 >>> 14 | al4 << 18) ^ (ah4 >>> 18 | al4 << 14) ^ (al4 >>> 9 | ah4 << 23);
          l = (al4 >>> 14 | ah4 << 18) ^ (al4 >>> 18 | ah4 << 14) ^ (ah4 >>> 9 | al4 << 23);
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = ah4 & ah5 ^ ~ah4 & ah6;
          l = al4 & al5 ^ ~al4 & al6;
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = K$2[i * 2];
          l = K$2[i * 2 + 1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = wh[i % 16];
          l = wl[i % 16];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          th = c & 65535 | d << 16;
          tl = a & 65535 | b << 16;
          h = th;
          l = tl;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = (ah0 >>> 28 | al0 << 4) ^ (al0 >>> 2 | ah0 << 30) ^ (al0 >>> 7 | ah0 << 25);
          l = (al0 >>> 28 | ah0 << 4) ^ (ah0 >>> 2 | al0 << 30) ^ (ah0 >>> 7 | al0 << 25);
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh7 = c & 65535 | d << 16;
          bl7 = a & 65535 | b << 16;
          h = bh3;
          l = bl3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = th;
          l = tl;
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh3 = c & 65535 | d << 16;
          bl3 = a & 65535 | b << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i % 16 === 15) for (j = 0; j < 16; j++) {
            h = wh[j];
            l = wl[j];
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = wh[(j + 9) % 16];
            l = wl[(j + 9) % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            th = wh[(j + 1) % 16];
            tl = wl[(j + 1) % 16];
            h = (th >>> 1 | tl << 31) ^ (th >>> 8 | tl << 24) ^ th >>> 7;
            l = (tl >>> 1 | th << 31) ^ (tl >>> 8 | th << 24) ^ (tl >>> 7 | th << 25);
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            th = wh[(j + 14) % 16];
            tl = wl[(j + 14) % 16];
            h = (th >>> 19 | tl << 13) ^ (tl >>> 29 | th << 3) ^ th >>> 6;
            l = (tl >>> 19 | th << 13) ^ (th >>> 29 | tl << 3) ^ (tl >>> 6 | th << 26);
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            wh[j] = c & 65535 | d << 16;
            wl[j] = a & 65535 | b << 16;
          }
        }
        h = ah0;
        l = al0;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[0];
        l = hl[0];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[0] = ah0 = c & 65535 | d << 16;
        hl[0] = al0 = a & 65535 | b << 16;
        h = ah1;
        l = al1;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[1];
        l = hl[1];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[1] = ah1 = c & 65535 | d << 16;
        hl[1] = al1 = a & 65535 | b << 16;
        h = ah2;
        l = al2;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[2];
        l = hl[2];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[2] = ah2 = c & 65535 | d << 16;
        hl[2] = al2 = a & 65535 | b << 16;
        h = ah3;
        l = al3;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[3];
        l = hl[3];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[3] = ah3 = c & 65535 | d << 16;
        hl[3] = al3 = a & 65535 | b << 16;
        h = ah4;
        l = al4;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[4];
        l = hl[4];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[4] = ah4 = c & 65535 | d << 16;
        hl[4] = al4 = a & 65535 | b << 16;
        h = ah5;
        l = al5;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[5];
        l = hl[5];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[5] = ah5 = c & 65535 | d << 16;
        hl[5] = al5 = a & 65535 | b << 16;
        h = ah6;
        l = al6;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[6];
        l = hl[6];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[6] = ah6 = c & 65535 | d << 16;
        hl[6] = al6 = a & 65535 | b << 16;
        h = ah7;
        l = al7;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[7];
        l = hl[7];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[7] = ah7 = c & 65535 | d << 16;
        hl[7] = al7 = a & 65535 | b << 16;
        pos += 128;
        n -= 128;
      }
      return n;
    }
    function crypto_hash(out, m, n) {
      var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
      hh[0] = 1779033703;
      hh[1] = 3144134277;
      hh[2] = 1013904242;
      hh[3] = 2773480762;
      hh[4] = 1359893119;
      hh[5] = 2600822924;
      hh[6] = 528734635;
      hh[7] = 1541459225;
      hl[0] = 4089235720;
      hl[1] = 2227873595;
      hl[2] = 4271175723;
      hl[3] = 1595750129;
      hl[4] = 2917565137;
      hl[5] = 725511199;
      hl[6] = 4215389547;
      hl[7] = 327033209;
      crypto_hashblocks_hl(hh, hl, m, n);
      n %= 128;
      for (i = 0; i < n; i++) x[i] = m[b - n + i];
      x[n] = 128;
      n = 256 - 128 * (n < 112 ? 1 : 0);
      x[n - 9] = 0;
      ts64(x, n - 8, b / 536870912 | 0, b << 3);
      crypto_hashblocks_hl(hh, hl, x, n);
      for (i = 0; i < 8; i++) ts64(out, 8 * i, hh[i], hl[i]);
      return 0;
    }
    function add$1(p, q) {
      var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
      Z(a, p[1], p[0]);
      Z(t, q[1], q[0]);
      M(a, a, t);
      A(b, p[0], p[1]);
      A(t, q[0], q[1]);
      M(b, b, t);
      M(c, p[3], q[3]);
      M(c, c, D2);
      M(d, p[2], q[2]);
      A(d, d, d);
      Z(e, b, a);
      Z(f, d, c);
      A(g, d, c);
      A(h, b, a);
      M(p[0], e, f);
      M(p[1], h, g);
      M(p[2], g, f);
      M(p[3], e, h);
    }
    function cswap(p, q, b) {
      var i;
      for (i = 0; i < 4; i++) sel25519(p[i], q[i], b);
    }
    function pack(r, p) {
      var tx2 = gf(), ty = gf(), zi = gf();
      inv25519(zi, p[2]);
      M(tx2, p[0], zi);
      M(ty, p[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx2) << 7;
    }
    function scalarmult(p, q, s) {
      var b, i;
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);
      for (i = 255; i >= 0; --i) {
        b = s[i / 8 | 0] >> (i & 7) & 1;
        cswap(p, q, b);
        add$1(q, p);
        add$1(p, p);
        cswap(p, q, b);
      }
    }
    function scalarbase(p, s) {
      var q = [
        gf(),
        gf(),
        gf(),
        gf()
      ];
      set25519(q[0], X);
      set25519(q[1], Y);
      set25519(q[2], gf1);
      M(q[3], X, Y);
      scalarmult(p, q, s);
    }
    function crypto_sign_keypair(pk, sk, seeded) {
      var d = new Uint8Array(64);
      var p = [
        gf(),
        gf(),
        gf(),
        gf()
      ];
      var i;
      if (!seeded) randombytes(sk, 32);
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      scalarbase(p, d);
      pack(pk, p);
      for (i = 0; i < 32; i++) sk[i + 32] = pk[i];
      return 0;
    }
    var L = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    function modL(r, x) {
      var carry, i, j, k;
      for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k = i - 12; j < k; ++j) {
          x[j] += carry - 16 * x[i] * L[j - (i - 32)];
          carry = Math.floor((x[j] + 128) / 256);
          x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
      }
      carry = 0;
      for (j = 0; j < 32; j++) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }
      for (j = 0; j < 32; j++) x[j] -= carry * L[j];
      for (i = 0; i < 32; i++) {
        x[i + 1] += x[i] >> 8;
        r[i] = x[i] & 255;
      }
    }
    function reduce(r) {
      var x = new Float64Array(64), i;
      for (i = 0; i < 64; i++) x[i] = r[i];
      for (i = 0; i < 64; i++) r[i] = 0;
      modL(r, x);
    }
    function crypto_sign(sm, m, n, sk) {
      var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
      var i, j, x = new Float64Array(64);
      var p = [
        gf(),
        gf(),
        gf(),
        gf()
      ];
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var smlen = n + 64;
      for (i = 0; i < n; i++) sm[64 + i] = m[i];
      for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];
      crypto_hash(r, sm.subarray(32), n + 32);
      reduce(r);
      scalarbase(p, r);
      pack(sm, p);
      for (i = 32; i < 64; i++) sm[i] = sk[i];
      crypto_hash(h, sm, n + 64);
      reduce(h);
      for (i = 0; i < 64; i++) x[i] = 0;
      for (i = 0; i < 32; i++) x[i] = r[i];
      for (i = 0; i < 32; i++) for (j = 0; j < 32; j++) x[i + j] += h[i] * d[j];
      modL(sm.subarray(32), x);
      return smlen;
    }
    function unpackneg(r, p) {
      var t = gf(), chk = gf(), num$1 = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r[2], gf1);
      unpack25519(r[1], p);
      S(num$1, r[1]);
      M(den, num$1, D);
      Z(num$1, num$1, r[2]);
      A(den, r[2], den);
      S(den2, den);
      S(den4, den2);
      M(den6, den4, den2);
      M(t, den6, num$1);
      M(t, t, den);
      pow2523(t, t);
      M(t, t, num$1);
      M(t, t, den);
      M(t, t, den);
      M(r[0], t, den);
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num$1)) M(r[0], r[0], I);
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num$1)) return -1;
      if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
      M(r[3], r[0], r[1]);
      return 0;
    }
    function crypto_sign_open(m, sm, n, pk) {
      var i;
      var t = new Uint8Array(32), h = new Uint8Array(64);
      var p = [
        gf(),
        gf(),
        gf(),
        gf()
      ], q = [
        gf(),
        gf(),
        gf(),
        gf()
      ];
      if (n < 64) return -1;
      if (unpackneg(q, pk)) return -1;
      for (i = 0; i < n; i++) m[i] = sm[i];
      for (i = 0; i < 32; i++) m[i + 32] = pk[i];
      crypto_hash(h, m, n);
      reduce(h);
      scalarmult(p, q, h);
      scalarbase(q, sm.subarray(32));
      add$1(p, q);
      pack(t, p);
      n -= 64;
      if (crypto_verify_32(sm, 0, t, 0)) {
        for (i = 0; i < n; i++) m[i] = 0;
        return -1;
      }
      for (i = 0; i < n; i++) m[i] = sm[i + 64];
      return n;
    }
    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
    nacl$2.lowlevel = {
      crypto_core_hsalsa20,
      crypto_stream_xor,
      crypto_stream,
      crypto_stream_salsa20_xor,
      crypto_stream_salsa20,
      crypto_onetimeauth,
      crypto_onetimeauth_verify,
      crypto_verify_16,
      crypto_verify_32,
      crypto_secretbox,
      crypto_secretbox_open,
      crypto_scalarmult,
      crypto_scalarmult_base,
      crypto_box_beforenm,
      crypto_box_afternm,
      crypto_box,
      crypto_box_open,
      crypto_box_keypair,
      crypto_hash,
      crypto_sign,
      crypto_sign_keypair,
      crypto_sign_open,
      crypto_secretbox_KEYBYTES,
      crypto_secretbox_NONCEBYTES,
      crypto_secretbox_ZEROBYTES,
      crypto_secretbox_BOXZEROBYTES,
      crypto_scalarmult_BYTES,
      crypto_scalarmult_SCALARBYTES,
      crypto_box_PUBLICKEYBYTES,
      crypto_box_SECRETKEYBYTES,
      crypto_box_BEFORENMBYTES,
      crypto_box_NONCEBYTES,
      crypto_box_ZEROBYTES,
      crypto_box_BOXZEROBYTES,
      crypto_sign_BYTES,
      crypto_sign_PUBLICKEYBYTES,
      crypto_sign_SECRETKEYBYTES,
      crypto_sign_SEEDBYTES,
      crypto_hash_BYTES,
      gf,
      D,
      L,
      pack25519,
      unpack25519,
      M,
      A,
      S,
      Z,
      pow2523,
      add: add$1,
      set25519,
      modL,
      scalarmult,
      scalarbase
    };
    function checkLengths(k, n) {
      if (k.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
      if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
    }
    function checkBoxLengths(pk, sk) {
      if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
      if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
    }
    function checkArrayTypes() {
      for (var i = 0; i < arguments.length; i++) if (!(arguments[i] instanceof Uint8Array)) throw new TypeError("unexpected type, use Uint8Array");
    }
    function cleanup(arr) {
      for (var i = 0; i < arr.length; i++) arr[i] = 0;
    }
    nacl$2.randomBytes = function(n) {
      var b = new Uint8Array(n);
      randombytes(b, n);
      return b;
    };
    nacl$2.secretbox = function(msg, nonce, key) {
      checkArrayTypes(msg, nonce, key);
      checkLengths(key, nonce);
      var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
      var c = new Uint8Array(m.length);
      for (var i = 0; i < msg.length; i++) m[i + crypto_secretbox_ZEROBYTES] = msg[i];
      crypto_secretbox(c, m, m.length, nonce, key);
      return c.subarray(crypto_secretbox_BOXZEROBYTES);
    };
    nacl$2.secretbox.open = function(box, nonce, key) {
      checkArrayTypes(box, nonce, key);
      checkLengths(key, nonce);
      var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
      var m = new Uint8Array(c.length);
      for (var i = 0; i < box.length; i++) c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
      if (c.length < 32) return null;
      if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
      return m.subarray(crypto_secretbox_ZEROBYTES);
    };
    nacl$2.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl$2.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl$2.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
    nacl$2.scalarMult = function(n, p) {
      checkArrayTypes(n, p);
      if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
      if (p.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
      var q = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult(q, n, p);
      return q;
    };
    nacl$2.scalarMult.base = function(n) {
      checkArrayTypes(n);
      if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
      var q = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult_base(q, n);
      return q;
    };
    nacl$2.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl$2.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
    nacl$2.box = function(msg, nonce, publicKey, secretKey) {
      var k = nacl$2.box.before(publicKey, secretKey);
      return nacl$2.secretbox(msg, nonce, k);
    };
    nacl$2.box.before = function(publicKey, secretKey) {
      checkArrayTypes(publicKey, secretKey);
      checkBoxLengths(publicKey, secretKey);
      var k = new Uint8Array(crypto_box_BEFORENMBYTES);
      crypto_box_beforenm(k, publicKey, secretKey);
      return k;
    };
    nacl$2.box.after = nacl$2.secretbox;
    nacl$2.box.open = function(msg, nonce, publicKey, secretKey) {
      var k = nacl$2.box.before(publicKey, secretKey);
      return nacl$2.secretbox.open(msg, nonce, k);
    };
    nacl$2.box.open.after = nacl$2.secretbox.open;
    nacl$2.box.keyPair = function() {
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
      crypto_box_keypair(pk, sk);
      return {
        publicKey: pk,
        secretKey: sk
      };
    };
    nacl$2.box.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      crypto_scalarmult_base(pk, secretKey);
      return {
        publicKey: pk,
        secretKey: new Uint8Array(secretKey)
      };
    };
    nacl$2.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl$2.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl$2.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl$2.box.nonceLength = crypto_box_NONCEBYTES;
    nacl$2.box.overheadLength = nacl$2.secretbox.overheadLength;
    nacl$2.sign = function(msg, secretKey) {
      checkArrayTypes(msg, secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error("bad secret key size");
      var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
      crypto_sign(signedMsg, msg, msg.length, secretKey);
      return signedMsg;
    };
    nacl$2.sign.open = function(signedMsg, publicKey) {
      checkArrayTypes(signedMsg, publicKey);
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error("bad public key size");
      var tmp = new Uint8Array(signedMsg.length);
      var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
      if (mlen < 0) return null;
      var m = new Uint8Array(mlen);
      for (var i = 0; i < m.length; i++) m[i] = tmp[i];
      return m;
    };
    nacl$2.sign.detached = function(msg, secretKey) {
      var signedMsg = nacl$2.sign(msg, secretKey);
      var sig = new Uint8Array(crypto_sign_BYTES);
      for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
      return sig;
    };
    nacl$2.sign.detached.verify = function(msg, sig, publicKey) {
      checkArrayTypes(msg, sig, publicKey);
      if (sig.length !== crypto_sign_BYTES) throw new Error("bad signature size");
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error("bad public key size");
      var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
      var m = new Uint8Array(crypto_sign_BYTES + msg.length);
      var i;
      for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
      for (i = 0; i < msg.length; i++) sm[i + crypto_sign_BYTES] = msg[i];
      return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
    };
    nacl$2.sign.keyPair = function() {
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      crypto_sign_keypair(pk, sk);
      return {
        publicKey: pk,
        secretKey: sk
      };
    };
    nacl$2.sign.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32 + i];
      return {
        publicKey: pk,
        secretKey: new Uint8Array(secretKey)
      };
    };
    nacl$2.sign.keyPair.fromSeed = function(seed) {
      checkArrayTypes(seed);
      if (seed.length !== crypto_sign_SEEDBYTES) throw new Error("bad seed size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      for (var i = 0; i < 32; i++) sk[i] = seed[i];
      crypto_sign_keypair(pk, sk, true);
      return {
        publicKey: pk,
        secretKey: sk
      };
    };
    nacl$2.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl$2.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl$2.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl$2.sign.signatureLength = crypto_sign_BYTES;
    nacl$2.hash = function(msg) {
      checkArrayTypes(msg);
      var h = new Uint8Array(crypto_hash_BYTES);
      crypto_hash(h, msg, msg.length);
      return h;
    };
    nacl$2.hash.hashLength = crypto_hash_BYTES;
    nacl$2.verify = function(x, y) {
      checkArrayTypes(x, y);
      if (x.length === 0 || y.length === 0) return false;
      if (x.length !== y.length) return false;
      return vn(x, 0, y, 0, x.length) === 0 ? true : false;
    };
    nacl$2.setPRNG = function(fn) {
      randombytes = fn;
    };
    (function() {
      var crypto$12 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
      if (crypto$12 && crypto$12.getRandomValues) {
        var QUOTA = 65536;
        nacl$2.setPRNG(function(x, n) {
          var i, v = new Uint8Array(n);
          for (i = 0; i < n; i += QUOTA) crypto$12.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
          for (i = 0; i < n; i++) x[i] = v[i];
          cleanup(v);
        });
      } else if (typeof __require$1 !== "undefined") {
        crypto$12 = require_tweetnacl();
        if (crypto$12 && crypto$12.randomBytes) nacl$2.setPRNG(function(x, n) {
          var i, v = crypto$12.randomBytes(n);
          for (i = 0; i < n; i++) x[i] = v[i];
          cleanup(v);
        });
      }
    })();
  })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
} });
function implicitAddressFromPublicKey$1(publicKey) {
  const key_without_prefix = publicKey.replace(/^ed25519:/, "");
  return encode$2$1(bs58Decode$1(key_without_prefix));
}
const NEAR_WALLET_TYPES = [
  "browser",
  "injected",
  "instant-link",
  "hardware",
  "bridge"
];
function looksLikeNearWallet(signer) {
  return signer !== null && typeof signer === "object" && "id" in signer && "metadata" in signer && "type" in signer && typeof signer.type === "string" && NEAR_WALLET_TYPES.includes(signer.type);
}
var KwilNonce = class {
  bytes;
  constructor(length = 32) {
    this.bytes = crypto.getRandomValues(new Uint8Array(length));
  }
  get clampUTF8() {
    return this.bytes.map((byte) => byte & 127);
  }
};
function createNearWalletSigner(wallet, recipient) {
  return async (message2) => {
    const messageString = typeof message2 === "string" ? message2 : decode$1$1(message2);
    if (!wallet.signMessage) throw new Error("Only wallets with signMessage are supported.");
    const nonceSuggestion = Buffer.from(new KwilNonce(32).bytes);
    const { nonce = nonceSuggestion, signature: signature2, callbackUrl } = await wallet.signMessage({
      message: messageString,
      recipient,
      nonce: nonceSuggestion
    });
    const nep413BorschSchema = { struct: {
      tag: "u32",
      message: "string",
      nonce: { array: {
        type: "u8",
        len: 32
      } },
      recipient: "string",
      callbackUrl: { option: "string" }
    } };
    const nep413BorshParams = {
      tag: 2147484061,
      message: messageString,
      nonce: Array.from(nonce),
      recipient,
      callbackUrl
    };
    const nep413BorshPayload = serialize$1(nep413BorschSchema, nep413BorshParams);
    return concat$1(writeUint16BE$1(nep413BorshPayload.length), nep413BorshPayload, decode$3(signature2));
  };
}
async function createNearWalletKwilSigner(wallet, currentAddress, store, kwilClient, recipient = "idos.network") {
  if (!wallet.signMessage) throw new Error("Only wallets with signMessage are supported.");
  if (wallet.id === "my-near-wallet") {
    const { accountId, signature: signature2, publicKey: publicKey$1, error } = Object.fromEntries(new URLSearchParams(window.location.hash.slice(1)).entries());
    if (signature2) {
      store.set("signer-address", accountId);
      store.set("signer-public-key", publicKey$1);
    }
    const signMessageOriginal = wallet.signMessage.bind(wallet);
    wallet.signMessage = async ({ message: message2, recipient: recipient$1 }) => {
      if (error) return Promise.reject();
      const lastMessage = store.get("sign-last-message");
      if (signature2 && message2 === lastMessage) {
        const nonce$1 = Buffer.from(store.get("sign-last-nonce"));
        const callbackUrl$1 = store.get("sign-last-url");
        return Promise.resolve({
          accountId: currentAddress,
          publicKey: publicKey$1,
          signature: signature2,
          nonce: nonce$1,
          message: message2,
          callbackUrl: callbackUrl$1
        });
      }
      const callbackUrl = window.location.href;
      const nonce = Buffer.from(new KwilNonce(32).clampUTF8);
      store.set("sign-last-message", message2);
      store.set("sign-last-nonce", Array.from(nonce));
      store.set("sign-last-url", callbackUrl);
      signMessageOriginal({
        message: message2,
        nonce,
        recipient: recipient$1,
        callbackUrl
      });
      return new Promise(() => ({}));
    };
  }
  const storedAddress = store.get("signer-address");
  let publicKey = store.get("signer-public-key");
  if (storedAddress !== currentAddress || !publicKey) {
    store.reset();
    await kwilClient.client.auth.logoutKGW();
    const message2 = "idOS authentication";
    const nonce = Buffer.from(new KwilNonce(32).bytes);
    ({ publicKey } = await wallet.signMessage({
      message: message2,
      recipient,
      nonce
    }));
    store.set("signer-address", currentAddress);
    store.set("signer-public-key", publicKey);
  }
  const signer = createNearWalletSigner(wallet, recipient);
  return new distExports.KwilSigner(signer, implicitAddressFromPublicKey$1(publicKey), "nep413");
}
var require_eventemitter3 = __commonJS$1({ "../../node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js"(exports, module) {
  var has2 = Object.prototype.hasOwnProperty, prefix2 = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__) prefix2 = false;
  }
  function EE2(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") throw new TypeError("The listener must be a function");
    var listener = new EE2(fn, context || emitter, once), evt = prefix2 ? prefix2 + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
  }
  function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0) return names;
    for (name in events = this._events) if (has2.call(events, name)) names.push(prefix2 ? name.slice(1) : name);
    if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));
    return names;
  };
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) ee[i] = handlers[i].fn;
    return ee;
  };
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix2 ? prefix2 + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) args[i - 1] = arguments[i];
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) args[j - 1] = arguments[j];
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix2 ? prefix2 + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) clearEvent(this, evt);
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) events.push(listeners[i]);
      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
      else clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix2 ? prefix2 + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix2;
  EventEmitter.EventEmitter = EventEmitter;
  if ("undefined" !== typeof module) module.exports = EventEmitter;
} });
var require_errors = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/errors.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XRPLFaucetError = exports.NotFoundError = exports.ValidationError = exports.ResponseFormatError = exports.TimeoutError = exports.RippledNotInitializedError = exports.DisconnectedError = exports.NotConnectedError = exports.RippledError = exports.ConnectionError = exports.UnexpectedError = exports.XrplError = void 0;
  var XrplError = class extends Error {
    constructor(message2 = "", data2) {
      super(message2);
      this.name = this.constructor.name;
      this.message = message2;
      this.data = data2;
      if (Error.captureStackTrace != null) Error.captureStackTrace(this, this.constructor);
    }
    toString() {
      let result = `[${this.name}(${this.message}`;
      if (this.data) result += `, ${JSON.stringify(this.data)}`;
      result += ")]";
      return result;
    }
    inspect() {
      return this.toString();
    }
  };
  exports.XrplError = XrplError;
  var RippledError = class extends XrplError {
  };
  exports.RippledError = RippledError;
  var UnexpectedError = class extends XrplError {
  };
  exports.UnexpectedError = UnexpectedError;
  var ConnectionError = class extends XrplError {
  };
  exports.ConnectionError = ConnectionError;
  var NotConnectedError = class extends ConnectionError {
  };
  exports.NotConnectedError = NotConnectedError;
  var DisconnectedError = class extends ConnectionError {
  };
  exports.DisconnectedError = DisconnectedError;
  var RippledNotInitializedError = class extends ConnectionError {
  };
  exports.RippledNotInitializedError = RippledNotInitializedError;
  var TimeoutError = class extends ConnectionError {
  };
  exports.TimeoutError = TimeoutError;
  var ResponseFormatError = class extends ConnectionError {
  };
  exports.ResponseFormatError = ResponseFormatError;
  var ValidationError = class extends XrplError {
  };
  exports.ValidationError = ValidationError;
  var XRPLFaucetError = class extends XrplError {
  };
  exports.XRPLFaucetError = XRPLFaucetError;
  var NotFoundError = class extends XrplError {
    constructor(message2 = "Not found") {
      super(message2);
    }
  };
  exports.NotFoundError = NotFoundError;
} });
var require_common$1 = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/common/index.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_API_VERSION = exports.RIPPLED_API_V2 = exports.RIPPLED_API_V1 = void 0;
  exports.RIPPLED_API_V1 = 1;
  exports.RIPPLED_API_V2 = 2;
  exports.DEFAULT_API_VERSION = exports.RIPPLED_API_V2;
} });
var require_AccountRoot = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/AccountRoot.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AccountRootFlags = void 0;
  var AccountRootFlags;
  (function(AccountRootFlags$1) {
    AccountRootFlags$1[AccountRootFlags$1["lsfPasswordSpent"] = 65536] = "lsfPasswordSpent";
    AccountRootFlags$1[AccountRootFlags$1["lsfRequireDestTag"] = 131072] = "lsfRequireDestTag";
    AccountRootFlags$1[AccountRootFlags$1["lsfRequireAuth"] = 262144] = "lsfRequireAuth";
    AccountRootFlags$1[AccountRootFlags$1["lsfDisallowXRP"] = 524288] = "lsfDisallowXRP";
    AccountRootFlags$1[AccountRootFlags$1["lsfDisableMaster"] = 1048576] = "lsfDisableMaster";
    AccountRootFlags$1[AccountRootFlags$1["lsfNoFreeze"] = 2097152] = "lsfNoFreeze";
    AccountRootFlags$1[AccountRootFlags$1["lsfGlobalFreeze"] = 4194304] = "lsfGlobalFreeze";
    AccountRootFlags$1[AccountRootFlags$1["lsfDefaultRipple"] = 8388608] = "lsfDefaultRipple";
    AccountRootFlags$1[AccountRootFlags$1["lsfDepositAuth"] = 16777216] = "lsfDepositAuth";
    AccountRootFlags$1[AccountRootFlags$1["lsfAMM"] = 33554432] = "lsfAMM";
    AccountRootFlags$1[AccountRootFlags$1["lsfDisallowIncomingNFTokenOffer"] = 67108864] = "lsfDisallowIncomingNFTokenOffer";
    AccountRootFlags$1[AccountRootFlags$1["lsfDisallowIncomingCheck"] = 134217728] = "lsfDisallowIncomingCheck";
    AccountRootFlags$1[AccountRootFlags$1["lsfDisallowIncomingPayChan"] = 268435456] = "lsfDisallowIncomingPayChan";
    AccountRootFlags$1[AccountRootFlags$1["lsfDisallowIncomingTrustline"] = 536870912] = "lsfDisallowIncomingTrustline";
    AccountRootFlags$1[AccountRootFlags$1["lsfAllowTrustLineClawback"] = 2147483648] = "lsfAllowTrustLineClawback";
  })(AccountRootFlags || (exports.AccountRootFlags = AccountRootFlags = {}));
} });
var require_definitions = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/enums/definitions.json"(exports, module) {
  module.exports = {
    "FIELDS": [
      ["Generic", {
        "isSerialized": false,
        "isSigningField": false,
        "isVLEncoded": false,
        "nth": 0,
        "type": "Unknown"
      }],
      ["Invalid", {
        "isSerialized": false,
        "isSigningField": false,
        "isVLEncoded": false,
        "nth": -1,
        "type": "Unknown"
      }],
      ["ObjectEndMarker", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 1,
        "type": "STObject"
      }],
      ["ArrayEndMarker", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 1,
        "type": "STArray"
      }],
      ["taker_gets_funded", {
        "isSerialized": false,
        "isSigningField": false,
        "isVLEncoded": false,
        "nth": 258,
        "type": "Amount"
      }],
      ["taker_pays_funded", {
        "isSerialized": false,
        "isSigningField": false,
        "isVLEncoded": false,
        "nth": 259,
        "type": "Amount"
      }],
      ["LedgerEntryType", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 1,
        "type": "UInt16"
      }],
      ["TransactionType", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 2,
        "type": "UInt16"
      }],
      ["SignerWeight", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 3,
        "type": "UInt16"
      }],
      ["TransferFee", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 4,
        "type": "UInt16"
      }],
      ["TradingFee", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 5,
        "type": "UInt16"
      }],
      ["DiscountedFee", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 6,
        "type": "UInt16"
      }],
      ["Version", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 16,
        "type": "UInt16"
      }],
      ["HookStateChangeCount", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 17,
        "type": "UInt16"
      }],
      ["HookEmitCount", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 18,
        "type": "UInt16"
      }],
      ["HookExecutionIndex", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 19,
        "type": "UInt16"
      }],
      ["HookApiVersion", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 20,
        "type": "UInt16"
      }],
      ["LedgerFixType", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 21,
        "type": "UInt16"
      }],
      ["NetworkID", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 1,
        "type": "UInt32"
      }],
      ["Flags", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 2,
        "type": "UInt32"
      }],
      ["SourceTag", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 3,
        "type": "UInt32"
      }],
      ["Sequence", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 4,
        "type": "UInt32"
      }],
      ["PreviousTxnLgrSeq", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 5,
        "type": "UInt32"
      }],
      ["LedgerSequence", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 6,
        "type": "UInt32"
      }],
      ["CloseTime", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 7,
        "type": "UInt32"
      }],
      ["ParentCloseTime", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 8,
        "type": "UInt32"
      }],
      ["SigningTime", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 9,
        "type": "UInt32"
      }],
      ["Expiration", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 10,
        "type": "UInt32"
      }],
      ["TransferRate", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 11,
        "type": "UInt32"
      }],
      ["WalletSize", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 12,
        "type": "UInt32"
      }],
      ["OwnerCount", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 13,
        "type": "UInt32"
      }],
      ["DestinationTag", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 14,
        "type": "UInt32"
      }],
      ["LastUpdateTime", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 15,
        "type": "UInt32"
      }],
      ["HighQualityIn", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 16,
        "type": "UInt32"
      }],
      ["HighQualityOut", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 17,
        "type": "UInt32"
      }],
      ["LowQualityIn", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 18,
        "type": "UInt32"
      }],
      ["LowQualityOut", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 19,
        "type": "UInt32"
      }],
      ["QualityIn", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 20,
        "type": "UInt32"
      }],
      ["QualityOut", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 21,
        "type": "UInt32"
      }],
      ["StampEscrow", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 22,
        "type": "UInt32"
      }],
      ["BondAmount", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 23,
        "type": "UInt32"
      }],
      ["LoadFee", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 24,
        "type": "UInt32"
      }],
      ["OfferSequence", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 25,
        "type": "UInt32"
      }],
      ["FirstLedgerSequence", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 26,
        "type": "UInt32"
      }],
      ["LastLedgerSequence", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 27,
        "type": "UInt32"
      }],
      ["TransactionIndex", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 28,
        "type": "UInt32"
      }],
      ["OperationLimit", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 29,
        "type": "UInt32"
      }],
      ["ReferenceFeeUnits", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 30,
        "type": "UInt32"
      }],
      ["ReserveBase", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 31,
        "type": "UInt32"
      }],
      ["ReserveIncrement", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 32,
        "type": "UInt32"
      }],
      ["SetFlag", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 33,
        "type": "UInt32"
      }],
      ["ClearFlag", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 34,
        "type": "UInt32"
      }],
      ["SignerQuorum", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 35,
        "type": "UInt32"
      }],
      ["CancelAfter", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 36,
        "type": "UInt32"
      }],
      ["FinishAfter", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 37,
        "type": "UInt32"
      }],
      ["SignerListID", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 38,
        "type": "UInt32"
      }],
      ["SettleDelay", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 39,
        "type": "UInt32"
      }],
      ["TicketCount", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 40,
        "type": "UInt32"
      }],
      ["TicketSequence", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 41,
        "type": "UInt32"
      }],
      ["NFTokenTaxon", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 42,
        "type": "UInt32"
      }],
      ["MintedNFTokens", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 43,
        "type": "UInt32"
      }],
      ["BurnedNFTokens", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 44,
        "type": "UInt32"
      }],
      ["HookStateCount", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 45,
        "type": "UInt32"
      }],
      ["EmitGeneration", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 46,
        "type": "UInt32"
      }],
      ["VoteWeight", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 48,
        "type": "UInt32"
      }],
      ["FirstNFTokenSequence", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 50,
        "type": "UInt32"
      }],
      ["OracleDocumentID", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 51,
        "type": "UInt32"
      }],
      ["PermissionValue", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 52,
        "type": "UInt32"
      }],
      ["IndexNext", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 1,
        "type": "UInt64"
      }],
      ["IndexPrevious", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 2,
        "type": "UInt64"
      }],
      ["BookNode", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 3,
        "type": "UInt64"
      }],
      ["OwnerNode", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 4,
        "type": "UInt64"
      }],
      ["BaseFee", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 5,
        "type": "UInt64"
      }],
      ["ExchangeRate", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 6,
        "type": "UInt64"
      }],
      ["LowNode", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 7,
        "type": "UInt64"
      }],
      ["HighNode", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 8,
        "type": "UInt64"
      }],
      ["DestinationNode", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 9,
        "type": "UInt64"
      }],
      ["Cookie", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 10,
        "type": "UInt64"
      }],
      ["ServerVersion", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 11,
        "type": "UInt64"
      }],
      ["NFTokenOfferNode", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 12,
        "type": "UInt64"
      }],
      ["EmitBurden", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 13,
        "type": "UInt64"
      }],
      ["HookOn", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 16,
        "type": "UInt64"
      }],
      ["HookInstructionCount", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 17,
        "type": "UInt64"
      }],
      ["HookReturnCode", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 18,
        "type": "UInt64"
      }],
      ["ReferenceCount", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 19,
        "type": "UInt64"
      }],
      ["XChainClaimID", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 20,
        "type": "UInt64"
      }],
      ["XChainAccountCreateCount", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 21,
        "type": "UInt64"
      }],
      ["XChainAccountClaimCount", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 22,
        "type": "UInt64"
      }],
      ["AssetPrice", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 23,
        "type": "UInt64"
      }],
      ["MaximumAmount", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 24,
        "type": "UInt64"
      }],
      ["OutstandingAmount", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 25,
        "type": "UInt64"
      }],
      ["MPTAmount", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 26,
        "type": "UInt64"
      }],
      ["IssuerNode", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 27,
        "type": "UInt64"
      }],
      ["SubjectNode", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 28,
        "type": "UInt64"
      }],
      ["LockedAmount", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 29,
        "type": "UInt64"
      }],
      ["EmailHash", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 1,
        "type": "Hash128"
      }],
      ["LedgerHash", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 1,
        "type": "Hash256"
      }],
      ["ParentHash", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 2,
        "type": "Hash256"
      }],
      ["TransactionHash", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 3,
        "type": "Hash256"
      }],
      ["AccountHash", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 4,
        "type": "Hash256"
      }],
      ["PreviousTxnID", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 5,
        "type": "Hash256"
      }],
      ["LedgerIndex", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 6,
        "type": "Hash256"
      }],
      ["WalletLocator", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 7,
        "type": "Hash256"
      }],
      ["RootIndex", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 8,
        "type": "Hash256"
      }],
      ["AccountTxnID", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 9,
        "type": "Hash256"
      }],
      ["NFTokenID", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 10,
        "type": "Hash256"
      }],
      ["EmitParentTxnID", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 11,
        "type": "Hash256"
      }],
      ["EmitNonce", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 12,
        "type": "Hash256"
      }],
      ["EmitHookHash", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 13,
        "type": "Hash256"
      }],
      ["AMMID", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 14,
        "type": "Hash256"
      }],
      ["BookDirectory", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 16,
        "type": "Hash256"
      }],
      ["InvoiceID", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 17,
        "type": "Hash256"
      }],
      ["Nickname", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 18,
        "type": "Hash256"
      }],
      ["Amendment", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 19,
        "type": "Hash256"
      }],
      ["Digest", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 21,
        "type": "Hash256"
      }],
      ["Channel", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 22,
        "type": "Hash256"
      }],
      ["ConsensusHash", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 23,
        "type": "Hash256"
      }],
      ["CheckID", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 24,
        "type": "Hash256"
      }],
      ["ValidatedHash", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 25,
        "type": "Hash256"
      }],
      ["PreviousPageMin", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 26,
        "type": "Hash256"
      }],
      ["NextPageMin", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 27,
        "type": "Hash256"
      }],
      ["NFTokenBuyOffer", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 28,
        "type": "Hash256"
      }],
      ["NFTokenSellOffer", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 29,
        "type": "Hash256"
      }],
      ["HookStateKey", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 30,
        "type": "Hash256"
      }],
      ["HookHash", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 31,
        "type": "Hash256"
      }],
      ["HookNamespace", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 32,
        "type": "Hash256"
      }],
      ["HookSetTxnID", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 33,
        "type": "Hash256"
      }],
      ["DomainID", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 34,
        "type": "Hash256"
      }],
      ["VaultID", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 35,
        "type": "Hash256"
      }],
      ["ParentBatchID", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 36,
        "type": "Hash256"
      }],
      ["hash", {
        "isSerialized": false,
        "isSigningField": false,
        "isVLEncoded": false,
        "nth": 257,
        "type": "Hash256"
      }],
      ["index", {
        "isSerialized": false,
        "isSigningField": false,
        "isVLEncoded": false,
        "nth": 258,
        "type": "Hash256"
      }],
      ["Amount", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 1,
        "type": "Amount"
      }],
      ["Balance", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 2,
        "type": "Amount"
      }],
      ["LimitAmount", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 3,
        "type": "Amount"
      }],
      ["TakerPays", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 4,
        "type": "Amount"
      }],
      ["TakerGets", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 5,
        "type": "Amount"
      }],
      ["LowLimit", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 6,
        "type": "Amount"
      }],
      ["HighLimit", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 7,
        "type": "Amount"
      }],
      ["Fee", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 8,
        "type": "Amount"
      }],
      ["SendMax", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 9,
        "type": "Amount"
      }],
      ["DeliverMin", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 10,
        "type": "Amount"
      }],
      ["Amount2", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 11,
        "type": "Amount"
      }],
      ["BidMin", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 12,
        "type": "Amount"
      }],
      ["BidMax", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 13,
        "type": "Amount"
      }],
      ["MinimumOffer", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 16,
        "type": "Amount"
      }],
      ["RippleEscrow", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 17,
        "type": "Amount"
      }],
      ["DeliveredAmount", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 18,
        "type": "Amount"
      }],
      ["NFTokenBrokerFee", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 19,
        "type": "Amount"
      }],
      ["BaseFeeDrops", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 22,
        "type": "Amount"
      }],
      ["ReserveBaseDrops", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 23,
        "type": "Amount"
      }],
      ["ReserveIncrementDrops", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 24,
        "type": "Amount"
      }],
      ["LPTokenOut", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 25,
        "type": "Amount"
      }],
      ["LPTokenIn", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 26,
        "type": "Amount"
      }],
      ["EPrice", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 27,
        "type": "Amount"
      }],
      ["Price", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 28,
        "type": "Amount"
      }],
      ["SignatureReward", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 29,
        "type": "Amount"
      }],
      ["MinAccountCreateAmount", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 30,
        "type": "Amount"
      }],
      ["LPTokenBalance", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 31,
        "type": "Amount"
      }],
      ["PublicKey", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 1,
        "type": "Blob"
      }],
      ["MessageKey", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 2,
        "type": "Blob"
      }],
      ["SigningPubKey", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 3,
        "type": "Blob"
      }],
      ["TxnSignature", {
        "isSerialized": true,
        "isSigningField": false,
        "isVLEncoded": true,
        "nth": 4,
        "type": "Blob"
      }],
      ["URI", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 5,
        "type": "Blob"
      }],
      ["Signature", {
        "isSerialized": true,
        "isSigningField": false,
        "isVLEncoded": true,
        "nth": 6,
        "type": "Blob"
      }],
      ["Domain", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 7,
        "type": "Blob"
      }],
      ["FundCode", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 8,
        "type": "Blob"
      }],
      ["RemoveCode", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 9,
        "type": "Blob"
      }],
      ["ExpireCode", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 10,
        "type": "Blob"
      }],
      ["CreateCode", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 11,
        "type": "Blob"
      }],
      ["MemoType", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 12,
        "type": "Blob"
      }],
      ["MemoData", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 13,
        "type": "Blob"
      }],
      ["MemoFormat", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 14,
        "type": "Blob"
      }],
      ["Fulfillment", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 16,
        "type": "Blob"
      }],
      ["Condition", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 17,
        "type": "Blob"
      }],
      ["MasterSignature", {
        "isSerialized": true,
        "isSigningField": false,
        "isVLEncoded": true,
        "nth": 18,
        "type": "Blob"
      }],
      ["UNLModifyValidator", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 19,
        "type": "Blob"
      }],
      ["ValidatorToDisable", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 20,
        "type": "Blob"
      }],
      ["ValidatorToReEnable", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 21,
        "type": "Blob"
      }],
      ["HookStateData", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 22,
        "type": "Blob"
      }],
      ["HookReturnString", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 23,
        "type": "Blob"
      }],
      ["HookParameterName", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 24,
        "type": "Blob"
      }],
      ["HookParameterValue", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 25,
        "type": "Blob"
      }],
      ["DIDDocument", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 26,
        "type": "Blob"
      }],
      ["Data", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 27,
        "type": "Blob"
      }],
      ["AssetClass", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 28,
        "type": "Blob"
      }],
      ["Provider", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 29,
        "type": "Blob"
      }],
      ["MPTokenMetadata", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 30,
        "type": "Blob"
      }],
      ["CredentialType", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 31,
        "type": "Blob"
      }],
      ["Account", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 1,
        "type": "AccountID"
      }],
      ["Owner", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 2,
        "type": "AccountID"
      }],
      ["Destination", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 3,
        "type": "AccountID"
      }],
      ["Issuer", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 4,
        "type": "AccountID"
      }],
      ["Authorize", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 5,
        "type": "AccountID"
      }],
      ["Unauthorize", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 6,
        "type": "AccountID"
      }],
      ["RegularKey", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 8,
        "type": "AccountID"
      }],
      ["NFTokenMinter", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 9,
        "type": "AccountID"
      }],
      ["EmitCallback", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 10,
        "type": "AccountID"
      }],
      ["Holder", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 11,
        "type": "AccountID"
      }],
      ["Delegate", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 12,
        "type": "AccountID"
      }],
      ["HookAccount", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 16,
        "type": "AccountID"
      }],
      ["OtherChainSource", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 18,
        "type": "AccountID"
      }],
      ["OtherChainDestination", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 19,
        "type": "AccountID"
      }],
      ["AttestationSignerAccount", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 20,
        "type": "AccountID"
      }],
      ["AttestationRewardAccount", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 21,
        "type": "AccountID"
      }],
      ["LockingChainDoor", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 22,
        "type": "AccountID"
      }],
      ["IssuingChainDoor", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 23,
        "type": "AccountID"
      }],
      ["Subject", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 24,
        "type": "AccountID"
      }],
      ["Number", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 1,
        "type": "Number"
      }],
      ["AssetsAvailable", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 2,
        "type": "Number"
      }],
      ["AssetsMaximum", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 3,
        "type": "Number"
      }],
      ["AssetsTotal", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 4,
        "type": "Number"
      }],
      ["LossUnrealized", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 5,
        "type": "Number"
      }],
      ["TransactionMetaData", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 2,
        "type": "STObject"
      }],
      ["CreatedNode", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 3,
        "type": "STObject"
      }],
      ["DeletedNode", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 4,
        "type": "STObject"
      }],
      ["ModifiedNode", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 5,
        "type": "STObject"
      }],
      ["PreviousFields", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 6,
        "type": "STObject"
      }],
      ["FinalFields", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 7,
        "type": "STObject"
      }],
      ["NewFields", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 8,
        "type": "STObject"
      }],
      ["TemplateEntry", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 9,
        "type": "STObject"
      }],
      ["Memo", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 10,
        "type": "STObject"
      }],
      ["SignerEntry", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 11,
        "type": "STObject"
      }],
      ["NFToken", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 12,
        "type": "STObject"
      }],
      ["EmitDetails", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 13,
        "type": "STObject"
      }],
      ["Hook", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 14,
        "type": "STObject"
      }],
      ["Permission", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 15,
        "type": "STObject"
      }],
      ["Signer", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 16,
        "type": "STObject"
      }],
      ["Majority", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 18,
        "type": "STObject"
      }],
      ["DisabledValidator", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 19,
        "type": "STObject"
      }],
      ["EmittedTxn", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 20,
        "type": "STObject"
      }],
      ["HookExecution", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 21,
        "type": "STObject"
      }],
      ["HookDefinition", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 22,
        "type": "STObject"
      }],
      ["HookParameter", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 23,
        "type": "STObject"
      }],
      ["HookGrant", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 24,
        "type": "STObject"
      }],
      ["VoteEntry", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 25,
        "type": "STObject"
      }],
      ["AuctionSlot", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 26,
        "type": "STObject"
      }],
      ["AuthAccount", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 27,
        "type": "STObject"
      }],
      ["XChainClaimProofSig", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 28,
        "type": "STObject"
      }],
      ["XChainCreateAccountProofSig", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 29,
        "type": "STObject"
      }],
      ["XChainClaimAttestationCollectionElement", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 30,
        "type": "STObject"
      }],
      ["XChainCreateAccountAttestationCollectionElement", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 31,
        "type": "STObject"
      }],
      ["PriceData", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 32,
        "type": "STObject"
      }],
      ["Credential", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 33,
        "type": "STObject"
      }],
      ["RawTransaction", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 34,
        "type": "STObject"
      }],
      ["BatchSigner", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 35,
        "type": "STObject"
      }],
      ["Book", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 36,
        "type": "STObject"
      }],
      ["Signers", {
        "isSerialized": true,
        "isSigningField": false,
        "isVLEncoded": false,
        "nth": 3,
        "type": "STArray"
      }],
      ["SignerEntries", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 4,
        "type": "STArray"
      }],
      ["Template", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 5,
        "type": "STArray"
      }],
      ["Necessary", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 6,
        "type": "STArray"
      }],
      ["Sufficient", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 7,
        "type": "STArray"
      }],
      ["AffectedNodes", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 8,
        "type": "STArray"
      }],
      ["Memos", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 9,
        "type": "STArray"
      }],
      ["NFTokens", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 10,
        "type": "STArray"
      }],
      ["Hooks", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 11,
        "type": "STArray"
      }],
      ["VoteSlots", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 12,
        "type": "STArray"
      }],
      ["AdditionalBooks", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 13,
        "type": "STArray"
      }],
      ["Majorities", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 16,
        "type": "STArray"
      }],
      ["DisabledValidators", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 17,
        "type": "STArray"
      }],
      ["HookExecutions", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 18,
        "type": "STArray"
      }],
      ["HookParameters", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 19,
        "type": "STArray"
      }],
      ["HookGrants", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 20,
        "type": "STArray"
      }],
      ["XChainClaimAttestations", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 21,
        "type": "STArray"
      }],
      ["XChainCreateAccountAttestations", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 22,
        "type": "STArray"
      }],
      ["PriceDataSeries", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 24,
        "type": "STArray"
      }],
      ["AuthAccounts", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 25,
        "type": "STArray"
      }],
      ["AuthorizeCredentials", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 26,
        "type": "STArray"
      }],
      ["UnauthorizeCredentials", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 27,
        "type": "STArray"
      }],
      ["AcceptedCredentials", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 28,
        "type": "STArray"
      }],
      ["Permissions", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 29,
        "type": "STArray"
      }],
      ["RawTransactions", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 30,
        "type": "STArray"
      }],
      ["BatchSigners", {
        "isSerialized": true,
        "isSigningField": false,
        "isVLEncoded": false,
        "nth": 31,
        "type": "STArray"
      }],
      ["CloseResolution", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 1,
        "type": "UInt8"
      }],
      ["Method", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 2,
        "type": "UInt8"
      }],
      ["TransactionResult", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 3,
        "type": "UInt8"
      }],
      ["Scale", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 4,
        "type": "UInt8"
      }],
      ["AssetScale", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 5,
        "type": "UInt8"
      }],
      ["TickSize", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 16,
        "type": "UInt8"
      }],
      ["UNLModifyDisabling", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 17,
        "type": "UInt8"
      }],
      ["HookResult", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 18,
        "type": "UInt8"
      }],
      ["WasLockingChainSend", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 19,
        "type": "UInt8"
      }],
      ["WithdrawalPolicy", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 20,
        "type": "UInt8"
      }],
      ["TakerPaysCurrency", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 1,
        "type": "Hash160"
      }],
      ["TakerPaysIssuer", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 2,
        "type": "Hash160"
      }],
      ["TakerGetsCurrency", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 3,
        "type": "Hash160"
      }],
      ["TakerGetsIssuer", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 4,
        "type": "Hash160"
      }],
      ["Paths", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 1,
        "type": "PathSet"
      }],
      ["Indexes", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 1,
        "type": "Vector256"
      }],
      ["Hashes", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 2,
        "type": "Vector256"
      }],
      ["Amendments", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 3,
        "type": "Vector256"
      }],
      ["NFTokenOffers", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 4,
        "type": "Vector256"
      }],
      ["CredentialIDs", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": true,
        "nth": 5,
        "type": "Vector256"
      }],
      ["MPTokenIssuanceID", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 1,
        "type": "Hash192"
      }],
      ["ShareMPTID", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 2,
        "type": "Hash192"
      }],
      ["LockingChainIssue", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 1,
        "type": "Issue"
      }],
      ["IssuingChainIssue", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 2,
        "type": "Issue"
      }],
      ["Asset", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 3,
        "type": "Issue"
      }],
      ["Asset2", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 4,
        "type": "Issue"
      }],
      ["XChainBridge", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 1,
        "type": "XChainBridge"
      }],
      ["BaseAsset", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 1,
        "type": "Currency"
      }],
      ["QuoteAsset", {
        "isSerialized": true,
        "isSigningField": true,
        "isVLEncoded": false,
        "nth": 2,
        "type": "Currency"
      }],
      ["Transaction", {
        "isSerialized": false,
        "isSigningField": false,
        "isVLEncoded": false,
        "nth": 257,
        "type": "Transaction"
      }],
      ["LedgerEntry", {
        "isSerialized": false,
        "isSigningField": false,
        "isVLEncoded": false,
        "nth": 257,
        "type": "LedgerEntry"
      }],
      ["Validation", {
        "isSerialized": false,
        "isSigningField": false,
        "isVLEncoded": false,
        "nth": 257,
        "type": "Validation"
      }],
      ["Metadata", {
        "isSerialized": false,
        "isSigningField": false,
        "isVLEncoded": false,
        "nth": 257,
        "type": "Metadata"
      }]
    ],
    "LEDGER_ENTRY_TYPES": {
      "AMM": 121,
      "AccountRoot": 97,
      "Amendments": 102,
      "Bridge": 105,
      "Check": 67,
      "Credential": 129,
      "DID": 73,
      "Delegate": 131,
      "DepositPreauth": 112,
      "DirectoryNode": 100,
      "Escrow": 117,
      "FeeSettings": 115,
      "Invalid": -1,
      "LedgerHashes": 104,
      "MPToken": 127,
      "MPTokenIssuance": 126,
      "NFTokenOffer": 55,
      "NFTokenPage": 80,
      "NegativeUNL": 78,
      "Offer": 111,
      "Oracle": 128,
      "PayChannel": 120,
      "PermissionedDomain": 130,
      "RippleState": 114,
      "SignerList": 83,
      "Ticket": 84,
      "Vault": 132,
      "XChainOwnedClaimID": 113,
      "XChainOwnedCreateAccountClaimID": 116
    },
    "TRANSACTION_RESULTS": {
      "tecAMM_ACCOUNT": 168,
      "tecAMM_BALANCE": 163,
      "tecAMM_EMPTY": 166,
      "tecAMM_FAILED": 164,
      "tecAMM_INVALID_TOKENS": 165,
      "tecAMM_NOT_EMPTY": 167,
      "tecARRAY_EMPTY": 190,
      "tecARRAY_TOO_LARGE": 191,
      "tecBAD_CREDENTIALS": 193,
      "tecCANT_ACCEPT_OWN_NFTOKEN_OFFER": 158,
      "tecCLAIM": 100,
      "tecCRYPTOCONDITION_ERROR": 146,
      "tecDIR_FULL": 121,
      "tecDST_TAG_NEEDED": 143,
      "tecDUPLICATE": 149,
      "tecEMPTY_DID": 187,
      "tecEXPIRED": 148,
      "tecFAILED_PROCESSING": 105,
      "tecFROZEN": 137,
      "tecHAS_OBLIGATIONS": 151,
      "tecHOOK_REJECTED": 153,
      "tecINCOMPLETE": 169,
      "tecINSUFFICIENT_FUNDS": 159,
      "tecINSUFFICIENT_PAYMENT": 161,
      "tecINSUFFICIENT_RESERVE": 141,
      "tecINSUFF_FEE": 136,
      "tecINSUF_RESERVE_LINE": 122,
      "tecINSUF_RESERVE_OFFER": 123,
      "tecINTERNAL": 144,
      "tecINVALID_UPDATE_TIME": 188,
      "tecINVARIANT_FAILED": 147,
      "tecKILLED": 150,
      "tecLIMIT_EXCEEDED": 195,
      "tecLOCKED": 192,
      "tecMAX_SEQUENCE_REACHED": 154,
      "tecNEED_MASTER_KEY": 142,
      "tecNFTOKEN_BUY_SELL_MISMATCH": 156,
      "tecNFTOKEN_OFFER_TYPE_MISMATCH": 157,
      "tecNO_ALTERNATIVE_KEY": 130,
      "tecNO_AUTH": 134,
      "tecNO_DELEGATE_PERMISSION": 198,
      "tecNO_DST": 124,
      "tecNO_DST_INSUF_XRP": 125,
      "tecNO_ENTRY": 140,
      "tecNO_ISSUER": 133,
      "tecNO_LINE": 135,
      "tecNO_LINE_INSUF_RESERVE": 126,
      "tecNO_LINE_REDUNDANT": 127,
      "tecNO_PERMISSION": 139,
      "tecNO_REGULAR_KEY": 131,
      "tecNO_SUITABLE_NFTOKEN_PAGE": 155,
      "tecNO_TARGET": 138,
      "tecOBJECT_NOT_FOUND": 160,
      "tecOVERSIZE": 145,
      "tecOWNERS": 132,
      "tecPATH_DRY": 128,
      "tecPATH_PARTIAL": 101,
      "tecPRECISION_LOSS": 197,
      "tecPSEUDO_ACCOUNT": 196,
      "tecTOKEN_PAIR_NOT_FOUND": 189,
      "tecTOO_SOON": 152,
      "tecUNFUNDED": 129,
      "tecUNFUNDED_ADD": 102,
      "tecUNFUNDED_AMM": 162,
      "tecUNFUNDED_OFFER": 103,
      "tecUNFUNDED_PAYMENT": 104,
      "tecWRONG_ASSET": 194,
      "tecXCHAIN_ACCOUNT_CREATE_PAST": 181,
      "tecXCHAIN_ACCOUNT_CREATE_TOO_MANY": 182,
      "tecXCHAIN_BAD_CLAIM_ID": 172,
      "tecXCHAIN_BAD_PUBLIC_KEY_ACCOUNT_PAIR": 185,
      "tecXCHAIN_BAD_TRANSFER_ISSUE": 170,
      "tecXCHAIN_CLAIM_NO_QUORUM": 173,
      "tecXCHAIN_CREATE_ACCOUNT_DISABLED": 186,
      "tecXCHAIN_CREATE_ACCOUNT_NONXRP_ISSUE": 175,
      "tecXCHAIN_INSUFF_CREATE_AMOUNT": 180,
      "tecXCHAIN_NO_CLAIM_ID": 171,
      "tecXCHAIN_NO_SIGNERS_LIST": 178,
      "tecXCHAIN_PAYMENT_FAILED": 183,
      "tecXCHAIN_PROOF_UNKNOWN_KEY": 174,
      "tecXCHAIN_REWARD_MISMATCH": 177,
      "tecXCHAIN_SELF_COMMIT": 184,
      "tecXCHAIN_SENDING_ACCOUNT_MISMATCH": 179,
      "tecXCHAIN_WRONG_CHAIN": 176,
      "tefALREADY": -198,
      "tefBAD_ADD_AUTH": -197,
      "tefBAD_AUTH": -196,
      "tefBAD_AUTH_MASTER": -183,
      "tefBAD_LEDGER": -195,
      "tefBAD_QUORUM": -185,
      "tefBAD_SIGNATURE": -186,
      "tefCREATED": -194,
      "tefEXCEPTION": -193,
      "tefFAILURE": -199,
      "tefINTERNAL": -192,
      "tefINVALID_LEDGER_FIX_TYPE": -178,
      "tefINVARIANT_FAILED": -182,
      "tefMASTER_DISABLED": -188,
      "tefMAX_LEDGER": -187,
      "tefNFTOKEN_IS_NOT_TRANSFERABLE": -179,
      "tefNOT_MULTI_SIGNING": -184,
      "tefNO_AUTH_REQUIRED": -191,
      "tefNO_TICKET": -180,
      "tefPAST_SEQ": -190,
      "tefTOO_BIG": -181,
      "tefWRONG_PRIOR": -189,
      "telBAD_DOMAIN": -398,
      "telBAD_PATH_COUNT": -397,
      "telBAD_PUBLIC_KEY": -396,
      "telCAN_NOT_QUEUE": -392,
      "telCAN_NOT_QUEUE_BALANCE": -391,
      "telCAN_NOT_QUEUE_BLOCKED": -389,
      "telCAN_NOT_QUEUE_BLOCKS": -390,
      "telCAN_NOT_QUEUE_FEE": -388,
      "telCAN_NOT_QUEUE_FULL": -387,
      "telENV_RPC_FAILED": -383,
      "telFAILED_PROCESSING": -395,
      "telINSUF_FEE_P": -394,
      "telLOCAL_ERROR": -399,
      "telNETWORK_ID_MAKES_TX_NON_CANONICAL": -384,
      "telNO_DST_PARTIAL": -393,
      "telREQUIRES_NETWORK_ID": -385,
      "telWRONG_NETWORK": -386,
      "temARRAY_EMPTY": -253,
      "temARRAY_TOO_LARGE": -252,
      "temBAD_AMM_TOKENS": -261,
      "temBAD_AMOUNT": -298,
      "temBAD_CURRENCY": -297,
      "temBAD_EXPIRATION": -296,
      "temBAD_FEE": -295,
      "temBAD_ISSUER": -294,
      "temBAD_LIMIT": -293,
      "temBAD_NFTOKEN_TRANSFER_FEE": -262,
      "temBAD_OFFER": -292,
      "temBAD_PATH": -291,
      "temBAD_PATH_LOOP": -290,
      "temBAD_QUORUM": -271,
      "temBAD_REGKEY": -289,
      "temBAD_SEND_XRP_LIMIT": -288,
      "temBAD_SEND_XRP_MAX": -287,
      "temBAD_SEND_XRP_NO_DIRECT": -286,
      "temBAD_SEND_XRP_PARTIAL": -285,
      "temBAD_SEND_XRP_PATHS": -284,
      "temBAD_SEQUENCE": -283,
      "temBAD_SIGNATURE": -282,
      "temBAD_SIGNER": -272,
      "temBAD_SRC_ACCOUNT": -281,
      "temBAD_TICK_SIZE": -269,
      "temBAD_TRANSFER_FEE": -251,
      "temBAD_TRANSFER_RATE": -280,
      "temBAD_WEIGHT": -270,
      "temCANNOT_PREAUTH_SELF": -267,
      "temDISABLED": -273,
      "temDST_IS_SRC": -279,
      "temDST_NEEDED": -278,
      "temEMPTY_DID": -254,
      "temINVALID": -277,
      "temINVALID_ACCOUNT_ID": -268,
      "temINVALID_COUNT": -266,
      "temINVALID_FLAG": -276,
      "temINVALID_INNER_BATCH": -250,
      "temMALFORMED": -299,
      "temREDUNDANT": -275,
      "temRIPPLE_EMPTY": -274,
      "temSEQ_AND_TICKET": -263,
      "temUNCERTAIN": -265,
      "temUNKNOWN": -264,
      "temXCHAIN_BAD_PROOF": -259,
      "temXCHAIN_BRIDGE_BAD_ISSUES": -258,
      "temXCHAIN_BRIDGE_BAD_MIN_ACCOUNT_CREATE_AMOUNT": -256,
      "temXCHAIN_BRIDGE_BAD_REWARD_AMOUNT": -255,
      "temXCHAIN_BRIDGE_NONDOOR_OWNER": -257,
      "temXCHAIN_EQUAL_DOOR_ACCOUNTS": -260,
      "terADDRESS_COLLISION": -86,
      "terFUNDS_SPENT": -98,
      "terINSUF_FEE_B": -97,
      "terLAST": -91,
      "terNO_ACCOUNT": -96,
      "terNO_AMM": -87,
      "terNO_AUTH": -95,
      "terNO_LINE": -94,
      "terNO_RIPPLE": -90,
      "terOWNERS": -93,
      "terPRE_SEQ": -92,
      "terPRE_TICKET": -88,
      "terQUEUED": -89,
      "terRETRY": -99,
      "tesSUCCESS": 0
    },
    "TRANSACTION_TYPES": {
      "AMMBid": 39,
      "AMMClawback": 31,
      "AMMCreate": 35,
      "AMMDelete": 40,
      "AMMDeposit": 36,
      "AMMVote": 38,
      "AMMWithdraw": 37,
      "AccountDelete": 21,
      "AccountSet": 3,
      "Batch": 71,
      "CheckCancel": 18,
      "CheckCash": 17,
      "CheckCreate": 16,
      "Clawback": 30,
      "CredentialAccept": 59,
      "CredentialCreate": 58,
      "CredentialDelete": 60,
      "DIDDelete": 50,
      "DIDSet": 49,
      "DelegateSet": 64,
      "DepositPreauth": 19,
      "EnableAmendment": 100,
      "EscrowCancel": 4,
      "EscrowCreate": 1,
      "EscrowFinish": 2,
      "Invalid": -1,
      "LedgerStateFix": 53,
      "MPTokenAuthorize": 57,
      "MPTokenIssuanceCreate": 54,
      "MPTokenIssuanceDestroy": 55,
      "MPTokenIssuanceSet": 56,
      "NFTokenAcceptOffer": 29,
      "NFTokenBurn": 26,
      "NFTokenCancelOffer": 28,
      "NFTokenCreateOffer": 27,
      "NFTokenMint": 25,
      "NFTokenModify": 61,
      "OfferCancel": 8,
      "OfferCreate": 7,
      "OracleDelete": 52,
      "OracleSet": 51,
      "Payment": 0,
      "PaymentChannelClaim": 15,
      "PaymentChannelCreate": 13,
      "PaymentChannelFund": 14,
      "PermissionedDomainDelete": 63,
      "PermissionedDomainSet": 62,
      "SetFee": 101,
      "SetRegularKey": 5,
      "SignerListSet": 12,
      "TicketCreate": 10,
      "TrustSet": 20,
      "UNLModify": 102,
      "VaultClawback": 70,
      "VaultCreate": 65,
      "VaultDelete": 67,
      "VaultDeposit": 68,
      "VaultSet": 66,
      "VaultWithdraw": 69,
      "XChainAccountCreateCommit": 44,
      "XChainAddAccountCreateAttestation": 46,
      "XChainAddClaimAttestation": 45,
      "XChainClaim": 43,
      "XChainCommit": 42,
      "XChainCreateBridge": 48,
      "XChainCreateClaimID": 41,
      "XChainModifyBridge": 47
    },
    "TYPES": {
      "AccountID": 8,
      "Amount": 6,
      "Blob": 7,
      "Currency": 26,
      "Done": -1,
      "Hash128": 4,
      "Hash160": 17,
      "Hash192": 21,
      "Hash256": 5,
      "Issue": 24,
      "LedgerEntry": 10002,
      "Metadata": 10004,
      "NotPresent": 0,
      "Number": 9,
      "PathSet": 18,
      "STArray": 15,
      "STObject": 14,
      "Transaction": 10001,
      "UInt16": 1,
      "UInt32": 2,
      "UInt384": 22,
      "UInt512": 23,
      "UInt64": 3,
      "UInt8": 16,
      "UInt96": 20,
      "Unknown": -2,
      "Validation": 10003,
      "Vector256": 19,
      "XChainBridge": 25
    }
  };
} });
var require_bytes = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/enums/bytes.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BytesLookup = exports.Bytes = void 0;
  var Bytes = class {
    constructor(name, ordinal, ordinalWidth) {
      this.name = name;
      this.ordinal = ordinal;
      this.ordinalWidth = ordinalWidth;
      this.bytes = new Uint8Array(ordinalWidth);
      for (let i = 0; i < ordinalWidth; i++) this.bytes[ordinalWidth - i - 1] = ordinal >>> i * 8 & 255;
    }
    toJSON() {
      return this.name;
    }
    toBytesSink(sink) {
      sink.put(this.bytes);
    }
    toBytes() {
      return this.bytes;
    }
  };
  exports.Bytes = Bytes;
  var BytesLookup = class {
    constructor(types$1, ordinalWidth) {
      this.ordinalWidth = ordinalWidth;
      Object.entries(types$1).forEach(([k, v]) => {
        this.add(k, v);
      });
    }
    /**
    * Add a new name value pair to the BytesLookup.
    *
    * @param name - A human readable name for the field.
    * @param value - The numeric value for the field.
    * @throws if the name or value already exist in the lookup because it's unclear how to decode.
    */
    add(name, value) {
      if (this[name]) throw new SyntaxError(`Attempted to add a value with a duplicate name "${name}". This is not allowed because it is unclear how to decode.`);
      if (this[value.toString()]) throw new SyntaxError(`Attempted to add a duplicate value under a different name (Given name: "${name}" and previous name: "${this[value.toString()]}. This is not allowed because it is unclear how to decode.
Given value: ${value.toString()}`);
      this[name] = new Bytes(name, value, this.ordinalWidth);
      this[value.toString()] = this[name];
    }
    from(value) {
      return value instanceof Bytes ? value : this[value];
    }
    fromParser(parser) {
      return this.from(parser.readUIntN(this.ordinalWidth).toString());
    }
  };
  exports.BytesLookup = BytesLookup;
} });
var require_binary_serializer = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BinarySerializer = exports.BytesList = void 0;
  const utils_1$50 = require_browser$4();
  var BytesList = class {
    constructor() {
      this.bytesArray = [];
    }
    /**
    * Get the total number of bytes in the BytesList
    *
    * @return the number of bytes
    */
    getLength() {
      return (0, utils_1$50.concat)(this.bytesArray).byteLength;
    }
    /**
    * Put bytes in the BytesList
    *
    * @param bytesArg A Uint8Array
    * @return this BytesList
    */
    put(bytesArg) {
      const bytes$1 = Uint8Array.from(bytesArg);
      this.bytesArray.push(bytes$1);
      return this;
    }
    /**
    * Write this BytesList to the back of another bytes list
    *
    *  @param list The BytesList to write to
    */
    toBytesSink(list) {
      list.put(this.toBytes());
    }
    toBytes() {
      return (0, utils_1$50.concat)(this.bytesArray);
    }
    toHex() {
      return (0, utils_1$50.bytesToHex)(this.toBytes());
    }
  };
  exports.BytesList = BytesList;
  var BinarySerializer = class {
    constructor(sink) {
      this.sink = new BytesList();
      this.sink = sink;
    }
    /**
    * Write a value to this BinarySerializer
    *
    * @param value a SerializedType value
    */
    write(value) {
      value.toBytesSink(this.sink);
    }
    /**
    * Write bytes to this BinarySerializer
    *
    * @param bytes the bytes to write
    */
    put(bytes$1) {
      this.sink.put(bytes$1);
    }
    /**
    * Write a value of a given type to this BinarySerializer
    *
    * @param type the type to write
    * @param value a value of that type
    */
    writeType(type2, value) {
      this.write(type2.from(value));
    }
    /**
    * Write BytesList to this BinarySerializer
    *
    * @param bl BytesList to write to BinarySerializer
    */
    writeBytesList(bl) {
      bl.toBytesSink(this.sink);
    }
    /**
    * Calculate the header of Variable Length encoded bytes
    *
    * @param length the length of the bytes
    */
    encodeVariableLength(length) {
      const lenBytes = new Uint8Array(3);
      if (length <= 192) {
        lenBytes[0] = length;
        return lenBytes.slice(0, 1);
      } else if (length <= 12480) {
        length -= 193;
        lenBytes[0] = 193 + (length >>> 8);
        lenBytes[1] = length & 255;
        return lenBytes.slice(0, 2);
      } else if (length <= 918744) {
        length -= 12481;
        lenBytes[0] = 241 + (length >>> 16);
        lenBytes[1] = length >> 8 & 255;
        lenBytes[2] = length & 255;
        return lenBytes.slice(0, 3);
      }
      throw new Error("Overflow error");
    }
    /**
    * Write field and value to BinarySerializer
    *
    * @param field field to write to BinarySerializer
    * @param value value to write to BinarySerializer
    */
    writeFieldAndValue(field, value, isUnlModifyWorkaround = false) {
      const associatedValue = field.associatedType.from(value);
      if (associatedValue.toBytesSink === void 0 || field.name === void 0) throw new Error();
      this.sink.put(field.header);
      if (field.isVariableLengthEncoded) this.writeLengthEncoded(associatedValue, isUnlModifyWorkaround);
      else associatedValue.toBytesSink(this.sink);
    }
    /**
    * Write a variable length encoded value to the BinarySerializer
    *
    * @param value length encoded value to write to BytesList
    */
    writeLengthEncoded(value, isUnlModifyWorkaround = false) {
      const bytes$1 = new BytesList();
      if (!isUnlModifyWorkaround) value.toBytesSink(bytes$1);
      this.put(this.encodeVariableLength(bytes$1.getLength()));
      this.writeBytesList(bytes$1);
    }
  };
  exports.BinarySerializer = BinarySerializer;
} });
var require_serialized_type = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/serialized-type.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Comparable = exports.SerializedType = void 0;
  const binary_serializer_1$4 = require_binary_serializer();
  const utils_1$49 = require_browser$4();
  var SerializedType = class {
    constructor(bytes$1) {
      this.bytes = new Uint8Array(0);
      this.bytes = bytes$1 !== null && bytes$1 !== void 0 ? bytes$1 : new Uint8Array(0);
    }
    static fromParser(parser, hint) {
      throw new Error("fromParser not implemented");
    }
    static from(value) {
      throw new Error("from not implemented");
    }
    /**
    * Write the bytes representation of a SerializedType to a BytesList
    *
    * @param list The BytesList to write SerializedType bytes to
    */
    toBytesSink(list) {
      list.put(this.bytes);
    }
    /**
    * Get the hex representation of a SerializedType's bytes
    *
    * @returns hex String of this.bytes
    */
    toHex() {
      return (0, utils_1$49.bytesToHex)(this.toBytes());
    }
    /**
    * Get the bytes representation of a SerializedType
    *
    * @returns A Uint8Array of the bytes
    */
    toBytes() {
      if (this.bytes) return this.bytes;
      const bytes$1 = new binary_serializer_1$4.BytesList();
      this.toBytesSink(bytes$1);
      return bytes$1.toBytes();
    }
    /**
    * Return the JSON representation of a SerializedType
    *
    * @param _definitions rippled definitions used to parse the values of transaction types and such.
    *                          Unused in default, but used in STObject, STArray
    *                          Can be customized for sidechains and amendments.
    * @returns any type, if not overloaded returns hexString representation of bytes
    */
    toJSON(_definitions, _fieldName) {
      return this.toHex();
    }
    /**
    * @returns hexString representation of this.bytes
    */
    toString() {
      return this.toHex();
    }
  };
  exports.SerializedType = SerializedType;
  var Comparable = class extends SerializedType {
    lt(other) {
      return this.compareTo(other) < 0;
    }
    eq(other) {
      return this.compareTo(other) === 0;
    }
    gt(other) {
      return this.compareTo(other) > 0;
    }
    gte(other) {
      return this.compareTo(other) > -1;
    }
    lte(other) {
      return this.compareTo(other) < 1;
    }
    /**
    * Overload this method to define how two Comparable SerializedTypes are compared
    *
    * @param other The comparable object to compare this to
    * @returns A number denoting the relationship of this and other
    */
    compareTo(other) {
      throw new Error(`cannot compare ${this.toString()} and ${other.toString()}`);
    }
  };
  exports.Comparable = Comparable;
} });
var require_constants = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/enums/constants.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DELEGATABLE_PERMISSIONS_WIDTH = exports.TRANSACTION_RESULT_WIDTH = exports.TRANSACTION_TYPE_WIDTH = exports.LEDGER_ENTRY_WIDTH = exports.TYPE_WIDTH = void 0;
  exports.TYPE_WIDTH = 2;
  exports.LEDGER_ENTRY_WIDTH = 2;
  exports.TRANSACTION_TYPE_WIDTH = 2;
  exports.TRANSACTION_RESULT_WIDTH = 1;
  exports.DELEGATABLE_PERMISSIONS_WIDTH = 4;
} });
var require_field = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/enums/field.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FieldLookup = void 0;
  const bytes_1$1 = require_bytes();
  const serialized_type_1$10 = require_serialized_type();
  const constants_1$1 = require_constants();
  function fieldHeader(type2, nth) {
    const header = [];
    if (type2 < 16) if (nth < 16) header.push(type2 << 4 | nth);
    else header.push(type2 << 4, nth);
    else if (nth < 16) header.push(nth, type2);
    else header.push(0, type2, nth);
    return Uint8Array.from(header);
  }
  function buildField([name, info], typeOrdinal) {
    const field = fieldHeader(typeOrdinal, info.nth);
    return {
      name,
      nth: info.nth,
      isVariableLengthEncoded: info.isVLEncoded,
      isSerialized: info.isSerialized,
      isSigningField: info.isSigningField,
      ordinal: typeOrdinal << 16 | info.nth,
      type: new bytes_1$1.Bytes(info.type, typeOrdinal, constants_1$1.TYPE_WIDTH),
      header: field,
      associatedType: serialized_type_1$10.SerializedType
    };
  }
  var FieldLookup = class {
    constructor(fields, types$1) {
      fields.forEach(([name, field_info]) => {
        const typeOrdinal = types$1[field_info.type];
        this[name] = buildField([name, field_info], typeOrdinal);
        this[this[name].ordinal.toString()] = this[name];
      });
    }
    fromString(value) {
      return this[value];
    }
  };
  exports.FieldLookup = FieldLookup;
} });
var require_xrpl_definitions_base = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/enums/xrpl-definitions-base.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BytesLookup = exports.Bytes = exports.FieldLookup = exports.XrplDefinitionsBase = void 0;
  const bytes_1 = require_bytes();
  Object.defineProperty(exports, "Bytes", {
    enumerable: true,
    get: function() {
      return bytes_1.Bytes;
    }
  });
  Object.defineProperty(exports, "BytesLookup", {
    enumerable: true,
    get: function() {
      return bytes_1.BytesLookup;
    }
  });
  const field_1 = require_field();
  Object.defineProperty(exports, "FieldLookup", {
    enumerable: true,
    get: function() {
      return field_1.FieldLookup;
    }
  });
  const constants_1 = require_constants();
  var XrplDefinitionsBase = class {
    /**
    * Present rippled types in a typed and updatable format.
    * For an example of the input format see `definitions.json`.
    * To generate a new definitions file from rippled source code, use the tool at
    * `packages/ripple-binary-codec/tools/generateDefinitions.js`.
    *
    * See the definitions.test.js file for examples of how to create your own updated definitions.json.
    *
    * @param enums - A json encoding of the core types, transaction types, transaction results, transaction names, and fields.
    * @param types - A list of type objects with the same name as the fields defined.
    *              You can use the coreTypes object if you are not adding new types.
    */
    constructor(enums2, types$1) {
      this.type = new bytes_1.BytesLookup(enums2.TYPES, constants_1.TYPE_WIDTH);
      this.ledgerEntryType = new bytes_1.BytesLookup(enums2.LEDGER_ENTRY_TYPES, constants_1.LEDGER_ENTRY_WIDTH);
      this.transactionType = new bytes_1.BytesLookup(enums2.TRANSACTION_TYPES, constants_1.TRANSACTION_TYPE_WIDTH);
      this.transactionResult = new bytes_1.BytesLookup(enums2.TRANSACTION_RESULTS, constants_1.TRANSACTION_RESULT_WIDTH);
      this.field = new field_1.FieldLookup(enums2.FIELDS, enums2.TYPES);
      this.transactionNames = Object.entries(enums2.TRANSACTION_TYPES).filter(([_key, value]) => value >= 0).map(([key, _value]) => key);
      this.dataTypes = {};
      this.associateTypes(types$1);
      this.granularPermissions = {
        TrustlineAuthorize: 65537,
        TrustlineFreeze: 65538,
        TrustlineUnfreeze: 65539,
        AccountDomainSet: 65540,
        AccountEmailHashSet: 65541,
        AccountMessageKeySet: 65542,
        AccountTransferRateSet: 65543,
        AccountTickSizeSet: 65544,
        PaymentMint: 65545,
        PaymentBurn: 65546,
        MPTokenIssuanceLock: 65547,
        MPTokenIssuanceUnlock: 65548
      };
      const incrementedTransactionTypes = Object.fromEntries(Object.entries(enums2.TRANSACTION_TYPES).map(([key, value]) => [key, value + 1]));
      const combinedPermissions = Object.assign(Object.assign({}, this.granularPermissions), incrementedTransactionTypes);
      this.delegatablePermissions = new bytes_1.BytesLookup(combinedPermissions, constants_1.DELEGATABLE_PERMISSIONS_WIDTH);
    }
    /**
    * Associates each Field to a corresponding class that TypeScript can recognize.
    *
    * @param types a list of type objects with the same name as the fields defined.
    *              Defaults to xrpl.js's core type definitions.
    */
    associateTypes(types$1) {
      this.dataTypes = Object.assign({}, this.dataTypes, types$1);
      Object.values(this.field).forEach((field) => {
        field.associatedType = this.dataTypes[field.type.name];
      });
      this.field["TransactionType"].associatedType = this.transactionType;
      this.field["TransactionResult"].associatedType = this.transactionResult;
      this.field["LedgerEntryType"].associatedType = this.ledgerEntryType;
      this.field["PermissionValue"].associatedType = this.delegatablePermissions;
    }
    getAssociatedTypes() {
      return this.dataTypes;
    }
  };
  exports.XrplDefinitionsBase = XrplDefinitionsBase;
} });
var require_enums = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/enums/index.js"(exports) {
  var __importDefault$22 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TRANSACTION_TYPES = exports.TransactionType = exports.TransactionResult = exports.LedgerEntryType = exports.Type = exports.Field = exports.DEFAULT_DEFINITIONS = exports.XrplDefinitionsBase = exports.Bytes = void 0;
  const definitions_json_1 = __importDefault$22(require_definitions());
  const xrpl_definitions_base_1$1 = require_xrpl_definitions_base();
  Object.defineProperty(exports, "XrplDefinitionsBase", {
    enumerable: true,
    get: function() {
      return xrpl_definitions_base_1$1.XrplDefinitionsBase;
    }
  });
  Object.defineProperty(exports, "Bytes", {
    enumerable: true,
    get: function() {
      return xrpl_definitions_base_1$1.Bytes;
    }
  });
  const DEFAULT_DEFINITIONS = new xrpl_definitions_base_1$1.XrplDefinitionsBase(definitions_json_1.default, {});
  exports.DEFAULT_DEFINITIONS = DEFAULT_DEFINITIONS;
  const Type = DEFAULT_DEFINITIONS.type;
  exports.Type = Type;
  const LedgerEntryType = DEFAULT_DEFINITIONS.ledgerEntryType;
  exports.LedgerEntryType = LedgerEntryType;
  const TransactionType = DEFAULT_DEFINITIONS.transactionType;
  exports.TransactionType = TransactionType;
  const TransactionResult = DEFAULT_DEFINITIONS.transactionResult;
  exports.TransactionResult = TransactionResult;
  const Field = DEFAULT_DEFINITIONS.field;
  exports.Field = Field;
  const TRANSACTION_TYPES = DEFAULT_DEFINITIONS.transactionNames;
  exports.TRANSACTION_TYPES = TRANSACTION_TYPES;
} });
var require_utils$5$1 = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/utils.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.compare = exports.equal = exports.readUInt32BE = exports.readUInt16BE = exports.writeUInt32BE = exports.writeUInt16BE = exports.writeUInt8 = void 0;
  function writeUInt8(array, value, offset) {
    value = Number(value);
    array[offset] = value;
  }
  exports.writeUInt8 = writeUInt8;
  function writeUInt16BE(array, value, offset) {
    value = Number(value);
    array[offset] = value >>> 8;
    array[offset + 1] = value;
  }
  exports.writeUInt16BE = writeUInt16BE;
  function writeUInt32BE(array, value, offset) {
    array[offset] = value >>> 24 & 255;
    array[offset + 1] = value >>> 16 & 255;
    array[offset + 2] = value >>> 8 & 255;
    array[offset + 3] = value & 255;
  }
  exports.writeUInt32BE = writeUInt32BE;
  function readUInt16BE(array, offset) {
    return new DataView(array.buffer).getUint16(offset, false).toString(10);
  }
  exports.readUInt16BE = readUInt16BE;
  function readUInt32BE(array, offset) {
    return new DataView(array.buffer).getUint32(offset, false).toString(10);
  }
  exports.readUInt32BE = readUInt32BE;
  function equal(a, b) {
    const aUInt = a instanceof ArrayBuffer ? new Uint8Array(a, 0) : a;
    const bUInt = b instanceof ArrayBuffer ? new Uint8Array(b, 0) : b;
    if (aUInt.byteLength != bUInt.byteLength) return false;
    if (aligned32(aUInt) && aligned32(bUInt)) return compare32(aUInt, bUInt) === 0;
    if (aligned16(aUInt) && aligned16(bUInt)) return compare16(aUInt, bUInt) === 0;
    return compare8(aUInt, bUInt) === 0;
  }
  exports.equal = equal;
  function compare8(a, b) {
    const ua = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
    const ub = new Uint8Array(b.buffer, b.byteOffset, b.byteLength);
    return compare$1(ua, ub);
  }
  function compare16(a, b) {
    const ua = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
    const ub = new Uint16Array(b.buffer, b.byteOffset, b.byteLength / 2);
    return compare$1(ua, ub);
  }
  function compare32(a, b) {
    const ua = new Uint32Array(a.buffer, a.byteOffset, a.byteLength / 4);
    const ub = new Uint32Array(b.buffer, b.byteOffset, b.byteLength / 4);
    return compare$1(ua, ub);
  }
  function compare$1(a, b) {
    if (a.byteLength !== b.byteLength) throw new Error("Cannot compare arrays of different length");
    for (let i = 0; i < a.length - 1; i += 1) {
      if (a[i] > b[i]) return 1;
      if (a[i] < b[i]) return -1;
    }
    return 0;
  }
  exports.compare = compare$1;
  function aligned16(array) {
    return array.byteOffset % 2 === 0 && array.byteLength % 2 === 0;
  }
  function aligned32(array) {
    return array.byteOffset % 4 === 0 && array.byteLength % 4 === 0;
  }
} });
var require_hash = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/hash.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Hash = void 0;
  const serialized_type_1$9 = require_serialized_type();
  const utils_1$48 = require_browser$4();
  const utils_2$6 = require_utils$5$1();
  var Hash = class extends serialized_type_1$9.Comparable {
    constructor(bytes$1) {
      super(bytes$1);
      if (this.bytes.length !== this.constructor.width) throw new Error(`Invalid Hash length ${this.bytes.byteLength}`);
    }
    /**
    * Construct a Hash object from an existing Hash object or a hex-string
    *
    * @param value A hash object or hex-string of a hash
    */
    static from(value) {
      if (value instanceof this) return value;
      if (typeof value === "string") {
        if (!utils_1$48.HEX_REGEX.test(value)) throw new Error(`Invalid hash string ${value}`);
        return new this((0, utils_1$48.hexToBytes)(value));
      }
      throw new Error("Cannot construct Hash from given value");
    }
    /**
    * Read a Hash object from a BinaryParser
    *
    * @param parser BinaryParser to read the hash from
    * @param hint length of the bytes to read, optional
    */
    static fromParser(parser, hint) {
      return new this(parser.read(hint !== null && hint !== void 0 ? hint : this.width));
    }
    /**
    * Overloaded operator for comparing two hash objects
    *
    * @param other The Hash to compare this to
    */
    compareTo(other) {
      return (0, utils_2$6.compare)(this.bytes, this.constructor.from(other).bytes);
    }
    /**
    * @returns the hex-string representation of this Hash
    */
    toString() {
      return this.toHex();
    }
    /**
    * Returns four bits at the specified depth within a hash
    *
    * @param depth The depth of the four bits
    * @returns The number represented by the four bits
    */
    nibblet(depth) {
      const byteIx = depth > 0 ? depth / 2 | 0 : 0;
      let b = this.bytes[byteIx];
      if (depth % 2 === 0) b = (b & 240) >>> 4;
      else b = b & 15;
      return b;
    }
  };
  exports.Hash = Hash;
} });
var require_hash_160 = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/hash-160.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Hash160 = void 0;
  const hash_1$3 = require_hash();
  var Hash160 = class Hash1602 extends hash_1$3.Hash {
    constructor(bytes$1) {
      if (bytes$1 && bytes$1.byteLength === 0) bytes$1 = Hash1602.ZERO_160.bytes;
      super(bytes$1 !== null && bytes$1 !== void 0 ? bytes$1 : Hash1602.ZERO_160.bytes);
    }
  };
  exports.Hash160 = Hash160;
  Hash160.width = 20;
  Hash160.ZERO_160 = new Hash160(new Uint8Array(Hash160.width));
} });
var require_account_id = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/account-id.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AccountID = void 0;
  const ripple_address_codec_1$11 = require_dist$3();
  const hash_160_1$2 = require_hash_160();
  const utils_1$47 = require_browser$4();
  const HEX_REGEX$3 = /^[A-F0-9]{40}$/;
  var AccountID = class AccountID2 extends hash_160_1$2.Hash160 {
    constructor(bytes$1) {
      super(bytes$1 !== null && bytes$1 !== void 0 ? bytes$1 : AccountID2.defaultAccountID.bytes);
    }
    /**
    * Defines how to construct an AccountID
    *
    * @param value either an existing AccountID, a hex-string, or a base58 r-Address
    * @returns an AccountID object
    */
    static from(value) {
      if (value instanceof AccountID2) return value;
      if (typeof value === "string") {
        if (value === "") return new AccountID2();
        return HEX_REGEX$3.test(value) ? new AccountID2((0, utils_1$47.hexToBytes)(value)) : this.fromBase58(value);
      }
      throw new Error("Cannot construct AccountID from value given");
    }
    /**
    * Defines how to build an AccountID from a base58 r-Address
    *
    * @param value a base58 r-Address
    * @returns an AccountID object
    */
    static fromBase58(value) {
      if ((0, ripple_address_codec_1$11.isValidXAddress)(value)) {
        const classic = (0, ripple_address_codec_1$11.xAddressToClassicAddress)(value);
        if (classic.tag !== false) throw new Error("Only allowed to have tag on Account or Destination");
        value = classic.classicAddress;
      }
      return new AccountID2(Uint8Array.from((0, ripple_address_codec_1$11.decodeAccountID)(value)));
    }
    /**
    * Overload of toJSON
    *
    * @returns the base58 string for this AccountID
    */
    toJSON() {
      return this.toBase58();
    }
    /**
    * Defines how to encode AccountID into a base58 address
    *
    * @returns the base58 string defined by this.bytes
    */
    toBase58() {
      return (0, ripple_address_codec_1$11.encodeAccountID)(this.bytes);
    }
  };
  exports.AccountID = AccountID;
  AccountID.defaultAccountID = new AccountID(new Uint8Array(20));
} });
var require_binary_parser = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/serdes/binary-parser.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BinaryParser = void 0;
  const enums_1$7 = require_enums();
  const utils_1$46 = require_browser$4();
  var BinaryParser = class {
    /**
    * Initialize bytes to a hex string
    *
    * @param hexBytes a hex string
    * @param definitions Rippled definitions used to parse the values of transaction types and such.
    *                          Can be customized for sidechains and amendments.
    */
    constructor(hexBytes, definitions = enums_1$7.DEFAULT_DEFINITIONS) {
      this.bytes = (0, utils_1$46.hexToBytes)(hexBytes);
      this.definitions = definitions;
    }
    /**
    * Peek the first byte of the BinaryParser
    *
    * @returns The first byte of the BinaryParser
    */
    peek() {
      if (this.bytes.byteLength === 0) throw new Error();
      return this.bytes[0];
    }
    /**
    * Consume the first n bytes of the BinaryParser
    *
    * @param n the number of bytes to skip
    */
    skip(n) {
      if (n > this.bytes.byteLength) throw new Error();
      this.bytes = this.bytes.slice(n);
    }
    /**
    * read the first n bytes from the BinaryParser
    *
    * @param n The number of bytes to read
    * @return The bytes
    */
    read(n) {
      if (n > this.bytes.byteLength) throw new Error();
      const slice = this.bytes.slice(0, n);
      this.skip(n);
      return slice;
    }
    /**
    * Read an integer of given size
    *
    * @param n The number of bytes to read
    * @return The number represented by those bytes
    */
    readUIntN(n) {
      if (0 >= n || n > 4) throw new Error("invalid n");
      return this.read(n).reduce((a, b) => a << 8 | b) >>> 0;
    }
    readUInt8() {
      return this.readUIntN(1);
    }
    readUInt16() {
      return this.readUIntN(2);
    }
    readUInt32() {
      return this.readUIntN(4);
    }
    size() {
      return this.bytes.byteLength;
    }
    end(customEnd) {
      const length = this.bytes.byteLength;
      return length === 0 || customEnd !== void 0 && length <= customEnd;
    }
    /**
    * Reads variable length encoded bytes
    *
    * @return The variable length bytes
    */
    readVariableLength() {
      return this.read(this.readVariableLengthLength());
    }
    /**
    * Reads the length of the variable length encoded bytes
    *
    * @return The length of the variable length encoded bytes
    */
    readVariableLengthLength() {
      const b1 = this.readUInt8();
      if (b1 <= 192) return b1;
      else if (b1 <= 240) {
        const b2 = this.readUInt8();
        return 193 + (b1 - 193) * 256 + b2;
      } else if (b1 <= 254) {
        const b2 = this.readUInt8();
        const b3 = this.readUInt8();
        return 12481 + (b1 - 241) * 65536 + b2 * 256 + b3;
      }
      throw new Error("Invalid variable length indicator");
    }
    /**
    * Reads the field ordinal from the BinaryParser
    *
    * @return Field ordinal
    */
    readFieldOrdinal() {
      let type2 = this.readUInt8();
      let nth = type2 & 15;
      type2 >>= 4;
      if (type2 === 0) {
        type2 = this.readUInt8();
        if (type2 === 0 || type2 < 16) throw new Error(`Cannot read FieldOrdinal, type_code ${type2} out of range`);
      }
      if (nth === 0) {
        nth = this.readUInt8();
        if (nth === 0 || nth < 16) throw new Error(`Cannot read FieldOrdinal, field_code ${nth} out of range`);
      }
      return type2 << 16 | nth;
    }
    /**
    * Read the field from the BinaryParser
    *
    * @return The field represented by the bytes at the head of the BinaryParser
    */
    readField() {
      return this.definitions.field.fromString(this.readFieldOrdinal().toString());
    }
    /**
    * Read a given type from the BinaryParser
    *
    * @param type The type that you want to read from the BinaryParser
    * @return The instance of that type read from the BinaryParser
    */
    readType(type2) {
      return type2.fromParser(this);
    }
    /**
    * Get the type associated with a given field
    *
    * @param field The field that you wan to get the type of
    * @return The type associated with the given field
    */
    typeForField(field) {
      return field.associatedType;
    }
    /**
    * Read value of the type specified by field from the BinaryParser
    *
    * @param field The field that you want to get the associated value for
    * @return The value associated with the given field
    */
    readFieldValue(field) {
      const type2 = this.typeForField(field);
      if (!type2) throw new Error(`unsupported: (${field.name}, ${field.type.name})`);
      const sizeHint = field.isVariableLengthEncoded ? this.readVariableLengthLength() : void 0;
      const value = type2.fromParser(this, sizeHint);
      if (value === void 0) throw new Error(`fromParser for (${field.name}, ${field.type.name}) -> undefined `);
      return value;
    }
    /**
    * Get the next field and value from the BinaryParser
    *
    * @return The field and value
    */
    readFieldAndValue() {
      const field = this.readField();
      return [field, this.readFieldValue(field)];
    }
  };
  exports.BinaryParser = BinaryParser;
} });
var require_currency = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/currency.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Currency = void 0;
  const hash_160_1$1 = require_hash_160();
  const utils_1$45 = require_browser$4();
  const XRP_HEX_REGEX = /^0{40}$/;
  const ISO_REGEX = /^[A-Z0-9a-z?!@#$%^&*(){}[\]|]{3}$/;
  const HEX_REGEX$2 = /^[A-F0-9]{40}$/;
  const STANDARD_FORMAT_HEX_REGEX = /^0{24}[\x00-\x7F]{6}0{10}$/;
  function isoToBytes(iso) {
    const bytes$1 = new Uint8Array(20);
    if (iso !== "XRP") {
      const isoBytes = iso.split("").map((c) => c.charCodeAt(0));
      bytes$1.set(isoBytes, 12);
    }
    return bytes$1;
  }
  function isIsoCode(iso) {
    return ISO_REGEX.test(iso);
  }
  function isoCodeFromHex(code) {
    const iso = (0, utils_1$45.hexToString)((0, utils_1$45.bytesToHex)(code));
    if (iso === "XRP") return null;
    if (isIsoCode(iso)) return iso;
    return null;
  }
  function isHex$1(hex) {
    return HEX_REGEX$2.test(hex);
  }
  function isStringRepresentation(input) {
    return input.length === 3 || isHex$1(input);
  }
  function isBytesArray(bytes$1) {
    return bytes$1.byteLength === 20;
  }
  function isValidRepresentation(input) {
    return input instanceof Uint8Array ? isBytesArray(input) : isStringRepresentation(input);
  }
  function bytesFromRepresentation(input) {
    if (!isValidRepresentation(input)) throw new Error(`Unsupported Currency representation: ${input}`);
    return input.length === 3 ? isoToBytes(input) : (0, utils_1$45.hexToBytes)(input);
  }
  var Currency = class Currency2 extends hash_160_1$1.Hash160 {
    constructor(byteBuf) {
      super(byteBuf !== null && byteBuf !== void 0 ? byteBuf : Currency2.XRP.bytes);
      const hex = (0, utils_1$45.bytesToHex)(this.bytes);
      if (XRP_HEX_REGEX.test(hex)) this._iso = "XRP";
      else if (STANDARD_FORMAT_HEX_REGEX.test(hex)) this._iso = isoCodeFromHex(this.bytes.slice(12, 15));
      else this._iso = null;
    }
    /**
    * Return the ISO code of this currency
    *
    * @returns ISO code if it exists, else null
    */
    iso() {
      return this._iso;
    }
    /**
    * Constructs a Currency object
    *
    * @param val Currency object or a string representation of a currency
    */
    static from(value) {
      if (value instanceof Currency2) return value;
      if (typeof value === "string") return new Currency2(bytesFromRepresentation(value));
      throw new Error("Cannot construct Currency from value given");
    }
    /**
    * Gets the JSON representation of a currency
    *
    * @returns JSON representation
    */
    toJSON() {
      const iso = this.iso();
      if (iso !== null) return iso;
      return (0, utils_1$45.bytesToHex)(this.bytes);
    }
  };
  exports.Currency = Currency;
  Currency.XRP = new Currency(new Uint8Array(20));
} });
var require_bignumber = __commonJS$1({ "../../node_modules/.pnpm/bignumber.js@9.3.0/node_modules/bignumber.js/bignumber.js"(exports, module) {
  (function(globalObject) {
    var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER$1 = 9007199254740991, POWS_TEN = [
      1,
      10,
      100,
      1e3,
      1e4,
      1e5,
      1e6,
      1e7,
      1e8,
      1e9,
      1e10,
      1e11,
      1e12,
      1e13
    ], SQRT_BASE = 1e7, MAX = 1e9;
    function clone(configObject) {
      var div, convertBase, parseNumeric, P = BigNumber$1.prototype = {
        constructor: BigNumber$1,
        toString: null,
        valueOf: null
      }, ONE = new BigNumber$1(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: "",
        suffix: ""
      }, ALPHABET$12 = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
      function BigNumber$1(v, b) {
        var alphabet$1, c, caseChanged, e, i, isNum, len, str, x = this;
        if (!(x instanceof BigNumber$1)) return new BigNumber$1(v, b);
        if (b == null) {
          if (v && v._isBigNumber === true) {
            x.s = v.s;
            if (!v.c || v.e > MAX_EXP) x.c = x.e = null;
            else if (v.e < MIN_EXP) x.c = [x.e = 0];
            else {
              x.e = v.e;
              x.c = v.c.slice();
            }
            return;
          }
          if ((isNum = typeof v == "number") && v * 0 == 0) {
            x.s = 1 / v < 0 ? (v = -v, -1) : 1;
            if (v === ~~v) {
              for (e = 0, i = v; i >= 10; i /= 10, e++) ;
              if (e > MAX_EXP) x.c = x.e = null;
              else {
                x.e = e;
                x.c = [v];
              }
              return;
            }
            str = String(v);
          } else {
            if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
            x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
          }
          if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
          if ((i = str.search(/e/i)) > 0) {
            if (e < 0) e = i;
            e += +str.slice(i + 1);
            str = str.substring(0, i);
          } else if (e < 0) e = str.length;
        } else {
          intCheck(b, 2, ALPHABET$12.length, "Base");
          if (b == 10 && alphabetHasNormalDecimalDigits) {
            x = new BigNumber$1(v);
            return round2(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
          }
          str = String(v);
          if (isNum = typeof v == "number") {
            if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
            x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
            if (BigNumber$1.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) throw Error(tooManyDigits + v);
          } else x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
          alphabet$1 = ALPHABET$12.slice(0, b);
          e = i = 0;
          for (len = str.length; i < len; i++) if (alphabet$1.indexOf(c = str.charAt(i)) < 0) {
            if (c == ".") {
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {
              if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }
            return parseNumeric(x, String(v), isNum, b);
          }
          isNum = false;
          str = convertBase(str, b, 10, x.s);
          if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
          else e = str.length;
        }
        for (i = 0; str.charCodeAt(i) === 48; i++) ;
        for (len = str.length; str.charCodeAt(--len) === 48; ) ;
        if (str = str.slice(i, ++len)) {
          len -= i;
          if (isNum && BigNumber$1.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER$1 || v !== mathfloor(v))) throw Error(tooManyDigits + x.s * v);
          if ((e = e - i - 1) > MAX_EXP) x.c = x.e = null;
          else if (e < MIN_EXP) x.c = [x.e = 0];
          else {
            x.e = e;
            x.c = [];
            i = (e + 1) % LOG_BASE;
            if (e < 0) i += LOG_BASE;
            if (i < len) {
              if (i) x.c.push(+str.slice(0, i));
              for (len -= LOG_BASE; i < len; ) x.c.push(+str.slice(i, i += LOG_BASE));
              i = LOG_BASE - (str = str.slice(i)).length;
            } else i -= len;
            for (; i--; str += "0") ;
            x.c.push(+str);
          }
        } else x.c = [x.e = 0];
      }
      BigNumber$1.clone = clone;
      BigNumber$1.ROUND_UP = 0;
      BigNumber$1.ROUND_DOWN = 1;
      BigNumber$1.ROUND_CEIL = 2;
      BigNumber$1.ROUND_FLOOR = 3;
      BigNumber$1.ROUND_HALF_UP = 4;
      BigNumber$1.ROUND_HALF_DOWN = 5;
      BigNumber$1.ROUND_HALF_EVEN = 6;
      BigNumber$1.ROUND_HALF_CEIL = 7;
      BigNumber$1.ROUND_HALF_FLOOR = 8;
      BigNumber$1.EUCLID = 9;
      BigNumber$1.config = BigNumber$1.set = function(obj) {
        var p, v;
        if (obj != null) if (typeof obj == "object") {
          if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }
          if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }
          if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -1e9, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -1e9, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }
          if (obj.hasOwnProperty(p = "RANGE")) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -1e9, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -1e9, MAX, p);
              if (v) MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              else throw Error(bignumberError + p + " cannot be zero: " + v);
            }
          }
          if (obj.hasOwnProperty(p = "CRYPTO")) {
            v = obj[p];
            if (v === !!v) if (v) if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) CRYPTO = v;
            else {
              CRYPTO = !v;
              throw Error(bignumberError + "crypto unavailable");
            }
            else CRYPTO = v;
            else throw Error(bignumberError + p + " not true or false: " + v);
          }
          if (obj.hasOwnProperty(p = "MODULO_MODE")) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }
          if (obj.hasOwnProperty(p = "POW_PRECISION")) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }
          if (obj.hasOwnProperty(p = "FORMAT")) {
            v = obj[p];
            if (typeof v == "object") FORMAT = v;
            else throw Error(bignumberError + p + " not an object: " + v);
          }
          if (obj.hasOwnProperty(p = "ALPHABET")) {
            v = obj[p];
            if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
              ALPHABET$12 = v;
            } else throw Error(bignumberError + p + " invalid: " + v);
          }
        } else throw Error(bignumberError + "Object expected: " + obj);
        return {
          DECIMAL_PLACES,
          ROUNDING_MODE,
          EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
          RANGE: [MIN_EXP, MAX_EXP],
          CRYPTO,
          MODULO_MODE,
          POW_PRECISION,
          FORMAT,
          ALPHABET: ALPHABET$12
        };
      };
      BigNumber$1.isBigNumber = function(v) {
        if (!v || v._isBigNumber !== true) return false;
        if (!BigNumber$1.DEBUG) return true;
        var i, n, c = v.c, e = v.e, s = v.s;
        out: if ({}.toString.call(c) == "[object Array]") {
          if ((s === 1 || s === -1) && e >= -1e9 && e <= MAX && e === mathfloor(e)) {
            if (c[0] === 0) {
              if (e === 0 && c.length === 1) return true;
              break out;
            }
            i = (e + 1) % LOG_BASE;
            if (i < 1) i += LOG_BASE;
            if (String(c[0]).length == i) {
              for (i = 0; i < c.length; i++) {
                n = c[i];
                if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
              }
              if (n !== 0) return true;
            }
          }
        } else if (c === null && e === null && (s === null || s === 1 || s === -1)) return true;
        throw Error(bignumberError + "Invalid BigNumber: " + v);
      };
      BigNumber$1.maximum = BigNumber$1.max = function() {
        return maxOrMin(arguments, -1);
      };
      BigNumber$1.minimum = BigNumber$1.min = function() {
        return maxOrMin(arguments, 1);
      };
      BigNumber$1.random = function() {
        var pow2_53 = 9007199254740992;
        var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
          return mathfloor(Math.random() * pow2_53);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(dp) {
          var a, b, e, k, v, i = 0, c = [], rand = new BigNumber$1(ONE);
          if (dp == null) dp = DECIMAL_PLACES;
          else intCheck(dp, 0, MAX);
          k = mathceil(dp / LOG_BASE);
          if (CRYPTO) if (crypto.getRandomValues) {
            a = crypto.getRandomValues(new Uint32Array(k *= 2));
            for (; i < k; ) {
              v = a[i] * 131072 + (a[i + 1] >>> 11);
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;
          } else if (crypto.randomBytes) {
            a = crypto.randomBytes(k *= 7);
            for (; i < k; ) {
              v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
              if (v >= 9e15) crypto.randomBytes(7).copy(a, i);
              else {
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error(bignumberError + "crypto unavailable");
          }
          if (!CRYPTO) for (; i < k; ) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
          k = c[--i];
          dp %= LOG_BASE;
          if (k && dp) {
            v = POWS_TEN[LOG_BASE - dp];
            c[i] = mathfloor(k / v) * v;
          }
          for (; c[i] === 0; c.pop(), i--) ;
          if (i < 0) c = [e = 0];
          else {
            for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE) ;
            for (i = 1, v = c[0]; v >= 10; v /= 10, i++) ;
            if (i < LOG_BASE) e -= LOG_BASE - i;
          }
          rand.e = e;
          rand.c = c;
          return rand;
        };
      }();
      BigNumber$1.sum = function() {
        var i = 1, args = arguments, sum = new BigNumber$1(args[0]);
        for (; i < args.length; ) sum = sum.plus(args[i++]);
        return sum;
      };
      convertBase = /* @__PURE__ */ function() {
        var decimal = "0123456789";
        function toBaseOut(str, baseIn, baseOut, alphabet$1) {
          var j, arr = [0], arrL, i = 0, len = str.length;
          for (; i < len; ) {
            for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
            arr[0] += alphabet$1.indexOf(str.charAt(i++));
            for (j = 0; j < arr.length; j++) if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
          return arr.reverse();
        }
        return function(str, baseIn, baseOut, sign$1, callerIsToString) {
          var alphabet$1, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
          if (i >= 0) {
            k = POW_PRECISION;
            POW_PRECISION = 0;
            str = str.replace(".", "");
            y = new BigNumber$1(baseIn);
            x = y.pow(str.length - i);
            POW_PRECISION = k;
            y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, "0"), 10, baseOut, decimal);
            y.e = y.c.length;
          }
          xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet$1 = ALPHABET$12, decimal) : (alphabet$1 = decimal, ALPHABET$12));
          e = k = xc.length;
          for (; xc[--k] == 0; xc.pop()) ;
          if (!xc[0]) return alphabet$1.charAt(0);
          if (i < 0) --e;
          else {
            x.c = xc;
            x.e = e;
            x.s = sign$1;
            x = div(x, y, dp, rm, baseOut);
            xc = x.c;
            r = x.r;
            e = x.e;
          }
          d = e + dp + 1;
          i = xc[d];
          k = baseOut / 2;
          r = r || d < 0 || xc[d + 1] != null;
          r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
          if (d < 1 || !xc[0]) str = r ? toFixedPoint(alphabet$1.charAt(1), -dp, alphabet$1.charAt(0)) : alphabet$1.charAt(0);
          else {
            xc.length = d;
            if (r) for (--baseOut; ++xc[--d] > baseOut; ) {
              xc[d] = 0;
              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
            for (k = xc.length; !xc[--k]; ) ;
            for (i = 0, str = ""; i <= k; str += alphabet$1.charAt(xc[i++])) ;
            str = toFixedPoint(str, e, alphabet$1.charAt(0));
          }
          return str;
        };
      }();
      div = /* @__PURE__ */ function() {
        function multiply(x, k, base$12) {
          var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
          for (x = x.slice(); i--; ) {
            xlo = x[i] % SQRT_BASE;
            xhi = x[i] / SQRT_BASE | 0;
            m = khi * xlo + xhi * klo;
            temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
            carry = (temp / base$12 | 0) + (m / SQRT_BASE | 0) + khi * xhi;
            x[i] = temp % base$12;
          }
          if (carry) x = [carry].concat(x);
          return x;
        }
        function compare$3(a, b, aL, bL) {
          var i, cmp;
          if (aL != bL) cmp = aL > bL ? 1 : -1;
          else for (i = cmp = 0; i < aL; i++) if (a[i] != b[i]) {
            cmp = a[i] > b[i] ? 1 : -1;
            break;
          }
          return cmp;
        }
        function subtract(a, b, aL, base$12) {
          var i = 0;
          for (; aL--; ) {
            a[aL] -= i;
            i = a[aL] < b[aL] ? 1 : 0;
            a[aL] = i * base$12 + a[aL] - b[aL];
          }
          for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
        }
        return function(x, y, dp, rm, base$12) {
          var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
          if (!xc || !xc[0] || !yc || !yc[0]) return new BigNumber$1(!x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
          q = new BigNumber$1(s);
          qc = q.c = [];
          e = x.e - y.e;
          s = dp + e + 1;
          if (!base$12) {
            base$12 = BASE;
            e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
            s = s / LOG_BASE | 0;
          }
          for (i = 0; yc[i] == (xc[i] || 0); i++) ;
          if (yc[i] > (xc[i] || 0)) e--;
          if (s < 0) {
            qc.push(1);
            more = true;
          } else {
            xL = xc.length;
            yL = yc.length;
            i = 0;
            s += 2;
            n = mathfloor(base$12 / (yc[0] + 1));
            if (n > 1) {
              yc = multiply(yc, n, base$12);
              xc = multiply(xc, n, base$12);
              yL = yc.length;
              xL = xc.length;
            }
            xi = yL;
            rem = xc.slice(0, yL);
            remL = rem.length;
            for (; remL < yL; rem[remL++] = 0) ;
            yz = yc.slice();
            yz = [0].concat(yz);
            yc0 = yc[0];
            if (yc[1] >= base$12 / 2) yc0++;
            do {
              n = 0;
              cmp = compare$3(yc, rem, yL, remL);
              if (cmp < 0) {
                rem0 = rem[0];
                if (yL != remL) rem0 = rem0 * base$12 + (rem[1] || 0);
                n = mathfloor(rem0 / yc0);
                if (n > 1) {
                  if (n >= base$12) n = base$12 - 1;
                  prod = multiply(yc, n, base$12);
                  prodL = prod.length;
                  remL = rem.length;
                  while (compare$3(prod, rem, prodL, remL) == 1) {
                    n--;
                    subtract(prod, yL < prodL ? yz : yc, prodL, base$12);
                    prodL = prod.length;
                    cmp = 1;
                  }
                } else {
                  if (n == 0) cmp = n = 1;
                  prod = yc.slice();
                  prodL = prod.length;
                }
                if (prodL < remL) prod = [0].concat(prod);
                subtract(rem, prod, remL, base$12);
                remL = rem.length;
                if (cmp == -1) while (compare$3(yc, rem, yL, remL) < 1) {
                  n++;
                  subtract(rem, yL < remL ? yz : yc, remL, base$12);
                  remL = rem.length;
                }
              } else if (cmp === 0) {
                n++;
                rem = [0];
              }
              qc[i++] = n;
              if (rem[0]) rem[remL++] = xc[xi] || 0;
              else {
                rem = [xc[xi]];
                remL = 1;
              }
            } while ((xi++ < xL || rem[0] != null) && s--);
            more = rem[0] != null;
            if (!qc[0]) qc.splice(0, 1);
          }
          if (base$12 == BASE) {
            for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) ;
            round2(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
          } else {
            q.e = e;
            q.r = +more;
          }
          return q;
        };
      }();
      function format(n, i, rm, id) {
        var c0, e, ne, len, str;
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);
        if (!n.c) return n.toString();
        c0 = n.c[0];
        ne = n.e;
        if (i == null) {
          str = coeffToString(n.c);
          str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
        } else {
          n = round2(new BigNumber$1(n), i, rm);
          e = n.e;
          str = coeffToString(n.c);
          len = str.length;
          if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
            for (; len < i; str += "0", len++) ;
            str = toExponential(str, e);
          } else {
            i -= ne;
            str = toFixedPoint(str, e, "0");
            if (e + 1 > len) {
              if (--i > 0) for (str += "."; i--; str += "0") ;
            } else {
              i += e - len;
              if (i > 0) {
                if (e + 1 == len) str += ".";
                for (; i--; str += "0") ;
              }
            }
          }
        }
        return n.s < 0 && c0 ? "-" + str : str;
      }
      function maxOrMin(args, n) {
        var k, y, i = 1, x = new BigNumber$1(args[0]);
        for (; i < args.length; i++) {
          y = new BigNumber$1(args[i]);
          if (!y.s || (k = compare$2(x, y)) === n || k === 0 && x.s === n) x = y;
        }
        return x;
      }
      function normalise(n, c, e) {
        var i = 1, j = c.length;
        for (; !c[--j]; c.pop()) ;
        for (j = c[0]; j >= 10; j /= 10, i++) ;
        if ((e = i + e * LOG_BASE - 1) > MAX_EXP) n.c = n.e = null;
        else if (e < MIN_EXP) n.c = [n.e = 0];
        else {
          n.e = e;
          n.c = c;
        }
        return n;
      }
      parseNumeric = /* @__PURE__ */ function() {
        var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(x, str, isNum, b) {
          var base$12, s = isNum ? str : str.replace(whitespaceOrPlus, "");
          if (isInfinityOrNaN.test(s)) x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
          else {
            if (!isNum) {
              s = s.replace(basePrefix, function(m, p1, p2) {
                base$12 = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                return !b || b == base$12 ? p1 : m;
              });
              if (b) {
                base$12 = b;
                s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
              }
              if (str != s) return new BigNumber$1(s, base$12);
            }
            if (BigNumber$1.DEBUG) throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
            x.s = null;
          }
          x.c = x.e = null;
        };
      }();
      function round2(x, sd, rm, r) {
        var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
        if (xc) {
          out: {
            for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
            i = sd - d;
            if (i < 0) {
              i += LOG_BASE;
              j = sd;
              n = xc[ni = 0];
              rd = mathfloor(n / pows10[d - j - 1] % 10);
            } else {
              ni = mathceil((i + 1) / LOG_BASE);
              if (ni >= xc.length) if (r) {
                for (; xc.length <= ni; xc.push(0)) ;
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else break out;
              else {
                n = k = xc[ni];
                for (d = 1; k >= 10; k /= 10, d++) ;
                i %= LOG_BASE;
                j = i - LOG_BASE + d;
                rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
              }
            }
            r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
            r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
            if (sd < 1 || !xc[0]) {
              xc.length = 0;
              if (r) {
                sd -= x.e + 1;
                xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                x.e = -sd || 0;
              } else xc[0] = x.e = 0;
              return x;
            }
            if (i == 0) {
              xc.length = ni;
              k = 1;
              ni--;
            } else {
              xc.length = ni + 1;
              k = pows10[LOG_BASE - i];
              xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
            }
            if (r) for (; ; ) if (ni == 0) {
              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++) ;
              j = xc[0] += k;
              for (k = 1; j >= 10; j /= 10, k++) ;
              if (i != k) {
                x.e++;
                if (xc[0] == BASE) xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k;
              if (xc[ni] != BASE) break;
              xc[ni--] = 0;
              k = 1;
            }
            for (i = xc.length; xc[--i] === 0; xc.pop()) ;
          }
          if (x.e > MAX_EXP) x.c = x.e = null;
          else if (x.e < MIN_EXP) x.c = [x.e = 0];
        }
        return x;
      }
      function valueOf(n) {
        var str, e = n.e;
        if (e === null) return n.toString();
        str = coeffToString(n.c);
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
        return n.s < 0 ? "-" + str : str;
      }
      P.absoluteValue = P.abs = function() {
        var x = new BigNumber$1(this);
        if (x.s < 0) x.s = 1;
        return x;
      };
      P.comparedTo = function(y, b) {
        return compare$2(this, new BigNumber$1(y, b));
      };
      P.decimalPlaces = P.dp = function(dp, rm) {
        var c, n, v, x = this;
        if (dp != null) {
          intCheck(dp, 0, MAX);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round2(new BigNumber$1(x), dp + x.e + 1, rm);
        }
        if (!(c = x.c)) return null;
        n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
        if (v = c[v]) for (; v % 10 == 0; v /= 10, n--) ;
        if (n < 0) n = 0;
        return n;
      };
      P.dividedBy = P.div = function(y, b) {
        return div(this, new BigNumber$1(y, b), DECIMAL_PLACES, ROUNDING_MODE);
      };
      P.dividedToIntegerBy = P.idiv = function(y, b) {
        return div(this, new BigNumber$1(y, b), 0, 1);
      };
      P.exponentiatedBy = P.pow = function(n, m) {
        var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
        n = new BigNumber$1(n);
        if (n.c && !n.isInteger()) throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
        if (m != null) m = new BigNumber$1(m);
        nIsBig = n.e > 14;
        if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
          y = new BigNumber$1(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
          return m ? y.mod(m) : y;
        }
        nIsNeg = n.s < 0;
        if (m) {
          if (m.c ? !m.c[0] : !m.s) return new BigNumber$1(NaN);
          isModExp = !nIsNeg && x.isInteger() && m.isInteger();
          if (isModExp) x = x.mod(m);
        } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
          k = x.s < 0 && isOdd(n) ? -0 : 0;
          if (x.e > -1) k = 1 / k;
          return new BigNumber$1(nIsNeg ? 1 / k : k);
        } else if (POW_PRECISION) k = mathceil(POW_PRECISION / LOG_BASE + 2);
        if (nIsBig) {
          half = new BigNumber$1(0.5);
          if (nIsNeg) n.s = 1;
          nIsOdd = isOdd(n);
        } else {
          i = Math.abs(+valueOf(n));
          nIsOdd = i % 2;
        }
        y = new BigNumber$1(ONE);
        for (; ; ) {
          if (nIsOdd) {
            y = y.times(x);
            if (!y.c) break;
            if (k) {
              if (y.c.length > k) y.c.length = k;
            } else if (isModExp) y = y.mod(m);
          }
          if (i) {
            i = mathfloor(i / 2);
            if (i === 0) break;
            nIsOdd = i % 2;
          } else {
            n = n.times(half);
            round2(n, n.e + 1, 1);
            if (n.e > 14) nIsOdd = isOdd(n);
            else {
              i = +valueOf(n);
              if (i === 0) break;
              nIsOdd = i % 2;
            }
          }
          x = x.times(x);
          if (k) {
            if (x.c && x.c.length > k) x.c.length = k;
          } else if (isModExp) x = x.mod(m);
        }
        if (isModExp) return y;
        if (nIsNeg) y = ONE.div(y);
        return m ? y.mod(m) : k ? round2(y, POW_PRECISION, ROUNDING_MODE, more) : y;
      };
      P.integerValue = function(rm) {
        var n = new BigNumber$1(this);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);
        return round2(n, n.e + 1, rm);
      };
      P.isEqualTo = P.eq = function(y, b) {
        return compare$2(this, new BigNumber$1(y, b)) === 0;
      };
      P.isFinite = function() {
        return !!this.c;
      };
      P.isGreaterThan = P.gt = function(y, b) {
        return compare$2(this, new BigNumber$1(y, b)) > 0;
      };
      P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
        return (b = compare$2(this, new BigNumber$1(y, b))) === 1 || b === 0;
      };
      P.isInteger = function() {
        return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
      };
      P.isLessThan = P.lt = function(y, b) {
        return compare$2(this, new BigNumber$1(y, b)) < 0;
      };
      P.isLessThanOrEqualTo = P.lte = function(y, b) {
        return (b = compare$2(this, new BigNumber$1(y, b))) === -1 || b === 0;
      };
      P.isNaN = function() {
        return !this.s;
      };
      P.isNegative = function() {
        return this.s < 0;
      };
      P.isPositive = function() {
        return this.s > 0;
      };
      P.isZero = function() {
        return !!this.c && this.c[0] == 0;
      };
      P.minus = function(y, b) {
        var i, j, t, xLTy, x = this, a = x.s;
        y = new BigNumber$1(y, b);
        b = y.s;
        if (!a || !b) return new BigNumber$1(NaN);
        if (a != b) {
          y.s = -b;
          return x.plus(y);
        }
        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
        if (!xe || !ye) {
          if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber$1(yc ? x : NaN);
          if (!xc[0] || !yc[0]) return yc[0] ? (y.s = -b, y) : new BigNumber$1(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        if (a = xe - ye) {
          if (xLTy = a < 0) {
            a = -a;
            t = xc;
          } else {
            ye = xe;
            t = yc;
          }
          t.reverse();
          for (b = a; b--; t.push(0)) ;
          t.reverse();
        } else {
          j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
          for (a = b = 0; b < j; b++) if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
        if (xLTy) {
          t = xc;
          xc = yc;
          yc = t;
          y.s = -y.s;
        }
        b = (j = yc.length) - (i = xc.length);
        if (b > 0) for (; b--; xc[i++] = 0) ;
        b = BASE - 1;
        for (; j > a; ) {
          if (xc[--j] < yc[j]) {
            for (i = j; i && !xc[--i]; xc[i] = b) ;
            --xc[i];
            xc[j] += BASE;
          }
          xc[j] -= yc[j];
        }
        for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
        if (!xc[0]) {
          y.s = ROUNDING_MODE == 3 ? -1 : 1;
          y.c = [y.e = 0];
          return y;
        }
        return normalise(y, xc, ye);
      };
      P.modulo = P.mod = function(y, b) {
        var q, s, x = this;
        y = new BigNumber$1(y, b);
        if (!x.c || !y.s || y.c && !y.c[0]) return new BigNumber$1(NaN);
        else if (!y.c || x.c && !x.c[0]) return new BigNumber$1(x);
        if (MODULO_MODE == 9) {
          s = y.s;
          y.s = 1;
          q = div(x, y, 0, 3);
          y.s = s;
          q.s *= s;
        } else q = div(x, y, 0, MODULO_MODE);
        y = x.minus(q.times(y));
        if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
        return y;
      };
      P.multipliedBy = P.times = function(y, b) {
        var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base$12, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber$1(y, b)).c;
        if (!xc || !yc || !xc[0] || !yc[0]) {
          if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) y.c = y.e = y.s = null;
          else {
            y.s *= x.s;
            if (!xc || !yc) y.c = y.e = null;
            else {
              y.c = [0];
              y.e = 0;
            }
          }
          return y;
        }
        e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
        y.s *= x.s;
        xcL = xc.length;
        ycL = yc.length;
        if (xcL < ycL) {
          zc = xc;
          xc = yc;
          yc = zc;
          i = xcL;
          xcL = ycL;
          ycL = i;
        }
        for (i = xcL + ycL, zc = []; i--; zc.push(0)) ;
        base$12 = BASE;
        sqrtBase = SQRT_BASE;
        for (i = ycL; --i >= 0; ) {
          c = 0;
          ylo = yc[i] % sqrtBase;
          yhi = yc[i] / sqrtBase | 0;
          for (k = xcL, j = i + k; j > i; ) {
            xlo = xc[--k] % sqrtBase;
            xhi = xc[k] / sqrtBase | 0;
            m = yhi * xlo + xhi * ylo;
            xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
            c = (xlo / base$12 | 0) + (m / sqrtBase | 0) + yhi * xhi;
            zc[j--] = xlo % base$12;
          }
          zc[j] = c;
        }
        if (c) ++e;
        else zc.splice(0, 1);
        return normalise(y, zc, e);
      };
      P.negated = function() {
        var x = new BigNumber$1(this);
        x.s = -x.s || null;
        return x;
      };
      P.plus = function(y, b) {
        var t, x = this, a = x.s;
        y = new BigNumber$1(y, b);
        b = y.s;
        if (!a || !b) return new BigNumber$1(NaN);
        if (a != b) {
          y.s = -b;
          return x.minus(y);
        }
        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
        if (!xe || !ye) {
          if (!xc || !yc) return new BigNumber$1(a / 0);
          if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber$1(xc[0] ? x : a * 0);
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        if (a = xe - ye) {
          if (a > 0) {
            ye = xe;
            t = yc;
          } else {
            a = -a;
            t = xc;
          }
          t.reverse();
          for (; a--; t.push(0)) ;
          t.reverse();
        }
        a = xc.length;
        b = yc.length;
        if (a - b < 0) {
          t = yc;
          yc = xc;
          xc = t;
          b = a;
        }
        for (a = 0; b; ) {
          a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
          xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
        }
        if (a) {
          xc = [a].concat(xc);
          ++ye;
        }
        return normalise(y, xc, ye);
      };
      P.precision = P.sd = function(sd, rm) {
        var c, n, v, x = this;
        if (sd != null && sd !== !!sd) {
          intCheck(sd, 1, MAX);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round2(new BigNumber$1(x), sd, rm);
        }
        if (!(c = x.c)) return null;
        v = c.length - 1;
        n = v * LOG_BASE + 1;
        if (v = c[v]) {
          for (; v % 10 == 0; v /= 10, n--) ;
          for (v = c[0]; v >= 10; v /= 10, n++) ;
        }
        if (sd && x.e + 1 > n) n = x.e + 1;
        return n;
      };
      P.shiftedBy = function(k) {
        intCheck(k, -9007199254740991, MAX_SAFE_INTEGER$1);
        return this.times("1e" + k);
      };
      P.squareRoot = P.sqrt = function() {
        var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber$1("0.5");
        if (s !== 1 || !c || !c[0]) return new BigNumber$1(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : Infinity);
        s = Math.sqrt(+valueOf(x));
        if (s == 0 || s == Infinity) {
          n = coeffToString(c);
          if ((n.length + e) % 2 == 0) n += "0";
          s = Math.sqrt(+n);
          e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
          if (s == Infinity) n = "5e" + e;
          else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new BigNumber$1(n);
        } else r = new BigNumber$1(s + "");
        if (r.c[0]) {
          e = r.e;
          s = e + dp;
          if (s < 3) s = 0;
          for (; ; ) {
            t = r;
            r = half.times(t.plus(div(x, t, dp, 1)));
            if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
              if (r.e < e) --s;
              n = n.slice(s - 3, s + 1);
              if (n == "9999" || !rep && n == "4999") {
                if (!rep) {
                  round2(t, t.e + DECIMAL_PLACES + 2, 0);
                  if (t.times(t).eq(x)) {
                    r = t;
                    break;
                  }
                }
                dp += 4;
                s += 4;
                rep = 1;
              } else {
                if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                  round2(r, r.e + DECIMAL_PLACES + 2, 1);
                  m = !r.times(r).eq(x);
                }
                break;
              }
            }
          }
        }
        return round2(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
      };
      P.toExponential = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp++;
        }
        return format(this, dp, rm, 1);
      };
      P.toFixed = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp = dp + this.e + 1;
        }
        return format(this, dp, rm);
      };
      P.toFormat = function(dp, rm, format$1) {
        var str, x = this;
        if (format$1 == null) if (dp != null && rm && typeof rm == "object") {
          format$1 = rm;
          rm = null;
        } else if (dp && typeof dp == "object") {
          format$1 = dp;
          dp = rm = null;
        } else format$1 = FORMAT;
        else if (typeof format$1 != "object") throw Error(bignumberError + "Argument not an object: " + format$1);
        str = x.toFixed(dp, rm);
        if (x.c) {
          var i, arr = str.split("."), g1 = +format$1.groupSize, g2 = +format$1.secondaryGroupSize, groupSeparator = format$1.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
          if (g2) {
            i = g1;
            g1 = g2;
            g2 = i;
            len -= i;
          }
          if (g1 > 0 && len > 0) {
            i = len % g1 || g1;
            intPart = intDigits.substr(0, i);
            for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
            if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
            if (isNeg) intPart = "-" + intPart;
          }
          str = fractionPart ? intPart + (format$1.decimalSeparator || "") + ((g2 = +format$1.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + (format$1.fractionGroupSeparator || "")) : fractionPart) : intPart;
        }
        return (format$1.prefix || "") + str + (format$1.suffix || "");
      };
      P.toFraction = function(md) {
        var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
        if (md != null) {
          n = new BigNumber$1(md);
          if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
        }
        if (!xc) return new BigNumber$1(x);
        d = new BigNumber$1(ONE);
        n1 = d0 = new BigNumber$1(ONE);
        d1 = n0 = new BigNumber$1(ONE);
        s = coeffToString(xc);
        e = d.e = s.length - x.e - 1;
        d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
        md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
        exp = MAX_EXP;
        MAX_EXP = Infinity;
        n = new BigNumber$1(s);
        n0.c[0] = 0;
        for (; ; ) {
          q = div(n, d, 0, 1);
          d2 = d0.plus(q.times(d1));
          if (d2.comparedTo(md) == 1) break;
          d0 = d1;
          d1 = d2;
          n1 = n0.plus(q.times(d2 = n1));
          n0 = d2;
          d = n.minus(q.times(d2 = d));
          n = d2;
        }
        d2 = div(md.minus(d0), d1, 0, 1);
        n0 = n0.plus(d2.times(n1));
        d0 = d0.plus(d2.times(d1));
        n0.s = n1.s = x.s;
        e = e * 2;
        r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
        MAX_EXP = exp;
        return r;
      };
      P.toNumber = function() {
        return +valueOf(this);
      };
      P.toPrecision = function(sd, rm) {
        if (sd != null) intCheck(sd, 1, MAX);
        return format(this, sd, rm, 2);
      };
      P.toString = function(b) {
        var str, n = this, s = n.s, e = n.e;
        if (e === null) if (s) {
          str = "Infinity";
          if (s < 0) str = "-" + str;
        } else str = "NaN";
        else {
          if (b == null) str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
          else if (b === 10 && alphabetHasNormalDecimalDigits) {
            n = round2(new BigNumber$1(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
            str = toFixedPoint(coeffToString(n.c), n.e, "0");
          } else {
            intCheck(b, 2, ALPHABET$12.length, "Base");
            str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
          }
          if (s < 0 && n.c[0]) str = "-" + str;
        }
        return str;
      };
      P.valueOf = P.toJSON = function() {
        return valueOf(this);
      };
      P._isBigNumber = true;
      if (configObject != null) BigNumber$1.set(configObject);
      return BigNumber$1;
    }
    function bitFloor(n) {
      var i = n | 0;
      return n > 0 || n === i ? i : i - 1;
    }
    function coeffToString(a) {
      var s, z2, i = 1, j = a.length, r = a[0] + "";
      for (; i < j; ) {
        s = a[i++] + "";
        z2 = LOG_BASE - s.length;
        for (; z2--; s = "0" + s) ;
        r += s;
      }
      for (j = r.length; r.charCodeAt(--j) === 48; ) ;
      return r.slice(0, j + 1 || 1);
    }
    function compare$2(x, y) {
      var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
      if (!i || !j) return null;
      a = xc && !xc[0];
      b = yc && !yc[0];
      if (a || b) return a ? b ? 0 : -j : i;
      if (i != j) return i;
      a = i < 0;
      b = k == l;
      if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
      if (!b) return k > l ^ a ? 1 : -1;
      j = (k = xc.length) < (l = yc.length) ? k : l;
      for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
      return k == l ? 0 : k > l ^ a ? 1 : -1;
    }
    function intCheck(n, min2, max2, name) {
      if (n < min2 || n > max2 || n !== mathfloor(n)) throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min2 || n > max2 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
    }
    function isOdd(n) {
      var k = n.c.length - 1;
      return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
    }
    function toExponential(str, e) {
      return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
    }
    function toFixedPoint(str, e, z2) {
      var len, zs;
      if (e < 0) {
        for (zs = z2 + "."; ++e; zs += z2) ;
        str = zs + str;
      } else {
        len = str.length;
        if (++e > len) {
          for (zs = z2, e -= len; --e; zs += z2) ;
          str += zs;
        } else if (e < len) str = str.slice(0, e) + "." + str.slice(e);
      }
      return str;
    }
    BigNumber = clone();
    BigNumber["default"] = BigNumber.BigNumber = BigNumber;
    if (typeof define == "function" && define.amd) define(function() {
      return BigNumber;
    });
    else if (typeof module != "undefined" && module.exports) module.exports = BigNumber;
    else {
      if (!globalObject) globalObject = typeof self != "undefined" && self ? self : window;
      globalObject.BigNumber = BigNumber;
    }
  })(void 0);
} });
var require_hash_192 = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/hash-192.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Hash192 = void 0;
  const hash_1$2 = require_hash();
  var Hash192 = class Hash1922 extends hash_1$2.Hash {
    constructor(bytes$1) {
      if (bytes$1 && bytes$1.byteLength === 0) bytes$1 = Hash1922.ZERO_192.bytes;
      super(bytes$1 !== null && bytes$1 !== void 0 ? bytes$1 : Hash1922.ZERO_192.bytes);
    }
  };
  exports.Hash192 = Hash192;
  Hash192.width = 24;
  Hash192.ZERO_192 = new Hash192(new Uint8Array(Hash192.width));
} });
var require_amount = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/amount.js"(exports) {
  var __importDefault$21 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Amount = void 0;
  const binary_parser_1$7 = require_binary_parser();
  const account_id_1$4 = require_account_id();
  const currency_1$3 = require_currency();
  const serialized_type_1$8 = require_serialized_type();
  const bignumber_js_1$13 = __importDefault$21(require_bignumber());
  const utils_1$44 = require_browser$4();
  const utils_2$5 = require_utils$5$1();
  const hash_192_1$2 = require_hash_192();
  const MIN_IOU_EXPONENT = -96;
  const MAX_IOU_EXPONENT = 80;
  const MAX_IOU_PRECISION = 16;
  const MAX_DROPS = new bignumber_js_1$13.default("1e17");
  const MIN_XRP = new bignumber_js_1$13.default("1e-6");
  const mask$1 = BigInt(4294967295);
  const mptMask = BigInt(9223372036854776e3);
  bignumber_js_1$13.default.config({ EXPONENTIAL_AT: [MIN_IOU_EXPONENT - MAX_IOU_PRECISION, MAX_IOU_EXPONENT + MAX_IOU_PRECISION] });
  function isAmountObjectIOU(arg) {
    const keys2 = Object.keys(arg).sort();
    return keys2.length === 3 && keys2[0] === "currency" && keys2[1] === "issuer" && keys2[2] === "value";
  }
  function isAmountObjectMPT(arg) {
    const keys2 = Object.keys(arg).sort();
    return keys2.length === 2 && keys2[0] === "mpt_issuance_id" && keys2[1] === "value";
  }
  var Amount = class Amount2 extends serialized_type_1$8.SerializedType {
    constructor(bytes$1) {
      super(bytes$1 !== null && bytes$1 !== void 0 ? bytes$1 : Amount2.defaultAmount.bytes);
    }
    /**
    * Construct an amount from an IOU, MPT or string amount
    *
    * @param value An Amount, object representing an IOU, or a string
    *     representing an integer amount
    * @returns An Amount object
    */
    static from(value) {
      if (value instanceof Amount2) return value;
      let amount = new Uint8Array(8);
      if (typeof value === "string") {
        Amount2.assertXrpIsValid(value);
        const number = BigInt(value);
        const intBuf = [new Uint8Array(4), new Uint8Array(4)];
        (0, utils_2$5.writeUInt32BE)(intBuf[0], Number(number >> BigInt(32)), 0);
        (0, utils_2$5.writeUInt32BE)(intBuf[1], Number(number & BigInt(mask$1)), 0);
        amount = (0, utils_1$44.concat)(intBuf);
        amount[0] |= 64;
        return new Amount2(amount);
      }
      if (isAmountObjectIOU(value)) {
        const number = new bignumber_js_1$13.default(value.value);
        Amount2.assertIouIsValid(number);
        if (number.isZero()) amount[0] |= 128;
        else {
          const integerNumberString = number.times(`1e${-((number.e || 0) - 15)}`).abs().toString();
          const num$1 = BigInt(integerNumberString);
          const intBuf = [new Uint8Array(4), new Uint8Array(4)];
          (0, utils_2$5.writeUInt32BE)(intBuf[0], Number(num$1 >> BigInt(32)), 0);
          (0, utils_2$5.writeUInt32BE)(intBuf[1], Number(num$1 & BigInt(mask$1)), 0);
          amount = (0, utils_1$44.concat)(intBuf);
          amount[0] |= 128;
          if (number.gt(new bignumber_js_1$13.default(0))) amount[0] |= 64;
          const exponent = (number.e || 0) - 15;
          const exponentByte = 97 + exponent;
          amount[0] |= exponentByte >>> 2;
          amount[1] |= (exponentByte & 3) << 6;
        }
        const currency = currency_1$3.Currency.from(value.currency).toBytes();
        const issuer = account_id_1$4.AccountID.from(value.issuer).toBytes();
        return new Amount2((0, utils_1$44.concat)([
          amount,
          currency,
          issuer
        ]));
      }
      if (isAmountObjectMPT(value)) {
        Amount2.assertMptIsValid(value.value);
        let leadingByte = new Uint8Array(1);
        leadingByte[0] |= 96;
        const num$1 = BigInt(value.value);
        const intBuf = [new Uint8Array(4), new Uint8Array(4)];
        (0, utils_2$5.writeUInt32BE)(intBuf[0], Number(num$1 >> BigInt(32)), 0);
        (0, utils_2$5.writeUInt32BE)(intBuf[1], Number(num$1 & BigInt(mask$1)), 0);
        amount = (0, utils_1$44.concat)(intBuf);
        const mptIssuanceID = hash_192_1$2.Hash192.from(value.mpt_issuance_id).toBytes();
        return new Amount2((0, utils_1$44.concat)([
          leadingByte,
          amount,
          mptIssuanceID
        ]));
      }
      throw new Error("Invalid type to construct an Amount");
    }
    /**
    * Read an amount from a BinaryParser
    *
    * @param parser BinaryParser to read the Amount from
    * @returns An Amount object
    */
    static fromParser(parser) {
      const isIOU = parser.peek() & 128;
      if (isIOU) return new Amount2(parser.read(48));
      const isMPT = parser.peek() & 32;
      const numBytes = isMPT ? 33 : 8;
      return new Amount2(parser.read(numBytes));
    }
    /**
    * Get the JSON representation of this Amount
    *
    * @returns the JSON interpretation of this.bytes
    */
    toJSON() {
      if (this.isNative()) {
        const bytes$1 = this.bytes;
        const isPositive = bytes$1[0] & 64;
        const sign$1 = isPositive ? "" : "-";
        bytes$1[0] &= 63;
        const msb = BigInt((0, utils_2$5.readUInt32BE)(bytes$1.slice(0, 4), 0));
        const lsb = BigInt((0, utils_2$5.readUInt32BE)(bytes$1.slice(4), 0));
        const num$1 = msb << BigInt(32) | lsb;
        return `${sign$1}${num$1.toString()}`;
      }
      if (this.isIOU()) {
        const parser = new binary_parser_1$7.BinaryParser(this.toString());
        const mantissa = parser.read(8);
        const currency = currency_1$3.Currency.fromParser(parser);
        const issuer = account_id_1$4.AccountID.fromParser(parser);
        const b1 = mantissa[0];
        const b2 = mantissa[1];
        const isPositive = b1 & 64;
        const sign$1 = isPositive ? "" : "-";
        const exponent = ((b1 & 63) << 2) + ((b2 & 255) >> 6) - 97;
        mantissa[0] = 0;
        mantissa[1] &= 63;
        const value = new bignumber_js_1$13.default(`${sign$1}0x${(0, utils_1$44.bytesToHex)(mantissa)}`).times(`1e${exponent}`);
        Amount2.assertIouIsValid(value);
        return {
          value: value.toString(),
          currency: currency.toJSON(),
          issuer: issuer.toJSON()
        };
      }
      if (this.isMPT()) {
        const parser = new binary_parser_1$7.BinaryParser(this.toString());
        const leadingByte = parser.read(1);
        const amount = parser.read(8);
        const mptID = hash_192_1$2.Hash192.fromParser(parser);
        const isPositive = leadingByte[0] & 64;
        const sign$1 = isPositive ? "" : "-";
        const msb = BigInt((0, utils_2$5.readUInt32BE)(amount.slice(0, 4), 0));
        const lsb = BigInt((0, utils_2$5.readUInt32BE)(amount.slice(4), 0));
        const num$1 = msb << BigInt(32) | lsb;
        return {
          value: `${sign$1}${num$1.toString()}`,
          mpt_issuance_id: mptID.toString()
        };
      }
      throw new Error("Invalid amount to construct JSON");
    }
    /**
    * Validate XRP amount
    *
    * @param amount String representing XRP amount
    * @returns void, but will throw if invalid amount
    */
    static assertXrpIsValid(amount) {
      if (amount.indexOf(".") !== -1) throw new Error(`${amount.toString()} is an illegal amount`);
      const decimal = new bignumber_js_1$13.default(amount);
      if (!decimal.isZero()) {
        if (decimal.lt(MIN_XRP) || decimal.gt(MAX_DROPS)) throw new Error(`${amount.toString()} is an illegal amount`);
      }
    }
    /**
    * Validate IOU.value amount
    *
    * @param decimal BigNumber object representing IOU.value
    * @returns void, but will throw if invalid amount
    */
    static assertIouIsValid(decimal) {
      if (!decimal.isZero()) {
        const p = decimal.precision();
        const e = (decimal.e || 0) - 15;
        if (p > MAX_IOU_PRECISION || e > MAX_IOU_EXPONENT || e < MIN_IOU_EXPONENT) throw new Error("Decimal precision out of range");
        this.verifyNoDecimal(decimal);
      }
    }
    /**
    * Validate MPT.value amount
    *
    * @param decimal BigNumber object representing MPT.value
    * @returns void, but will throw if invalid amount
    */
    static assertMptIsValid(amount) {
      if (amount.indexOf(".") !== -1) throw new Error(`${amount.toString()} is an illegal amount`);
      const decimal = new bignumber_js_1$13.default(amount);
      if (!decimal.isZero()) {
        if (decimal < (0, bignumber_js_1$13.default)(0)) throw new Error(`${amount.toString()} is an illegal amount`);
        if (Number(BigInt(amount) & BigInt(mptMask)) != 0) throw new Error(`${amount.toString()} is an illegal amount`);
      }
    }
    /**
    * Ensure that the value after being multiplied by the exponent does not
    * contain a decimal.
    *
    * @param decimal a Decimal object
    * @returns a string of the object without a decimal
    */
    static verifyNoDecimal(decimal) {
      const integerNumberString = decimal.times(`1e${-((decimal.e || 0) - 15)}`).abs().toString();
      if (integerNumberString.indexOf(".") !== -1) throw new Error("Decimal place found in integerNumberString");
    }
    /**
    * Test if this amount is in units of Native Currency(XRP)
    *
    * @returns true if Native (XRP)
    */
    isNative() {
      return (this.bytes[0] & 128) === 0 && (this.bytes[0] & 32) === 0;
    }
    /**
    * Test if this amount is in units of MPT
    *
    * @returns true if MPT
    */
    isMPT() {
      return (this.bytes[0] & 128) === 0 && (this.bytes[0] & 32) !== 0;
    }
    /**
    * Test if this amount is in units of IOU
    *
    * @returns true if IOU
    */
    isIOU() {
      return (this.bytes[0] & 128) !== 0;
    }
  };
  exports.Amount = Amount;
  Amount.defaultAmount = new Amount((0, utils_1$44.hexToBytes)("4000000000000000"));
} });
var require_blob = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/blob.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Blob = void 0;
  const serialized_type_1$7 = require_serialized_type();
  const utils_1$43 = require_browser$4();
  var Blob2 = class Blob3 extends serialized_type_1$7.SerializedType {
    constructor(bytes$1) {
      super(bytes$1);
    }
    /**
    * Defines how to read a Blob from a BinaryParser
    *
    * @param parser The binary parser to read the Blob from
    * @param hint The length of the blob, computed by readVariableLengthLength() and passed in
    * @returns A Blob object
    */
    static fromParser(parser, hint) {
      return new Blob3(parser.read(hint));
    }
    /**
    * Create a Blob object from a hex-string
    *
    * @param value existing Blob object or a hex-string
    * @returns A Blob object
    */
    static from(value) {
      if (value instanceof Blob3) return value;
      if (typeof value === "string") {
        if (!/^[A-F0-9]*$/iu.test(value)) throw new Error("Cannot construct Blob from a non-hex string");
        return new Blob3((0, utils_1$43.hexToBytes)(value));
      }
      throw new Error("Cannot construct Blob from value given");
    }
  };
  exports.Blob = Blob2;
} });
var require_hash_128 = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/hash-128.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Hash128 = void 0;
  const hash_1$1 = require_hash();
  const utils_1$42 = require_browser$4();
  var Hash128 = class Hash1282 extends hash_1$1.Hash {
    constructor(bytes$1) {
      if (bytes$1 && bytes$1.byteLength === 0) bytes$1 = Hash1282.ZERO_128.bytes;
      super(bytes$1 !== null && bytes$1 !== void 0 ? bytes$1 : Hash1282.ZERO_128.bytes);
    }
    /**
    * Get the hex representation of a hash-128 bytes, allowing unset
    *
    * @returns hex String of this.bytes
    */
    toHex() {
      const hex = (0, utils_1$42.bytesToHex)(this.toBytes());
      if (/^0+$/.exec(hex)) return "";
      return hex;
    }
  };
  exports.Hash128 = Hash128;
  Hash128.width = 16;
  Hash128.ZERO_128 = new Hash128(new Uint8Array(Hash128.width));
} });
var require_hash_256 = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/hash-256.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Hash256 = void 0;
  const hash_1 = require_hash();
  var Hash256 = class Hash2562 extends hash_1.Hash {
    constructor(bytes$1) {
      super(bytes$1 !== null && bytes$1 !== void 0 ? bytes$1 : Hash2562.ZERO_256.bytes);
    }
  };
  exports.Hash256 = Hash256;
  Hash256.width = 32;
  Hash256.ZERO_256 = new Hash256(new Uint8Array(Hash256.width));
} });
var require_issue = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/issue.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Issue = void 0;
  const utils_1$41 = require_browser$4();
  const binary_parser_1$6 = require_binary_parser();
  const account_id_1$3 = require_account_id();
  const currency_1$2 = require_currency();
  const serialized_type_1$6 = require_serialized_type();
  const hash_192_1$1 = require_hash_192();
  function isIssueObject(arg) {
    const keys2 = Object.keys(arg).sort();
    const isXRP = keys2.length === 1 && keys2[0] === "currency";
    const isIOU = keys2.length === 2 && keys2[0] === "currency" && keys2[1] === "issuer";
    const isMPT = keys2.length === 1 && keys2[0] === "mpt_issuance_id";
    return isXRP || isIOU || isMPT;
  }
  var Issue = class Issue2 extends serialized_type_1$6.SerializedType {
    constructor(bytes$1) {
      super(bytes$1 !== null && bytes$1 !== void 0 ? bytes$1 : Issue2.ZERO_ISSUED_CURRENCY.bytes);
    }
    /**
    * Construct an amount from an IOU or string amount
    *
    * @param value An Amount, object representing an IOU, MPTAmount, or a string
    *     representing an integer amount
    * @returns An Issue object
    */
    static from(value) {
      if (value instanceof Issue2) return value;
      if (isIssueObject(value)) {
        if (value.currency) {
          const currency = currency_1$2.Currency.from(value.currency.toString()).toBytes();
          if (value.issuer) {
            const issuer = account_id_1$3.AccountID.from(value.issuer.toString()).toBytes();
            return new Issue2((0, utils_1$41.concat)([currency, issuer]));
          }
          return new Issue2(currency);
        }
        if (value.mpt_issuance_id) {
          const mptIssuanceIdBytes = hash_192_1$1.Hash192.from(value.mpt_issuance_id.toString()).toBytes();
          return new Issue2(mptIssuanceIdBytes);
        }
      }
      throw new Error("Invalid type to construct an Amount");
    }
    /**
    * Read an amount from a BinaryParser
    *
    * @param parser BinaryParser to read the Amount from
    * @param hint The number of bytes to consume from the parser.
    * For an MPT amount, pass 24 (the fixed length for Hash192).
    *
    * @returns An Issue object
    */
    static fromParser(parser, hint) {
      if (hint === hash_192_1$1.Hash192.width) {
        const mptBytes = parser.read(hash_192_1$1.Hash192.width);
        return new Issue2(mptBytes);
      }
      const currency = parser.read(20);
      if (new currency_1$2.Currency(currency).toJSON() === "XRP") return new Issue2(currency);
      const currencyAndIssuer = [currency, parser.read(20)];
      return new Issue2((0, utils_1$41.concat)(currencyAndIssuer));
    }
    /**
    * Get the JSON representation of this Amount
    *
    * @returns the JSON interpretation of this.bytes
    */
    toJSON() {
      if (this.toBytes().length === hash_192_1$1.Hash192.width) return { mpt_issuance_id: this.toHex().toUpperCase() };
      const parser = new binary_parser_1$6.BinaryParser(this.toString());
      const currency = currency_1$2.Currency.fromParser(parser);
      if (currency.toJSON() === "XRP") return { currency: currency.toJSON() };
      const issuer = account_id_1$3.AccountID.fromParser(parser);
      return {
        currency: currency.toJSON(),
        issuer: issuer.toJSON()
      };
    }
  };
  exports.Issue = Issue;
  Issue.ZERO_ISSUED_CURRENCY = new Issue(new Uint8Array(20));
} });
var require_path_set = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/path-set.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PathSet = void 0;
  const account_id_1$2 = require_account_id();
  const currency_1$1 = require_currency();
  const binary_parser_1$5 = require_binary_parser();
  const serialized_type_1$5 = require_serialized_type();
  const utils_1$40 = require_browser$4();
  const PATHSET_END_BYTE = 0;
  const PATH_SEPARATOR_BYTE = 255;
  const TYPE_ACCOUNT = 1;
  const TYPE_CURRENCY = 16;
  const TYPE_ISSUER = 32;
  function isHopObject(arg) {
    return arg.issuer !== void 0 || arg.account !== void 0 || arg.currency !== void 0;
  }
  function isPathSet(arg) {
    return Array.isArray(arg) && arg.length === 0 || Array.isArray(arg) && Array.isArray(arg[0]) && arg[0].length === 0 || Array.isArray(arg) && Array.isArray(arg[0]) && isHopObject(arg[0][0]);
  }
  var Hop = class Hop2 extends serialized_type_1$5.SerializedType {
    /**
    * Create a Hop from a HopObject
    *
    * @param value Either a hop or HopObject to create a hop with
    * @returns a Hop
    */
    static from(value) {
      if (value instanceof Hop2) return value;
      const bytes$1 = [Uint8Array.from([0])];
      if (value.account) {
        bytes$1.push(account_id_1$2.AccountID.from(value.account).toBytes());
        bytes$1[0][0] |= TYPE_ACCOUNT;
      }
      if (value.currency) {
        bytes$1.push(currency_1$1.Currency.from(value.currency).toBytes());
        bytes$1[0][0] |= TYPE_CURRENCY;
      }
      if (value.issuer) {
        bytes$1.push(account_id_1$2.AccountID.from(value.issuer).toBytes());
        bytes$1[0][0] |= TYPE_ISSUER;
      }
      return new Hop2((0, utils_1$40.concat)(bytes$1));
    }
    /**
    * Construct a Hop from a BinaryParser
    *
    * @param parser BinaryParser to read the Hop from
    * @returns a Hop
    */
    static fromParser(parser) {
      const type2 = parser.readUInt8();
      const bytes$1 = [Uint8Array.from([type2])];
      if (type2 & TYPE_ACCOUNT) bytes$1.push(parser.read(account_id_1$2.AccountID.width));
      if (type2 & TYPE_CURRENCY) bytes$1.push(parser.read(currency_1$1.Currency.width));
      if (type2 & TYPE_ISSUER) bytes$1.push(parser.read(account_id_1$2.AccountID.width));
      return new Hop2((0, utils_1$40.concat)(bytes$1));
    }
    /**
    * Get the JSON interpretation of this hop
    *
    * @returns a HopObject, an JS object with optional account, issuer, and currency
    */
    toJSON() {
      const hopParser = new binary_parser_1$5.BinaryParser((0, utils_1$40.bytesToHex)(this.bytes));
      const type2 = hopParser.readUInt8();
      let account, currency, issuer;
      if (type2 & TYPE_ACCOUNT) account = account_id_1$2.AccountID.fromParser(hopParser).toJSON();
      if (type2 & TYPE_CURRENCY) currency = currency_1$1.Currency.fromParser(hopParser).toJSON();
      if (type2 & TYPE_ISSUER) issuer = account_id_1$2.AccountID.fromParser(hopParser).toJSON();
      const result = {};
      if (account) result.account = account;
      if (issuer) result.issuer = issuer;
      if (currency) result.currency = currency;
      return result;
    }
    /**
    * get a number representing the type of this hop
    *
    * @returns a number to be bitwise and-ed with TYPE_ constants to describe the types in the hop
    */
    type() {
      return this.bytes[0];
    }
  };
  var Path = class Path2 extends serialized_type_1$5.SerializedType {
    /**
    * construct a Path from an array of Hops
    *
    * @param value Path or array of HopObjects to construct a Path
    * @returns the Path
    */
    static from(value) {
      if (value instanceof Path2) return value;
      const bytes$1 = [];
      value.forEach((hop) => {
        bytes$1.push(Hop.from(hop).toBytes());
      });
      return new Path2((0, utils_1$40.concat)(bytes$1));
    }
    /**
    * Read a Path from a BinaryParser
    *
    * @param parser BinaryParser to read Path from
    * @returns the Path represented by the bytes read from the BinaryParser
    */
    static fromParser(parser) {
      const bytes$1 = [];
      while (!parser.end()) {
        bytes$1.push(Hop.fromParser(parser).toBytes());
        if (parser.peek() === PATHSET_END_BYTE || parser.peek() === PATH_SEPARATOR_BYTE) break;
      }
      return new Path2((0, utils_1$40.concat)(bytes$1));
    }
    /**
    * Get the JSON representation of this Path
    *
    * @returns an Array of HopObject constructed from this.bytes
    */
    toJSON() {
      const json = [];
      const pathParser = new binary_parser_1$5.BinaryParser(this.toString());
      while (!pathParser.end()) json.push(Hop.fromParser(pathParser).toJSON());
      return json;
    }
  };
  var PathSet = class PathSet2 extends serialized_type_1$5.SerializedType {
    /**
    * Construct a PathSet from an Array of Arrays representing paths
    *
    * @param value A PathSet or Array of Array of HopObjects
    * @returns the PathSet constructed from value
    */
    static from(value) {
      if (value instanceof PathSet2) return value;
      if (isPathSet(value)) {
        const bytes$1 = [];
        value.forEach((path) => {
          bytes$1.push(Path.from(path).toBytes());
          bytes$1.push(Uint8Array.from([PATH_SEPARATOR_BYTE]));
        });
        bytes$1[bytes$1.length - 1] = Uint8Array.from([PATHSET_END_BYTE]);
        return new PathSet2((0, utils_1$40.concat)(bytes$1));
      }
      throw new Error("Cannot construct PathSet from given value");
    }
    /**
    * Construct a PathSet from a BinaryParser
    *
    * @param parser A BinaryParser to read PathSet from
    * @returns the PathSet read from parser
    */
    static fromParser(parser) {
      const bytes$1 = [];
      while (!parser.end()) {
        bytes$1.push(Path.fromParser(parser).toBytes());
        bytes$1.push(parser.read(1));
        if (bytes$1[bytes$1.length - 1][0] == PATHSET_END_BYTE) break;
      }
      return new PathSet2((0, utils_1$40.concat)(bytes$1));
    }
    /**
    * Get the JSON representation of this PathSet
    *
    * @returns an Array of Array of HopObjects, representing this PathSet
    */
    toJSON() {
      const json = [];
      const pathParser = new binary_parser_1$5.BinaryParser(this.toString());
      while (!pathParser.end()) {
        json.push(Path.fromParser(pathParser).toJSON());
        pathParser.skip(1);
      }
      return json;
    }
  };
  exports.PathSet = PathSet;
} });
var require_uint = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/uint.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UInt = void 0;
  const serialized_type_1$4 = require_serialized_type();
  function compare(n1, n2) {
    return n1 < n2 ? -1 : n1 == n2 ? 0 : 1;
  }
  var UInt = class extends serialized_type_1$4.Comparable {
    constructor(bytes$1) {
      super(bytes$1);
    }
    /**
    * Overload of compareTo for Comparable
    *
    * @param other other UInt to compare this to
    * @returns -1, 0, or 1 depending on how the objects relate to each other
    */
    compareTo(other) {
      return compare(this.valueOf(), other.valueOf());
    }
    /**
    * Convert a UInt object to JSON
    *
    * @returns number or string represented by this.bytes
    */
    toJSON() {
      const val = this.valueOf();
      return typeof val === "number" ? val : val.toString();
    }
    static checkUintRange(val, min2, max2) {
      if (val < min2 || val > max2) throw new Error(`Invalid ${this.constructor.name}: ${val} must be >= ${min2} and <= ${max2}`);
    }
  };
  exports.UInt = UInt;
} });
var require_uint_64 = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/uint-64.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UInt64 = void 0;
  const uint_1$3 = require_uint();
  const utils_1$39 = require_browser$4();
  const utils_2$4 = require_utils$5$1();
  const enums_1$6 = require_enums();
  const HEX_REGEX$1 = /^[a-fA-F0-9]{1,16}$/;
  const BASE10_REGEX = /^[0-9]{1,20}$/;
  const mask = BigInt(4294967295);
  function useBase10(fieldName) {
    return fieldName === "MaximumAmount" || fieldName === "OutstandingAmount" || fieldName === "MPTAmount";
  }
  var UInt64 = class UInt642 extends uint_1$3.UInt {
    constructor(bytes$1) {
      super(bytes$1 !== null && bytes$1 !== void 0 ? bytes$1 : UInt642.defaultUInt64.bytes);
    }
    static fromParser(parser) {
      return new UInt642(parser.read(UInt642.width));
    }
    /**
    * Construct a UInt64 object
    *
    * @param val A UInt64, hex-string, bigInt, or number
    * @returns A UInt64 object
    */
    static from(val, fieldName = "") {
      if (val instanceof UInt642) return val;
      let buf = new Uint8Array(UInt642.width);
      if (typeof val === "number") {
        if (val < 0) throw new Error("value must be an unsigned integer");
        const number = BigInt(val);
        const intBuf = [new Uint8Array(4), new Uint8Array(4)];
        (0, utils_2$4.writeUInt32BE)(intBuf[0], Number(number >> BigInt(32)), 0);
        (0, utils_2$4.writeUInt32BE)(intBuf[1], Number(number & BigInt(mask)), 0);
        return new UInt642((0, utils_1$39.concat)(intBuf));
      }
      if (typeof val === "string") {
        if (useBase10(fieldName)) {
          if (!BASE10_REGEX.test(val)) throw new Error(`${fieldName} ${val} is not a valid base 10 string`);
          val = BigInt(val).toString(16);
        }
        if (typeof val === "string" && !HEX_REGEX$1.test(val)) throw new Error(`${val} is not a valid hex-string`);
        const strBuf = val.padStart(16, "0");
        buf = (0, utils_1$39.hexToBytes)(strBuf);
        return new UInt642(buf);
      }
      if (typeof val === "bigint") {
        const intBuf = [new Uint8Array(4), new Uint8Array(4)];
        (0, utils_2$4.writeUInt32BE)(intBuf[0], Number(Number(val >> BigInt(32))), 0);
        (0, utils_2$4.writeUInt32BE)(intBuf[1], Number(val & BigInt(mask)), 0);
        return new UInt642((0, utils_1$39.concat)(intBuf));
      }
      throw new Error("Cannot construct UInt64 from given value");
    }
    /**
    * The JSON representation of a UInt64 object
    *
    * @returns a hex-string
    */
    toJSON(_definitions = enums_1$6.DEFAULT_DEFINITIONS, fieldName = "") {
      const hexString = (0, utils_1$39.bytesToHex)(this.bytes);
      if (useBase10(fieldName)) return BigInt("0x" + hexString).toString(10);
      return hexString;
    }
    /**
    * Get the value of the UInt64
    *
    * @returns the number represented buy this.bytes
    */
    valueOf() {
      const msb = BigInt((0, utils_2$4.readUInt32BE)(this.bytes.slice(0, 4), 0));
      const lsb = BigInt((0, utils_2$4.readUInt32BE)(this.bytes.slice(4), 0));
      return msb << BigInt(32) | lsb;
    }
    /**
    * Get the bytes representation of the UInt64 object
    *
    * @returns 8 bytes representing the UInt64
    */
    toBytes() {
      return this.bytes;
    }
  };
  exports.UInt64 = UInt64;
  UInt64.width = 64 / 8;
  UInt64.defaultUInt64 = new UInt64(new Uint8Array(UInt64.width));
} });
var require_st_object = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/st-object.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.STObject = void 0;
  const enums_1$5 = require_enums();
  const serialized_type_1$3 = require_serialized_type();
  const ripple_address_codec_1$10 = require_dist$3();
  const binary_parser_1$4 = require_binary_parser();
  const binary_serializer_1$3 = require_binary_serializer();
  const st_array_1$1 = require_st_array();
  const uint_64_1$2 = require_uint_64();
  const OBJECT_END_MARKER_BYTE = Uint8Array.from([225]);
  const OBJECT_END_MARKER$1 = "ObjectEndMarker";
  const ST_OBJECT = "STObject";
  const DESTINATION = "Destination";
  const ACCOUNT = "Account";
  const SOURCE_TAG = "SourceTag";
  const DEST_TAG = "DestinationTag";
  function handleXAddress(field, xAddress) {
    const decoded = (0, ripple_address_codec_1$10.xAddressToClassicAddress)(xAddress);
    let tagName;
    if (field === DESTINATION) tagName = DEST_TAG;
    else if (field === ACCOUNT) tagName = SOURCE_TAG;
    else if (decoded.tag !== false) throw new Error(`${field} cannot have an associated tag`);
    return decoded.tag !== false ? {
      [field]: decoded.classicAddress,
      [tagName]: decoded.tag
    } : { [field]: decoded.classicAddress };
  }
  function checkForDuplicateTags(obj1, obj2) {
    if (!(obj1[SOURCE_TAG] === void 0 || obj2[SOURCE_TAG] === void 0)) throw new Error("Cannot have Account X-Address and SourceTag");
    if (!(obj1[DEST_TAG] === void 0 || obj2[DEST_TAG] === void 0)) throw new Error("Cannot have Destination X-Address and DestinationTag");
  }
  var STObject = class STObject2 extends serialized_type_1$3.SerializedType {
    /**
    * Construct a STObject from a BinaryParser
    *
    * @param parser BinaryParser to read STObject from
    * @returns A STObject object
    */
    static fromParser(parser) {
      const list = new binary_serializer_1$3.BytesList();
      const bytes$1 = new binary_serializer_1$3.BinarySerializer(list);
      while (!parser.end()) {
        const field = parser.readField();
        if (field.name === OBJECT_END_MARKER$1) break;
        const associatedValue = parser.readFieldValue(field);
        bytes$1.writeFieldAndValue(field, associatedValue);
        if (field.type.name === ST_OBJECT) bytes$1.put(OBJECT_END_MARKER_BYTE);
      }
      return new STObject2(list.toBytes());
    }
    /**
    * Construct a STObject from a JSON object
    *
    * @param value An object to include
    * @param filter optional, denote which field to include in serialized object
    * @param definitions optional, types and values to use to encode/decode a transaction
    * @returns a STObject object
    */
    static from(value, filter, definitions = enums_1$5.DEFAULT_DEFINITIONS) {
      if (value instanceof STObject2) return value;
      const list = new binary_serializer_1$3.BytesList();
      const bytes$1 = new binary_serializer_1$3.BinarySerializer(list);
      let isUnlModify = false;
      const xAddressDecoded = Object.entries(value).reduce((acc, [key, val]) => {
        let handled = void 0;
        if (val && (0, ripple_address_codec_1$10.isValidXAddress)(val.toString())) {
          handled = handleXAddress(key, val.toString());
          checkForDuplicateTags(handled, value);
        }
        return Object.assign(acc, handled !== null && handled !== void 0 ? handled : { [key]: val });
      }, {});
      function isValidFieldInstance(f) {
        return f !== void 0 && xAddressDecoded[f.name] !== void 0 && f.isSerialized;
      }
      let sorted = Object.keys(xAddressDecoded).map((f) => {
        if (!(f in definitions.field)) {
          if (f[0] === f[0].toLowerCase()) return void 0;
          throw new Error(`Field ${f} is not defined in the definitions`);
        }
        return definitions.field[f];
      }).filter(isValidFieldInstance).sort((a, b) => {
        return a.ordinal - b.ordinal;
      });
      if (filter !== void 0) sorted = sorted.filter(filter);
      sorted.forEach((field) => {
        const associatedValue = field.type.name === ST_OBJECT ? this.from(xAddressDecoded[field.name], void 0, definitions) : field.type.name === "STArray" ? st_array_1$1.STArray.from(xAddressDecoded[field.name], definitions) : field.type.name === "UInt64" ? uint_64_1$2.UInt64.from(xAddressDecoded[field.name], field.name) : field.associatedType.from(xAddressDecoded[field.name]);
        if (associatedValue == void 0) throw new TypeError(`Unable to interpret "${field.name}: ${xAddressDecoded[field.name]}".`);
        if (associatedValue.name === "UNLModify") isUnlModify = true;
        const isUnlModifyWorkaround = field.name == "Account" && isUnlModify;
        bytes$1.writeFieldAndValue(field, associatedValue, isUnlModifyWorkaround);
        if (field.type.name === ST_OBJECT) bytes$1.put(OBJECT_END_MARKER_BYTE);
      });
      return new STObject2(list.toBytes());
    }
    /**
    * Get the JSON interpretation of this.bytes
    * @param definitions rippled definitions used to parse the values of transaction types and such.
    *                          Can be customized for sidechains and amendments.
    * @returns a JSON object
    */
    toJSON(definitions) {
      const objectParser = new binary_parser_1$4.BinaryParser(this.toString(), definitions);
      const accumulator = {};
      while (!objectParser.end()) {
        const field = objectParser.readField();
        if (field.name === OBJECT_END_MARKER$1) break;
        accumulator[field.name] = objectParser.readFieldValue(field).toJSON(definitions, field.name);
      }
      return accumulator;
    }
  };
  exports.STObject = STObject;
} });
var require_st_array = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/st-array.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.STArray = void 0;
  const enums_1$4 = require_enums();
  const serialized_type_1$2 = require_serialized_type();
  const st_object_1$2 = require_st_object();
  const binary_parser_1$3 = require_binary_parser();
  const utils_1$38 = require_browser$4();
  const ARRAY_END_MARKER = Uint8Array.from([241]);
  const ARRAY_END_MARKER_NAME = "ArrayEndMarker";
  const OBJECT_END_MARKER = Uint8Array.from([225]);
  function isObjects(args) {
    return Array.isArray(args) && args.every((arg) => typeof arg === "object" && Object.keys(arg).length === 1 && typeof Object.values(arg)[0] === "object");
  }
  var STArray = class STArray2 extends serialized_type_1$2.SerializedType {
    /**
    * Construct an STArray from a BinaryParser
    *
    * @param parser BinaryParser to parse an STArray from
    * @returns An STArray Object
    */
    static fromParser(parser) {
      const bytes$1 = [];
      while (!parser.end()) {
        const field = parser.readField();
        if (field.name === ARRAY_END_MARKER_NAME) break;
        bytes$1.push(field.header, parser.readFieldValue(field).toBytes(), OBJECT_END_MARKER);
      }
      bytes$1.push(ARRAY_END_MARKER);
      return new STArray2((0, utils_1$38.concat)(bytes$1));
    }
    /**
    * Construct an STArray from an Array of JSON Objects
    *
    * @param value STArray or Array of Objects to parse into an STArray
    * @param definitions optional, types and values to use to encode/decode a transaction
    * @returns An STArray object
    */
    static from(value, definitions = enums_1$4.DEFAULT_DEFINITIONS) {
      if (value instanceof STArray2) return value;
      if (isObjects(value)) {
        const bytes$1 = [];
        value.forEach((obj) => {
          bytes$1.push(st_object_1$2.STObject.from(obj, void 0, definitions).toBytes());
        });
        bytes$1.push(ARRAY_END_MARKER);
        return new STArray2((0, utils_1$38.concat)(bytes$1));
      }
      throw new Error("Cannot construct STArray from value given");
    }
    /**
    * Return the JSON representation of this.bytes
    *
    * @param definitions optional, types and values to use to encode/decode a transaction
    * @returns An Array of JSON objects
    */
    toJSON(definitions = enums_1$4.DEFAULT_DEFINITIONS) {
      const result = [];
      const arrayParser = new binary_parser_1$3.BinaryParser(this.toString(), definitions);
      while (!arrayParser.end()) {
        const field = arrayParser.readField();
        if (field.name === ARRAY_END_MARKER_NAME) break;
        const outer = {};
        outer[field.name] = st_object_1$2.STObject.fromParser(arrayParser).toJSON(definitions);
        result.push(outer);
      }
      return result;
    }
  };
  exports.STArray = STArray;
} });
var require_uint_16 = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/uint-16.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UInt16 = void 0;
  const uint_1$2 = require_uint();
  const utils_1$37 = require_utils$5$1();
  var UInt16 = class UInt162 extends uint_1$2.UInt {
    constructor(bytes$1) {
      super(bytes$1 !== null && bytes$1 !== void 0 ? bytes$1 : UInt162.defaultUInt16.bytes);
    }
    static fromParser(parser) {
      return new UInt162(parser.read(UInt162.width));
    }
    /**
    * Construct a UInt16 object from a number
    *
    * @param val UInt16 object or number
    */
    static from(val) {
      if (val instanceof UInt162) return val;
      if (typeof val === "number") {
        UInt162.checkUintRange(val, 0, 65535);
        const buf = new Uint8Array(UInt162.width);
        (0, utils_1$37.writeUInt16BE)(buf, val, 0);
        return new UInt162(buf);
      }
      throw new Error("Can not construct UInt16 with given value");
    }
    /**
    * get the value of a UInt16 object
    *
    * @returns the number represented by this.bytes
    */
    valueOf() {
      return parseInt((0, utils_1$37.readUInt16BE)(this.bytes, 0));
    }
  };
  exports.UInt16 = UInt16;
  UInt16.width = 16 / 8;
  UInt16.defaultUInt16 = new UInt16(new Uint8Array(UInt16.width));
} });
var require_uint_32 = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/uint-32.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UInt32 = void 0;
  const uint_1$1 = require_uint();
  const utils_1$36 = require_utils$5$1();
  var UInt32 = class UInt322 extends uint_1$1.UInt {
    constructor(bytes$1) {
      super(bytes$1 !== null && bytes$1 !== void 0 ? bytes$1 : UInt322.defaultUInt32.bytes);
    }
    static fromParser(parser) {
      return new UInt322(parser.read(UInt322.width));
    }
    /**
    * Construct a UInt32 object from a number
    *
    * @param val UInt32 object or number
    */
    static from(val) {
      if (val instanceof UInt322) return val;
      const buf = new Uint8Array(UInt322.width);
      if (typeof val === "string") {
        const num$1 = Number.parseInt(val);
        (0, utils_1$36.writeUInt32BE)(buf, num$1, 0);
        return new UInt322(buf);
      }
      if (typeof val === "number") {
        UInt322.checkUintRange(val, 0, 4294967295);
        (0, utils_1$36.writeUInt32BE)(buf, val, 0);
        return new UInt322(buf);
      }
      throw new Error("Cannot construct UInt32 from given value");
    }
    /**
    * get the value of a UInt32 object
    *
    * @returns the number represented by this.bytes
    */
    valueOf() {
      return parseInt((0, utils_1$36.readUInt32BE)(this.bytes, 0), 10);
    }
  };
  exports.UInt32 = UInt32;
  UInt32.width = 32 / 8;
  UInt32.defaultUInt32 = new UInt32(new Uint8Array(UInt32.width));
} });
var require_uint_8 = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/uint-8.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UInt8 = void 0;
  const uint_1 = require_uint();
  const utils_1$35 = require_browser$4();
  const utils_2$3 = require_utils$5$1();
  var UInt8 = class UInt82 extends uint_1.UInt {
    constructor(bytes$1) {
      super(bytes$1 !== null && bytes$1 !== void 0 ? bytes$1 : UInt82.defaultUInt8.bytes);
    }
    static fromParser(parser) {
      return new UInt82(parser.read(UInt82.width));
    }
    /**
    * Construct a UInt8 object from a number
    *
    * @param val UInt8 object or number
    */
    static from(val) {
      if (val instanceof UInt82) return val;
      if (typeof val === "number") {
        UInt82.checkUintRange(val, 0, 255);
        const buf = new Uint8Array(UInt82.width);
        (0, utils_2$3.writeUInt8)(buf, val, 0);
        return new UInt82(buf);
      }
      throw new Error("Cannot construct UInt8 from given value");
    }
    /**
    * get the value of a UInt8 object
    *
    * @returns the number represented by this.bytes
    */
    valueOf() {
      return parseInt((0, utils_1$35.bytesToHex)(this.bytes), 16);
    }
  };
  exports.UInt8 = UInt8;
  UInt8.width = 8 / 8;
  UInt8.defaultUInt8 = new UInt8(new Uint8Array(UInt8.width));
} });
var require_vector_256 = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/vector-256.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Vector256 = void 0;
  const serialized_type_1$1 = require_serialized_type();
  const hash_256_1$2 = require_hash_256();
  const binary_serializer_1$2 = require_binary_serializer();
  const utils_1$34 = require_browser$4();
  function isStrings(arg) {
    return Array.isArray(arg) && (arg.length === 0 || typeof arg[0] === "string");
  }
  var Vector256 = class Vector2562 extends serialized_type_1$1.SerializedType {
    constructor(bytes$1) {
      super(bytes$1);
    }
    /**
    * Construct a Vector256 from a BinaryParser
    *
    * @param parser BinaryParser to
    * @param hint length of the vector, in bytes, optional
    * @returns a Vector256 object
    */
    static fromParser(parser, hint) {
      const bytesList = new binary_serializer_1$2.BytesList();
      const bytes$1 = hint !== null && hint !== void 0 ? hint : parser.size();
      const hashes$2 = bytes$1 / 32;
      for (let i = 0; i < hashes$2; i++) hash_256_1$2.Hash256.fromParser(parser).toBytesSink(bytesList);
      return new Vector2562(bytesList.toBytes());
    }
    /**
    * Construct a Vector256 object from an array of hashes
    *
    * @param value A Vector256 object or array of hex-strings representing Hash256's
    * @returns a Vector256 object
    */
    static from(value) {
      if (value instanceof Vector2562) return value;
      if (isStrings(value)) {
        const bytesList = new binary_serializer_1$2.BytesList();
        value.forEach((hash$12) => {
          hash_256_1$2.Hash256.from(hash$12).toBytesSink(bytesList);
        });
        return new Vector2562(bytesList.toBytes());
      }
      throw new Error("Cannot construct Vector256 from given value");
    }
    /**
    * Return an Array of hex-strings represented by this.bytes
    *
    * @returns An Array of strings representing the Hash256 objects
    */
    toJSON() {
      if (this.bytes.byteLength % 32 !== 0) throw new Error("Invalid bytes for Vector256");
      const result = [];
      for (let i = 0; i < this.bytes.byteLength; i += 32) result.push((0, utils_1$34.bytesToHex)(this.bytes.slice(i, i + 32)));
      return result;
    }
  };
  exports.Vector256 = Vector256;
} });
var require_xchain_bridge = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/xchain-bridge.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XChainBridge = void 0;
  const binary_parser_1$2 = require_binary_parser();
  const account_id_1$1 = require_account_id();
  const serialized_type_1 = require_serialized_type();
  const issue_1$1 = require_issue();
  const utils_1$33 = require_browser$4();
  function isXChainBridgeObject(arg) {
    const keys2 = Object.keys(arg).sort();
    return keys2.length === 4 && keys2[0] === "IssuingChainDoor" && keys2[1] === "IssuingChainIssue" && keys2[2] === "LockingChainDoor" && keys2[3] === "LockingChainIssue";
  }
  var XChainBridge = class XChainBridge2 extends serialized_type_1.SerializedType {
    constructor(bytes$1) {
      super(bytes$1 !== null && bytes$1 !== void 0 ? bytes$1 : XChainBridge2.ZERO_XCHAIN_BRIDGE.bytes);
    }
    /**
    * Construct a cross-chain bridge from a JSON
    *
    * @param value XChainBridge or JSON to parse into an XChainBridge
    * @returns An XChainBridge object
    */
    static from(value) {
      if (value instanceof XChainBridge2) return value;
      if (!isXChainBridgeObject(value)) throw new Error("Invalid type to construct an XChainBridge");
      const bytes$1 = [];
      this.TYPE_ORDER.forEach((item) => {
        const { name, type: type2 } = item;
        if (type2 === account_id_1$1.AccountID) bytes$1.push(Uint8Array.from([20]));
        const object = type2.from(value[name]);
        bytes$1.push(object.toBytes());
      });
      return new XChainBridge2((0, utils_1$33.concat)(bytes$1));
    }
    /**
    * Read an XChainBridge from a BinaryParser
    *
    * @param parser BinaryParser to read the XChainBridge from
    * @returns An XChainBridge object
    */
    static fromParser(parser) {
      const bytes$1 = [];
      this.TYPE_ORDER.forEach((item) => {
        const { type: type2 } = item;
        if (type2 === account_id_1$1.AccountID) {
          parser.skip(1);
          bytes$1.push(Uint8Array.from([20]));
        }
        const object = type2.fromParser(parser);
        bytes$1.push(object.toBytes());
      });
      return new XChainBridge2((0, utils_1$33.concat)(bytes$1));
    }
    /**
    * Get the JSON representation of this XChainBridge
    *
    * @returns the JSON interpretation of this.bytes
    */
    toJSON() {
      const parser = new binary_parser_1$2.BinaryParser(this.toString());
      const json = {};
      XChainBridge2.TYPE_ORDER.forEach((item) => {
        const { name, type: type2 } = item;
        if (type2 === account_id_1$1.AccountID) parser.skip(1);
        const object = type2.fromParser(parser).toJSON();
        json[name] = object;
      });
      return json;
    }
  };
  exports.XChainBridge = XChainBridge;
  XChainBridge.ZERO_XCHAIN_BRIDGE = new XChainBridge((0, utils_1$33.concat)([
    Uint8Array.from([20]),
    new Uint8Array(40),
    Uint8Array.from([20]),
    new Uint8Array(40)
  ]));
  XChainBridge.TYPE_ORDER = [
    {
      name: "LockingChainDoor",
      type: account_id_1$1.AccountID
    },
    {
      name: "LockingChainIssue",
      type: issue_1$1.Issue
    },
    {
      name: "IssuingChainDoor",
      type: account_id_1$1.AccountID
    },
    {
      name: "IssuingChainIssue",
      type: issue_1$1.Issue
    }
  ];
} });
var require_types = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/types/index.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Vector256 = exports.UInt64 = exports.UInt32 = exports.UInt16 = exports.UInt8 = exports.STObject = exports.STArray = exports.PathSet = exports.Hash256 = exports.Hash192 = exports.Hash160 = exports.Hash128 = exports.Currency = exports.Blob = exports.Amount = exports.AccountID = exports.coreTypes = void 0;
  const account_id_1 = require_account_id();
  Object.defineProperty(exports, "AccountID", {
    enumerable: true,
    get: function() {
      return account_id_1.AccountID;
    }
  });
  const amount_1 = require_amount();
  Object.defineProperty(exports, "Amount", {
    enumerable: true,
    get: function() {
      return amount_1.Amount;
    }
  });
  const blob_1 = require_blob();
  Object.defineProperty(exports, "Blob", {
    enumerable: true,
    get: function() {
      return blob_1.Blob;
    }
  });
  const currency_1 = require_currency();
  Object.defineProperty(exports, "Currency", {
    enumerable: true,
    get: function() {
      return currency_1.Currency;
    }
  });
  const hash_128_1 = require_hash_128();
  Object.defineProperty(exports, "Hash128", {
    enumerable: true,
    get: function() {
      return hash_128_1.Hash128;
    }
  });
  const hash_160_1 = require_hash_160();
  Object.defineProperty(exports, "Hash160", {
    enumerable: true,
    get: function() {
      return hash_160_1.Hash160;
    }
  });
  const hash_192_1 = require_hash_192();
  Object.defineProperty(exports, "Hash192", {
    enumerable: true,
    get: function() {
      return hash_192_1.Hash192;
    }
  });
  const hash_256_1$1 = require_hash_256();
  Object.defineProperty(exports, "Hash256", {
    enumerable: true,
    get: function() {
      return hash_256_1$1.Hash256;
    }
  });
  const issue_1 = require_issue();
  const path_set_1 = require_path_set();
  Object.defineProperty(exports, "PathSet", {
    enumerable: true,
    get: function() {
      return path_set_1.PathSet;
    }
  });
  const st_array_1 = require_st_array();
  Object.defineProperty(exports, "STArray", {
    enumerable: true,
    get: function() {
      return st_array_1.STArray;
    }
  });
  const st_object_1$1 = require_st_object();
  Object.defineProperty(exports, "STObject", {
    enumerable: true,
    get: function() {
      return st_object_1$1.STObject;
    }
  });
  const uint_16_1 = require_uint_16();
  Object.defineProperty(exports, "UInt16", {
    enumerable: true,
    get: function() {
      return uint_16_1.UInt16;
    }
  });
  const uint_32_1$1 = require_uint_32();
  Object.defineProperty(exports, "UInt32", {
    enumerable: true,
    get: function() {
      return uint_32_1$1.UInt32;
    }
  });
  const uint_64_1$1 = require_uint_64();
  Object.defineProperty(exports, "UInt64", {
    enumerable: true,
    get: function() {
      return uint_64_1$1.UInt64;
    }
  });
  const uint_8_1$1 = require_uint_8();
  Object.defineProperty(exports, "UInt8", {
    enumerable: true,
    get: function() {
      return uint_8_1$1.UInt8;
    }
  });
  const vector_256_1 = require_vector_256();
  Object.defineProperty(exports, "Vector256", {
    enumerable: true,
    get: function() {
      return vector_256_1.Vector256;
    }
  });
  const xchain_bridge_1 = require_xchain_bridge();
  const enums_1$3 = require_enums();
  const coreTypes = {
    AccountID: account_id_1.AccountID,
    Amount: amount_1.Amount,
    Blob: blob_1.Blob,
    Currency: currency_1.Currency,
    Hash128: hash_128_1.Hash128,
    Hash160: hash_160_1.Hash160,
    Hash192: hash_192_1.Hash192,
    Hash256: hash_256_1$1.Hash256,
    Issue: issue_1.Issue,
    PathSet: path_set_1.PathSet,
    STArray: st_array_1.STArray,
    STObject: st_object_1$1.STObject,
    UInt8: uint_8_1$1.UInt8,
    UInt16: uint_16_1.UInt16,
    UInt32: uint_32_1$1.UInt32,
    UInt64: uint_64_1$1.UInt64,
    Vector256: vector_256_1.Vector256,
    XChainBridge: xchain_bridge_1.XChainBridge
  };
  exports.coreTypes = coreTypes;
  enums_1$3.DEFAULT_DEFINITIONS.associateTypes(coreTypes);
} });
var require_hash_prefixes = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/hash-prefixes.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HashPrefix = void 0;
  const utils_1$32 = require_utils$5$1();
  function bytes2(uint32) {
    const result = new Uint8Array(4);
    (0, utils_1$32.writeUInt32BE)(result, uint32, 0);
    return result;
  }
  const HashPrefix$1 = {
    transactionID: bytes2(1415073280),
    transaction: bytes2(1397638144),
    accountStateEntry: bytes2(1296846336),
    innerNode: bytes2(1296649728),
    ledgerHeader: bytes2(1280791040),
    transactionSig: bytes2(1398036480),
    transactionMultiSig: bytes2(1397576704),
    validation: bytes2(1447119872),
    proposal: bytes2(1347571712),
    paymentChannelClaim: bytes2(1129073920),
    batch: bytes2(1111705600)
  };
  exports.HashPrefix = HashPrefix$1;
} });
var require_hashes$1 = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/hashes.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transactionID = exports.sha512Half = exports.Sha512Half = void 0;
  const hash_prefixes_1$4 = require_hash_prefixes();
  const types_1$5 = require_types();
  const binary_serializer_1$1 = require_binary_serializer();
  const sha512_1$1 = require_browser$1();
  var Sha512Half = class Sha512Half2 extends binary_serializer_1$1.BytesList {
    constructor() {
      super(...arguments);
      this.hash = sha512_1$1.sha512.create();
    }
    /**
    * Construct a new Sha512Hash and write bytes this.hash
    *
    * @param bytes bytes to write to this.hash
    * @returns the new Sha512Hash object
    */
    static put(bytes$1) {
      return new Sha512Half2().put(bytes$1);
    }
    /**
    * Write bytes to an existing Sha512Hash
    *
    * @param bytes bytes to write to object
    * @returns the Sha512 object
    */
    put(bytes$1) {
      this.hash.update(bytes$1);
      return this;
    }
    /**
    * Compute SHA512 hash and slice in half
    *
    * @returns half of a SHA512 hash
    */
    finish256() {
      return Uint8Array.from(this.hash.digest().slice(0, 32));
    }
    /**
    * Constructs a Hash256 from the Sha512Half object
    *
    * @returns a Hash256 object
    */
    finish() {
      return new types_1$5.Hash256(this.finish256());
    }
  };
  exports.Sha512Half = Sha512Half;
  function sha512Half$1(...args) {
    const hash$12 = new Sha512Half();
    args.forEach((a) => hash$12.put(a));
    return hash$12.finish256();
  }
  exports.sha512Half = sha512Half$1;
  function transactionID(serialized) {
    return new types_1$5.Hash256(sha512Half$1(hash_prefixes_1$4.HashPrefix.transactionID, serialized));
  }
  exports.transactionID = transactionID;
} });
var require_binary = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/binary.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.signingBatchData = exports.transactionID = exports.sha512Half = exports.binaryToJSON = exports.signingClaimData = exports.signingData = exports.multiSigningData = exports.readJSON = exports.serializeObject = exports.makeParser = exports.BytesList = exports.BinarySerializer = exports.BinaryParser = void 0;
  const utils_1$31 = require_browser$4();
  const types_1$4 = require_types();
  const binary_parser_1$1 = require_binary_parser();
  Object.defineProperty(exports, "BinaryParser", {
    enumerable: true,
    get: function() {
      return binary_parser_1$1.BinaryParser;
    }
  });
  const hash_prefixes_1$3 = require_hash_prefixes();
  const binary_serializer_1 = require_binary_serializer();
  Object.defineProperty(exports, "BinarySerializer", {
    enumerable: true,
    get: function() {
      return binary_serializer_1.BinarySerializer;
    }
  });
  Object.defineProperty(exports, "BytesList", {
    enumerable: true,
    get: function() {
      return binary_serializer_1.BytesList;
    }
  });
  const hashes_1$3 = require_hashes$1();
  Object.defineProperty(exports, "sha512Half", {
    enumerable: true,
    get: function() {
      return hashes_1$3.sha512Half;
    }
  });
  Object.defineProperty(exports, "transactionID", {
    enumerable: true,
    get: function() {
      return hashes_1$3.transactionID;
    }
  });
  const enums_1$2 = require_enums();
  const makeParser = (bytes$1, definitions) => new binary_parser_1$1.BinaryParser(bytes$1 instanceof Uint8Array ? (0, utils_1$31.bytesToHex)(bytes$1) : bytes$1, definitions);
  exports.makeParser = makeParser;
  const readJSON = (parser, definitions = enums_1$2.DEFAULT_DEFINITIONS) => parser.readType(types_1$4.coreTypes.STObject).toJSON(definitions);
  exports.readJSON = readJSON;
  const binaryToJSON$1 = (bytes$1, definitions) => readJSON(makeParser(bytes$1, definitions), definitions);
  exports.binaryToJSON = binaryToJSON$1;
  function serializeObject$1(object, opts = {}) {
    const { prefix: prefix$2, suffix, signingFieldsOnly = false, definitions } = opts;
    const bytesList = new binary_serializer_1.BytesList();
    if (prefix$2) bytesList.put(prefix$2);
    const filter = signingFieldsOnly ? (f) => f.isSigningField : void 0;
    types_1$4.coreTypes.STObject.from(object, filter, definitions).toBytesSink(bytesList);
    if (suffix) bytesList.put(suffix);
    return bytesList.toBytes();
  }
  exports.serializeObject = serializeObject$1;
  function signingData$1(transaction, prefix$2 = hash_prefixes_1$3.HashPrefix.transactionSig, opts = {}) {
    return serializeObject$1(transaction, {
      prefix: prefix$2,
      signingFieldsOnly: true,
      definitions: opts.definitions
    });
  }
  exports.signingData = signingData$1;
  function signingClaimData$1(claim) {
    const num$1 = BigInt(String(claim.amount));
    const prefix$2 = hash_prefixes_1$3.HashPrefix.paymentChannelClaim;
    const channel = types_1$4.coreTypes.Hash256.from(claim.channel).toBytes();
    const amount = types_1$4.coreTypes.UInt64.from(num$1).toBytes();
    const bytesList = new binary_serializer_1.BytesList();
    bytesList.put(prefix$2);
    bytesList.put(channel);
    bytesList.put(amount);
    return bytesList.toBytes();
  }
  exports.signingClaimData = signingClaimData$1;
  function multiSigningData$1(transaction, signingAccount, opts = { definitions: enums_1$2.DEFAULT_DEFINITIONS }) {
    const prefix$2 = hash_prefixes_1$3.HashPrefix.transactionMultiSig;
    const suffix = types_1$4.coreTypes.AccountID.from(signingAccount).toBytes();
    return serializeObject$1(transaction, {
      prefix: prefix$2,
      suffix,
      signingFieldsOnly: true,
      definitions: opts.definitions
    });
  }
  exports.multiSigningData = multiSigningData$1;
  function signingBatchData$1(batch) {
    if (batch.flags == null) throw Error("No field `flags'");
    if (batch.txIDs == null) throw Error("No field `txIDs`");
    const prefix$2 = hash_prefixes_1$3.HashPrefix.batch;
    const flags = types_1$4.coreTypes.UInt32.from(batch.flags).toBytes();
    const txIDsLength = types_1$4.coreTypes.UInt32.from(batch.txIDs.length).toBytes();
    const bytesList = new binary_serializer_1.BytesList();
    bytesList.put(prefix$2);
    bytesList.put(flags);
    bytesList.put(txIDsLength);
    batch.txIDs.forEach((txID) => {
      bytesList.put(types_1$4.coreTypes.Hash256.from(txID).toBytes());
    });
    return bytesList.toBytes();
  }
  exports.signingBatchData = signingBatchData$1;
} });
var require_shamap = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/shamap.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ShaMapLeaf = exports.ShaMapNode = exports.ShaMap = void 0;
  const types_1$3 = require_types();
  const hash_prefixes_1$2 = require_hash_prefixes();
  const hashes_1$2 = require_hashes$1();
  var ShaMapNode = class {
  };
  exports.ShaMapNode = ShaMapNode;
  var ShaMapLeaf = class extends ShaMapNode {
    constructor(index, item) {
      super();
      this.index = index;
      this.item = item;
    }
    /**
    * @returns true as ShaMapLeaf is a leaf node
    */
    isLeaf() {
      return true;
    }
    /**
    * @returns false as ShaMapLeaf is not an inner node
    */
    isInner() {
      return false;
    }
    /**
    * Get the prefix of the this.item
    *
    * @returns The hash prefix, unless this.item is undefined, then it returns an empty Uint8Array
    */
    hashPrefix() {
      return this.item === void 0 ? new Uint8Array(0) : this.item.hashPrefix();
    }
    /**
    * Hash the bytes representation of this
    *
    * @returns hash of this.item concatenated with this.index
    */
    hash() {
      const hash$12 = hashes_1$2.Sha512Half.put(this.hashPrefix());
      this.toBytesSink(hash$12);
      return hash$12.finish();
    }
    /**
    * Write the bytes representation of this to a BytesList
    * @param list BytesList to write bytes to
    */
    toBytesSink(list) {
      if (this.item !== void 0) this.item.toBytesSink(list);
      this.index.toBytesSink(list);
    }
  };
  exports.ShaMapLeaf = ShaMapLeaf;
  var ShaMapInner = class ShaMapInner2 extends ShaMapNode {
    constructor(depth = 0) {
      super();
      this.depth = depth;
      this.slotBits = 0;
      this.branches = Array(16);
    }
    /**
    * @returns true as ShaMapInner is an inner node
    */
    isInner() {
      return true;
    }
    /**
    * @returns false as ShaMapInner is not a leaf node
    */
    isLeaf() {
      return false;
    }
    /**
    * Get the hash prefix for this node
    *
    * @returns hash prefix describing an inner node
    */
    hashPrefix() {
      return hash_prefixes_1$2.HashPrefix.innerNode;
    }
    /**
    * Set a branch of this node to be another node
    *
    * @param slot Slot to add branch to this.branches
    * @param branch Branch to add
    */
    setBranch(slot, branch) {
      this.slotBits = this.slotBits | 1 << slot;
      this.branches[slot] = branch;
    }
    /**
    * @returns true if node is empty
    */
    empty() {
      return this.slotBits === 0;
    }
    /**
    * Compute the hash of this node
    *
    * @returns The hash of this node
    */
    hash() {
      if (this.empty()) return types_1$3.coreTypes.Hash256.ZERO_256;
      const hash$12 = hashes_1$2.Sha512Half.put(this.hashPrefix());
      this.toBytesSink(hash$12);
      return hash$12.finish();
    }
    /**
    * Writes the bytes representation of this node to a BytesList
    *
    * @param list BytesList to write bytes to
    */
    toBytesSink(list) {
      for (let i = 0; i < this.branches.length; i++) {
        const branch = this.branches[i];
        const hash$12 = branch ? branch.hash() : types_1$3.coreTypes.Hash256.ZERO_256;
        hash$12.toBytesSink(list);
      }
    }
    /**
    * Add item to the SHAMap
    *
    * @param index Hash of the index of the item being inserted
    * @param item Item to insert in the map
    * @param leaf Leaf node to insert when branch doesn't exist
    */
    addItem(index, item, leaf) {
      if (index === void 0) throw new Error();
      if (index !== void 0) {
        const nibble = index.nibblet(this.depth);
        const existing = this.branches[nibble];
        if (existing === void 0) this.setBranch(nibble, leaf || new ShaMapLeaf(index, item));
        else if (existing instanceof ShaMapLeaf) {
          const newInner = new ShaMapInner2(this.depth + 1);
          newInner.addItem(existing.index, void 0, existing);
          newInner.addItem(index, item, leaf);
          this.setBranch(nibble, newInner);
        } else if (existing instanceof ShaMapInner2) existing.addItem(index, item, leaf);
        else throw new Error("invalid ShaMap.addItem call");
      }
    }
  };
  var ShaMap = class extends ShaMapInner {
  };
  exports.ShaMap = ShaMap;
} });
var require_ledger_hashes = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/ledger-hashes.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeLedgerData = exports.ledgerHash = exports.transactionTreeHash = exports.accountStateHash = void 0;
  const shamap_1$1 = require_shamap();
  const hash_prefixes_1$1 = require_hash_prefixes();
  const hashes_1$1 = require_hashes$1();
  const binary_1 = require_binary();
  const hash_256_1 = require_hash_256();
  const st_object_1 = require_st_object();
  const uint_64_1 = require_uint_64();
  const uint_32_1 = require_uint_32();
  const uint_8_1 = require_uint_8();
  const binary_parser_1 = require_binary_parser();
  function computeHash(itemizer, itemsJson) {
    const map = new shamap_1$1.ShaMap();
    itemsJson.forEach((item) => map.addItem(...itemizer(item)));
    return map.hash();
  }
  function transactionItemizer(json) {
    if (!json.hash) throw new Error();
    const index = hash_256_1.Hash256.from(json.hash);
    const item = {
      hashPrefix() {
        return hash_prefixes_1$1.HashPrefix.transaction;
      },
      toBytesSink(sink) {
        const serializer = new binary_1.BinarySerializer(sink);
        serializer.writeLengthEncoded(st_object_1.STObject.from(json));
        serializer.writeLengthEncoded(st_object_1.STObject.from(json.metaData));
      }
    };
    return [
      index,
      item,
      void 0
    ];
  }
  function entryItemizer(json) {
    const index = hash_256_1.Hash256.from(json.index);
    const bytes$1 = (0, binary_1.serializeObject)(json);
    const item = {
      hashPrefix() {
        return hash_prefixes_1$1.HashPrefix.accountStateEntry;
      },
      toBytesSink(sink) {
        sink.put(bytes$1);
      }
    };
    return [
      index,
      item,
      void 0
    ];
  }
  function transactionTreeHash(param) {
    const itemizer = transactionItemizer;
    return computeHash(itemizer, param);
  }
  exports.transactionTreeHash = transactionTreeHash;
  function accountStateHash(param) {
    const itemizer = entryItemizer;
    return computeHash(itemizer, param);
  }
  exports.accountStateHash = accountStateHash;
  function ledgerHash(header) {
    const hash$12 = new hashes_1$1.Sha512Half();
    hash$12.put(hash_prefixes_1$1.HashPrefix.ledgerHeader);
    if (header.parent_close_time === void 0 || header.close_flags === void 0) throw new Error();
    uint_32_1.UInt32.from(header.ledger_index).toBytesSink(hash$12);
    uint_64_1.UInt64.from(BigInt(String(header.total_coins))).toBytesSink(hash$12);
    hash_256_1.Hash256.from(header.parent_hash).toBytesSink(hash$12);
    hash_256_1.Hash256.from(header.transaction_hash).toBytesSink(hash$12);
    hash_256_1.Hash256.from(header.account_hash).toBytesSink(hash$12);
    uint_32_1.UInt32.from(header.parent_close_time).toBytesSink(hash$12);
    uint_32_1.UInt32.from(header.close_time).toBytesSink(hash$12);
    uint_8_1.UInt8.from(header.close_time_resolution).toBytesSink(hash$12);
    uint_8_1.UInt8.from(header.close_flags).toBytesSink(hash$12);
    return hash$12.finish();
  }
  exports.ledgerHash = ledgerHash;
  function decodeLedgerData(binary$1, definitions) {
    if (typeof binary$1 !== "string") throw new Error("binary must be a hex string");
    const parser = new binary_parser_1.BinaryParser(binary$1, definitions);
    return {
      ledger_index: parser.readUInt32(),
      total_coins: parser.readType(uint_64_1.UInt64).valueOf().toString(),
      parent_hash: parser.readType(hash_256_1.Hash256).toHex(),
      transaction_hash: parser.readType(hash_256_1.Hash256).toHex(),
      account_hash: parser.readType(hash_256_1.Hash256).toHex(),
      parent_close_time: parser.readUInt32(),
      close_time: parser.readUInt32(),
      close_time_resolution: parser.readUInt8(),
      close_flags: parser.readUInt8()
    };
  }
  exports.decodeLedgerData = decodeLedgerData;
} });
var require_quality$1 = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/quality.js"(exports) {
  var __importDefault$20 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.quality = void 0;
  const types_1$2 = require_types();
  const bignumber_js_1$12 = __importDefault$20(require_bignumber());
  const utils_1$30 = require_browser$4();
  var quality = class {
    /**
    * Encode quality amount
    *
    * @param arg string representation of an amount
    * @returns Serialized quality
    */
    static encode(quality$1) {
      const decimal = (0, bignumber_js_1$12.default)(quality$1);
      const exponent = ((decimal === null || decimal === void 0 ? void 0 : decimal.e) || 0) - 15;
      const qualityString = decimal.times(`1e${-exponent}`).abs().toString();
      const bytes$1 = types_1$2.coreTypes.UInt64.from(BigInt(qualityString)).toBytes();
      bytes$1[0] = exponent + 100;
      return bytes$1;
    }
    /**
    * Decode quality amount
    *
    * @param arg hex-string denoting serialized quality
    * @returns deserialized quality
    */
    static decode(quality$1) {
      const bytes$1 = (0, utils_1$30.hexToBytes)(quality$1).slice(-8);
      const exponent = bytes$1[0] - 100;
      const mantissa = new bignumber_js_1$12.default(`0x${(0, utils_1$30.bytesToHex)(bytes$1.slice(1))}`);
      return mantissa.times(`1e${exponent}`);
    }
  };
  exports.quality = quality;
} });
var require_coretypes = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/coretypes.js"(exports) {
  var __createBinding$8 = Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
      enumerable: true,
      get: function() {
        return m[k];
      }
    };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  };
  var __setModuleDefault$3 = Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function(o, v) {
    o["default"] = v;
  };
  var __importStar$3 = function(mod$1) {
    if (mod$1 && mod$1.__esModule) return mod$1;
    var result = {};
    if (mod$1 != null) {
      for (var k in mod$1) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod$1, k)) __createBinding$8(result, mod$1, k);
    }
    __setModuleDefault$3(result, mod$1);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.types = exports.ShaMap = exports.HashPrefix = exports.quality = exports.TransactionResult = exports.Type = exports.LedgerEntryType = exports.TransactionType = exports.Field = exports.DEFAULT_DEFINITIONS = exports.ledgerHashes = exports.binary = exports.hashes = void 0;
  const enums_1$1 = require_enums();
  Object.defineProperty(exports, "DEFAULT_DEFINITIONS", {
    enumerable: true,
    get: function() {
      return enums_1$1.DEFAULT_DEFINITIONS;
    }
  });
  Object.defineProperty(exports, "Field", {
    enumerable: true,
    get: function() {
      return enums_1$1.Field;
    }
  });
  Object.defineProperty(exports, "TransactionType", {
    enumerable: true,
    get: function() {
      return enums_1$1.TransactionType;
    }
  });
  Object.defineProperty(exports, "LedgerEntryType", {
    enumerable: true,
    get: function() {
      return enums_1$1.LedgerEntryType;
    }
  });
  Object.defineProperty(exports, "Type", {
    enumerable: true,
    get: function() {
      return enums_1$1.Type;
    }
  });
  Object.defineProperty(exports, "TransactionResult", {
    enumerable: true,
    get: function() {
      return enums_1$1.TransactionResult;
    }
  });
  const types2 = __importStar$3(require_types());
  exports.types = types2;
  const binary = __importStar$3(require_binary());
  exports.binary = binary;
  const shamap_1 = require_shamap();
  Object.defineProperty(exports, "ShaMap", {
    enumerable: true,
    get: function() {
      return shamap_1.ShaMap;
    }
  });
  const ledgerHashes = __importStar$3(require_ledger_hashes());
  exports.ledgerHashes = ledgerHashes;
  const hashes$1 = __importStar$3(require_hashes$1());
  exports.hashes = hashes$1;
  const quality_1$1 = require_quality$1();
  Object.defineProperty(exports, "quality", {
    enumerable: true,
    get: function() {
      return quality_1$1.quality;
    }
  });
  const hash_prefixes_1 = require_hash_prefixes();
  Object.defineProperty(exports, "HashPrefix", {
    enumerable: true,
    get: function() {
      return hash_prefixes_1.HashPrefix;
    }
  });
} });
var require_xrpl_definitions = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/enums/xrpl-definitions.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XrplDefinitions = void 0;
  const xrpl_definitions_base_1 = require_xrpl_definitions_base();
  const types_1$1 = require_types();
  var XrplDefinitions = class extends xrpl_definitions_base_1.XrplDefinitionsBase {
    /**
    * Present rippled types in a typed and updatable format.
    * For an example of the input format see `definitions.json`
    * To generate a new definitions file from rippled source code, use the tool at
    * `packages/ripple-binary-codec/tools/generateDefinitions.js`.
    *
    * See the definitions.test.js file for examples of how to create your own updated definitions.json.
    *
    * @param enums - A json encoding of the core types, transaction types, transaction results, transaction names, and fields.
    * @param additionalTypes - A list of SerializedType objects with the same name as the fields defined.
    *              These types will be included in addition to the coreTypes used on mainnet.
    */
    constructor(enums2, additionalTypes) {
      const types$1 = Object.assign({}, types_1$1.coreTypes, additionalTypes);
      super(enums2, types$1);
    }
  };
  exports.XrplDefinitions = XrplDefinitions;
} });
var require_dist$1$1 = __commonJS$1({ "../../node_modules/.pnpm/ripple-binary-codec@2.4.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-binary-codec/dist/index.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.coreTypes = exports.DEFAULT_DEFINITIONS = exports.XrplDefinitionsBase = exports.XrplDefinitions = exports.TRANSACTION_TYPES = exports.decodeLedgerData = exports.decodeQuality = exports.encodeQuality = exports.encodeForSigningBatch = exports.encodeForMultisigning = exports.encodeForSigningClaim = exports.encodeForSigning = exports.encode = exports.decode = void 0;
  const coretypes_1 = require_coretypes();
  const ledger_hashes_1 = require_ledger_hashes();
  Object.defineProperty(exports, "decodeLedgerData", {
    enumerable: true,
    get: function() {
      return ledger_hashes_1.decodeLedgerData;
    }
  });
  const enums_1 = require_enums();
  Object.defineProperty(exports, "XrplDefinitionsBase", {
    enumerable: true,
    get: function() {
      return enums_1.XrplDefinitionsBase;
    }
  });
  Object.defineProperty(exports, "TRANSACTION_TYPES", {
    enumerable: true,
    get: function() {
      return enums_1.TRANSACTION_TYPES;
    }
  });
  Object.defineProperty(exports, "DEFAULT_DEFINITIONS", {
    enumerable: true,
    get: function() {
      return enums_1.DEFAULT_DEFINITIONS;
    }
  });
  const xrpl_definitions_1 = require_xrpl_definitions();
  Object.defineProperty(exports, "XrplDefinitions", {
    enumerable: true,
    get: function() {
      return xrpl_definitions_1.XrplDefinitions;
    }
  });
  const types_1 = require_types();
  Object.defineProperty(exports, "coreTypes", {
    enumerable: true,
    get: function() {
      return types_1.coreTypes;
    }
  });
  const utils_1$29 = require_browser$4();
  const { signingData, signingClaimData, multiSigningData, signingBatchData, binaryToJSON, serializeObject } = coretypes_1.binary;
  function decode$4(binary$1, definitions) {
    if (typeof binary$1 !== "string") throw new Error("binary must be a hex string");
    return binaryToJSON(binary$1, definitions);
  }
  exports.decode = decode$4;
  function encode$4(json, definitions) {
    if (typeof json !== "object") throw new Error();
    return (0, utils_1$29.bytesToHex)(serializeObject(json, { definitions }));
  }
  exports.encode = encode$4;
  function encodeForSigning$1(json, definitions) {
    if (typeof json !== "object") throw new Error();
    return (0, utils_1$29.bytesToHex)(signingData(json, coretypes_1.HashPrefix.transactionSig, { definitions }));
  }
  exports.encodeForSigning = encodeForSigning$1;
  function encodeForSigningClaim$1(json) {
    if (typeof json !== "object") throw new Error();
    return (0, utils_1$29.bytesToHex)(signingClaimData(json));
  }
  exports.encodeForSigningClaim = encodeForSigningClaim$1;
  function encodeForMultisigning(json, signer, definitions) {
    if (typeof json !== "object") throw new Error();
    if (json["SigningPubKey"] !== "") throw new Error();
    const definitionsOpt = definitions ? { definitions } : void 0;
    return (0, utils_1$29.bytesToHex)(multiSigningData(json, signer, definitionsOpt));
  }
  exports.encodeForMultisigning = encodeForMultisigning;
  function encodeForSigningBatch(json) {
    if (typeof json !== "object") throw new Error("Need an object to encode a Batch transaction");
    return (0, utils_1$29.bytesToHex)(signingBatchData(json));
  }
  exports.encodeForSigningBatch = encodeForSigningBatch;
  function encodeQuality(value) {
    if (typeof value !== "string") throw new Error();
    return (0, utils_1$29.bytesToHex)(coretypes_1.quality.encode(value));
  }
  exports.encodeQuality = encodeQuality;
  function decodeQuality(value) {
    if (typeof value !== "string") throw new Error();
    return coretypes_1.quality.decode(value).toString();
  }
  exports.decodeQuality = decodeQuality;
} });
var require_utils$4$1 = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/utils/index.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isHex = exports.hasFlag = exports.isFlagEnabled = exports.onlyHasFields = exports.INTEGER_SANITY_CHECK = void 0;
  const HEX_REGEX = /^[0-9A-Fa-f]+$/u;
  exports.INTEGER_SANITY_CHECK = /^[0-9]+$/u;
  function onlyHasFields(obj, fields) {
    return Object.keys(obj).every((key) => fields.includes(key));
  }
  exports.onlyHasFields = onlyHasFields;
  function isFlagEnabled(Flags, checkFlag) {
    return (BigInt(checkFlag) & BigInt(Flags)) === BigInt(checkFlag);
  }
  exports.isFlagEnabled = isFlagEnabled;
  function hasFlag2(tx2, flag, flagName) {
    if (tx2.Flags == null) return false;
    if (typeof tx2.Flags === "number") return isFlagEnabled(tx2.Flags, flag);
    return tx2.Flags[flagName] === true;
  }
  exports.hasFlag = hasFlag2;
  function isHex(str) {
    return HEX_REGEX.test(str);
  }
  exports.isHex = isHex;
} });
var require_common = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/common.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.containsDuplicates = exports.validateCredentialsList = exports.validateCredentialType = exports.parseAmountValue = exports.validateBaseTransaction = exports.GlobalFlags = exports.validateOptionalField = exports.validateRequiredField = exports.isArray = exports.isXChainBridge = exports.isAmount = exports.isAccount = exports.isMPTAmount = exports.isAuthorizeCredential = exports.isIssuedCurrency = exports.isCurrency = exports.isNumber = exports.isString = exports.isRecord = exports.MAX_AUTHORIZED_CREDENTIALS = void 0;
  const utils_1$28 = require_browser$4();
  const ripple_address_codec_1$9 = require_dist$3();
  const ripple_binary_codec_1$10 = require_dist$1$1();
  const errors_1$58 = require_errors();
  const utils_2$2 = require_utils$4$1();
  const MEMO_SIZE = 3;
  exports.MAX_AUTHORIZED_CREDENTIALS = 8;
  const MAX_CREDENTIAL_BYTE_LENGTH = 64;
  const MAX_CREDENTIAL_TYPE_LENGTH = MAX_CREDENTIAL_BYTE_LENGTH * 2;
  function isMemo(obj) {
    if (obj.Memo == null) return false;
    const memo = obj.Memo;
    const size = Object.keys(memo).length;
    const validData = memo.MemoData == null || typeof memo.MemoData === "string";
    const validFormat = memo.MemoFormat == null || typeof memo.MemoFormat === "string";
    const validType = memo.MemoType == null || typeof memo.MemoType === "string";
    return size >= 1 && size <= MEMO_SIZE && validData && validFormat && validType && (0, utils_2$2.onlyHasFields)(memo, [
      "MemoFormat",
      "MemoData",
      "MemoType"
    ]);
  }
  const SIGNER_SIZE = 3;
  function isSigner(obj) {
    const signerWrapper = obj;
    if (signerWrapper.Signer == null) return false;
    const signer = signerWrapper.Signer;
    return Object.keys(signer).length === SIGNER_SIZE && typeof signer.Account === "string" && typeof signer.TxnSignature === "string" && typeof signer.SigningPubKey === "string";
  }
  const XRP_CURRENCY_SIZE = 1;
  const ISSUE_SIZE = 2;
  const ISSUED_CURRENCY_SIZE = 3;
  const XCHAIN_BRIDGE_SIZE = 4;
  const MPTOKEN_SIZE = 2;
  const AUTHORIZE_CREDENTIAL_SIZE = 1;
  function isRecord(value) {
    return value !== null && typeof value === "object";
  }
  exports.isRecord = isRecord;
  function isString(str) {
    return typeof str === "string";
  }
  exports.isString = isString;
  function isNumber(num$1) {
    return typeof num$1 === "number";
  }
  exports.isNumber = isNumber;
  function isCurrency(input) {
    return isRecord(input) && (Object.keys(input).length === ISSUE_SIZE && typeof input.issuer === "string" && typeof input.currency === "string" || Object.keys(input).length === XRP_CURRENCY_SIZE && input.currency === "XRP");
  }
  exports.isCurrency = isCurrency;
  function isIssuedCurrency(input) {
    return isRecord(input) && Object.keys(input).length === ISSUED_CURRENCY_SIZE && typeof input.value === "string" && typeof input.issuer === "string" && typeof input.currency === "string";
  }
  exports.isIssuedCurrency = isIssuedCurrency;
  function isAuthorizeCredential(input) {
    return isRecord(input) && isRecord(input.Credential) && Object.keys(input).length === AUTHORIZE_CREDENTIAL_SIZE && typeof input.Credential.CredentialType === "string" && typeof input.Credential.Issuer === "string";
  }
  exports.isAuthorizeCredential = isAuthorizeCredential;
  function isMPTAmount(input) {
    return isRecord(input) && Object.keys(input).length === MPTOKEN_SIZE && typeof input.value === "string" && typeof input.mpt_issuance_id === "string";
  }
  exports.isMPTAmount = isMPTAmount;
  function isAccount(account) {
    return typeof account === "string" && ((0, ripple_address_codec_1$9.isValidClassicAddress)(account) || (0, ripple_address_codec_1$9.isValidXAddress)(account));
  }
  exports.isAccount = isAccount;
  function isAmount(amount) {
    return typeof amount === "string" || isIssuedCurrency(amount) || isMPTAmount(amount);
  }
  exports.isAmount = isAmount;
  function isXChainBridge(input) {
    return isRecord(input) && Object.keys(input).length === XCHAIN_BRIDGE_SIZE && typeof input.LockingChainDoor === "string" && isCurrency(input.LockingChainIssue) && typeof input.IssuingChainDoor === "string" && isCurrency(input.IssuingChainIssue);
  }
  exports.isXChainBridge = isXChainBridge;
  function isArray(input) {
    return Array.isArray(input);
  }
  exports.isArray = isArray;
  function validateRequiredField(tx2, param, checkValidity, errorOpts = {}) {
    var _a, _b;
    const paramNameStr = (_a = errorOpts.paramName) !== null && _a !== void 0 ? _a : param;
    const txType = (_b = errorOpts.txType) !== null && _b !== void 0 ? _b : tx2.TransactionType;
    if (tx2[param] == null) throw new errors_1$58.ValidationError(`${txType}: missing field ${String(paramNameStr)}`);
    if (!checkValidity(tx2[param])) throw new errors_1$58.ValidationError(`${txType}: invalid field ${String(paramNameStr)}`);
  }
  exports.validateRequiredField = validateRequiredField;
  function validateOptionalField(tx2, param, checkValidity, errorOpts = {}) {
    var _a, _b;
    const paramNameStr = (_a = errorOpts.paramName) !== null && _a !== void 0 ? _a : param;
    const txType = (_b = errorOpts.txType) !== null && _b !== void 0 ? _b : tx2.TransactionType;
    if (tx2[param] !== void 0 && !checkValidity(tx2[param])) throw new errors_1$58.ValidationError(`${txType}: invalid field ${String(paramNameStr)}`);
  }
  exports.validateOptionalField = validateOptionalField;
  var GlobalFlags;
  (function(GlobalFlags$1) {
    GlobalFlags$1[GlobalFlags$1["tfInnerBatchTxn"] = 1073741824] = "tfInnerBatchTxn";
  })(GlobalFlags || (exports.GlobalFlags = GlobalFlags = {}));
  function validateBaseTransaction(common2) {
    if (common2.TransactionType === void 0) throw new errors_1$58.ValidationError("BaseTransaction: missing field TransactionType");
    if (typeof common2.TransactionType !== "string") throw new errors_1$58.ValidationError("BaseTransaction: TransactionType not string");
    if (!ripple_binary_codec_1$10.TRANSACTION_TYPES.includes(common2.TransactionType)) throw new errors_1$58.ValidationError(`BaseTransaction: Unknown TransactionType ${common2.TransactionType}`);
    validateRequiredField(common2, "Account", isString);
    validateOptionalField(common2, "Fee", isString);
    validateOptionalField(common2, "Sequence", isNumber);
    validateOptionalField(common2, "AccountTxnID", isString);
    validateOptionalField(common2, "LastLedgerSequence", isNumber);
    const memos = common2.Memos;
    if (memos !== void 0 && !memos.every(isMemo)) throw new errors_1$58.ValidationError("BaseTransaction: invalid Memos");
    const signers = common2.Signers;
    if (signers !== void 0 && (signers.length === 0 || !signers.every(isSigner))) throw new errors_1$58.ValidationError("BaseTransaction: invalid Signers");
    validateOptionalField(common2, "SourceTag", isNumber);
    validateOptionalField(common2, "SigningPubKey", isString);
    validateOptionalField(common2, "TicketSequence", isNumber);
    validateOptionalField(common2, "TxnSignature", isString);
    validateOptionalField(common2, "NetworkID", isNumber);
    validateOptionalField(common2, "Delegate", isAccount);
    const delegate = common2.Delegate;
    if (delegate != null && delegate === common2.Account) throw new errors_1$58.ValidationError("BaseTransaction: Account and Delegate addresses cannot be the same");
  }
  exports.validateBaseTransaction = validateBaseTransaction;
  function parseAmountValue(amount) {
    if (!isAmount(amount)) return NaN;
    if (typeof amount === "string") return parseFloat(amount);
    return parseFloat(amount.value);
  }
  exports.parseAmountValue = parseAmountValue;
  function validateCredentialType(tx2) {
    if (typeof tx2.TransactionType !== "string") throw new errors_1$58.ValidationError("Invalid TransactionType");
    if (tx2.CredentialType === void 0) throw new errors_1$58.ValidationError(`${tx2.TransactionType}: missing field CredentialType`);
    if (!isString(tx2.CredentialType)) throw new errors_1$58.ValidationError(`${tx2.TransactionType}: CredentialType must be a string`);
    if (tx2.CredentialType.length === 0) throw new errors_1$58.ValidationError(`${tx2.TransactionType}: CredentialType cannot be an empty string`);
    else if (tx2.CredentialType.length > MAX_CREDENTIAL_TYPE_LENGTH) throw new errors_1$58.ValidationError(`${tx2.TransactionType}: CredentialType length cannot be > ${MAX_CREDENTIAL_TYPE_LENGTH}`);
    if (!utils_1$28.HEX_REGEX.test(tx2.CredentialType)) throw new errors_1$58.ValidationError(`${tx2.TransactionType}: CredentialType must be encoded in hex`);
  }
  exports.validateCredentialType = validateCredentialType;
  function validateCredentialsList(credentials, transactionType, isStringID, maxCredentials) {
    if (credentials == null) return;
    if (!Array.isArray(credentials)) throw new errors_1$58.ValidationError(`${transactionType}: Credentials must be an array`);
    if (credentials.length > maxCredentials) throw new errors_1$58.ValidationError(`${transactionType}: Credentials length cannot exceed ${maxCredentials} elements`);
    else if (credentials.length === 0) throw new errors_1$58.ValidationError(`${transactionType}: Credentials cannot be an empty array`);
    credentials.forEach((credential) => {
      if (isStringID) {
        if (!isString(credential)) throw new errors_1$58.ValidationError(`${transactionType}: Invalid Credentials ID list format`);
      } else if (!isAuthorizeCredential(credential)) throw new errors_1$58.ValidationError(`${transactionType}: Invalid Credentials format`);
    });
    if (containsDuplicates(credentials)) throw new errors_1$58.ValidationError(`${transactionType}: Credentials cannot contain duplicate elements`);
  }
  exports.validateCredentialsList = validateCredentialsList;
  function isAuthorizeCredentialArray(list) {
    return typeof list[0] !== "string";
  }
  function containsDuplicates(objectList) {
    if (typeof objectList[0] === "string") {
      const objSet = new Set(objectList.map((obj) => JSON.stringify(obj)));
      return objSet.size !== objectList.length;
    }
    const seen = /* @__PURE__ */ new Set();
    if (isAuthorizeCredentialArray(objectList)) for (const item of objectList) {
      const key = `${item.Credential.Issuer}-${item.Credential.CredentialType}`;
      if (seen.has(key)) return true;
      seen.add(key);
    }
    return false;
  }
  exports.containsDuplicates = containsDuplicates;
} });
var require_accountSet = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/accountSet.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateAccountSet = exports.AccountSetTfFlags = exports.AccountSetAsfFlags = void 0;
  const errors_1$57 = require_errors();
  const common_1$61 = require_common();
  var AccountSetAsfFlags;
  (function(AccountSetAsfFlags$1) {
    AccountSetAsfFlags$1[AccountSetAsfFlags$1["asfRequireDest"] = 1] = "asfRequireDest";
    AccountSetAsfFlags$1[AccountSetAsfFlags$1["asfRequireAuth"] = 2] = "asfRequireAuth";
    AccountSetAsfFlags$1[AccountSetAsfFlags$1["asfDisallowXRP"] = 3] = "asfDisallowXRP";
    AccountSetAsfFlags$1[AccountSetAsfFlags$1["asfDisableMaster"] = 4] = "asfDisableMaster";
    AccountSetAsfFlags$1[AccountSetAsfFlags$1["asfAccountTxnID"] = 5] = "asfAccountTxnID";
    AccountSetAsfFlags$1[AccountSetAsfFlags$1["asfNoFreeze"] = 6] = "asfNoFreeze";
    AccountSetAsfFlags$1[AccountSetAsfFlags$1["asfGlobalFreeze"] = 7] = "asfGlobalFreeze";
    AccountSetAsfFlags$1[AccountSetAsfFlags$1["asfDefaultRipple"] = 8] = "asfDefaultRipple";
    AccountSetAsfFlags$1[AccountSetAsfFlags$1["asfDepositAuth"] = 9] = "asfDepositAuth";
    AccountSetAsfFlags$1[AccountSetAsfFlags$1["asfAuthorizedNFTokenMinter"] = 10] = "asfAuthorizedNFTokenMinter";
    AccountSetAsfFlags$1[AccountSetAsfFlags$1["asfDisallowIncomingNFTokenOffer"] = 12] = "asfDisallowIncomingNFTokenOffer";
    AccountSetAsfFlags$1[AccountSetAsfFlags$1["asfDisallowIncomingCheck"] = 13] = "asfDisallowIncomingCheck";
    AccountSetAsfFlags$1[AccountSetAsfFlags$1["asfDisallowIncomingPayChan"] = 14] = "asfDisallowIncomingPayChan";
    AccountSetAsfFlags$1[AccountSetAsfFlags$1["asfDisallowIncomingTrustline"] = 15] = "asfDisallowIncomingTrustline";
    AccountSetAsfFlags$1[AccountSetAsfFlags$1["asfAllowTrustLineClawback"] = 16] = "asfAllowTrustLineClawback";
  })(AccountSetAsfFlags || (exports.AccountSetAsfFlags = AccountSetAsfFlags = {}));
  var AccountSetTfFlags;
  (function(AccountSetTfFlags$1) {
    AccountSetTfFlags$1[AccountSetTfFlags$1["tfRequireDestTag"] = 65536] = "tfRequireDestTag";
    AccountSetTfFlags$1[AccountSetTfFlags$1["tfOptionalDestTag"] = 131072] = "tfOptionalDestTag";
    AccountSetTfFlags$1[AccountSetTfFlags$1["tfRequireAuth"] = 262144] = "tfRequireAuth";
    AccountSetTfFlags$1[AccountSetTfFlags$1["tfOptionalAuth"] = 524288] = "tfOptionalAuth";
    AccountSetTfFlags$1[AccountSetTfFlags$1["tfDisallowXRP"] = 1048576] = "tfDisallowXRP";
    AccountSetTfFlags$1[AccountSetTfFlags$1["tfAllowXRP"] = 2097152] = "tfAllowXRP";
  })(AccountSetTfFlags || (exports.AccountSetTfFlags = AccountSetTfFlags = {}));
  const MIN_TICK_SIZE = 3;
  const MAX_TICK_SIZE = 15;
  function validateAccountSet(tx2) {
    (0, common_1$61.validateBaseTransaction)(tx2);
    (0, common_1$61.validateOptionalField)(tx2, "NFTokenMinter", common_1$61.isAccount);
    if (tx2.ClearFlag !== void 0) {
      if (typeof tx2.ClearFlag !== "number") throw new errors_1$57.ValidationError("AccountSet: invalid ClearFlag");
      if (!Object.values(AccountSetAsfFlags).includes(tx2.ClearFlag)) throw new errors_1$57.ValidationError("AccountSet: invalid ClearFlag");
    }
    if (tx2.Domain !== void 0 && typeof tx2.Domain !== "string") throw new errors_1$57.ValidationError("AccountSet: invalid Domain");
    if (tx2.EmailHash !== void 0 && typeof tx2.EmailHash !== "string") throw new errors_1$57.ValidationError("AccountSet: invalid EmailHash");
    if (tx2.MessageKey !== void 0 && typeof tx2.MessageKey !== "string") throw new errors_1$57.ValidationError("AccountSet: invalid MessageKey");
    if (tx2.SetFlag !== void 0) {
      if (typeof tx2.SetFlag !== "number") throw new errors_1$57.ValidationError("AccountSet: invalid SetFlag");
      if (!Object.values(AccountSetAsfFlags).includes(tx2.SetFlag)) throw new errors_1$57.ValidationError("AccountSet: invalid SetFlag");
    }
    if (tx2.TransferRate !== void 0 && typeof tx2.TransferRate !== "number") throw new errors_1$57.ValidationError("AccountSet: invalid TransferRate");
    if (tx2.TickSize !== void 0) {
      if (typeof tx2.TickSize !== "number") throw new errors_1$57.ValidationError("AccountSet: invalid TickSize");
      if (tx2.TickSize !== 0 && (tx2.TickSize < MIN_TICK_SIZE || tx2.TickSize > MAX_TICK_SIZE)) throw new errors_1$57.ValidationError("AccountSet: invalid TickSize");
    }
  }
  exports.validateAccountSet = validateAccountSet;
} });
var require_AMMClawback = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/AMMClawback.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateAMMClawback = exports.AMMClawbackFlags = void 0;
  const errors_1$56 = require_errors();
  const common_1$60 = require_common();
  var AMMClawbackFlags;
  (function(AMMClawbackFlags$1) {
    AMMClawbackFlags$1[AMMClawbackFlags$1["tfClawTwoAssets"] = 1] = "tfClawTwoAssets";
  })(AMMClawbackFlags || (exports.AMMClawbackFlags = AMMClawbackFlags = {}));
  function validateAMMClawback(tx2) {
    (0, common_1$60.validateBaseTransaction)(tx2);
    (0, common_1$60.validateRequiredField)(tx2, "Holder", common_1$60.isAccount);
    (0, common_1$60.validateRequiredField)(tx2, "Asset", common_1$60.isCurrency);
    const asset = tx2.Asset;
    const amount = tx2.Amount;
    if (tx2.Holder === asset.issuer) throw new errors_1$56.ValidationError("AMMClawback: Holder and Asset.issuer must be distinct");
    if (tx2.Account !== asset.issuer) throw new errors_1$56.ValidationError("AMMClawback: Account must be the same as Asset.issuer");
    (0, common_1$60.validateRequiredField)(tx2, "Asset2", common_1$60.isCurrency);
    (0, common_1$60.validateOptionalField)(tx2, "Amount", common_1$60.isAmount);
    if (tx2.Amount != null) {
      if (amount.currency !== asset.currency) throw new errors_1$56.ValidationError("AMMClawback: Amount.currency must match Asset.currency");
      if (amount.issuer !== asset.issuer) throw new errors_1$56.ValidationError("AMMClawback: Amount.issuer must match Amount.issuer");
    }
  }
  exports.validateAMMClawback = validateAMMClawback;
} });
var require_AMMDeposit = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/AMMDeposit.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateAMMDeposit = exports.AMMDepositFlags = void 0;
  const errors_1$55 = require_errors();
  const common_1$59 = require_common();
  var AMMDepositFlags;
  (function(AMMDepositFlags$1) {
    AMMDepositFlags$1[AMMDepositFlags$1["tfLPToken"] = 65536] = "tfLPToken";
    AMMDepositFlags$1[AMMDepositFlags$1["tfSingleAsset"] = 524288] = "tfSingleAsset";
    AMMDepositFlags$1[AMMDepositFlags$1["tfTwoAsset"] = 1048576] = "tfTwoAsset";
    AMMDepositFlags$1[AMMDepositFlags$1["tfOneAssetLPToken"] = 2097152] = "tfOneAssetLPToken";
    AMMDepositFlags$1[AMMDepositFlags$1["tfLimitLPToken"] = 4194304] = "tfLimitLPToken";
    AMMDepositFlags$1[AMMDepositFlags$1["tfTwoAssetIfEmpty"] = 8388608] = "tfTwoAssetIfEmpty";
  })(AMMDepositFlags || (exports.AMMDepositFlags = AMMDepositFlags = {}));
  function validateAMMDeposit(tx2) {
    (0, common_1$59.validateBaseTransaction)(tx2);
    if (tx2.Asset == null) throw new errors_1$55.ValidationError("AMMDeposit: missing field Asset");
    if (!(0, common_1$59.isCurrency)(tx2.Asset)) throw new errors_1$55.ValidationError("AMMDeposit: Asset must be a Currency");
    if (tx2.Asset2 == null) throw new errors_1$55.ValidationError("AMMDeposit: missing field Asset2");
    if (!(0, common_1$59.isCurrency)(tx2.Asset2)) throw new errors_1$55.ValidationError("AMMDeposit: Asset2 must be a Currency");
    if (tx2.Amount2 != null && tx2.Amount == null) throw new errors_1$55.ValidationError("AMMDeposit: must set Amount with Amount2");
    else if (tx2.EPrice != null && tx2.Amount == null) throw new errors_1$55.ValidationError("AMMDeposit: must set Amount with EPrice");
    else if (tx2.LPTokenOut == null && tx2.Amount == null) throw new errors_1$55.ValidationError("AMMDeposit: must set at least LPTokenOut or Amount");
    if (tx2.LPTokenOut != null && !(0, common_1$59.isIssuedCurrency)(tx2.LPTokenOut)) throw new errors_1$55.ValidationError("AMMDeposit: LPTokenOut must be an IssuedCurrencyAmount");
    if (tx2.Amount != null && !(0, common_1$59.isAmount)(tx2.Amount)) throw new errors_1$55.ValidationError("AMMDeposit: Amount must be an Amount");
    if (tx2.Amount2 != null && !(0, common_1$59.isAmount)(tx2.Amount2)) throw new errors_1$55.ValidationError("AMMDeposit: Amount2 must be an Amount");
    if (tx2.EPrice != null && !(0, common_1$59.isAmount)(tx2.EPrice)) throw new errors_1$55.ValidationError("AMMDeposit: EPrice must be an Amount");
  }
  exports.validateAMMDeposit = validateAMMDeposit;
} });
var require_AMMWithdraw = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/AMMWithdraw.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateAMMWithdraw = exports.AMMWithdrawFlags = void 0;
  const errors_1$54 = require_errors();
  const common_1$58 = require_common();
  var AMMWithdrawFlags;
  (function(AMMWithdrawFlags$1) {
    AMMWithdrawFlags$1[AMMWithdrawFlags$1["tfLPToken"] = 65536] = "tfLPToken";
    AMMWithdrawFlags$1[AMMWithdrawFlags$1["tfWithdrawAll"] = 131072] = "tfWithdrawAll";
    AMMWithdrawFlags$1[AMMWithdrawFlags$1["tfOneAssetWithdrawAll"] = 262144] = "tfOneAssetWithdrawAll";
    AMMWithdrawFlags$1[AMMWithdrawFlags$1["tfSingleAsset"] = 524288] = "tfSingleAsset";
    AMMWithdrawFlags$1[AMMWithdrawFlags$1["tfTwoAsset"] = 1048576] = "tfTwoAsset";
    AMMWithdrawFlags$1[AMMWithdrawFlags$1["tfOneAssetLPToken"] = 2097152] = "tfOneAssetLPToken";
    AMMWithdrawFlags$1[AMMWithdrawFlags$1["tfLimitLPToken"] = 4194304] = "tfLimitLPToken";
  })(AMMWithdrawFlags || (exports.AMMWithdrawFlags = AMMWithdrawFlags = {}));
  function validateAMMWithdraw(tx2) {
    (0, common_1$58.validateBaseTransaction)(tx2);
    if (tx2.Asset == null) throw new errors_1$54.ValidationError("AMMWithdraw: missing field Asset");
    if (!(0, common_1$58.isCurrency)(tx2.Asset)) throw new errors_1$54.ValidationError("AMMWithdraw: Asset must be a Currency");
    if (tx2.Asset2 == null) throw new errors_1$54.ValidationError("AMMWithdraw: missing field Asset2");
    if (!(0, common_1$58.isCurrency)(tx2.Asset2)) throw new errors_1$54.ValidationError("AMMWithdraw: Asset2 must be a Currency");
    if (tx2.Amount2 != null && tx2.Amount == null) throw new errors_1$54.ValidationError("AMMWithdraw: must set Amount with Amount2");
    else if (tx2.EPrice != null && tx2.Amount == null) throw new errors_1$54.ValidationError("AMMWithdraw: must set Amount with EPrice");
    if (tx2.LPTokenIn != null && !(0, common_1$58.isIssuedCurrency)(tx2.LPTokenIn)) throw new errors_1$54.ValidationError("AMMWithdraw: LPTokenIn must be an IssuedCurrencyAmount");
    if (tx2.Amount != null && !(0, common_1$58.isAmount)(tx2.Amount)) throw new errors_1$54.ValidationError("AMMWithdraw: Amount must be an Amount");
    if (tx2.Amount2 != null && !(0, common_1$58.isAmount)(tx2.Amount2)) throw new errors_1$54.ValidationError("AMMWithdraw: Amount2 must be an Amount");
    if (tx2.EPrice != null && !(0, common_1$58.isAmount)(tx2.EPrice)) throw new errors_1$54.ValidationError("AMMWithdraw: EPrice must be an Amount");
  }
  exports.validateAMMWithdraw = validateAMMWithdraw;
} });
var require_batch = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/batch.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateBatch = exports.BatchFlags = void 0;
  const errors_1$53 = require_errors();
  const utils_1$27 = require_utils$4$1();
  const common_1$57 = require_common();
  var BatchFlags;
  (function(BatchFlags$1) {
    BatchFlags$1[BatchFlags$1["tfAllOrNothing"] = 65536] = "tfAllOrNothing";
    BatchFlags$1[BatchFlags$1["tfOnlyOne"] = 131072] = "tfOnlyOne";
    BatchFlags$1[BatchFlags$1["tfUntilFailure"] = 262144] = "tfUntilFailure";
    BatchFlags$1[BatchFlags$1["tfIndependent"] = 524288] = "tfIndependent";
  })(BatchFlags || (exports.BatchFlags = BatchFlags = {}));
  function validateBatch(tx2) {
    var _a;
    (0, common_1$57.validateBaseTransaction)(tx2);
    (0, common_1$57.validateRequiredField)(tx2, "RawTransactions", common_1$57.isArray);
    tx2.RawTransactions.forEach((rawTxObj, index) => {
      if (!(0, common_1$57.isRecord)(rawTxObj)) throw new errors_1$53.ValidationError(`Batch: RawTransactions[${index}] is not object.`);
      (0, common_1$57.validateRequiredField)(rawTxObj, "RawTransaction", common_1$57.isRecord, {
        paramName: `RawTransactions[${index}].RawTransaction`,
        txType: "Batch"
      });
      const rawTx = rawTxObj.RawTransaction;
      if (rawTx.TransactionType === "Batch") throw new errors_1$53.ValidationError(`Batch: RawTransactions[${index}] is a Batch transaction. Cannot nest Batch transactions.`);
      if (!(0, utils_1$27.hasFlag)(rawTx, common_1$57.GlobalFlags.tfInnerBatchTxn, "tfInnerBatchTxn")) throw new errors_1$53.ValidationError(`Batch: RawTransactions[${index}] must contain the \`tfInnerBatchTxn\` flag.`);
    });
    (0, common_1$57.validateOptionalField)(tx2, "BatchSigners", common_1$57.isArray);
    (_a = tx2.BatchSigners) === null || _a === void 0 || _a.forEach((signerObj, index) => {
      if (!(0, common_1$57.isRecord)(signerObj)) throw new errors_1$53.ValidationError(`Batch: BatchSigners[${index}] is not object.`);
      const signerRecord = signerObj;
      (0, common_1$57.validateRequiredField)(signerRecord, "BatchSigner", common_1$57.isRecord, {
        paramName: `BatchSigners[${index}].BatchSigner`,
        txType: "Batch"
      });
      const signer = signerRecord.BatchSigner;
      (0, common_1$57.validateRequiredField)(signer, "Account", common_1$57.isString, {
        paramName: `BatchSigners[${index}].Account`,
        txType: "Batch"
      });
      (0, common_1$57.validateOptionalField)(signer, "SigningPubKey", common_1$57.isString, {
        paramName: `BatchSigners[${index}].SigningPubKey`,
        txType: "Batch"
      });
      (0, common_1$57.validateOptionalField)(signer, "TxnSignature", common_1$57.isString, {
        paramName: `BatchSigners[${index}].TxnSignature`,
        txType: "Batch"
      });
      (0, common_1$57.validateOptionalField)(signer, "Signers", common_1$57.isArray, {
        paramName: `BatchSigners[${index}].Signers`,
        txType: "Batch"
      });
    });
  }
  exports.validateBatch = validateBatch;
} });
var require_MPTokenAuthorize = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/MPTokenAuthorize.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateMPTokenAuthorize = exports.MPTokenAuthorizeFlags = void 0;
  const common_1$56 = require_common();
  var MPTokenAuthorizeFlags;
  (function(MPTokenAuthorizeFlags$1) {
    MPTokenAuthorizeFlags$1[MPTokenAuthorizeFlags$1["tfMPTUnauthorize"] = 1] = "tfMPTUnauthorize";
  })(MPTokenAuthorizeFlags || (exports.MPTokenAuthorizeFlags = MPTokenAuthorizeFlags = {}));
  function validateMPTokenAuthorize(tx2) {
    (0, common_1$56.validateBaseTransaction)(tx2);
    (0, common_1$56.validateRequiredField)(tx2, "MPTokenIssuanceID", common_1$56.isString);
    (0, common_1$56.validateOptionalField)(tx2, "Holder", common_1$56.isAccount);
  }
  exports.validateMPTokenAuthorize = validateMPTokenAuthorize;
} });
var require_MPTokenIssuanceCreate = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/MPTokenIssuanceCreate.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateMPTokenIssuanceCreate = exports.MPTokenIssuanceCreateFlags = void 0;
  const errors_1$52 = require_errors();
  const utils_1$26 = require_utils$4$1();
  const common_1$55 = require_common();
  const MAX_AMT = "9223372036854775807";
  const MAX_TRANSFER_FEE = 5e4;
  var MPTokenIssuanceCreateFlags;
  (function(MPTokenIssuanceCreateFlags$1) {
    MPTokenIssuanceCreateFlags$1[MPTokenIssuanceCreateFlags$1["tfMPTCanLock"] = 2] = "tfMPTCanLock";
    MPTokenIssuanceCreateFlags$1[MPTokenIssuanceCreateFlags$1["tfMPTRequireAuth"] = 4] = "tfMPTRequireAuth";
    MPTokenIssuanceCreateFlags$1[MPTokenIssuanceCreateFlags$1["tfMPTCanEscrow"] = 8] = "tfMPTCanEscrow";
    MPTokenIssuanceCreateFlags$1[MPTokenIssuanceCreateFlags$1["tfMPTCanTrade"] = 16] = "tfMPTCanTrade";
    MPTokenIssuanceCreateFlags$1[MPTokenIssuanceCreateFlags$1["tfMPTCanTransfer"] = 32] = "tfMPTCanTransfer";
    MPTokenIssuanceCreateFlags$1[MPTokenIssuanceCreateFlags$1["tfMPTCanClawback"] = 64] = "tfMPTCanClawback";
  })(MPTokenIssuanceCreateFlags || (exports.MPTokenIssuanceCreateFlags = MPTokenIssuanceCreateFlags = {}));
  function validateMPTokenIssuanceCreate(tx2) {
    var _a;
    (0, common_1$55.validateBaseTransaction)(tx2);
    (0, common_1$55.validateOptionalField)(tx2, "MaximumAmount", common_1$55.isString);
    (0, common_1$55.validateOptionalField)(tx2, "MPTokenMetadata", common_1$55.isString);
    (0, common_1$55.validateOptionalField)(tx2, "TransferFee", common_1$55.isNumber);
    (0, common_1$55.validateOptionalField)(tx2, "AssetScale", common_1$55.isNumber);
    if (typeof tx2.MPTokenMetadata === "string" && tx2.MPTokenMetadata === "") throw new errors_1$52.ValidationError("MPTokenIssuanceCreate: MPTokenMetadata must not be empty string");
    if (typeof tx2.MPTokenMetadata === "string" && !(0, utils_1$26.isHex)(tx2.MPTokenMetadata)) throw new errors_1$52.ValidationError("MPTokenIssuanceCreate: MPTokenMetadata must be in hex format");
    if (typeof tx2.MaximumAmount === "string") {
      if (!utils_1$26.INTEGER_SANITY_CHECK.exec(tx2.MaximumAmount)) throw new errors_1$52.ValidationError("MPTokenIssuanceCreate: Invalid MaximumAmount");
      else if (BigInt(tx2.MaximumAmount) > BigInt(MAX_AMT) || BigInt(tx2.MaximumAmount) < BigInt(`0`)) throw new errors_1$52.ValidationError("MPTokenIssuanceCreate: MaximumAmount out of range");
    }
    if (typeof tx2.TransferFee === "number") {
      const flags = tx2.Flags;
      const isTfMPTCanTransfer = typeof flags === "number" ? (0, utils_1$26.isFlagEnabled)(flags, MPTokenIssuanceCreateFlags.tfMPTCanTransfer) : (_a = flags.tfMPTCanTransfer) !== null && _a !== void 0 ? _a : false;
      if (tx2.TransferFee < 0 || tx2.TransferFee > MAX_TRANSFER_FEE) throw new errors_1$52.ValidationError(`MPTokenIssuanceCreate: TransferFee must be between 0 and ${MAX_TRANSFER_FEE}`);
      if (tx2.TransferFee && !isTfMPTCanTransfer) throw new errors_1$52.ValidationError("MPTokenIssuanceCreate: TransferFee cannot be provided without enabling tfMPTCanTransfer flag");
    }
  }
  exports.validateMPTokenIssuanceCreate = validateMPTokenIssuanceCreate;
} });
var require_MPTokenIssuanceSet = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/MPTokenIssuanceSet.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateMPTokenIssuanceSet = exports.MPTokenIssuanceSetFlags = void 0;
  const errors_1$51 = require_errors();
  const utils_1$25 = require_utils$4$1();
  const common_1$54 = require_common();
  var MPTokenIssuanceSetFlags;
  (function(MPTokenIssuanceSetFlags$1) {
    MPTokenIssuanceSetFlags$1[MPTokenIssuanceSetFlags$1["tfMPTLock"] = 1] = "tfMPTLock";
    MPTokenIssuanceSetFlags$1[MPTokenIssuanceSetFlags$1["tfMPTUnlock"] = 2] = "tfMPTUnlock";
  })(MPTokenIssuanceSetFlags || (exports.MPTokenIssuanceSetFlags = MPTokenIssuanceSetFlags = {}));
  function validateMPTokenIssuanceSet(tx2) {
    var _a, _b;
    (0, common_1$54.validateBaseTransaction)(tx2);
    (0, common_1$54.validateRequiredField)(tx2, "MPTokenIssuanceID", common_1$54.isString);
    (0, common_1$54.validateOptionalField)(tx2, "Holder", common_1$54.isAccount);
    const flags = tx2.Flags;
    const isTfMPTLock = typeof flags === "number" ? (0, utils_1$25.isFlagEnabled)(flags, MPTokenIssuanceSetFlags.tfMPTLock) : (_a = flags.tfMPTLock) !== null && _a !== void 0 ? _a : false;
    const isTfMPTUnlock = typeof flags === "number" ? (0, utils_1$25.isFlagEnabled)(flags, MPTokenIssuanceSetFlags.tfMPTUnlock) : (_b = flags.tfMPTUnlock) !== null && _b !== void 0 ? _b : false;
    if (isTfMPTLock && isTfMPTUnlock) throw new errors_1$51.ValidationError("MPTokenIssuanceSet: flag conflict");
  }
  exports.validateMPTokenIssuanceSet = validateMPTokenIssuanceSet;
} });
var require_NFTokenCreateOffer = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenCreateOffer.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateNFTokenCreateOffer = exports.NFTokenCreateOfferFlags = void 0;
  const errors_1$50 = require_errors();
  const utils_1$24 = require_utils$4$1();
  const common_1$53 = require_common();
  var NFTokenCreateOfferFlags;
  (function(NFTokenCreateOfferFlags$1) {
    NFTokenCreateOfferFlags$1[NFTokenCreateOfferFlags$1["tfSellNFToken"] = 1] = "tfSellNFToken";
  })(NFTokenCreateOfferFlags || (exports.NFTokenCreateOfferFlags = NFTokenCreateOfferFlags = {}));
  function validateNFTokenSellOfferCases(tx2) {
    if (tx2.Owner != null) throw new errors_1$50.ValidationError("NFTokenCreateOffer: Owner must not be present for sell offers");
  }
  function validateNFTokenBuyOfferCases(tx2) {
    if (tx2.Owner == null) throw new errors_1$50.ValidationError("NFTokenCreateOffer: Owner must be present for buy offers");
    if ((0, common_1$53.parseAmountValue)(tx2.Amount) <= 0) throw new errors_1$50.ValidationError("NFTokenCreateOffer: Amount must be greater than 0 for buy offers");
  }
  function validateNFTokenCreateOffer(tx2) {
    (0, common_1$53.validateBaseTransaction)(tx2);
    if (tx2.Account === tx2.Owner) throw new errors_1$50.ValidationError("NFTokenCreateOffer: Owner and Account must not be equal");
    if (tx2.Account === tx2.Destination) throw new errors_1$50.ValidationError("NFTokenCreateOffer: Destination and Account must not be equal");
    (0, common_1$53.validateOptionalField)(tx2, "Destination", common_1$53.isAccount);
    (0, common_1$53.validateOptionalField)(tx2, "Owner", common_1$53.isAccount);
    if (tx2.NFTokenID == null) throw new errors_1$50.ValidationError("NFTokenCreateOffer: missing field NFTokenID");
    if (!(0, common_1$53.isAmount)(tx2.Amount)) throw new errors_1$50.ValidationError("NFTokenCreateOffer: invalid Amount");
    if (typeof tx2.Flags === "number" && (0, utils_1$24.isFlagEnabled)(tx2.Flags, NFTokenCreateOfferFlags.tfSellNFToken)) validateNFTokenSellOfferCases(tx2);
    else validateNFTokenBuyOfferCases(tx2);
  }
  exports.validateNFTokenCreateOffer = validateNFTokenCreateOffer;
} });
var require_NFTokenMint = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenMint.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateNFTokenMint = exports.NFTokenMintFlags = void 0;
  const errors_1$49 = require_errors();
  const utils_1$23 = require_utils$4$1();
  const common_1$52 = require_common();
  var NFTokenMintFlags;
  (function(NFTokenMintFlags$1) {
    NFTokenMintFlags$1[NFTokenMintFlags$1["tfBurnable"] = 1] = "tfBurnable";
    NFTokenMintFlags$1[NFTokenMintFlags$1["tfOnlyXRP"] = 2] = "tfOnlyXRP";
    NFTokenMintFlags$1[NFTokenMintFlags$1["tfTrustLine"] = 4] = "tfTrustLine";
    NFTokenMintFlags$1[NFTokenMintFlags$1["tfTransferable"] = 8] = "tfTransferable";
    NFTokenMintFlags$1[NFTokenMintFlags$1["tfMutable"] = 16] = "tfMutable";
  })(NFTokenMintFlags || (exports.NFTokenMintFlags = NFTokenMintFlags = {}));
  function validateNFTokenMint(tx2) {
    (0, common_1$52.validateBaseTransaction)(tx2);
    if (tx2.Account === tx2.Issuer) throw new errors_1$49.ValidationError("NFTokenMint: Issuer must not be equal to Account");
    (0, common_1$52.validateOptionalField)(tx2, "Issuer", common_1$52.isAccount);
    if (typeof tx2.URI === "string" && tx2.URI === "") throw new errors_1$49.ValidationError("NFTokenMint: URI must not be empty string");
    if (typeof tx2.URI === "string" && !(0, utils_1$23.isHex)(tx2.URI)) throw new errors_1$49.ValidationError("NFTokenMint: URI must be in hex format");
    if (tx2.NFTokenTaxon == null) throw new errors_1$49.ValidationError("NFTokenMint: missing field NFTokenTaxon");
    if (tx2.Amount == null) {
      if (tx2.Expiration != null || tx2.Destination != null) throw new errors_1$49.ValidationError("NFTokenMint: Amount is required when Expiration or Destination is present");
    }
    (0, common_1$52.validateOptionalField)(tx2, "Amount", common_1$52.isAmount);
    (0, common_1$52.validateOptionalField)(tx2, "Expiration", common_1$52.isNumber);
    (0, common_1$52.validateOptionalField)(tx2, "Destination", common_1$52.isAccount);
  }
  exports.validateNFTokenMint = validateNFTokenMint;
} });
var require_offerCreate = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/offerCreate.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateOfferCreate = exports.OfferCreateFlags = void 0;
  const errors_1$48 = require_errors();
  const common_1$51 = require_common();
  var OfferCreateFlags;
  (function(OfferCreateFlags$1) {
    OfferCreateFlags$1[OfferCreateFlags$1["tfPassive"] = 65536] = "tfPassive";
    OfferCreateFlags$1[OfferCreateFlags$1["tfImmediateOrCancel"] = 131072] = "tfImmediateOrCancel";
    OfferCreateFlags$1[OfferCreateFlags$1["tfFillOrKill"] = 262144] = "tfFillOrKill";
    OfferCreateFlags$1[OfferCreateFlags$1["tfSell"] = 524288] = "tfSell";
  })(OfferCreateFlags || (exports.OfferCreateFlags = OfferCreateFlags = {}));
  function validateOfferCreate(tx2) {
    (0, common_1$51.validateBaseTransaction)(tx2);
    if (tx2.TakerGets === void 0) throw new errors_1$48.ValidationError("OfferCreate: missing field TakerGets");
    if (tx2.TakerPays === void 0) throw new errors_1$48.ValidationError("OfferCreate: missing field TakerPays");
    if (typeof tx2.TakerGets !== "string" && !(0, common_1$51.isAmount)(tx2.TakerGets)) throw new errors_1$48.ValidationError("OfferCreate: invalid TakerGets");
    if (typeof tx2.TakerPays !== "string" && !(0, common_1$51.isAmount)(tx2.TakerPays)) throw new errors_1$48.ValidationError("OfferCreate: invalid TakerPays");
    if (tx2.Expiration !== void 0 && typeof tx2.Expiration !== "number") throw new errors_1$48.ValidationError("OfferCreate: invalid Expiration");
    if (tx2.OfferSequence !== void 0 && typeof tx2.OfferSequence !== "number") throw new errors_1$48.ValidationError("OfferCreate: invalid OfferSequence");
  }
  exports.validateOfferCreate = validateOfferCreate;
} });
var require_payment = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/payment.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validatePayment = exports.PaymentFlags = void 0;
  const errors_1$47 = require_errors();
  const utils_1$22 = require_utils$4$1();
  const common_1$50 = require_common();
  var PaymentFlags;
  (function(PaymentFlags$1) {
    PaymentFlags$1[PaymentFlags$1["tfNoRippleDirect"] = 65536] = "tfNoRippleDirect";
    PaymentFlags$1[PaymentFlags$1["tfPartialPayment"] = 131072] = "tfPartialPayment";
    PaymentFlags$1[PaymentFlags$1["tfLimitQuality"] = 262144] = "tfLimitQuality";
  })(PaymentFlags || (exports.PaymentFlags = PaymentFlags = {}));
  function validatePayment(tx2) {
    (0, common_1$50.validateBaseTransaction)(tx2);
    if (tx2.Amount === void 0) throw new errors_1$47.ValidationError("PaymentTransaction: missing field Amount");
    if (!(0, common_1$50.isAmount)(tx2.Amount)) throw new errors_1$47.ValidationError("PaymentTransaction: invalid Amount");
    (0, common_1$50.validateRequiredField)(tx2, "Destination", common_1$50.isAccount);
    (0, common_1$50.validateOptionalField)(tx2, "DestinationTag", common_1$50.isNumber);
    (0, common_1$50.validateCredentialsList)(tx2.CredentialIDs, tx2.TransactionType, true, common_1$50.MAX_AUTHORIZED_CREDENTIALS);
    if (tx2.InvoiceID !== void 0 && typeof tx2.InvoiceID !== "string") throw new errors_1$47.ValidationError("PaymentTransaction: InvoiceID must be a string");
    if (tx2.Paths !== void 0 && !isPaths(tx2.Paths)) throw new errors_1$47.ValidationError("PaymentTransaction: invalid Paths");
    if (tx2.SendMax !== void 0 && !(0, common_1$50.isAmount)(tx2.SendMax)) throw new errors_1$47.ValidationError("PaymentTransaction: invalid SendMax");
    checkPartialPayment(tx2);
  }
  exports.validatePayment = validatePayment;
  function checkPartialPayment(tx2) {
    var _a;
    if (tx2.DeliverMin != null) {
      if (tx2.Flags == null) throw new errors_1$47.ValidationError("PaymentTransaction: tfPartialPayment flag required with DeliverMin");
      const flags = tx2.Flags;
      const isTfPartialPayment = typeof flags === "number" ? (0, utils_1$22.isFlagEnabled)(flags, PaymentFlags.tfPartialPayment) : (_a = flags.tfPartialPayment) !== null && _a !== void 0 ? _a : false;
      if (!isTfPartialPayment) throw new errors_1$47.ValidationError("PaymentTransaction: tfPartialPayment flag required with DeliverMin");
      if (!(0, common_1$50.isAmount)(tx2.DeliverMin)) throw new errors_1$47.ValidationError("PaymentTransaction: invalid DeliverMin");
    }
  }
  function isPathStep(pathStep) {
    if (pathStep.account !== void 0 && typeof pathStep.account !== "string") return false;
    if (pathStep.currency !== void 0 && typeof pathStep.currency !== "string") return false;
    if (pathStep.issuer !== void 0 && typeof pathStep.issuer !== "string") return false;
    if (pathStep.account !== void 0 && pathStep.currency === void 0 && pathStep.issuer === void 0) return true;
    if (pathStep.currency !== void 0 || pathStep.issuer !== void 0) return true;
    return false;
  }
  function isPath(path) {
    if (!Array.isArray(path) || path.length === 0) return false;
    for (const pathStep of path) if (!isPathStep(pathStep)) return false;
    return true;
  }
  function isPaths(paths) {
    if (!Array.isArray(paths) || paths.length === 0) return false;
    for (const path of paths) {
      if (!Array.isArray(path) || path.length === 0) return false;
      if (!isPath(path)) return false;
    }
    return true;
  }
} });
var require_paymentChannelClaim = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/paymentChannelClaim.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validatePaymentChannelClaim = exports.PaymentChannelClaimFlags = void 0;
  const errors_1$46 = require_errors();
  const common_1$49 = require_common();
  var PaymentChannelClaimFlags;
  (function(PaymentChannelClaimFlags$1) {
    PaymentChannelClaimFlags$1[PaymentChannelClaimFlags$1["tfRenew"] = 65536] = "tfRenew";
    PaymentChannelClaimFlags$1[PaymentChannelClaimFlags$1["tfClose"] = 131072] = "tfClose";
  })(PaymentChannelClaimFlags || (exports.PaymentChannelClaimFlags = PaymentChannelClaimFlags = {}));
  function validatePaymentChannelClaim(tx2) {
    (0, common_1$49.validateBaseTransaction)(tx2);
    (0, common_1$49.validateCredentialsList)(tx2.CredentialIDs, tx2.TransactionType, true, common_1$49.MAX_AUTHORIZED_CREDENTIALS);
    if (tx2.Channel === void 0) throw new errors_1$46.ValidationError("PaymentChannelClaim: missing Channel");
    if (typeof tx2.Channel !== "string") throw new errors_1$46.ValidationError("PaymentChannelClaim: Channel must be a string");
    if (tx2.Balance !== void 0 && typeof tx2.Balance !== "string") throw new errors_1$46.ValidationError("PaymentChannelClaim: Balance must be a string");
    if (tx2.Amount !== void 0 && typeof tx2.Amount !== "string") throw new errors_1$46.ValidationError("PaymentChannelClaim: Amount must be a string");
    if (tx2.Signature !== void 0 && typeof tx2.Signature !== "string") throw new errors_1$46.ValidationError("PaymentChannelClaim: Signature must be a string");
    if (tx2.PublicKey !== void 0 && typeof tx2.PublicKey !== "string") throw new errors_1$46.ValidationError("PaymentChannelClaim: PublicKey must be a string");
  }
  exports.validatePaymentChannelClaim = validatePaymentChannelClaim;
} });
var require_trustSet = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/trustSet.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateTrustSet = exports.TrustSetFlags = void 0;
  const errors_1$45 = require_errors();
  const common_1$48 = require_common();
  var TrustSetFlags;
  (function(TrustSetFlags$1) {
    TrustSetFlags$1[TrustSetFlags$1["tfSetfAuth"] = 65536] = "tfSetfAuth";
    TrustSetFlags$1[TrustSetFlags$1["tfSetNoRipple"] = 131072] = "tfSetNoRipple";
    TrustSetFlags$1[TrustSetFlags$1["tfClearNoRipple"] = 262144] = "tfClearNoRipple";
    TrustSetFlags$1[TrustSetFlags$1["tfSetFreeze"] = 1048576] = "tfSetFreeze";
    TrustSetFlags$1[TrustSetFlags$1["tfClearFreeze"] = 2097152] = "tfClearFreeze";
    TrustSetFlags$1[TrustSetFlags$1["tfSetDeepFreeze"] = 4194304] = "tfSetDeepFreeze";
    TrustSetFlags$1[TrustSetFlags$1["tfClearDeepFreeze"] = 8388608] = "tfClearDeepFreeze";
  })(TrustSetFlags || (exports.TrustSetFlags = TrustSetFlags = {}));
  function validateTrustSet(tx2) {
    (0, common_1$48.validateBaseTransaction)(tx2);
    const { LimitAmount, QualityIn, QualityOut } = tx2;
    if (LimitAmount === void 0) throw new errors_1$45.ValidationError("TrustSet: missing field LimitAmount");
    if (!(0, common_1$48.isAmount)(LimitAmount)) throw new errors_1$45.ValidationError("TrustSet: invalid LimitAmount");
    if (QualityIn !== void 0 && typeof QualityIn !== "number") throw new errors_1$45.ValidationError("TrustSet: QualityIn must be a number");
    if (QualityOut !== void 0 && typeof QualityOut !== "number") throw new errors_1$45.ValidationError("TrustSet: QualityOut must be a number");
  }
  exports.validateTrustSet = validateTrustSet;
} });
var require_XChainModifyBridge = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainModifyBridge.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateXChainModifyBridge = exports.XChainModifyBridgeFlags = void 0;
  const common_1$47 = require_common();
  var XChainModifyBridgeFlags;
  (function(XChainModifyBridgeFlags$1) {
    XChainModifyBridgeFlags$1[XChainModifyBridgeFlags$1["tfClearAccountCreateAmount"] = 65536] = "tfClearAccountCreateAmount";
  })(XChainModifyBridgeFlags || (exports.XChainModifyBridgeFlags = XChainModifyBridgeFlags = {}));
  function validateXChainModifyBridge(tx2) {
    (0, common_1$47.validateBaseTransaction)(tx2);
    (0, common_1$47.validateRequiredField)(tx2, "XChainBridge", common_1$47.isXChainBridge);
    (0, common_1$47.validateOptionalField)(tx2, "SignatureReward", common_1$47.isAmount);
    (0, common_1$47.validateOptionalField)(tx2, "MinAccountCreateAmount", common_1$47.isAmount);
  }
  exports.validateXChainModifyBridge = validateXChainModifyBridge;
} });
var require_flags = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/utils/flags.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseTransactionFlags = exports.convertTxFlagsToNumber = exports.setTransactionFlagsToNumber = exports.parseAccountRootFlags = void 0;
  const errors_1$44 = require_errors();
  const AccountRoot_1$1 = require_AccountRoot();
  const accountSet_1$2 = require_accountSet();
  const AMMClawback_1$2 = require_AMMClawback();
  const AMMDeposit_1$2 = require_AMMDeposit();
  const AMMWithdraw_1$2 = require_AMMWithdraw();
  const batch_1$1 = require_batch();
  const common_1$46 = require_common();
  const MPTokenAuthorize_1$2 = require_MPTokenAuthorize();
  const MPTokenIssuanceCreate_1$2 = require_MPTokenIssuanceCreate();
  const MPTokenIssuanceSet_1$2 = require_MPTokenIssuanceSet();
  const NFTokenCreateOffer_1$2 = require_NFTokenCreateOffer();
  const NFTokenMint_1$2 = require_NFTokenMint();
  const offerCreate_1$2 = require_offerCreate();
  const payment_1$2 = require_payment();
  const paymentChannelClaim_1$2 = require_paymentChannelClaim();
  const trustSet_1$2 = require_trustSet();
  const XChainModifyBridge_1$2 = require_XChainModifyBridge();
  const _1$2 = require_utils$4$1();
  function parseAccountRootFlags(flags) {
    const flagsInterface = {};
    Object.values(AccountRoot_1$1.AccountRootFlags).forEach((flag) => {
      if (typeof flag === "string" && (0, _1$2.isFlagEnabled)(flags, AccountRoot_1$1.AccountRootFlags[flag])) flagsInterface[flag] = true;
    });
    return flagsInterface;
  }
  exports.parseAccountRootFlags = parseAccountRootFlags;
  const txToFlag = {
    AccountSet: accountSet_1$2.AccountSetTfFlags,
    AMMClawback: AMMClawback_1$2.AMMClawbackFlags,
    AMMDeposit: AMMDeposit_1$2.AMMDepositFlags,
    AMMWithdraw: AMMWithdraw_1$2.AMMWithdrawFlags,
    Batch: batch_1$1.BatchFlags,
    MPTokenAuthorize: MPTokenAuthorize_1$2.MPTokenAuthorizeFlags,
    MPTokenIssuanceCreate: MPTokenIssuanceCreate_1$2.MPTokenIssuanceCreateFlags,
    MPTokenIssuanceSet: MPTokenIssuanceSet_1$2.MPTokenIssuanceSetFlags,
    NFTokenCreateOffer: NFTokenCreateOffer_1$2.NFTokenCreateOfferFlags,
    NFTokenMint: NFTokenMint_1$2.NFTokenMintFlags,
    OfferCreate: offerCreate_1$2.OfferCreateFlags,
    PaymentChannelClaim: paymentChannelClaim_1$2.PaymentChannelClaimFlags,
    Payment: payment_1$2.PaymentFlags,
    TrustSet: trustSet_1$2.TrustSetFlags,
    XChainModifyBridge: XChainModifyBridge_1$2.XChainModifyBridgeFlags
  };
  function isTxToFlagKey(transactionType) {
    return transactionType in txToFlag;
  }
  function setTransactionFlagsToNumber(tx2) {
    console.warn("This function is deprecated. Use convertTxFlagsToNumber() instead and use the returned value to modify the Transaction.Flags from the caller.");
    if (tx2.Flags) tx2.Flags = convertTxFlagsToNumber(tx2);
  }
  exports.setTransactionFlagsToNumber = setTransactionFlagsToNumber;
  function convertTxFlagsToNumber(tx2) {
    const txFlags = tx2.Flags;
    if (txFlags == null) return 0;
    if (typeof txFlags === "number") return txFlags;
    if (isTxToFlagKey(tx2.TransactionType)) {
      const flagEnum = txToFlag[tx2.TransactionType];
      return Object.keys(txFlags).reduce((resultFlags, flag) => {
        if (flagEnum[flag] == null && common_1$46.GlobalFlags[flag] == null) throw new errors_1$44.ValidationError(`Invalid flag ${flag}.`);
        return txFlags[flag] ? resultFlags | (flagEnum[flag] || common_1$46.GlobalFlags[flag]) : resultFlags;
      }, 0);
    }
    return Object.keys(txFlags).reduce((resultFlags, flag) => {
      if (common_1$46.GlobalFlags[flag] == null) throw new errors_1$44.ValidationError(`Invalid flag ${flag}. Valid flags are ${JSON.stringify(common_1$46.GlobalFlags)}`);
      return txFlags[flag] ? resultFlags | common_1$46.GlobalFlags[flag] : resultFlags;
    }, 0);
  }
  exports.convertTxFlagsToNumber = convertTxFlagsToNumber;
  function parseTransactionFlags(tx2) {
    const flags = convertTxFlagsToNumber(tx2);
    if (flags === 0) return {};
    const booleanFlagMap = {};
    if (isTxToFlagKey(tx2.TransactionType)) {
      const transactionTypeFlags = txToFlag[tx2.TransactionType];
      Object.values(transactionTypeFlags).forEach((flag) => {
        if (typeof flag === "string" && (0, _1$2.isFlagEnabled)(flags, transactionTypeFlags[flag])) booleanFlagMap[flag] = true;
      });
    }
    Object.values(common_1$46.GlobalFlags).forEach((flag) => {
      if (typeof flag === "string" && (0, _1$2.isFlagEnabled)(flags, common_1$46.GlobalFlags[flag])) booleanFlagMap[flag] = true;
    });
    return booleanFlagMap;
  }
  exports.parseTransactionFlags = parseTransactionFlags;
} });
var require_derive = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/derive.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deriveXAddress = exports.deriveAddress = exports.deriveKeypair = void 0;
  const ripple_address_codec_1$8 = require_dist$3();
  const ripple_keypairs_1$6 = require_dist$2();
  Object.defineProperty(exports, "deriveKeypair", {
    enumerable: true,
    get: function() {
      return ripple_keypairs_1$6.deriveKeypair;
    }
  });
  Object.defineProperty(exports, "deriveAddress", {
    enumerable: true,
    get: function() {
      return ripple_keypairs_1$6.deriveAddress;
    }
  });
  function deriveXAddress(options) {
    const classicAddress = (0, ripple_keypairs_1$6.deriveAddress)(options.publicKey);
    return (0, ripple_address_codec_1$8.classicAddressToXAddress)(classicAddress, options.tag, options.test);
  }
  exports.deriveXAddress = deriveXAddress;
} });
var require_collections = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/collections.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.omitBy = exports.groupBy = void 0;
  function groupBy(array, iteratee) {
    function predicate(acc, value, index, arrayReference) {
      const key = iteratee(value, index, arrayReference) || 0;
      const group = acc[key] || [];
      group.push(value);
      acc[key] = group;
      return acc;
    }
    return array.reduce(predicate, {});
  }
  exports.groupBy = groupBy;
  function omitBy(obj, predicate) {
    const keys2 = Object.keys(obj);
    const keysToKeep = keys2.filter((kb) => !predicate(obj[kb], kb));
    return keysToKeep.reduce((acc, key) => {
      acc[key] = obj[key];
      return acc;
    }, {});
  }
  exports.omitBy = omitBy;
} });
var require_xrpConversion = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/xrpConversion.js"(exports) {
  var __importDefault$19 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.xrpToDrops = exports.dropsToXrp = void 0;
  const bignumber_js_1$11 = __importDefault$19(require_bignumber());
  const errors_1$43 = require_errors();
  const DROPS_PER_XRP = 1e6;
  const MAX_FRACTION_LENGTH = 6;
  const BASE_TEN$1 = 10;
  const SANITY_CHECK = /^-?[0-9.]+$/u;
  function dropsToXrp(dropsToConvert) {
    const drops = new bignumber_js_1$11.default(dropsToConvert).toString(BASE_TEN$1);
    if (typeof dropsToConvert === "string" && drops === "NaN") throw new errors_1$43.ValidationError(`dropsToXrp: invalid value '${dropsToConvert}', should be a BigNumber or string-encoded number.`);
    if (drops.includes(".")) throw new errors_1$43.ValidationError(`dropsToXrp: value '${drops}' has too many decimal places.`);
    if (!SANITY_CHECK.exec(drops)) throw new errors_1$43.ValidationError(`dropsToXrp: failed sanity check - value '${drops}', does not match (^-?[0-9]+$).`);
    return new bignumber_js_1$11.default(drops).dividedBy(DROPS_PER_XRP).toNumber();
  }
  exports.dropsToXrp = dropsToXrp;
  function xrpToDrops(xrpToConvert) {
    const xrp = new bignumber_js_1$11.default(xrpToConvert).toString(BASE_TEN$1);
    if (typeof xrpToConvert === "string" && xrp === "NaN") throw new errors_1$43.ValidationError(`xrpToDrops: invalid value '${xrpToConvert}', should be a BigNumber or string-encoded number.`);
    if (!SANITY_CHECK.exec(xrp)) throw new errors_1$43.ValidationError(`xrpToDrops: failed sanity check - value '${xrp}', does not match (^-?[0-9.]+$).`);
    const components = xrp.split(".");
    if (components.length > 2) throw new errors_1$43.ValidationError(`xrpToDrops: failed sanity check - value '${xrp}' has too many decimal points.`);
    const fraction = components[1] || "0";
    if (fraction.length > MAX_FRACTION_LENGTH) throw new errors_1$43.ValidationError(`xrpToDrops: value '${xrp}' has too many decimal places.`);
    return new bignumber_js_1$11.default(xrp).times(DROPS_PER_XRP).integerValue(bignumber_js_1$11.default.ROUND_FLOOR).toString(BASE_TEN$1);
  }
  exports.xrpToDrops = xrpToDrops;
} });
var require_getBalanceChanges = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/getBalanceChanges.js"(exports) {
  var __importDefault$18 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const bignumber_js_1$10 = __importDefault$18(require_bignumber());
  const collections_1$1 = require_collections();
  const xrpConversion_1$3 = require_xrpConversion();
  function normalizeNode(affectedNode) {
    const diffType = Object.keys(affectedNode)[0];
    const node2 = affectedNode[diffType];
    return Object.assign(Object.assign({}, node2), {
      NodeType: diffType,
      LedgerEntryType: node2.LedgerEntryType,
      LedgerIndex: node2.LedgerIndex,
      NewFields: node2.NewFields,
      FinalFields: node2.FinalFields,
      PreviousFields: node2.PreviousFields
    });
  }
  function normalizeNodes(metadata) {
    if (metadata.AffectedNodes.length === 0) return [];
    return metadata.AffectedNodes.map(normalizeNode);
  }
  function groupByAccount(balanceChanges) {
    const grouped = (0, collections_1$1.groupBy)(balanceChanges, (node2) => node2.account);
    return Object.entries(grouped).map(([account, items]) => {
      return {
        account,
        balances: items.map((item) => item.balance)
      };
    });
  }
  function getValue(balance) {
    if (typeof balance === "string") return new bignumber_js_1$10.default(balance);
    return new bignumber_js_1$10.default(balance.value);
  }
  function computeBalanceChange(node2) {
    var _a, _b, _c;
    let value = null;
    if ((_a = node2.NewFields) === null || _a === void 0 ? void 0 : _a.Balance) value = getValue(node2.NewFields.Balance);
    else if (((_b = node2.PreviousFields) === null || _b === void 0 ? void 0 : _b.Balance) && ((_c = node2.FinalFields) === null || _c === void 0 ? void 0 : _c.Balance)) value = getValue(node2.FinalFields.Balance).minus(getValue(node2.PreviousFields.Balance));
    if (value === null || value.isZero()) return null;
    return value;
  }
  function getXRPQuantity(node2) {
    var _a, _b, _c;
    const value = computeBalanceChange(node2);
    if (value === null) return null;
    return {
      account: (_b = (_a = node2.FinalFields) === null || _a === void 0 ? void 0 : _a.Account) !== null && _b !== void 0 ? _b : (_c = node2.NewFields) === null || _c === void 0 ? void 0 : _c.Account,
      balance: {
        currency: "XRP",
        value: (0, xrpConversion_1$3.dropsToXrp)(value).toString()
      }
    };
  }
  function flipTrustlinePerspective(balanceChange) {
    const negatedBalance = new bignumber_js_1$10.default(balanceChange.balance.value).negated();
    return {
      account: balanceChange.balance.issuer,
      balance: {
        issuer: balanceChange.account,
        currency: balanceChange.balance.currency,
        value: negatedBalance.toString()
      }
    };
  }
  function getTrustlineQuantity(node2) {
    var _a, _b;
    const value = computeBalanceChange(node2);
    if (value === null) return null;
    const fields = node2.NewFields == null ? node2.FinalFields : node2.NewFields;
    const result = {
      account: (_a = fields === null || fields === void 0 ? void 0 : fields.LowLimit) === null || _a === void 0 ? void 0 : _a.issuer,
      balance: {
        issuer: (_b = fields === null || fields === void 0 ? void 0 : fields.HighLimit) === null || _b === void 0 ? void 0 : _b.issuer,
        currency: (fields === null || fields === void 0 ? void 0 : fields.Balance).currency,
        value: value.toString()
      }
    };
    return [result, flipTrustlinePerspective(result)];
  }
  function getBalanceChanges(metadata) {
    const quantities = normalizeNodes(metadata).map((node2) => {
      if (node2.LedgerEntryType === "AccountRoot") {
        const xrpQuantity = getXRPQuantity(node2);
        if (xrpQuantity == null) return [];
        return [xrpQuantity];
      }
      if (node2.LedgerEntryType === "RippleState") {
        const trustlineQuantity = getTrustlineQuantity(node2);
        if (trustlineQuantity == null) return [];
        return trustlineQuantity;
      }
      return [];
    });
    return groupByAccount(quantities.flat());
  }
  exports.default = getBalanceChanges;
} });
var require_metadata = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/metadata.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isDeletedNode = exports.isModifiedNode = exports.isCreatedNode = void 0;
  function isCreatedNode(node2) {
    return Object.prototype.hasOwnProperty.call(node2, `CreatedNode`);
  }
  exports.isCreatedNode = isCreatedNode;
  function isModifiedNode(node2) {
    return Object.prototype.hasOwnProperty.call(node2, `ModifiedNode`);
  }
  exports.isModifiedNode = isModifiedNode;
  function isDeletedNode(node2) {
    return Object.prototype.hasOwnProperty.call(node2, `DeletedNode`);
  }
  exports.isDeletedNode = isDeletedNode;
} });
var require_getNFTokenID = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/getNFTokenID.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const ripple_binary_codec_1$9 = require_dist$1$1();
  const metadata_1$1 = require_metadata();
  function ensureDecodedMeta$1(meta2) {
    if (typeof meta2 === "string") return (0, ripple_binary_codec_1$9.decode)(meta2);
    return meta2;
  }
  function getNFTokenID(meta2) {
    if (typeof meta2 !== "string" && (meta2 === null || meta2 === void 0 ? void 0 : meta2.AffectedNodes) === void 0) throw new TypeError(`Unable to parse the parameter given to getNFTokenID.
      'meta' must be the metadata from an NFTokenMint transaction. Received ${JSON.stringify(meta2)} instead.`);
    const decodedMeta = ensureDecodedMeta$1(meta2);
    const affectedNodes = decodedMeta.AffectedNodes.filter((node2) => {
      var _a;
      if ((0, metadata_1$1.isCreatedNode)(node2)) return node2.CreatedNode.LedgerEntryType === "NFTokenPage";
      if ((0, metadata_1$1.isModifiedNode)(node2)) return node2.ModifiedNode.LedgerEntryType === "NFTokenPage" && Boolean((_a = node2.ModifiedNode.PreviousFields) === null || _a === void 0 ? void 0 : _a.NFTokens);
      return false;
    });
    const previousTokenIDSet = new Set(affectedNodes.flatMap((node2) => {
      var _a;
      const nftokens = (0, metadata_1$1.isModifiedNode)(node2) ? (_a = node2.ModifiedNode.PreviousFields) === null || _a === void 0 ? void 0 : _a.NFTokens : [];
      return nftokens.map((token) => token.NFToken.NFTokenID);
    }).filter((id) => Boolean(id)));
    const finalTokenIDs = affectedNodes.flatMap((node2) => {
      var _a, _b, _c, _d, _e, _f;
      return ((_f = (_c = (_b = (_a = node2.ModifiedNode) === null || _a === void 0 ? void 0 : _a.FinalFields) === null || _b === void 0 ? void 0 : _b.NFTokens) !== null && _c !== void 0 ? _c : (_e = (_d = node2.CreatedNode) === null || _d === void 0 ? void 0 : _d.NewFields) === null || _e === void 0 ? void 0 : _e.NFTokens) !== null && _f !== void 0 ? _f : []).map((token) => token.NFToken.NFTokenID);
    }).filter((nftokenID$1) => Boolean(nftokenID$1));
    const nftokenID = finalTokenIDs.find((id) => !previousTokenIDSet.has(id));
    return nftokenID;
  }
  exports.default = getNFTokenID;
} });
var require_getXChainClaimID = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/getXChainClaimID.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const ripple_binary_codec_1$8 = require_dist$1$1();
  const metadata_1 = require_metadata();
  function ensureDecodedMeta(meta2) {
    if (typeof meta2 === "string") return (0, ripple_binary_codec_1$8.decode)(meta2);
    return meta2;
  }
  function getXChainClaimID(meta2) {
    if (typeof meta2 !== "string" && (meta2 === null || meta2 === void 0 ? void 0 : meta2.AffectedNodes) === void 0) throw new TypeError(`Unable to parse the parameter given to getXChainClaimID.
      'meta' must be the metadata from an XChainCreateClaimID transaction. Received ${JSON.stringify(meta2)} instead.`);
    const decodedMeta = ensureDecodedMeta(meta2);
    if (!decodedMeta.TransactionResult) throw new TypeError("Cannot get XChainClaimID from un-validated transaction");
    if (decodedMeta.TransactionResult !== "tesSUCCESS") return void 0;
    const createdNode = decodedMeta.AffectedNodes.find((node2) => (0, metadata_1.isCreatedNode)(node2) && node2.CreatedNode.LedgerEntryType === "XChainOwnedClaimID");
    return createdNode.CreatedNode.NewFields.XChainClaimID;
  }
  exports.default = getXChainClaimID;
} });
var require_HashPrefix = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/HashPrefix.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var HashPrefix;
  (function(HashPrefix$2) {
    HashPrefix$2[HashPrefix$2["TRANSACTION_ID"] = 1415073280] = "TRANSACTION_ID";
    HashPrefix$2[HashPrefix$2["TRANSACTION_NODE"] = 1397638144] = "TRANSACTION_NODE";
    HashPrefix$2[HashPrefix$2["INNER_NODE"] = 1296649728] = "INNER_NODE";
    HashPrefix$2[HashPrefix$2["LEAF_NODE"] = 1296846336] = "LEAF_NODE";
    HashPrefix$2[HashPrefix$2["TRANSACTION_SIGN"] = 1398036480] = "TRANSACTION_SIGN";
    HashPrefix$2[HashPrefix$2["TRANSACTION_SIGN_TESTNET"] = 1937012736] = "TRANSACTION_SIGN_TESTNET";
    HashPrefix$2[HashPrefix$2["TRANSACTION_MULTISIGN"] = 1397576704] = "TRANSACTION_MULTISIGN";
    HashPrefix$2[HashPrefix$2["LEDGER"] = 1280791040] = "LEDGER";
  })(HashPrefix || (HashPrefix = {}));
  exports.default = HashPrefix;
} });
var require_sha512Half = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/sha512Half.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const sha512_1 = require_browser$1();
  const utils_1$21 = require_browser$4();
  const HASH_BYTES = 32;
  function sha512Half(hex) {
    return (0, utils_1$21.bytesToHex)((0, sha512_1.sha512)((0, utils_1$21.hexToBytes)(hex)).slice(0, HASH_BYTES));
  }
  exports.default = sha512Half;
} });
var require_node = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/SHAMap/node.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Node = exports.NodeType = void 0;
  var NodeType;
  (function(NodeType$1) {
    NodeType$1[NodeType$1["INNER"] = 1] = "INNER";
    NodeType$1[NodeType$1["TRANSACTION_NO_METADATA"] = 2] = "TRANSACTION_NO_METADATA";
    NodeType$1[NodeType$1["TRANSACTION_METADATA"] = 3] = "TRANSACTION_METADATA";
    NodeType$1[NodeType$1["ACCOUNT_STATE"] = 4] = "ACCOUNT_STATE";
  })(NodeType || (exports.NodeType = NodeType = {}));
  var Node = class {
  };
  exports.Node = Node;
} });
var require_LeafNode = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/SHAMap/LeafNode.js"(exports) {
  var __importDefault$17 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const errors_1$42 = require_errors();
  const HashPrefix_1$3 = __importDefault$17(require_HashPrefix());
  const sha512Half_1$3 = __importDefault$17(require_sha512Half());
  const node_1$1 = require_node();
  const HEX$3 = 16;
  var LeafNode = class extends node_1$1.Node {
    constructor(tag, data2, type2) {
      super();
      this.tag = tag;
      this.type = type2;
      this.data = data2;
    }
    get hash() {
      switch (this.type) {
        case node_1$1.NodeType.ACCOUNT_STATE: {
          const leafPrefix = HashPrefix_1$3.default.LEAF_NODE.toString(HEX$3);
          return (0, sha512Half_1$3.default)(leafPrefix + this.data + this.tag);
        }
        case node_1$1.NodeType.TRANSACTION_NO_METADATA: {
          const txIDPrefix = HashPrefix_1$3.default.TRANSACTION_ID.toString(HEX$3);
          return (0, sha512Half_1$3.default)(txIDPrefix + this.data);
        }
        case node_1$1.NodeType.TRANSACTION_METADATA: {
          const txNodePrefix = HashPrefix_1$3.default.TRANSACTION_NODE.toString(HEX$3);
          return (0, sha512Half_1$3.default)(txNodePrefix + this.data + this.tag);
        }
        default:
          throw new errors_1$42.XrplError("Tried to hash a SHAMap node of unknown type.");
      }
    }
    addItem(tag, node2) {
      throw new errors_1$42.XrplError("Cannot call addItem on a LeafNode");
    }
  };
  exports.default = LeafNode;
} });
var require_InnerNode = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/SHAMap/InnerNode.js"(exports) {
  var __importDefault$16 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const errors_1$41 = require_errors();
  const HashPrefix_1$2 = __importDefault$16(require_HashPrefix());
  const sha512Half_1$2 = __importDefault$16(require_sha512Half());
  const LeafNode_1$1 = __importDefault$16(require_LeafNode());
  const node_1 = require_node();
  const HEX_ZERO = "0000000000000000000000000000000000000000000000000000000000000000";
  const SLOT_MAX = 15;
  const HEX$2 = 16;
  var InnerNode = class InnerNode2 extends node_1.Node {
    constructor(depth = 0) {
      super();
      this.leaves = {};
      this.type = node_1.NodeType.INNER;
      this.depth = depth;
      this.empty = true;
    }
    get hash() {
      if (this.empty) return HEX_ZERO;
      let hex = "";
      for (let iter = 0; iter <= SLOT_MAX; iter++) {
        const child = this.leaves[iter];
        const hash$12 = child == null ? HEX_ZERO : child.hash;
        hex += hash$12;
      }
      const prefix$2 = HashPrefix_1$2.default.INNER_NODE.toString(HEX$2);
      return (0, sha512Half_1$2.default)(prefix$2 + hex);
    }
    addItem(tag, node2) {
      const existingNode = this.getNode(parseInt(tag[this.depth], HEX$2));
      if (existingNode === void 0) {
        this.setNode(parseInt(tag[this.depth], HEX$2), node2);
        return;
      }
      if (existingNode instanceof InnerNode2) existingNode.addItem(tag, node2);
      else if (existingNode instanceof LeafNode_1$1.default) if (existingNode.tag === tag) throw new errors_1$41.XrplError("Tried to add a node to a SHAMap that was already in there.");
      else {
        const newInnerNode = new InnerNode2(this.depth + 1);
        newInnerNode.addItem(existingNode.tag, existingNode);
        newInnerNode.addItem(tag, node2);
        this.setNode(parseInt(tag[this.depth], HEX$2), newInnerNode);
      }
    }
    setNode(slot, node2) {
      if (slot < 0 || slot > SLOT_MAX) throw new errors_1$41.XrplError("Invalid slot: slot must be between 0-15.");
      this.leaves[slot] = node2;
      this.empty = false;
    }
    getNode(slot) {
      if (slot < 0 || slot > SLOT_MAX) throw new errors_1$41.XrplError("Invalid slot: slot must be between 0-15.");
      return this.leaves[slot];
    }
  };
  exports.default = InnerNode;
} });
var require_SHAMap = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/SHAMap/index.js"(exports) {
  var __createBinding$7 = Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
      enumerable: true,
      get: function() {
        return m[k];
      }
    };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  };
  var __exportStar$5 = function(m, exports$1) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding$7(exports$1, m, p);
  };
  var __importDefault$15 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const InnerNode_1 = __importDefault$15(require_InnerNode());
  const LeafNode_1 = __importDefault$15(require_LeafNode());
  var SHAMap = class {
    constructor() {
      this.root = new InnerNode_1.default(0);
    }
    get hash() {
      return this.root.hash;
    }
    addItem(tag, data2, type2) {
      this.root.addItem(tag, new LeafNode_1.default(tag, data2, type2));
    }
  };
  __exportStar$5(require_node(), exports);
  exports.default = SHAMap;
} });
var require_hashLedger = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/hashLedger.js"(exports) {
  var __createBinding$6 = Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
      enumerable: true,
      get: function() {
        return m[k];
      }
    };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  };
  var __setModuleDefault$2 = Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function(o, v) {
    o["default"] = v;
  };
  var __importStar$2 = function(mod$1) {
    if (mod$1 && mod$1.__esModule) return mod$1;
    var result = {};
    if (mod$1 != null) {
      for (var k in mod$1) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod$1, k)) __createBinding$6(result, mod$1, k);
    }
    __setModuleDefault$2(result, mod$1);
    return result;
  };
  var __importDefault$14 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hashStateTree = exports.hashTxTree = exports.hashLedgerHeader = exports.hashSignedTx = void 0;
  const utils_1$20 = require_browser$4();
  const bignumber_js_1$9 = __importDefault$14(require_bignumber());
  const ripple_binary_codec_1$7 = require_dist$1$1();
  const errors_1$40 = require_errors();
  const common_1$45 = require_common();
  const utils_2$1 = require_utils$4$1();
  const HashPrefix_1$1 = __importDefault$14(require_HashPrefix());
  const sha512Half_1$1 = __importDefault$14(require_sha512Half());
  const SHAMap_1 = __importStar$2(require_SHAMap());
  const HEX$1 = 16;
  function intToHex(integer, byteLength) {
    const foo = Number(integer).toString(HEX$1).padStart(byteLength * 2, "0");
    return foo;
  }
  function bigintToHex(integerString, byteLength) {
    const hex = new bignumber_js_1$9.default(integerString).toString(HEX$1);
    return hex.padStart(byteLength * 2, "0");
  }
  function addLengthPrefix(hex) {
    const length = hex.length / 2;
    if (length <= 192) return (0, utils_1$20.bytesToHex)([length]) + hex;
    if (length <= 12480) {
      const prefix$2 = length - 193;
      return (0, utils_1$20.bytesToHex)([193 + (prefix$2 >>> 8), prefix$2 & 255]) + hex;
    }
    if (length <= 918744) {
      const prefix$2 = length - 12481;
      return (0, utils_1$20.bytesToHex)([
        241 + (prefix$2 >>> 16),
        prefix$2 >>> 8 & 255,
        prefix$2 & 255
      ]) + hex;
    }
    throw new errors_1$40.XrplError("Variable integer overflow.");
  }
  function hashSignedTx(tx2) {
    let txBlob;
    let txObject;
    if (typeof tx2 === "string") {
      txBlob = tx2;
      txObject = (0, ripple_binary_codec_1$7.decode)(tx2);
    } else {
      txBlob = (0, ripple_binary_codec_1$7.encode)(tx2);
      txObject = tx2;
    }
    if (txObject.TxnSignature === void 0 && txObject.Signers === void 0 && txObject.SigningPubKey === void 0 && !(0, utils_2$1.hasFlag)(txObject, common_1$45.GlobalFlags.tfInnerBatchTxn, "tfInnerBatchTxn")) throw new errors_1$40.ValidationError("The transaction must be signed to hash it.");
    const prefix$2 = HashPrefix_1$1.default.TRANSACTION_ID.toString(16).toUpperCase();
    return (0, sha512Half_1$1.default)(prefix$2.concat(txBlob));
  }
  exports.hashSignedTx = hashSignedTx;
  function hashLedgerHeader(ledgerHeader) {
    const prefix$2 = HashPrefix_1$1.default.LEDGER.toString(HEX$1).toUpperCase();
    const ledger = prefix$2 + intToHex(Number(ledgerHeader.ledger_index), 4) + bigintToHex(ledgerHeader.total_coins, 8) + ledgerHeader.parent_hash + ledgerHeader.transaction_hash + ledgerHeader.account_hash + intToHex(ledgerHeader.parent_close_time, 4) + intToHex(ledgerHeader.close_time, 4) + intToHex(ledgerHeader.close_time_resolution, 1) + intToHex(ledgerHeader.close_flags, 1);
    return (0, sha512Half_1$1.default)(ledger);
  }
  exports.hashLedgerHeader = hashLedgerHeader;
  function hashTxTree(transactions) {
    var _a;
    const shamap = new SHAMap_1.default();
    for (const txJSON of transactions) {
      const txBlobHex = (0, ripple_binary_codec_1$7.encode)(txJSON);
      const metaHex = (0, ripple_binary_codec_1$7.encode)((_a = txJSON.metaData) !== null && _a !== void 0 ? _a : {});
      const txHash = hashSignedTx(txBlobHex);
      const data2 = addLengthPrefix(txBlobHex) + addLengthPrefix(metaHex);
      shamap.addItem(txHash, data2, SHAMap_1.NodeType.TRANSACTION_METADATA);
    }
    return shamap.hash;
  }
  exports.hashTxTree = hashTxTree;
  function hashStateTree(entries) {
    const shamap = new SHAMap_1.default();
    entries.forEach((ledgerEntry) => {
      const data2 = (0, ripple_binary_codec_1$7.encode)(ledgerEntry);
      shamap.addItem(ledgerEntry.index, data2, SHAMap_1.NodeType.ACCOUNT_STATE);
    });
    return shamap.hash;
  }
  exports.hashStateTree = hashStateTree;
  function computeTransactionHash(ledger, options) {
    const { transaction_hash } = ledger;
    if (!options.computeTreeHashes) return transaction_hash;
    if (ledger.transactions == null) throw new errors_1$40.ValidationError("transactions is missing from the ledger");
    const transactionHash = hashTxTree(ledger.transactions);
    if (transaction_hash !== transactionHash) throw new errors_1$40.ValidationError("transactionHash in header does not match computed hash of transactions", {
      transactionHashInHeader: transaction_hash,
      computedHashOfTransactions: transactionHash
    });
    return transactionHash;
  }
  function computeStateHash(ledger, options) {
    const { account_hash } = ledger;
    if (!options.computeTreeHashes) return account_hash;
    if (ledger.accountState == null) throw new errors_1$40.ValidationError("accountState is missing from the ledger");
    const stateHash = hashStateTree(ledger.accountState);
    if (account_hash !== stateHash) throw new errors_1$40.ValidationError("stateHash in header does not match computed hash of state");
    return stateHash;
  }
  function hashLedger(ledger, options = {}) {
    const subhashes = {
      transaction_hash: computeTransactionHash(ledger, options),
      account_hash: computeStateHash(ledger, options)
    };
    return hashLedgerHeader(Object.assign(Object.assign({}, ledger), subhashes));
  }
  exports.default = hashLedger;
} });
var require_ledgerSpaces = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/ledgerSpaces.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const ledgerSpaces = {
    account: "a",
    dirNode: "d",
    generatorMap: "g",
    rippleState: "r",
    offer: "o",
    ownerDir: "O",
    bookDir: "B",
    contract: "c",
    skipList: "s",
    escrow: "u",
    amendment: "f",
    feeSettings: "e",
    ticket: "T",
    signerList: "S",
    paychan: "x",
    check: "C",
    depositPreauth: "p"
  };
  exports.default = ledgerSpaces;
} });
var require_hashes = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/hashes/index.js"(exports) {
  var __createBinding$5 = Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
      enumerable: true,
      get: function() {
        return m[k];
      }
    };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  };
  var __setModuleDefault$1 = Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function(o, v) {
    o["default"] = v;
  };
  var __importStar$1 = function(mod$1) {
    if (mod$1 && mod$1.__esModule) return mod$1;
    var result = {};
    if (mod$1 != null) {
      for (var k in mod$1) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod$1, k)) __createBinding$5(result, mod$1, k);
    }
    __setModuleDefault$1(result, mod$1);
    return result;
  };
  var __importDefault$13 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hashTxTree = exports.hashStateTree = exports.hashLedger = exports.hashSignedTx = exports.hashLedgerHeader = exports.hashPaymentChannel = exports.hashEscrow = exports.hashTrustline = exports.hashOfferId = exports.hashSignerListId = exports.hashAccountRoot = exports.hashTx = void 0;
  const utils_1$19 = require_browser$4();
  const bignumber_js_1$8 = __importDefault$13(require_bignumber());
  const ripple_address_codec_1$7 = require_dist$3();
  const hashLedger_1$1 = __importStar$1(require_hashLedger());
  exports.hashLedger = hashLedger_1$1.default;
  Object.defineProperty(exports, "hashLedgerHeader", {
    enumerable: true,
    get: function() {
      return hashLedger_1$1.hashLedgerHeader;
    }
  });
  Object.defineProperty(exports, "hashSignedTx", {
    enumerable: true,
    get: function() {
      return hashLedger_1$1.hashSignedTx;
    }
  });
  Object.defineProperty(exports, "hashTxTree", {
    enumerable: true,
    get: function() {
      return hashLedger_1$1.hashTxTree;
    }
  });
  Object.defineProperty(exports, "hashStateTree", {
    enumerable: true,
    get: function() {
      return hashLedger_1$1.hashStateTree;
    }
  });
  const HashPrefix_1 = __importDefault$13(require_HashPrefix());
  const ledgerSpaces_1 = __importDefault$13(require_ledgerSpaces());
  const sha512Half_1 = __importDefault$13(require_sha512Half());
  const HEX = 16;
  const BYTE_LENGTH = 4;
  function addressToHex(address) {
    return (0, utils_1$19.bytesToHex)((0, ripple_address_codec_1$7.decodeAccountID)(address));
  }
  function ledgerSpaceHex(name) {
    return ledgerSpaces_1.default[name].charCodeAt(0).toString(HEX).padStart(4, "0");
  }
  const MASK = 255;
  function currencyToHex(currency) {
    if (currency.length !== 3) return currency;
    const bytes$1 = Array(20).fill(0);
    bytes$1[12] = currency.charCodeAt(0) & MASK;
    bytes$1[13] = currency.charCodeAt(1) & MASK;
    bytes$1[14] = currency.charCodeAt(2) & MASK;
    return (0, utils_1$19.bytesToHex)(Uint8Array.from(bytes$1));
  }
  function hashTx(txBlobHex) {
    const prefix$2 = HashPrefix_1.default.TRANSACTION_SIGN.toString(HEX).toUpperCase();
    return (0, sha512Half_1.default)(prefix$2 + txBlobHex);
  }
  exports.hashTx = hashTx;
  function hashAccountRoot(address) {
    return (0, sha512Half_1.default)(ledgerSpaceHex("account") + addressToHex(address));
  }
  exports.hashAccountRoot = hashAccountRoot;
  function hashSignerListId(address) {
    return (0, sha512Half_1.default)(`${ledgerSpaceHex("signerList") + addressToHex(address)}00000000`);
  }
  exports.hashSignerListId = hashSignerListId;
  function hashOfferId(address, sequence) {
    const hexPrefix = ledgerSpaces_1.default.offer.charCodeAt(0).toString(HEX).padStart(2, "0");
    const hexSequence = sequence.toString(HEX).padStart(8, "0");
    const prefix$2 = `00${hexPrefix}`;
    return (0, sha512Half_1.default)(prefix$2 + addressToHex(address) + hexSequence);
  }
  exports.hashOfferId = hashOfferId;
  function hashTrustline(address1, address2, currency) {
    const address1Hex = addressToHex(address1);
    const address2Hex = addressToHex(address2);
    const swap$1 = new bignumber_js_1$8.default(address1Hex, 16).isGreaterThan(new bignumber_js_1$8.default(address2Hex, 16));
    const lowAddressHex = swap$1 ? address2Hex : address1Hex;
    const highAddressHex = swap$1 ? address1Hex : address2Hex;
    const prefix$2 = ledgerSpaceHex("rippleState");
    return (0, sha512Half_1.default)(prefix$2 + lowAddressHex + highAddressHex + currencyToHex(currency));
  }
  exports.hashTrustline = hashTrustline;
  function hashEscrow(address, sequence) {
    return (0, sha512Half_1.default)(ledgerSpaceHex("escrow") + addressToHex(address) + sequence.toString(HEX).padStart(BYTE_LENGTH * 2, "0"));
  }
  exports.hashEscrow = hashEscrow;
  function hashPaymentChannel(address, dstAddress, sequence) {
    return (0, sha512Half_1.default)(ledgerSpaceHex("paychan") + addressToHex(address) + addressToHex(dstAddress) + sequence.toString(HEX).padStart(BYTE_LENGTH * 2, "0"));
  }
  exports.hashPaymentChannel = hashPaymentChannel;
} });
var require_parseNFTokenID = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/parseNFTokenID.js"(exports) {
  var __importDefault$12 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const utils_1$18 = require_browser$4();
  const bignumber_js_1$7 = __importDefault$12(require_bignumber());
  const ripple_address_codec_1$6 = require_dist$3();
  const errors_1$39 = require_errors();
  function unscrambleTaxon(taxon, tokenSeq) {
    const seed = 384160001;
    const increment = 2459;
    const max2 = 4294967296;
    const scramble = new bignumber_js_1$7.default(seed).multipliedBy(tokenSeq).modulo(max2).plus(increment).modulo(max2).toNumber();
    return (taxon ^ scramble) >>> 0;
  }
  function parseNFTokenID(nftokenID) {
    const expectedLength = 64;
    if (nftokenID.length !== expectedLength) throw new errors_1$39.XrplError(`Attempting to parse a nftokenID with length ${nftokenID.length}
    , but expected a token with length ${expectedLength}`);
    const scrambledTaxon = new bignumber_js_1$7.default(nftokenID.substring(48, 56), 16).toNumber();
    const sequence = new bignumber_js_1$7.default(nftokenID.substring(56, 64), 16).toNumber();
    const NFTokenIDData = {
      NFTokenID: nftokenID,
      Flags: new bignumber_js_1$7.default(nftokenID.substring(0, 4), 16).toNumber(),
      TransferFee: new bignumber_js_1$7.default(nftokenID.substring(4, 8), 16).toNumber(),
      Issuer: (0, ripple_address_codec_1$6.encodeAccountID)((0, utils_1$18.hexToBytes)(nftokenID.substring(8, 48))),
      Taxon: unscrambleTaxon(scrambledTaxon, sequence),
      Sequence: sequence
    };
    return NFTokenIDData;
  }
  exports.default = parseNFTokenID;
} });
var require_quality = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/quality.js"(exports) {
  var __importDefault$11 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.percentToQuality = exports.transferRateToDecimal = exports.qualityToDecimal = exports.decimalToQuality = exports.percentToTransferRate = exports.decimalToTransferRate = void 0;
  const bignumber_js_1$6 = __importDefault$11(require_bignumber());
  const errors_1$38 = require_errors();
  const BASE_TEN = 10;
  const ONE_BILLION = "1000000000";
  const TWO_BILLION = "2000000000";
  function percentToDecimal(percent) {
    if (!percent.endsWith("%")) throw new errors_1$38.ValidationError(`Value ${percent} must end with %`);
    const split$1 = percent.split("%").filter((str) => str !== "");
    if (split$1.length !== 1) throw new errors_1$38.ValidationError(`Value ${percent} contains too many % signs`);
    return new bignumber_js_1$6.default(split$1[0]).dividedBy("100").toString(BASE_TEN);
  }
  function decimalToTransferRate(decimal) {
    const rate = new bignumber_js_1$6.default(decimal).times(ONE_BILLION).plus(ONE_BILLION);
    if (rate.isLessThan(ONE_BILLION) || rate.isGreaterThan(TWO_BILLION)) throw new errors_1$38.ValidationError(`Decimal value must be between 0 and 1.00.`);
    const billionths = rate.toString(BASE_TEN);
    if (billionths === ONE_BILLION) return 0;
    if (billionths === "NaN") throw new errors_1$38.ValidationError(`Value is not a number`);
    if (billionths.includes(".")) throw new errors_1$38.ValidationError(`Decimal exceeds maximum precision.`);
    return Number(billionths);
  }
  exports.decimalToTransferRate = decimalToTransferRate;
  function percentToTransferRate(percent) {
    return decimalToTransferRate(percentToDecimal(percent));
  }
  exports.percentToTransferRate = percentToTransferRate;
  function decimalToQuality(decimal) {
    const rate = new bignumber_js_1$6.default(decimal).times(ONE_BILLION);
    const billionths = rate.toString(BASE_TEN);
    if (billionths === "NaN") throw new errors_1$38.ValidationError(`Value is not a number`);
    if (billionths.includes("-")) throw new errors_1$38.ValidationError("Cannot have negative Quality");
    if (billionths === ONE_BILLION) return 0;
    if (billionths.includes(".")) throw new errors_1$38.ValidationError(`Decimal exceeds maximum precision.`);
    return Number(billionths);
  }
  exports.decimalToQuality = decimalToQuality;
  function qualityToDecimal(quality$1) {
    if (!Number.isInteger(quality$1)) throw new errors_1$38.ValidationError("Quality must be an integer");
    if (quality$1 < 0) throw new errors_1$38.ValidationError("Negative quality not allowed");
    if (quality$1 === 0) return "1";
    const decimal = new bignumber_js_1$6.default(quality$1).dividedBy(ONE_BILLION);
    return decimal.toString(BASE_TEN);
  }
  exports.qualityToDecimal = qualityToDecimal;
  function transferRateToDecimal(rate) {
    if (!Number.isInteger(rate)) throw new errors_1$38.ValidationError("Error decoding, transfer Rate must be an integer");
    if (rate === 0) return "0";
    const decimal = new bignumber_js_1$6.default(rate).minus(ONE_BILLION).dividedBy(ONE_BILLION);
    if (decimal.isLessThan(0)) throw new errors_1$38.ValidationError("Error decoding, negative transfer rate");
    return decimal.toString(BASE_TEN);
  }
  exports.transferRateToDecimal = transferRateToDecimal;
  function percentToQuality(percent) {
    return decimalToQuality(percentToDecimal(percent));
  }
  exports.percentToQuality = percentToQuality;
} });
var require_signPaymentChannelClaim = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/signPaymentChannelClaim.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const ripple_binary_codec_1$6 = require_dist$1$1();
  const ripple_keypairs_1$5 = require_dist$2();
  const xrpConversion_1$2 = require_xrpConversion();
  function signPaymentChannelClaim(channel, xrpAmount, privateKey) {
    const signingData$2 = (0, ripple_binary_codec_1$6.encodeForSigningClaim)({
      channel,
      amount: (0, xrpConversion_1$2.xrpToDrops)(xrpAmount)
    });
    return (0, ripple_keypairs_1$5.sign)(signingData$2, privateKey);
  }
  exports.default = signPaymentChannelClaim;
} });
var require_stringConversion = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/stringConversion.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.convertStringToHex = exports.convertHexToString = void 0;
  const utils_1$17 = require_browser$4();
  function convertStringToHex(string) {
    return (0, utils_1$17.stringToHex)(string);
  }
  exports.convertStringToHex = convertStringToHex;
  function convertHexToString(hex, encoding = "utf8") {
    return (0, utils_1$17.hexToString)(hex, encoding);
  }
  exports.convertHexToString = convertHexToString;
} });
var require_timeConversion = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/timeConversion.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isoTimeToRippleTime = exports.rippleTimeToISOTime = exports.unixTimeToRippleTime = exports.rippleTimeToUnixTime = void 0;
  const RIPPLE_EPOCH_DIFF = 946684800;
  function rippleTimeToUnixTime(rpepoch) {
    return (rpepoch + RIPPLE_EPOCH_DIFF) * 1e3;
  }
  exports.rippleTimeToUnixTime = rippleTimeToUnixTime;
  function unixTimeToRippleTime(timestamp) {
    return Math.round(timestamp / 1e3) - RIPPLE_EPOCH_DIFF;
  }
  exports.unixTimeToRippleTime = unixTimeToRippleTime;
  function rippleTimeToISOTime(rippleTime) {
    return new Date(rippleTimeToUnixTime(rippleTime)).toISOString();
  }
  exports.rippleTimeToISOTime = rippleTimeToISOTime;
  function isoTimeToRippleTime(iso8601) {
    const isoDate = typeof iso8601 === "string" ? new Date(iso8601) : iso8601;
    return unixTimeToRippleTime(isoDate.getTime());
  }
  exports.isoTimeToRippleTime = isoTimeToRippleTime;
} });
var require_verifyPaymentChannelClaim = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/verifyPaymentChannelClaim.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const ripple_binary_codec_1$5 = require_dist$1$1();
  const ripple_keypairs_1$4 = require_dist$2();
  const xrpConversion_1$1 = require_xrpConversion();
  function verifyPaymentChannelClaim(channel, xrpAmount, signature2, publicKey) {
    const signingData$2 = (0, ripple_binary_codec_1$5.encodeForSigningClaim)({
      channel,
      amount: (0, xrpConversion_1$1.xrpToDrops)(xrpAmount)
    });
    return (0, ripple_keypairs_1$4.verify)(signingData$2, signature2, publicKey);
  }
  exports.default = verifyPaymentChannelClaim;
} });
var require_utils$3$1 = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/utils/index.js"(exports) {
  var __importDefault$10 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getXChainClaimID = exports.parseNFTokenID = exports.getNFTokenID = exports.encodeForSigningClaim = exports.encodeForSigning = exports.encodeForMultiSigning = exports.decode = exports.encode = exports.decodeXAddress = exports.encodeXAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.decodeNodePublic = exports.encodeNodePublic = exports.decodeAccountID = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.isValidClassicAddress = exports.isValidXAddress = exports.xAddressToClassicAddress = exports.classicAddressToXAddress = exports.convertHexToString = exports.convertStringToHex = exports.verifyPaymentChannelClaim = exports.verifyKeypairSignature = exports.signPaymentChannelClaim = exports.deriveXAddress = exports.deriveAddress = exports.deriveKeypair = exports.hashes = exports.isValidAddress = exports.isValidSecret = exports.qualityToDecimal = exports.transferRateToDecimal = exports.decimalToTransferRate = exports.percentToTransferRate = exports.decimalToQuality = exports.percentToQuality = exports.unixTimeToRippleTime = exports.rippleTimeToUnixTime = exports.isoTimeToRippleTime = exports.rippleTimeToISOTime = exports.hasNextPage = exports.xrpToDrops = exports.dropsToXrp = exports.getBalanceChanges = void 0;
  const ripple_address_codec_1$5 = require_dist$3();
  Object.defineProperty(exports, "classicAddressToXAddress", {
    enumerable: true,
    get: function() {
      return ripple_address_codec_1$5.classicAddressToXAddress;
    }
  });
  Object.defineProperty(exports, "decodeAccountID", {
    enumerable: true,
    get: function() {
      return ripple_address_codec_1$5.decodeAccountID;
    }
  });
  Object.defineProperty(exports, "decodeAccountPublic", {
    enumerable: true,
    get: function() {
      return ripple_address_codec_1$5.decodeAccountPublic;
    }
  });
  Object.defineProperty(exports, "decodeNodePublic", {
    enumerable: true,
    get: function() {
      return ripple_address_codec_1$5.decodeNodePublic;
    }
  });
  Object.defineProperty(exports, "decodeSeed", {
    enumerable: true,
    get: function() {
      return ripple_address_codec_1$5.decodeSeed;
    }
  });
  Object.defineProperty(exports, "decodeXAddress", {
    enumerable: true,
    get: function() {
      return ripple_address_codec_1$5.decodeXAddress;
    }
  });
  Object.defineProperty(exports, "encodeAccountID", {
    enumerable: true,
    get: function() {
      return ripple_address_codec_1$5.encodeAccountID;
    }
  });
  Object.defineProperty(exports, "encodeAccountPublic", {
    enumerable: true,
    get: function() {
      return ripple_address_codec_1$5.encodeAccountPublic;
    }
  });
  Object.defineProperty(exports, "encodeNodePublic", {
    enumerable: true,
    get: function() {
      return ripple_address_codec_1$5.encodeNodePublic;
    }
  });
  Object.defineProperty(exports, "encodeSeed", {
    enumerable: true,
    get: function() {
      return ripple_address_codec_1$5.encodeSeed;
    }
  });
  Object.defineProperty(exports, "encodeXAddress", {
    enumerable: true,
    get: function() {
      return ripple_address_codec_1$5.encodeXAddress;
    }
  });
  Object.defineProperty(exports, "isValidClassicAddress", {
    enumerable: true,
    get: function() {
      return ripple_address_codec_1$5.isValidClassicAddress;
    }
  });
  Object.defineProperty(exports, "isValidXAddress", {
    enumerable: true,
    get: function() {
      return ripple_address_codec_1$5.isValidXAddress;
    }
  });
  Object.defineProperty(exports, "xAddressToClassicAddress", {
    enumerable: true,
    get: function() {
      return ripple_address_codec_1$5.xAddressToClassicAddress;
    }
  });
  const ripple_binary_codec_1$4 = require_dist$1$1();
  const ripple_keypairs_1$3 = require_dist$2();
  Object.defineProperty(exports, "verifyKeypairSignature", {
    enumerable: true,
    get: function() {
      return ripple_keypairs_1$3.verify;
    }
  });
  const derive_1 = require_derive();
  Object.defineProperty(exports, "deriveKeypair", {
    enumerable: true,
    get: function() {
      return derive_1.deriveKeypair;
    }
  });
  Object.defineProperty(exports, "deriveAddress", {
    enumerable: true,
    get: function() {
      return derive_1.deriveAddress;
    }
  });
  Object.defineProperty(exports, "deriveXAddress", {
    enumerable: true,
    get: function() {
      return derive_1.deriveXAddress;
    }
  });
  const getBalanceChanges_1 = __importDefault$10(require_getBalanceChanges());
  exports.getBalanceChanges = getBalanceChanges_1.default;
  const getNFTokenID_1 = __importDefault$10(require_getNFTokenID());
  exports.getNFTokenID = getNFTokenID_1.default;
  const getXChainClaimID_1 = __importDefault$10(require_getXChainClaimID());
  exports.getXChainClaimID = getXChainClaimID_1.default;
  const hashes_1 = require_hashes();
  const parseNFTokenID_1 = __importDefault$10(require_parseNFTokenID());
  exports.parseNFTokenID = parseNFTokenID_1.default;
  const quality_1 = require_quality();
  Object.defineProperty(exports, "percentToTransferRate", {
    enumerable: true,
    get: function() {
      return quality_1.percentToTransferRate;
    }
  });
  Object.defineProperty(exports, "decimalToTransferRate", {
    enumerable: true,
    get: function() {
      return quality_1.decimalToTransferRate;
    }
  });
  Object.defineProperty(exports, "transferRateToDecimal", {
    enumerable: true,
    get: function() {
      return quality_1.transferRateToDecimal;
    }
  });
  Object.defineProperty(exports, "percentToQuality", {
    enumerable: true,
    get: function() {
      return quality_1.percentToQuality;
    }
  });
  Object.defineProperty(exports, "decimalToQuality", {
    enumerable: true,
    get: function() {
      return quality_1.decimalToQuality;
    }
  });
  Object.defineProperty(exports, "qualityToDecimal", {
    enumerable: true,
    get: function() {
      return quality_1.qualityToDecimal;
    }
  });
  const signPaymentChannelClaim_1 = __importDefault$10(require_signPaymentChannelClaim());
  exports.signPaymentChannelClaim = signPaymentChannelClaim_1.default;
  const stringConversion_1 = require_stringConversion();
  Object.defineProperty(exports, "convertHexToString", {
    enumerable: true,
    get: function() {
      return stringConversion_1.convertHexToString;
    }
  });
  Object.defineProperty(exports, "convertStringToHex", {
    enumerable: true,
    get: function() {
      return stringConversion_1.convertStringToHex;
    }
  });
  const timeConversion_1 = require_timeConversion();
  Object.defineProperty(exports, "rippleTimeToISOTime", {
    enumerable: true,
    get: function() {
      return timeConversion_1.rippleTimeToISOTime;
    }
  });
  Object.defineProperty(exports, "isoTimeToRippleTime", {
    enumerable: true,
    get: function() {
      return timeConversion_1.isoTimeToRippleTime;
    }
  });
  Object.defineProperty(exports, "rippleTimeToUnixTime", {
    enumerable: true,
    get: function() {
      return timeConversion_1.rippleTimeToUnixTime;
    }
  });
  Object.defineProperty(exports, "unixTimeToRippleTime", {
    enumerable: true,
    get: function() {
      return timeConversion_1.unixTimeToRippleTime;
    }
  });
  const verifyPaymentChannelClaim_1 = __importDefault$10(require_verifyPaymentChannelClaim());
  exports.verifyPaymentChannelClaim = verifyPaymentChannelClaim_1.default;
  const xrpConversion_1 = require_xrpConversion();
  Object.defineProperty(exports, "xrpToDrops", {
    enumerable: true,
    get: function() {
      return xrpConversion_1.xrpToDrops;
    }
  });
  Object.defineProperty(exports, "dropsToXrp", {
    enumerable: true,
    get: function() {
      return xrpConversion_1.dropsToXrp;
    }
  });
  function isValidSecret(secret) {
    try {
      (0, derive_1.deriveKeypair)(secret);
      return true;
    } catch (_err) {
      return false;
    }
  }
  exports.isValidSecret = isValidSecret;
  function encode$32(object) {
    return (0, ripple_binary_codec_1$4.encode)(object);
  }
  exports.encode = encode$32;
  function encodeForSigning(object) {
    return (0, ripple_binary_codec_1$4.encodeForSigning)(object);
  }
  exports.encodeForSigning = encodeForSigning;
  function encodeForSigningClaim(object) {
    return (0, ripple_binary_codec_1$4.encodeForSigningClaim)(object);
  }
  exports.encodeForSigningClaim = encodeForSigningClaim;
  function encodeForMultiSigning(object, signer) {
    return (0, ripple_binary_codec_1$4.encodeForMultisigning)(object, signer);
  }
  exports.encodeForMultiSigning = encodeForMultiSigning;
  function decode$32(hex) {
    return (0, ripple_binary_codec_1$4.decode)(hex);
  }
  exports.decode = decode$32;
  function isValidAddress(address) {
    return (0, ripple_address_codec_1$5.isValidXAddress)(address) || (0, ripple_address_codec_1$5.isValidClassicAddress)(address);
  }
  exports.isValidAddress = isValidAddress;
  function hasNextPage(response) {
    return Boolean(response.result["marker"]);
  }
  exports.hasNextPage = hasNextPage;
  const hashes = {
    hashSignedTx: hashes_1.hashSignedTx,
    hashTx: hashes_1.hashTx,
    hashAccountRoot: hashes_1.hashAccountRoot,
    hashSignerListId: hashes_1.hashSignerListId,
    hashOfferId: hashes_1.hashOfferId,
    hashTrustline: hashes_1.hashTrustline,
    hashTxTree: hashes_1.hashTxTree,
    hashStateTree: hashes_1.hashStateTree,
    hashLedger: hashes_1.hashLedger,
    hashLedgerHeader: hashes_1.hashLedgerHeader,
    hashEscrow: hashes_1.hashEscrow,
    hashPaymentChannel: hashes_1.hashPaymentChannel
  };
  exports.hashes = hashes;
} });
var require_submit = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/sugar/submit.js"(exports) {
  var __awaiter$8 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getLastLedgerSequence = exports.getSignedTx = exports.waitForFinalTransactionOutcome = exports.submitRequest = void 0;
  const errors_1$37 = require_errors();
  const utils_1$16 = require_utils$3$1();
  const LEDGER_CLOSE_TIME = 1e3;
  function sleep(ms2) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return new Promise((resolve) => {
        setTimeout(resolve, ms2);
      });
    });
  }
  function submitRequest(client2, signedTransaction, failHard = false) {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (!isSigned(signedTransaction)) throw new errors_1$37.ValidationError("Transaction must be signed.");
      const signedTxEncoded = typeof signedTransaction === "string" ? signedTransaction : (0, utils_1$16.encode)(signedTransaction);
      const request = {
        command: "submit",
        tx_blob: signedTxEncoded,
        fail_hard: isAccountDelete(signedTransaction) || failHard
      };
      return client2.request(request);
    });
  }
  exports.submitRequest = submitRequest;
  function waitForFinalTransactionOutcome(client2, txHash, lastLedger, submissionResult) {
    return __awaiter$8(this, void 0, void 0, function* () {
      yield sleep(LEDGER_CLOSE_TIME);
      const latestLedger = yield client2.getLedgerIndex();
      if (lastLedger < latestLedger) throw new errors_1$37.XrplError(`The latest ledger sequence ${latestLedger} is greater than the transaction's LastLedgerSequence (${lastLedger}).
Preliminary result: ${submissionResult}`);
      const txResponse = yield client2.request({
        command: "tx",
        transaction: txHash
      }).catch((error) => __awaiter$8(this, void 0, void 0, function* () {
        var _a;
        const message2 = (_a = error === null || error === void 0 ? void 0 : error.data) === null || _a === void 0 ? void 0 : _a.error;
        if (message2 === "txnNotFound") return waitForFinalTransactionOutcome(client2, txHash, lastLedger, submissionResult);
        throw new Error(`${message2} 
 Preliminary result: ${submissionResult}.
Full error details: ${String(error)}`);
      }));
      if (txResponse.result.validated) return txResponse;
      return waitForFinalTransactionOutcome(client2, txHash, lastLedger, submissionResult);
    });
  }
  exports.waitForFinalTransactionOutcome = waitForFinalTransactionOutcome;
  function isSigned(transaction) {
    const tx2 = typeof transaction === "string" ? (0, utils_1$16.decode)(transaction) : transaction;
    if (typeof tx2 === "string") return false;
    if (tx2.Signers != null) {
      const signers = tx2.Signers;
      for (const signer of signers) if (signer.Signer.SigningPubKey == null || signer.Signer.TxnSignature == null) return false;
      return true;
    }
    return tx2.SigningPubKey != null && tx2.TxnSignature != null;
  }
  function getSignedTx(client2, transaction, { autofill = true, wallet } = {}) {
    return __awaiter$8(this, void 0, void 0, function* () {
      if (isSigned(transaction)) return transaction;
      if (!wallet) throw new errors_1$37.ValidationError("Wallet must be provided when submitting an unsigned transaction");
      let tx2 = typeof transaction === "string" ? (0, utils_1$16.decode)(transaction) : transaction;
      if (autofill) tx2 = yield client2.autofill(tx2);
      return wallet.sign(tx2).tx_blob;
    });
  }
  exports.getSignedTx = getSignedTx;
  function getLastLedgerSequence(transaction) {
    const tx2 = typeof transaction === "string" ? (0, utils_1$16.decode)(transaction) : transaction;
    return tx2.LastLedgerSequence;
  }
  exports.getLastLedgerSequence = getLastLedgerSequence;
  function isAccountDelete(transaction) {
    const tx2 = typeof transaction === "string" ? (0, utils_1$16.decode)(transaction) : transaction;
    return tx2.TransactionType === "AccountDelete";
  }
} });
var require_utils$2$1 = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/sugar/utils.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ensureClassicAddress = void 0;
  const ripple_address_codec_1$4 = require_dist$3();
  function ensureClassicAddress(account) {
    if ((0, ripple_address_codec_1$4.isValidXAddress)(account)) {
      const { classicAddress, tag } = (0, ripple_address_codec_1$4.xAddressToClassicAddress)(account);
      if (tag !== false) throw new Error("This command does not support the use of a tag. Use an address without a tag.");
      return classicAddress;
    }
    return account;
  }
  exports.ensureClassicAddress = ensureClassicAddress;
} });
var require_sugar = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/sugar/index.js"(exports) {
  var __createBinding$4 = Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
      enumerable: true,
      get: function() {
        return m[k];
      }
    };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  };
  var __exportStar$4 = function(m, exports$1) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding$4(exports$1, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar$4(require_submit(), exports);
  __exportStar$4(require_utils$2$1(), exports);
} });
var require_getFeeXrp = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/sugar/getFeeXrp.js"(exports) {
  var __awaiter$7 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault$9 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const bignumber_js_1$5 = __importDefault$9(require_bignumber());
  const errors_1$36 = require_errors();
  const NUM_DECIMAL_PLACES = 6;
  const BASE_10 = 10;
  function getFeeXrp(client2, cushion) {
    var _a;
    return __awaiter$7(this, void 0, void 0, function* () {
      const feeCushion = cushion !== null && cushion !== void 0 ? cushion : client2.feeCushion;
      const serverInfo = (yield client2.request({ command: "server_info" })).result.info;
      const baseFee = (_a = serverInfo.validated_ledger) === null || _a === void 0 ? void 0 : _a.base_fee_xrp;
      if (baseFee == null) throw new errors_1$36.XrplError("getFeeXrp: Could not get base_fee_xrp from server_info");
      const baseFeeXrp = new bignumber_js_1$5.default(baseFee);
      if (serverInfo.load_factor == null) serverInfo.load_factor = 1;
      let fee = baseFeeXrp.times(serverInfo.load_factor).times(feeCushion);
      fee = bignumber_js_1$5.default.min(fee, client2.maxFeeXRP);
      return new bignumber_js_1$5.default(fee.toFixed(NUM_DECIMAL_PLACES)).toString(BASE_10);
    });
  }
  exports.default = getFeeXrp;
} });
var require_autofill = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/sugar/autofill.js"(exports) {
  var __awaiter$6 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __asyncValues = function(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle2(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle2(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v$1) {
        resolve({
          value: v$1,
          done: d
        });
      }, reject);
    }
  };
  var __importDefault$8 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.autofillBatchTxn = exports.handleDeliverMax = exports.checkAccountDeleteBlockers = exports.setLatestValidatedLedgerSequence = exports.getTransactionFee = exports.setNextValidSequenceNumber = exports.setValidAddresses = exports.txNeedsNetworkID = void 0;
  const bignumber_js_1$4 = __importDefault$8(require_bignumber());
  const ripple_address_codec_1$3 = require_dist$3();
  const errors_1$35 = require_errors();
  const utils_1$15 = require_utils$3$1();
  const getFeeXrp_1 = __importDefault$8(require_getFeeXrp());
  const LEDGER_OFFSET = 20;
  const RESTRICTED_NETWORKS = 1024;
  const REQUIRED_NETWORKID_VERSION = "1.11.0";
  function isNotLaterRippledVersion(source, target) {
    if (source === target) return true;
    const sourceDecomp = source.split(".");
    const targetDecomp = target.split(".");
    const sourceMajor = parseInt(sourceDecomp[0], 10);
    const sourceMinor = parseInt(sourceDecomp[1], 10);
    const targetMajor = parseInt(targetDecomp[0], 10);
    const targetMinor = parseInt(targetDecomp[1], 10);
    if (sourceMajor !== targetMajor) return sourceMajor < targetMajor;
    if (sourceMinor !== targetMinor) return sourceMinor < targetMinor;
    const sourcePatch = sourceDecomp[2].split("-");
    const targetPatch = targetDecomp[2].split("-");
    const sourcePatchVersion = parseInt(sourcePatch[0], 10);
    const targetPatchVersion = parseInt(targetPatch[0], 10);
    if (sourcePatchVersion !== targetPatchVersion) return sourcePatchVersion < targetPatchVersion;
    if (sourcePatch.length !== targetPatch.length) return sourcePatch.length > targetPatch.length;
    if (sourcePatch.length === 2) {
      if (!sourcePatch[1][0].startsWith(targetPatch[1][0])) return sourcePatch[1] < targetPatch[1];
      if (sourcePatch[1].startsWith("b")) return parseInt(sourcePatch[1].slice(1), 10) < parseInt(targetPatch[1].slice(1), 10);
      return parseInt(sourcePatch[1].slice(2), 10) < parseInt(targetPatch[1].slice(2), 10);
    }
    return false;
  }
  function txNeedsNetworkID(client2) {
    if (client2.networkID !== void 0 && client2.networkID > RESTRICTED_NETWORKS) {
      if (client2.buildVersion && isNotLaterRippledVersion(REQUIRED_NETWORKID_VERSION, client2.buildVersion)) return true;
    }
    return false;
  }
  exports.txNeedsNetworkID = txNeedsNetworkID;
  function setValidAddresses(tx2) {
    validateAccountAddress(tx2, "Account", "SourceTag");
    if (tx2["Destination"] != null) validateAccountAddress(tx2, "Destination", "DestinationTag");
    convertToClassicAddress(tx2, "Authorize");
    convertToClassicAddress(tx2, "Unauthorize");
    convertToClassicAddress(tx2, "Owner");
    convertToClassicAddress(tx2, "RegularKey");
  }
  exports.setValidAddresses = setValidAddresses;
  function validateAccountAddress(tx2, accountField, tagField) {
    const { classicAccount, tag } = getClassicAccountAndTag(tx2[accountField]);
    tx2[accountField] = classicAccount;
    if (tag != null && tag !== false) {
      if (tx2[tagField] && tx2[tagField] !== tag) throw new errors_1$35.ValidationError(`The ${tagField}, if present, must match the tag of the ${accountField} X-address`);
      tx2[tagField] = tag;
    }
  }
  function getClassicAccountAndTag(account, expectedTag) {
    if ((0, ripple_address_codec_1$3.isValidXAddress)(account)) {
      const classic = (0, ripple_address_codec_1$3.xAddressToClassicAddress)(account);
      return {
        classicAccount: classic.classicAddress,
        tag: classic.tag
      };
    }
    return {
      classicAccount: account,
      tag: expectedTag
    };
  }
  function convertToClassicAddress(tx2, fieldName) {
    const account = tx2[fieldName];
    if (typeof account === "string") {
      const { classicAccount } = getClassicAccountAndTag(account);
      tx2[fieldName] = classicAccount;
    }
  }
  function getNextValidSequenceNumber(client2, account) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const request = {
        command: "account_info",
        account,
        ledger_index: "current"
      };
      const data2 = yield client2.request(request);
      return data2.result.account_data.Sequence;
    });
  }
  function setNextValidSequenceNumber(client2, tx2) {
    return __awaiter$6(this, void 0, void 0, function* () {
      tx2.Sequence = yield getNextValidSequenceNumber(client2, tx2.Account);
    });
  }
  exports.setNextValidSequenceNumber = setNextValidSequenceNumber;
  function fetchOwnerReserveFee(client2) {
    var _a;
    return __awaiter$6(this, void 0, void 0, function* () {
      const response = yield client2.request({ command: "server_state" });
      const fee = (_a = response.result.state.validated_ledger) === null || _a === void 0 ? void 0 : _a.reserve_inc;
      if (fee == null) return Promise.reject(new Error("Could not fetch Owner Reserve."));
      return new bignumber_js_1$4.default(fee);
    });
  }
  function calculateFeePerTransactionType(client2, tx2, signersCount = 0) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const netFeeXRP = yield (0, getFeeXrp_1.default)(client2);
      const netFeeDrops = (0, utils_1$15.xrpToDrops)(netFeeXRP);
      let baseFee = new bignumber_js_1$4.default(netFeeDrops);
      const isSpecialTxCost = ["AccountDelete", "AMMCreate"].includes(tx2.TransactionType);
      if (tx2.TransactionType === "EscrowFinish" && tx2.Fulfillment != null) {
        const fulfillmentBytesSize = Math.ceil(tx2.Fulfillment.length / 2);
        baseFee = new bignumber_js_1$4.default(scaleValue(netFeeDrops, 33 + fulfillmentBytesSize / 16));
      } else if (isSpecialTxCost) baseFee = yield fetchOwnerReserveFee(client2);
      else if (tx2.TransactionType === "Batch") {
        const rawTxFees = yield tx2.RawTransactions.reduce((acc, rawTxn) => __awaiter$6(this, void 0, void 0, function* () {
          const resolvedAcc = yield acc;
          const fee = yield calculateFeePerTransactionType(client2, rawTxn.RawTransaction);
          return bignumber_js_1$4.default.sum(resolvedAcc, fee);
        }), Promise.resolve(new bignumber_js_1$4.default(0)));
        baseFee = bignumber_js_1$4.default.sum(baseFee.times(2), rawTxFees);
      }
      if (signersCount > 0) baseFee = bignumber_js_1$4.default.sum(baseFee, scaleValue(netFeeDrops, signersCount));
      const maxFeeDrops = (0, utils_1$15.xrpToDrops)(client2.maxFeeXRP);
      const totalFee = isSpecialTxCost ? baseFee : bignumber_js_1$4.default.min(baseFee, maxFeeDrops);
      return totalFee.dp(0, bignumber_js_1$4.default.ROUND_CEIL);
    });
  }
  function getTransactionFee(client2, tx2, signersCount = 0) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const fee = yield calculateFeePerTransactionType(client2, tx2, signersCount);
      tx2.Fee = fee.toString(10);
    });
  }
  exports.getTransactionFee = getTransactionFee;
  function scaleValue(value, multiplier) {
    return new bignumber_js_1$4.default(value).times(multiplier).toString();
  }
  function setLatestValidatedLedgerSequence(client2, tx2) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const ledgerSequence = yield client2.getLedgerIndex();
      tx2.LastLedgerSequence = ledgerSequence + LEDGER_OFFSET;
    });
  }
  exports.setLatestValidatedLedgerSequence = setLatestValidatedLedgerSequence;
  function checkAccountDeleteBlockers(client2, tx2) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const request = {
        command: "account_objects",
        account: tx2.Account,
        ledger_index: "validated",
        deletion_blockers_only: true
      };
      const response = yield client2.request(request);
      return new Promise((resolve, reject) => {
        if (response.result.account_objects.length > 0) reject(new errors_1$35.XrplError(`Account ${tx2.Account} cannot be deleted; there are Escrows, PayChannels, RippleStates, or Checks associated with the account.`, response.result.account_objects));
        resolve();
      });
    });
  }
  exports.checkAccountDeleteBlockers = checkAccountDeleteBlockers;
  function handleDeliverMax(tx2) {
    if (tx2.DeliverMax != null) {
      if (tx2.Amount == null) tx2.Amount = tx2.DeliverMax;
      if (tx2.Amount != null && tx2.Amount !== tx2.DeliverMax) throw new errors_1$35.ValidationError("PaymentTransaction: Amount and DeliverMax fields must be identical when both are provided");
      delete tx2.DeliverMax;
    }
  }
  exports.handleDeliverMax = handleDeliverMax;
  function autofillBatchTxn(client2, tx2) {
    var _a, e_1, _b, _c;
    return __awaiter$6(this, void 0, void 0, function* () {
      const accountSequences = {};
      try {
        for (var _d = true, _e = __asyncValues(tx2.RawTransactions), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
          _c = _f.value;
          _d = false;
          const rawTxn = _c;
          const txn = rawTxn.RawTransaction;
          if (txn.Sequence == null && txn.TicketSequence == null) if (txn.Account in accountSequences) {
            txn.Sequence = accountSequences[txn.Account];
            accountSequences[txn.Account] += 1;
          } else {
            const nextSequence = yield getNextValidSequenceNumber(client2, txn.Account);
            const sequence = txn.Account === tx2.Account ? nextSequence + 1 : nextSequence;
            accountSequences[txn.Account] = sequence + 1;
            txn.Sequence = sequence;
          }
          if (txn.Fee == null) txn.Fee = "0";
          else if (txn.Fee !== "0") throw new errors_1$35.XrplError('Must have `Fee of "0" in inner Batch transaction.');
          if (txn.SigningPubKey == null) txn.SigningPubKey = "";
          else if (txn.SigningPubKey !== "") throw new errors_1$35.XrplError('Must have `SigningPubKey` of "" in inner Batch transaction.');
          if (txn.TxnSignature != null) throw new errors_1$35.XrplError("Must not have `TxnSignature` in inner Batch transaction.");
          if (txn.Signers != null) throw new errors_1$35.XrplError("Must not have `Signers` in inner Batch transaction.");
          if (txn.NetworkID == null && txNeedsNetworkID(client2)) txn.NetworkID = client2.networkID;
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    });
  }
  exports.autofillBatchTxn = autofillBatchTxn;
} });
var require_balances = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/sugar/balances.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatBalances = void 0;
  function formatBalances(trustlines) {
    return trustlines.map((trustline) => ({
      value: trustline.balance,
      currency: trustline.currency,
      issuer: trustline.account
    }));
  }
  exports.formatBalances = formatBalances;
} });
var require_Offer = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/Offer.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OfferFlags = void 0;
  var OfferFlags;
  (function(OfferFlags$1) {
    OfferFlags$1[OfferFlags$1["lsfPassive"] = 65536] = "lsfPassive";
    OfferFlags$1[OfferFlags$1["lsfSell"] = 131072] = "lsfSell";
  })(OfferFlags || (exports.OfferFlags = OfferFlags = {}));
} });
var require_getOrderbook = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/sugar/getOrderbook.js"(exports) {
  var __awaiter$5 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault$7 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sortAndLimitOffers = exports.separateBuySellOrders = exports.combineOrders = exports.extractOffers = exports.reverseRequest = exports.requestAllOffers = exports.createBookOffersRequest = exports.validateOrderbookOptions = void 0;
  const bignumber_js_1$3 = __importDefault$7(require_bignumber());
  const errors_1$34 = require_errors();
  const Offer_1$1 = require_Offer();
  const DEFAULT_LIMIT = 20;
  function sortOffers(offers) {
    return offers.sort((offerA, offerB) => {
      var _a, _b;
      const qualityA = (_a = offerA.quality) !== null && _a !== void 0 ? _a : 0;
      const qualityB = (_b = offerB.quality) !== null && _b !== void 0 ? _b : 0;
      return new bignumber_js_1$3.default(qualityA).comparedTo(qualityB);
    });
  }
  const getOrderbookOptionsSet = /* @__PURE__ */ new Set([
    "limit",
    "ledger_index",
    "ledger_hash",
    "taker"
  ]);
  function validateOrderbookOptions(options) {
    for (const key of Object.keys(options)) if (!getOrderbookOptionsSet.has(key)) throw new errors_1$34.ValidationError(`Unexpected option: ${key}`, options);
    if (options.limit && typeof options.limit !== "number") throw new errors_1$34.ValidationError("limit must be a number", options.limit);
    if (options.ledger_index && !(typeof options.ledger_index === "number" || typeof options.ledger_index === "string" && [
      "validated",
      "closed",
      "current"
    ].includes(options.ledger_index))) throw new errors_1$34.ValidationError('ledger_index must be a number or a string of "validated", "closed", or "current"', options.ledger_index);
    if (options.ledger_hash !== void 0 && options.ledger_hash !== null && typeof options.ledger_hash !== "string") throw new errors_1$34.ValidationError("ledger_hash must be a string", options.ledger_hash);
    if (options.taker !== void 0 && typeof options.taker !== "string") throw new errors_1$34.ValidationError("taker must be a string", options.taker);
  }
  exports.validateOrderbookOptions = validateOrderbookOptions;
  function createBookOffersRequest(currency1, currency2, options) {
    var _a, _b;
    const request = {
      command: "book_offers",
      taker_pays: currency1,
      taker_gets: currency2,
      ledger_index: (_a = options.ledger_index) !== null && _a !== void 0 ? _a : "validated",
      ledger_hash: options.ledger_hash === null ? void 0 : options.ledger_hash,
      limit: (_b = options.limit) !== null && _b !== void 0 ? _b : DEFAULT_LIMIT,
      taker: options.taker ? options.taker : void 0
    };
    return request;
  }
  exports.createBookOffersRequest = createBookOffersRequest;
  function requestAllOffers(client2, request) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const results = yield client2.requestAll(request);
      return results.map((result) => result.result.offers);
    });
  }
  exports.requestAllOffers = requestAllOffers;
  function reverseRequest(request) {
    return Object.assign(Object.assign({}, request), {
      taker_pays: request.taker_gets,
      taker_gets: request.taker_pays
    });
  }
  exports.reverseRequest = reverseRequest;
  function extractOffers(offerResults) {
    return offerResults.flatMap((offerResult) => offerResult);
  }
  exports.extractOffers = extractOffers;
  function combineOrders(directOffers, reverseOffers) {
    return [...directOffers, ...reverseOffers];
  }
  exports.combineOrders = combineOrders;
  function separateBuySellOrders(orders) {
    const buy = [];
    const sell = [];
    orders.forEach((order) => {
      if ((order.Flags & Offer_1$1.OfferFlags.lsfSell) === 0) buy.push(order);
      else sell.push(order);
    });
    return {
      buy,
      sell
    };
  }
  exports.separateBuySellOrders = separateBuySellOrders;
  function sortAndLimitOffers(offers, limit) {
    const sortedOffers = sortOffers(offers);
    return sortedOffers.slice(0, limit);
  }
  exports.sortAndLimitOffers = sortAndLimitOffers;
} });
var require_lib$2 = __commonJS$1({ "../../node_modules/.pnpm/@scure+bip32@1.7.0/node_modules/@scure/bip32/lib/index.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HDKey = exports.HARDENED_OFFSET = void 0;
  /*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */
  const modular_1 = require_modular$1();
  const secp256k1_1 = require_secp256k1$1$1();
  const hmac_1 = require_hmac$1();
  const legacy_1 = require_legacy();
  const sha2_1$1 = require_sha2$1();
  const utils_1$14 = require_utils$10();
  const base_1$1 = require_lib$1();
  const Point = secp256k1_1.secp256k1.ProjectivePoint;
  const base58check = (0, base_1$1.createBase58check)(sha2_1$1.sha256);
  function bytesToNumber(bytes$1) {
    (0, utils_1$14.abytes)(bytes$1);
    const h = bytes$1.length === 0 ? "0" : (0, utils_1$14.bytesToHex)(bytes$1);
    return BigInt("0x" + h);
  }
  function numberToBytes(num$1) {
    if (typeof num$1 !== "bigint") throw new Error("bigint expected");
    return (0, utils_1$14.hexToBytes)(num$1.toString(16).padStart(64, "0"));
  }
  const MASTER_SECRET = (0, utils_1$14.utf8ToBytes)("Bitcoin seed");
  const BITCOIN_VERSIONS = {
    private: 76066276,
    public: 76067358
  };
  exports.HARDENED_OFFSET = 2147483648;
  const hash160 = (data2) => (0, legacy_1.ripemd160)((0, sha2_1$1.sha256)(data2));
  const fromU32 = (data2) => (0, utils_1$14.createView)(data2).getUint32(0, false);
  const toU32 = (n) => {
    if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) throw new Error("invalid number, should be from 0 to 2**32-1, got " + n);
    const buf = new Uint8Array(4);
    (0, utils_1$14.createView)(buf).setUint32(0, n, false);
    return buf;
  };
  var HDKey = class HDKey2 {
    get fingerprint() {
      if (!this.pubHash) throw new Error("No publicKey set!");
      return fromU32(this.pubHash);
    }
    get identifier() {
      return this.pubHash;
    }
    get pubKeyHash() {
      return this.pubHash;
    }
    get privateKey() {
      return this.privKeyBytes || null;
    }
    get publicKey() {
      return this.pubKey || null;
    }
    get privateExtendedKey() {
      const priv = this.privateKey;
      if (!priv) throw new Error("No private key");
      return base58check.encode(this.serialize(this.versions.private, (0, utils_1$14.concatBytes)(new Uint8Array([0]), priv)));
    }
    get publicExtendedKey() {
      if (!this.pubKey) throw new Error("No public key");
      return base58check.encode(this.serialize(this.versions.public, this.pubKey));
    }
    static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {
      (0, utils_1$14.abytes)(seed);
      if (8 * seed.length < 128 || 8 * seed.length > 512) throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got " + seed.length);
      const I = (0, hmac_1.hmac)(sha2_1$1.sha512, MASTER_SECRET, seed);
      return new HDKey2({
        versions,
        chainCode: I.slice(32),
        privateKey: I.slice(0, 32)
      });
    }
    static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {
      const keyBuffer = base58check.decode(base58key);
      const keyView = (0, utils_1$14.createView)(keyBuffer);
      const version2 = keyView.getUint32(0, false);
      const opt = {
        versions,
        depth: keyBuffer[4],
        parentFingerprint: keyView.getUint32(5, false),
        index: keyView.getUint32(9, false),
        chainCode: keyBuffer.slice(13, 45)
      };
      const key = keyBuffer.slice(45);
      const isPriv = key[0] === 0;
      if (version2 !== versions[isPriv ? "private" : "public"]) throw new Error("Version mismatch");
      if (isPriv) return new HDKey2({
        ...opt,
        privateKey: key.slice(1)
      });
      else return new HDKey2({
        ...opt,
        publicKey: key
      });
    }
    static fromJSON(json) {
      return HDKey2.fromExtendedKey(json.xpriv);
    }
    constructor(opt) {
      this.depth = 0;
      this.index = 0;
      this.chainCode = null;
      this.parentFingerprint = 0;
      if (!opt || typeof opt !== "object") throw new Error("HDKey.constructor must not be called directly");
      this.versions = opt.versions || BITCOIN_VERSIONS;
      this.depth = opt.depth || 0;
      this.chainCode = opt.chainCode || null;
      this.index = opt.index || 0;
      this.parentFingerprint = opt.parentFingerprint || 0;
      if (!this.depth) {
        if (this.parentFingerprint || this.index) throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
      }
      if (opt.publicKey && opt.privateKey) throw new Error("HDKey: publicKey and privateKey at same time.");
      if (opt.privateKey) {
        if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(opt.privateKey)) throw new Error("Invalid private key");
        this.privKey = typeof opt.privateKey === "bigint" ? opt.privateKey : bytesToNumber(opt.privateKey);
        this.privKeyBytes = numberToBytes(this.privKey);
        this.pubKey = secp256k1_1.secp256k1.getPublicKey(opt.privateKey, true);
      } else if (opt.publicKey) this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true);
      else throw new Error("HDKey: no public or private key provided");
      this.pubHash = hash160(this.pubKey);
    }
    derive(path) {
      if (!/^[mM]'?/.test(path)) throw new Error('Path must start with "m" or "M"');
      if (/^[mM]'?$/.test(path)) return this;
      const parts = path.replace(/^[mM]'?\//, "").split("/");
      let child = this;
      for (const c of parts) {
        const m = /^(\d+)('?)$/.exec(c);
        const m1 = m && m[1];
        if (!m || m.length !== 3 || typeof m1 !== "string") throw new Error("invalid child index: " + c);
        let idx = +m1;
        if (!Number.isSafeInteger(idx) || idx >= exports.HARDENED_OFFSET) throw new Error("Invalid index");
        if (m[2] === "'") idx += exports.HARDENED_OFFSET;
        child = child.deriveChild(idx);
      }
      return child;
    }
    deriveChild(index) {
      if (!this.pubKey || !this.chainCode) throw new Error("No publicKey or chainCode set");
      let data2 = toU32(index);
      if (index >= exports.HARDENED_OFFSET) {
        const priv = this.privateKey;
        if (!priv) throw new Error("Could not derive hardened child key");
        data2 = (0, utils_1$14.concatBytes)(new Uint8Array([0]), priv, data2);
      } else data2 = (0, utils_1$14.concatBytes)(this.pubKey, data2);
      const I = (0, hmac_1.hmac)(sha2_1$1.sha512, this.chainCode, data2);
      const childTweak = bytesToNumber(I.slice(0, 32));
      const chainCode = I.slice(32);
      if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(childTweak)) throw new Error("Tweak bigger than curve order");
      const opt = {
        versions: this.versions,
        chainCode,
        depth: this.depth + 1,
        parentFingerprint: this.fingerprint,
        index
      };
      try {
        if (this.privateKey) {
          const added = (0, modular_1.mod)(this.privKey + childTweak, secp256k1_1.secp256k1.CURVE.n);
          if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(added)) throw new Error("The tweak was out of range or the resulted private key is invalid");
          opt.privateKey = added;
        } else {
          const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));
          if (added.equals(Point.ZERO)) throw new Error("The tweak was equal to negative P, which made the result key invalid");
          opt.publicKey = added.toRawBytes(true);
        }
        return new HDKey2(opt);
      } catch (err) {
        return this.deriveChild(index + 1);
      }
    }
    sign(hash$12) {
      if (!this.privateKey) throw new Error("No privateKey set!");
      (0, utils_1$14.abytes)(hash$12, 32);
      return secp256k1_1.secp256k1.sign(hash$12, this.privKey).toCompactRawBytes();
    }
    verify(hash$12, signature2) {
      (0, utils_1$14.abytes)(hash$12, 32);
      (0, utils_1$14.abytes)(signature2, 64);
      if (!this.publicKey) throw new Error("No publicKey set!");
      let sig;
      try {
        sig = secp256k1_1.secp256k1.Signature.fromCompact(signature2);
      } catch (error) {
        return false;
      }
      return secp256k1_1.secp256k1.verify(sig, hash$12, this.publicKey);
    }
    wipePrivateData() {
      this.privKey = void 0;
      if (this.privKeyBytes) {
        this.privKeyBytes.fill(0);
        this.privKeyBytes = void 0;
      }
      return this;
    }
    toJSON() {
      return {
        xpriv: this.privateExtendedKey,
        xpub: this.publicExtendedKey
      };
    }
    serialize(version2, key) {
      if (!this.chainCode) throw new Error("No chainCode set");
      (0, utils_1$14.abytes)(key, 33);
      return (0, utils_1$14.concatBytes)(toU32(version2), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);
    }
  };
  exports.HDKey = HDKey;
} });
var require_pbkdf2 = __commonJS$1({ "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/pbkdf2.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pbkdf2 = pbkdf2;
  exports.pbkdf2Async = pbkdf2Async;
  const hmac_ts_1 = require_hmac$1();
  const utils_ts_1 = require_utils$10();
  function pbkdf2Init(hash$12, _password, _salt, _opts) {
    (0, utils_ts_1.ahash)(hash$12);
    const opts = (0, utils_ts_1.checkOpts)({
      dkLen: 32,
      asyncTick: 10
    }, _opts);
    const { c, dkLen, asyncTick } = opts;
    (0, utils_ts_1.anumber)(c);
    (0, utils_ts_1.anumber)(dkLen);
    (0, utils_ts_1.anumber)(asyncTick);
    if (c < 1) throw new Error("iterations (c) should be >= 1");
    const password = (0, utils_ts_1.kdfInputToBytes)(_password);
    const salt = (0, utils_ts_1.kdfInputToBytes)(_salt);
    const DK2 = new Uint8Array(dkLen);
    const PRF = hmac_ts_1.hmac.create(hash$12, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return {
      c,
      dkLen,
      asyncTick,
      DK: DK2,
      PRF,
      PRFSalt
    };
  }
  function pbkdf2Output(PRF, PRFSalt, DK2, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW) prfW.destroy();
    (0, utils_ts_1.clean)(u);
    return DK2;
  }
  function pbkdf2(hash$12, password, salt, opts) {
    const { c, dkLen, DK: DK2, PRF, PRFSalt } = pbkdf2Init(hash$12, password, salt, opts);
    let prfW;
    const arr = new Uint8Array(4);
    const view = (0, utils_ts_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
      const Ti = DK2.subarray(pos, pos + PRF.outputLen);
      view.setInt32(0, ti, false);
      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
      Ti.set(u.subarray(0, Ti.length));
      for (let ui = 1; ui < c; ui++) {
        PRF._cloneInto(prfW).update(u).digestInto(u);
        for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];
      }
    }
    return pbkdf2Output(PRF, PRFSalt, DK2, prfW, u);
  }
  async function pbkdf2Async(hash$12, password, salt, opts) {
    const { c, dkLen, asyncTick, DK: DK2, PRF, PRFSalt } = pbkdf2Init(hash$12, password, salt, opts);
    let prfW;
    const arr = new Uint8Array(4);
    const view = (0, utils_ts_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
      const Ti = DK2.subarray(pos, pos + PRF.outputLen);
      view.setInt32(0, ti, false);
      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
      Ti.set(u.subarray(0, Ti.length));
      await (0, utils_ts_1.asyncLoop)(c - 1, asyncTick, () => {
        PRF._cloneInto(prfW).update(u).digestInto(u);
        for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];
      });
    }
    return pbkdf2Output(PRF, PRFSalt, DK2, prfW, u);
  }
} });
var require_bip39 = __commonJS$1({ "../../node_modules/.pnpm/@scure+bip39@1.6.0/node_modules/@scure/bip39/index.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.generateMnemonic = generateMnemonic;
  exports.mnemonicToEntropy = mnemonicToEntropy;
  exports.entropyToMnemonic = entropyToMnemonic;
  exports.validateMnemonic = validateMnemonic;
  exports.mnemonicToSeed = mnemonicToSeed;
  exports.mnemonicToSeedSync = mnemonicToSeedSync;
  /*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */
  const pbkdf2_1 = require_pbkdf2();
  const sha2_1 = require_sha2$1();
  const utils_1$13 = require_utils$10();
  const base_1 = require_lib$1();
  const isJapanese = (wordlist) => wordlist[0] === "";
  function nfkd(str) {
    if (typeof str !== "string") throw new TypeError("invalid mnemonic type: " + typeof str);
    return str.normalize("NFKD");
  }
  function normalize(str) {
    const norm = nfkd(str);
    const words = norm.split(" ");
    if (![
      12,
      15,
      18,
      21,
      24
    ].includes(words.length)) throw new Error("Invalid mnemonic");
    return {
      nfkd: norm,
      words
    };
  }
  function aentropy(ent) {
    (0, utils_1$13.abytes)(ent, 16, 20, 24, 28, 32);
  }
  function generateMnemonic(wordlist, strength = 128) {
    (0, utils_1$13.anumber)(strength);
    if (strength % 32 !== 0 || strength > 256) throw new TypeError("Invalid entropy");
    return entropyToMnemonic((0, utils_1$13.randomBytes)(strength / 8), wordlist);
  }
  const calcChecksum = (entropy) => {
    const bitsLeft = 8 - entropy.length / 4;
    return new Uint8Array([(0, sha2_1.sha256)(entropy)[0] >> bitsLeft << bitsLeft]);
  };
  function getCoder(wordlist) {
    if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== "string") throw new Error("Wordlist: expected array of 2048 strings");
    wordlist.forEach((i) => {
      if (typeof i !== "string") throw new Error("wordlist: non-string element: " + i);
    });
    return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist));
  }
  function mnemonicToEntropy(mnemonic, wordlist) {
    const { words } = normalize(mnemonic);
    const entropy = getCoder(wordlist).decode(words);
    aentropy(entropy);
    return entropy;
  }
  function entropyToMnemonic(entropy, wordlist) {
    aentropy(entropy);
    const words = getCoder(wordlist).encode(entropy);
    return words.join(isJapanese(wordlist) ? "" : " ");
  }
  function validateMnemonic(mnemonic, wordlist) {
    try {
      mnemonicToEntropy(mnemonic, wordlist);
    } catch (e) {
      return false;
    }
    return true;
  }
  const psalt = (passphrase) => nfkd("mnemonic" + passphrase);
  function mnemonicToSeed(mnemonic, passphrase = "") {
    return (0, pbkdf2_1.pbkdf2Async)(sha2_1.sha512, normalize(mnemonic).nfkd, psalt(passphrase), {
      c: 2048,
      dkLen: 64
    });
  }
  function mnemonicToSeedSync(mnemonic, passphrase = "") {
    return (0, pbkdf2_1.pbkdf2)(sha2_1.sha512, normalize(mnemonic).nfkd, psalt(passphrase), {
      c: 2048,
      dkLen: 64
    });
  }
} });
var require_english = __commonJS$1({ "../../node_modules/.pnpm/@scure+bip39@1.6.0/node_modules/@scure/bip39/wordlists/english.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wordlist = void 0;
  exports.wordlist = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`.split("\n");
} });
var require_ECDSA = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/ECDSA.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var ECDSA;
  (function(ECDSA$1) {
    ECDSA$1["ed25519"] = "ed25519";
    ECDSA$1["secp256k1"] = "ecdsa-secp256k1";
  })(ECDSA || (ECDSA = {}));
  exports.default = ECDSA;
} });
var require_accountDelete = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/accountDelete.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateAccountDelete = void 0;
  const common_1$44 = require_common();
  function validateAccountDelete(tx2) {
    (0, common_1$44.validateBaseTransaction)(tx2);
    (0, common_1$44.validateRequiredField)(tx2, "Destination", common_1$44.isAccount);
    (0, common_1$44.validateOptionalField)(tx2, "DestinationTag", common_1$44.isNumber);
    (0, common_1$44.validateCredentialsList)(tx2.CredentialIDs, tx2.TransactionType, true, common_1$44.MAX_AUTHORIZED_CREDENTIALS);
  }
  exports.validateAccountDelete = validateAccountDelete;
} });
var require_AMMBid = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/AMMBid.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateAMMBid = void 0;
  const errors_1$33 = require_errors();
  const common_1$43 = require_common();
  const MAX_AUTH_ACCOUNTS = 4;
  function validateAMMBid(tx2) {
    (0, common_1$43.validateBaseTransaction)(tx2);
    if (tx2.Asset == null) throw new errors_1$33.ValidationError("AMMBid: missing field Asset");
    if (!(0, common_1$43.isCurrency)(tx2.Asset)) throw new errors_1$33.ValidationError("AMMBid: Asset must be a Currency");
    if (tx2.Asset2 == null) throw new errors_1$33.ValidationError("AMMBid: missing field Asset2");
    if (!(0, common_1$43.isCurrency)(tx2.Asset2)) throw new errors_1$33.ValidationError("AMMBid: Asset2 must be a Currency");
    if (tx2.BidMin != null && !(0, common_1$43.isAmount)(tx2.BidMin)) throw new errors_1$33.ValidationError("AMMBid: BidMin must be an Amount");
    if (tx2.BidMax != null && !(0, common_1$43.isAmount)(tx2.BidMax)) throw new errors_1$33.ValidationError("AMMBid: BidMax must be an Amount");
    if (tx2.AuthAccounts != null) {
      if (!Array.isArray(tx2.AuthAccounts)) throw new errors_1$33.ValidationError(`AMMBid: AuthAccounts must be an AuthAccount array`);
      if (tx2.AuthAccounts.length > MAX_AUTH_ACCOUNTS) throw new errors_1$33.ValidationError(`AMMBid: AuthAccounts length must not be greater than ${MAX_AUTH_ACCOUNTS}`);
      validateAuthAccounts(tx2.Account, tx2.AuthAccounts);
    }
  }
  exports.validateAMMBid = validateAMMBid;
  function validateAuthAccounts(senderAddress, authAccounts) {
    for (const authAccount of authAccounts) {
      if (authAccount.AuthAccount == null || typeof authAccount.AuthAccount !== "object") throw new errors_1$33.ValidationError(`AMMBid: invalid AuthAccounts`);
      if (authAccount.AuthAccount.Account == null) throw new errors_1$33.ValidationError(`AMMBid: invalid AuthAccounts`);
      if (typeof authAccount.AuthAccount.Account !== "string") throw new errors_1$33.ValidationError(`AMMBid: invalid AuthAccounts`);
      if (authAccount.AuthAccount.Account === senderAddress) throw new errors_1$33.ValidationError(`AMMBid: AuthAccounts must not include sender's address`);
    }
    return true;
  }
} });
var require_AMMCreate = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/AMMCreate.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateAMMCreate = exports.AMM_MAX_TRADING_FEE = void 0;
  const errors_1$32 = require_errors();
  const common_1$42 = require_common();
  exports.AMM_MAX_TRADING_FEE = 1e3;
  function validateAMMCreate(tx2) {
    (0, common_1$42.validateBaseTransaction)(tx2);
    if (tx2.Amount == null) throw new errors_1$32.ValidationError("AMMCreate: missing field Amount");
    if (!(0, common_1$42.isAmount)(tx2.Amount)) throw new errors_1$32.ValidationError("AMMCreate: Amount must be an Amount");
    if (tx2.Amount2 == null) throw new errors_1$32.ValidationError("AMMCreate: missing field Amount2");
    if (!(0, common_1$42.isAmount)(tx2.Amount2)) throw new errors_1$32.ValidationError("AMMCreate: Amount2 must be an Amount");
    if (tx2.TradingFee == null) throw new errors_1$32.ValidationError("AMMCreate: missing field TradingFee");
    if (typeof tx2.TradingFee !== "number") throw new errors_1$32.ValidationError("AMMCreate: TradingFee must be a number");
    if (tx2.TradingFee < 0 || tx2.TradingFee > exports.AMM_MAX_TRADING_FEE) throw new errors_1$32.ValidationError(`AMMCreate: TradingFee must be between 0 and ${exports.AMM_MAX_TRADING_FEE}`);
  }
  exports.validateAMMCreate = validateAMMCreate;
} });
var require_AMMDelete = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/AMMDelete.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateAMMDelete = void 0;
  const errors_1$31 = require_errors();
  const common_1$41 = require_common();
  function validateAMMDelete(tx2) {
    (0, common_1$41.validateBaseTransaction)(tx2);
    if (tx2.Asset == null) throw new errors_1$31.ValidationError("AMMDelete: missing field Asset");
    if (!(0, common_1$41.isCurrency)(tx2.Asset)) throw new errors_1$31.ValidationError("AMMDelete: Asset must be a Currency");
    if (tx2.Asset2 == null) throw new errors_1$31.ValidationError("AMMDelete: missing field Asset2");
    if (!(0, common_1$41.isCurrency)(tx2.Asset2)) throw new errors_1$31.ValidationError("AMMDelete: Asset2 must be a Currency");
  }
  exports.validateAMMDelete = validateAMMDelete;
} });
var require_AMMVote = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/AMMVote.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateAMMVote = void 0;
  const errors_1$30 = require_errors();
  const AMMCreate_1$1 = require_AMMCreate();
  const common_1$40 = require_common();
  function validateAMMVote(tx2) {
    (0, common_1$40.validateBaseTransaction)(tx2);
    if (tx2.Asset == null) throw new errors_1$30.ValidationError("AMMVote: missing field Asset");
    if (!(0, common_1$40.isCurrency)(tx2.Asset)) throw new errors_1$30.ValidationError("AMMVote: Asset must be a Currency");
    if (tx2.Asset2 == null) throw new errors_1$30.ValidationError("AMMVote: missing field Asset2");
    if (!(0, common_1$40.isCurrency)(tx2.Asset2)) throw new errors_1$30.ValidationError("AMMVote: Asset2 must be a Currency");
    if (tx2.TradingFee == null) throw new errors_1$30.ValidationError("AMMVote: missing field TradingFee");
    if (typeof tx2.TradingFee !== "number") throw new errors_1$30.ValidationError("AMMVote: TradingFee must be a number");
    if (tx2.TradingFee < 0 || tx2.TradingFee > AMMCreate_1$1.AMM_MAX_TRADING_FEE) throw new errors_1$30.ValidationError(`AMMVote: TradingFee must be between 0 and ${AMMCreate_1$1.AMM_MAX_TRADING_FEE}`);
  }
  exports.validateAMMVote = validateAMMVote;
} });
var require_checkCancel = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/checkCancel.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateCheckCancel = void 0;
  const errors_1$29 = require_errors();
  const common_1$39 = require_common();
  function validateCheckCancel(tx2) {
    (0, common_1$39.validateBaseTransaction)(tx2);
    if (tx2.CheckID !== void 0 && typeof tx2.CheckID !== "string") throw new errors_1$29.ValidationError("CheckCancel: invalid CheckID");
  }
  exports.validateCheckCancel = validateCheckCancel;
} });
var require_checkCash = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/checkCash.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateCheckCash = void 0;
  const errors_1$28 = require_errors();
  const common_1$38 = require_common();
  function validateCheckCash(tx2) {
    (0, common_1$38.validateBaseTransaction)(tx2);
    if (tx2.Amount == null && tx2.DeliverMin == null) throw new errors_1$28.ValidationError("CheckCash: must have either Amount or DeliverMin");
    if (tx2.Amount != null && tx2.DeliverMin != null) throw new errors_1$28.ValidationError("CheckCash: cannot have both Amount and DeliverMin");
    if (tx2.Amount != null && tx2.Amount !== void 0 && !(0, common_1$38.isAmount)(tx2.Amount)) throw new errors_1$28.ValidationError("CheckCash: invalid Amount");
    if (tx2.DeliverMin != null && tx2.DeliverMin !== void 0 && !(0, common_1$38.isAmount)(tx2.DeliverMin)) throw new errors_1$28.ValidationError("CheckCash: invalid DeliverMin");
    if (tx2.CheckID !== void 0 && typeof tx2.CheckID !== "string") throw new errors_1$28.ValidationError("CheckCash: invalid CheckID");
  }
  exports.validateCheckCash = validateCheckCash;
} });
var require_checkCreate = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/checkCreate.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateCheckCreate = void 0;
  const errors_1$27 = require_errors();
  const common_1$37 = require_common();
  function validateCheckCreate(tx2) {
    (0, common_1$37.validateBaseTransaction)(tx2);
    if (tx2.SendMax === void 0) throw new errors_1$27.ValidationError("CheckCreate: missing field SendMax");
    (0, common_1$37.validateRequiredField)(tx2, "Destination", common_1$37.isAccount);
    (0, common_1$37.validateOptionalField)(tx2, "DestinationTag", common_1$37.isNumber);
    if (typeof tx2.SendMax !== "string" && !(0, common_1$37.isIssuedCurrency)(tx2.SendMax)) throw new errors_1$27.ValidationError("CheckCreate: invalid SendMax");
    if (tx2.Expiration !== void 0 && typeof tx2.Expiration !== "number") throw new errors_1$27.ValidationError("CheckCreate: invalid Expiration");
    if (tx2.InvoiceID !== void 0 && typeof tx2.InvoiceID !== "string") throw new errors_1$27.ValidationError("CheckCreate: invalid InvoiceID");
  }
  exports.validateCheckCreate = validateCheckCreate;
} });
var require_clawback = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/clawback.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateClawback = void 0;
  const errors_1$26 = require_errors();
  const common_1$36 = require_common();
  function validateClawback(tx2) {
    (0, common_1$36.validateBaseTransaction)(tx2);
    (0, common_1$36.validateOptionalField)(tx2, "Holder", common_1$36.isAccount);
    if (tx2.Amount == null) throw new errors_1$26.ValidationError("Clawback: missing field Amount");
    if (!(0, common_1$36.isIssuedCurrency)(tx2.Amount) && !(0, common_1$36.isMPTAmount)(tx2.Amount)) throw new errors_1$26.ValidationError("Clawback: invalid Amount");
    if ((0, common_1$36.isIssuedCurrency)(tx2.Amount) && tx2.Account === tx2.Amount.issuer) throw new errors_1$26.ValidationError("Clawback: invalid holder Account");
    if ((0, common_1$36.isMPTAmount)(tx2.Amount) && tx2.Account === tx2.Holder) throw new errors_1$26.ValidationError("Clawback: invalid holder Account");
    if ((0, common_1$36.isIssuedCurrency)(tx2.Amount) && tx2.Holder) throw new errors_1$26.ValidationError("Clawback: cannot have Holder for currency");
    if ((0, common_1$36.isMPTAmount)(tx2.Amount) && !tx2.Holder) throw new errors_1$26.ValidationError("Clawback: missing Holder");
  }
  exports.validateClawback = validateClawback;
} });
var require_CredentialAccept = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/CredentialAccept.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateCredentialAccept = void 0;
  const common_1$35 = require_common();
  function validateCredentialAccept(tx2) {
    (0, common_1$35.validateBaseTransaction)(tx2);
    (0, common_1$35.validateRequiredField)(tx2, "Account", common_1$35.isString);
    (0, common_1$35.validateRequiredField)(tx2, "Issuer", common_1$35.isString);
    (0, common_1$35.validateCredentialType)(tx2);
  }
  exports.validateCredentialAccept = validateCredentialAccept;
} });
var require_CredentialCreate = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/CredentialCreate.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateCredentialCreate = void 0;
  const utils_1$12 = require_browser$4();
  const errors_1$25 = require_errors();
  const common_1$34 = require_common();
  const MAX_URI_LENGTH = 256;
  function validateCredentialCreate(tx2) {
    (0, common_1$34.validateBaseTransaction)(tx2);
    (0, common_1$34.validateRequiredField)(tx2, "Account", common_1$34.isString);
    (0, common_1$34.validateRequiredField)(tx2, "Subject", common_1$34.isString);
    (0, common_1$34.validateCredentialType)(tx2);
    (0, common_1$34.validateOptionalField)(tx2, "Expiration", common_1$34.isNumber);
    validateURI(tx2.URI);
  }
  exports.validateCredentialCreate = validateCredentialCreate;
  function validateURI(URI) {
    if (URI === void 0) return;
    if (typeof URI !== "string") throw new errors_1$25.ValidationError("CredentialCreate: invalid field URI");
    if (URI.length === 0) throw new errors_1$25.ValidationError("CredentialCreate: URI cannot be an empty string");
    else if (URI.length > MAX_URI_LENGTH) throw new errors_1$25.ValidationError(`CredentialCreate: URI length must be <= ${MAX_URI_LENGTH}`);
    if (!utils_1$12.HEX_REGEX.test(URI)) throw new errors_1$25.ValidationError("CredentialCreate: URI must be encoded in hex");
  }
} });
var require_CredentialDelete = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/CredentialDelete.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateCredentialDelete = void 0;
  const errors_1$24 = require_errors();
  const common_1$33 = require_common();
  function validateCredentialDelete(tx2) {
    (0, common_1$33.validateBaseTransaction)(tx2);
    if (!tx2.Subject && !tx2.Issuer) throw new errors_1$24.ValidationError("CredentialDelete: either `Issuer` or `Subject` must be provided");
    (0, common_1$33.validateRequiredField)(tx2, "Account", common_1$33.isString);
    (0, common_1$33.validateCredentialType)(tx2);
    (0, common_1$33.validateOptionalField)(tx2, "Subject", common_1$33.isString);
    (0, common_1$33.validateOptionalField)(tx2, "Issuer", common_1$33.isString);
  }
  exports.validateCredentialDelete = validateCredentialDelete;
} });
var require_delegateSet = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/delegateSet.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateDelegateSet = void 0;
  const errors_1$23 = require_errors();
  const common_1$32 = require_common();
  const PERMISSIONS_MAX_LENGTH = 10;
  const NON_DELEGATABLE_TRANSACTIONS = /* @__PURE__ */ new Set([
    "AccountSet",
    "SetRegularKey",
    "SignerListSet",
    "DelegateSet",
    "AccountDelete",
    "Batch",
    "EnableAmendment",
    "SetFee",
    "UNLModify"
  ]);
  function validateDelegateSet(tx2) {
    (0, common_1$32.validateBaseTransaction)(tx2);
    (0, common_1$32.validateRequiredField)(tx2, "Authorize", common_1$32.isAccount);
    if (tx2.Authorize === tx2.Account) throw new errors_1$23.ValidationError("DelegateSet: Authorize and Account must be different.");
    (0, common_1$32.validateRequiredField)(tx2, "Permissions", Array.isArray);
    const permissions = tx2.Permissions;
    if (permissions.length > PERMISSIONS_MAX_LENGTH) throw new errors_1$23.ValidationError(`DelegateSet: Permissions array length cannot be greater than ${PERMISSIONS_MAX_LENGTH}.`);
    const permissionValueSet = /* @__PURE__ */ new Set();
    permissions.forEach((permission) => {
      if (permission == null || Object.keys(permission).length !== 1 || permission.Permission == null || Object.keys(permission.Permission).length !== 1) throw new errors_1$23.ValidationError("DelegateSet: Permissions array element is malformed");
      const permissionValue = permission.Permission.PermissionValue;
      if (permissionValue == null) throw new errors_1$23.ValidationError("DelegateSet: PermissionValue must be defined");
      if (typeof permissionValue !== "string") throw new errors_1$23.ValidationError("DelegateSet: PermissionValue must be a string");
      if (NON_DELEGATABLE_TRANSACTIONS.has(permissionValue)) throw new errors_1$23.ValidationError(`DelegateSet: PermissionValue contains a non-delegatable transaction ${permissionValue}`);
      permissionValueSet.add(permissionValue);
    });
    if (permissions.length !== permissionValueSet.size) throw new errors_1$23.ValidationError("DelegateSet: Permissions array cannot contain duplicate values");
  }
  exports.validateDelegateSet = validateDelegateSet;
} });
var require_depositPreauth = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/depositPreauth.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateDepositPreauth = void 0;
  const errors_1$22 = require_errors();
  const common_1$31 = require_common();
  function validateDepositPreauth(tx2) {
    (0, common_1$31.validateBaseTransaction)(tx2);
    validateSingleAuthorizationFieldProvided(tx2);
    if (tx2.Authorize !== void 0) {
      if (typeof tx2.Authorize !== "string") throw new errors_1$22.ValidationError("DepositPreauth: Authorize must be a string");
      if (tx2.Account === tx2.Authorize) throw new errors_1$22.ValidationError("DepositPreauth: Account can't preauthorize its own address");
    } else if (tx2.Unauthorize !== void 0) {
      if (typeof tx2.Unauthorize !== "string") throw new errors_1$22.ValidationError("DepositPreauth: Unauthorize must be a string");
      if (tx2.Account === tx2.Unauthorize) throw new errors_1$22.ValidationError("DepositPreauth: Account can't unauthorize its own address");
    } else if (tx2.AuthorizeCredentials !== void 0) (0, common_1$31.validateCredentialsList)(tx2.AuthorizeCredentials, tx2.TransactionType, false, common_1$31.MAX_AUTHORIZED_CREDENTIALS);
    else if (tx2.UnauthorizeCredentials !== void 0) (0, common_1$31.validateCredentialsList)(tx2.UnauthorizeCredentials, tx2.TransactionType, false, common_1$31.MAX_AUTHORIZED_CREDENTIALS);
  }
  exports.validateDepositPreauth = validateDepositPreauth;
  function validateSingleAuthorizationFieldProvided(tx2) {
    const fields = [
      "Authorize",
      "Unauthorize",
      "AuthorizeCredentials",
      "UnauthorizeCredentials"
    ];
    const countProvided = fields.filter((key) => tx2[key] !== void 0).length;
    if (countProvided !== 1) throw new errors_1$22.ValidationError("DepositPreauth: Requires exactly one field of the following: Authorize, Unauthorize, AuthorizeCredentials, UnauthorizeCredentials.");
  }
} });
var require_DIDDelete = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/DIDDelete.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateDIDDelete = void 0;
  const common_1$30 = require_common();
  function validateDIDDelete(tx2) {
    (0, common_1$30.validateBaseTransaction)(tx2);
  }
  exports.validateDIDDelete = validateDIDDelete;
} });
var require_DIDSet = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/DIDSet.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateDIDSet = void 0;
  const errors_1$21 = require_errors();
  const common_1$29 = require_common();
  function validateDIDSet(tx2) {
    (0, common_1$29.validateBaseTransaction)(tx2);
    (0, common_1$29.validateOptionalField)(tx2, "Data", common_1$29.isString);
    (0, common_1$29.validateOptionalField)(tx2, "DIDDocument", common_1$29.isString);
    (0, common_1$29.validateOptionalField)(tx2, "URI", common_1$29.isString);
    if (tx2.Data === void 0 && tx2.DIDDocument === void 0 && tx2.URI === void 0) throw new errors_1$21.ValidationError("DIDSet: Must have at least one of `Data`, `DIDDocument`, and `URI`");
  }
  exports.validateDIDSet = validateDIDSet;
} });
var require_escrowCancel = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/escrowCancel.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateEscrowCancel = void 0;
  const errors_1$20 = require_errors();
  const common_1$28 = require_common();
  function validateEscrowCancel(tx2) {
    (0, common_1$28.validateBaseTransaction)(tx2);
    (0, common_1$28.validateRequiredField)(tx2, "Owner", common_1$28.isAccount);
    if (tx2.OfferSequence == null) throw new errors_1$20.ValidationError("EscrowCancel: missing OfferSequence");
    if (typeof tx2.OfferSequence !== "number" && typeof tx2.OfferSequence !== "string" || Number.isNaN(Number(tx2.OfferSequence))) throw new errors_1$20.ValidationError("EscrowCancel: OfferSequence must be a number");
  }
  exports.validateEscrowCancel = validateEscrowCancel;
} });
var require_escrowCreate = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/escrowCreate.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateEscrowCreate = void 0;
  const errors_1$19 = require_errors();
  const common_1$27 = require_common();
  function validateEscrowCreate(tx2) {
    (0, common_1$27.validateBaseTransaction)(tx2);
    if (tx2.Amount === void 0) throw new errors_1$19.ValidationError("EscrowCreate: missing field Amount");
    if (typeof tx2.Amount !== "string") throw new errors_1$19.ValidationError("EscrowCreate: Amount must be a string");
    (0, common_1$27.validateRequiredField)(tx2, "Destination", common_1$27.isAccount);
    (0, common_1$27.validateOptionalField)(tx2, "DestinationTag", common_1$27.isNumber);
    if (tx2.CancelAfter === void 0 && tx2.FinishAfter === void 0) throw new errors_1$19.ValidationError("EscrowCreate: Either CancelAfter or FinishAfter must be specified");
    if (tx2.FinishAfter === void 0 && tx2.Condition === void 0) throw new errors_1$19.ValidationError("EscrowCreate: Either Condition or FinishAfter must be specified");
    if (tx2.CancelAfter !== void 0 && typeof tx2.CancelAfter !== "number") throw new errors_1$19.ValidationError("EscrowCreate: CancelAfter must be a number");
    if (tx2.FinishAfter !== void 0 && typeof tx2.FinishAfter !== "number") throw new errors_1$19.ValidationError("EscrowCreate: FinishAfter must be a number");
    if (tx2.Condition !== void 0 && typeof tx2.Condition !== "string") throw new errors_1$19.ValidationError("EscrowCreate: Condition must be a string");
  }
  exports.validateEscrowCreate = validateEscrowCreate;
} });
var require_escrowFinish = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/escrowFinish.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateEscrowFinish = void 0;
  const errors_1$18 = require_errors();
  const common_1$26 = require_common();
  function validateEscrowFinish(tx2) {
    (0, common_1$26.validateBaseTransaction)(tx2);
    (0, common_1$26.validateRequiredField)(tx2, "Owner", common_1$26.isAccount);
    (0, common_1$26.validateCredentialsList)(tx2.CredentialIDs, tx2.TransactionType, true, common_1$26.MAX_AUTHORIZED_CREDENTIALS);
    if (tx2.OfferSequence == null) throw new errors_1$18.ValidationError("EscrowFinish: missing field OfferSequence");
    if (typeof tx2.OfferSequence !== "number" && typeof tx2.OfferSequence !== "string" || Number.isNaN(Number(tx2.OfferSequence))) throw new errors_1$18.ValidationError("EscrowFinish: OfferSequence must be a number");
    if (tx2.Condition !== void 0 && typeof tx2.Condition !== "string") throw new errors_1$18.ValidationError("EscrowFinish: Condition must be a string");
    if (tx2.Fulfillment !== void 0 && typeof tx2.Fulfillment !== "string") throw new errors_1$18.ValidationError("EscrowFinish: Fulfillment must be a string");
  }
  exports.validateEscrowFinish = validateEscrowFinish;
} });
var require_MPTokenIssuanceDestroy = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/MPTokenIssuanceDestroy.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateMPTokenIssuanceDestroy = void 0;
  const common_1$25 = require_common();
  function validateMPTokenIssuanceDestroy(tx2) {
    (0, common_1$25.validateBaseTransaction)(tx2);
    (0, common_1$25.validateRequiredField)(tx2, "MPTokenIssuanceID", common_1$25.isString);
  }
  exports.validateMPTokenIssuanceDestroy = validateMPTokenIssuanceDestroy;
} });
var require_NFTokenAcceptOffer = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenAcceptOffer.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateNFTokenAcceptOffer = void 0;
  const errors_1$17 = require_errors();
  const common_1$24 = require_common();
  function validateNFTokenBrokerFee(tx2) {
    const value = (0, common_1$24.parseAmountValue)(tx2.NFTokenBrokerFee);
    if (Number.isNaN(value)) throw new errors_1$17.ValidationError("NFTokenAcceptOffer: invalid NFTokenBrokerFee");
    if (value <= 0) throw new errors_1$17.ValidationError("NFTokenAcceptOffer: NFTokenBrokerFee must be greater than 0; omit if there is no fee");
    if (tx2.NFTokenSellOffer == null || tx2.NFTokenBuyOffer == null) throw new errors_1$17.ValidationError("NFTokenAcceptOffer: both NFTokenSellOffer and NFTokenBuyOffer must be set if using brokered mode");
  }
  function validateNFTokenAcceptOffer(tx2) {
    (0, common_1$24.validateBaseTransaction)(tx2);
    if (tx2.NFTokenBrokerFee != null) validateNFTokenBrokerFee(tx2);
    if (tx2.NFTokenSellOffer == null && tx2.NFTokenBuyOffer == null) throw new errors_1$17.ValidationError("NFTokenAcceptOffer: must set either NFTokenSellOffer or NFTokenBuyOffer");
  }
  exports.validateNFTokenAcceptOffer = validateNFTokenAcceptOffer;
} });
var require_NFTokenBurn = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenBurn.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateNFTokenBurn = void 0;
  const common_1$23 = require_common();
  function validateNFTokenBurn(tx2) {
    (0, common_1$23.validateBaseTransaction)(tx2);
    (0, common_1$23.validateRequiredField)(tx2, "NFTokenID", common_1$23.isString);
    (0, common_1$23.validateOptionalField)(tx2, "Owner", common_1$23.isAccount);
  }
  exports.validateNFTokenBurn = validateNFTokenBurn;
} });
var require_NFTokenCancelOffer = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenCancelOffer.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateNFTokenCancelOffer = void 0;
  const errors_1$16 = require_errors();
  const common_1$22 = require_common();
  function validateNFTokenCancelOffer(tx2) {
    (0, common_1$22.validateBaseTransaction)(tx2);
    if (!Array.isArray(tx2.NFTokenOffers)) throw new errors_1$16.ValidationError("NFTokenCancelOffer: missing field NFTokenOffers");
    if (tx2.NFTokenOffers.length < 1) throw new errors_1$16.ValidationError("NFTokenCancelOffer: empty field NFTokenOffers");
  }
  exports.validateNFTokenCancelOffer = validateNFTokenCancelOffer;
} });
var require_NFTokenModify = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/NFTokenModify.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateNFTokenModify = void 0;
  const errors_1$15 = require_errors();
  const utils_1$11 = require_utils$4$1();
  const common_1$21 = require_common();
  function validateNFTokenModify(tx2) {
    (0, common_1$21.validateBaseTransaction)(tx2);
    (0, common_1$21.validateRequiredField)(tx2, "NFTokenID", common_1$21.isString);
    (0, common_1$21.validateOptionalField)(tx2, "Owner", common_1$21.isAccount);
    (0, common_1$21.validateOptionalField)(tx2, "URI", common_1$21.isString);
    if (tx2.URI !== void 0 && typeof tx2.URI === "string") {
      if (tx2.URI === "") throw new errors_1$15.ValidationError("NFTokenModify: URI must not be empty string");
      if (!(0, utils_1$11.isHex)(tx2.URI)) throw new errors_1$15.ValidationError("NFTokenModify: URI must be in hex format");
    }
  }
  exports.validateNFTokenModify = validateNFTokenModify;
} });
var require_offerCancel = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/offerCancel.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateOfferCancel = void 0;
  const errors_1$14 = require_errors();
  const common_1$20 = require_common();
  function validateOfferCancel(tx2) {
    (0, common_1$20.validateBaseTransaction)(tx2);
    if (tx2.OfferSequence === void 0) throw new errors_1$14.ValidationError("OfferCancel: missing field OfferSequence");
    if (typeof tx2.OfferSequence !== "number") throw new errors_1$14.ValidationError("OfferCancel: OfferSequence must be a number");
  }
  exports.validateOfferCancel = validateOfferCancel;
} });
var require_oracleDelete = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/oracleDelete.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateOracleDelete = void 0;
  const common_1$19 = require_common();
  function validateOracleDelete(tx2) {
    (0, common_1$19.validateBaseTransaction)(tx2);
    (0, common_1$19.validateRequiredField)(tx2, "OracleDocumentID", common_1$19.isNumber);
  }
  exports.validateOracleDelete = validateOracleDelete;
} });
var require_oracleSet = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/oracleSet.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateOracleSet = void 0;
  const errors_1$13 = require_errors();
  const utils_1$10 = require_utils$4$1();
  const common_1$18 = require_common();
  const PRICE_DATA_SERIES_MAX_LENGTH = 10;
  const SCALE_MAX = 10;
  const MINIMUM_ASSET_PRICE_LENGTH = 1;
  const MAXIMUM_ASSET_PRICE_LENGTH = 16;
  function validateOracleSet(tx2) {
    (0, common_1$18.validateBaseTransaction)(tx2);
    (0, common_1$18.validateRequiredField)(tx2, "OracleDocumentID", common_1$18.isNumber);
    (0, common_1$18.validateRequiredField)(tx2, "LastUpdateTime", common_1$18.isNumber);
    (0, common_1$18.validateOptionalField)(tx2, "Provider", common_1$18.isString);
    (0, common_1$18.validateOptionalField)(tx2, "URI", common_1$18.isString);
    (0, common_1$18.validateOptionalField)(tx2, "AssetClass", common_1$18.isString);
    (0, common_1$18.validateRequiredField)(tx2, "PriceDataSeries", (value) => {
      if (!Array.isArray(value)) throw new errors_1$13.ValidationError("OracleSet: PriceDataSeries must be an array");
      if (value.length > PRICE_DATA_SERIES_MAX_LENGTH) throw new errors_1$13.ValidationError(`OracleSet: PriceDataSeries must have at most ${PRICE_DATA_SERIES_MAX_LENGTH} PriceData objects`);
      for (const priceData of value) {
        if (typeof priceData !== "object") throw new errors_1$13.ValidationError("OracleSet: PriceDataSeries must be an array of objects");
        if (priceData.PriceData == null) throw new errors_1$13.ValidationError("OracleSet: PriceDataSeries must have a `PriceData` object");
        if (Object.keys(priceData).length !== 1) throw new errors_1$13.ValidationError("OracleSet: PriceDataSeries must only have a single PriceData object");
        if (typeof priceData.PriceData.BaseAsset !== "string") throw new errors_1$13.ValidationError("OracleSet: PriceDataSeries must have a `BaseAsset` string");
        if (typeof priceData.PriceData.QuoteAsset !== "string") throw new errors_1$13.ValidationError("OracleSet: PriceDataSeries must have a `QuoteAsset` string");
        if (priceData.PriceData.AssetPrice == null !== (priceData.PriceData.Scale == null)) throw new errors_1$13.ValidationError("OracleSet: PriceDataSeries must have both `AssetPrice` and `Scale` if any are present");
        if ("AssetPrice" in priceData.PriceData) {
          if (!(0, common_1$18.isNumber)(priceData.PriceData.AssetPrice)) {
            if (typeof priceData.PriceData.AssetPrice !== "string") throw new errors_1$13.ValidationError("OracleSet: Field AssetPrice must be a string or a number");
            if (!(0, utils_1$10.isHex)(priceData.PriceData.AssetPrice)) throw new errors_1$13.ValidationError("OracleSet: Field AssetPrice must be a valid hex string");
            if (priceData.PriceData.AssetPrice.length < MINIMUM_ASSET_PRICE_LENGTH || priceData.PriceData.AssetPrice.length > MAXIMUM_ASSET_PRICE_LENGTH) throw new errors_1$13.ValidationError(`OracleSet: Length of AssetPrice field must be between ${MINIMUM_ASSET_PRICE_LENGTH} and ${MAXIMUM_ASSET_PRICE_LENGTH} characters long`);
          }
        }
        if ("Scale" in priceData.PriceData && !(0, common_1$18.isNumber)(priceData.PriceData.Scale)) throw new errors_1$13.ValidationError("OracleSet: invalid field Scale");
        if (priceData.PriceData.Scale < 0 || priceData.PriceData.Scale > SCALE_MAX) throw new errors_1$13.ValidationError(`OracleSet: Scale must be in range 0-${SCALE_MAX}`);
      }
      return true;
    });
  }
  exports.validateOracleSet = validateOracleSet;
} });
var require_paymentChannelCreate = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/paymentChannelCreate.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validatePaymentChannelCreate = void 0;
  const errors_1$12 = require_errors();
  const common_1$17 = require_common();
  function validatePaymentChannelCreate(tx2) {
    (0, common_1$17.validateBaseTransaction)(tx2);
    if (tx2.Amount === void 0) throw new errors_1$12.ValidationError("PaymentChannelCreate: missing Amount");
    if (typeof tx2.Amount !== "string") throw new errors_1$12.ValidationError("PaymentChannelCreate: Amount must be a string");
    (0, common_1$17.validateRequiredField)(tx2, "Destination", common_1$17.isAccount);
    (0, common_1$17.validateOptionalField)(tx2, "DestinationTag", common_1$17.isNumber);
    if (tx2.SettleDelay === void 0) throw new errors_1$12.ValidationError("PaymentChannelCreate: missing SettleDelay");
    if (typeof tx2.SettleDelay !== "number") throw new errors_1$12.ValidationError("PaymentChannelCreate: SettleDelay must be a number");
    if (tx2.PublicKey === void 0) throw new errors_1$12.ValidationError("PaymentChannelCreate: missing PublicKey");
    if (typeof tx2.PublicKey !== "string") throw new errors_1$12.ValidationError("PaymentChannelCreate: PublicKey must be a string");
    if (tx2.CancelAfter !== void 0 && typeof tx2.CancelAfter !== "number") throw new errors_1$12.ValidationError("PaymentChannelCreate: CancelAfter must be a number");
  }
  exports.validatePaymentChannelCreate = validatePaymentChannelCreate;
} });
var require_paymentChannelFund = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/paymentChannelFund.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validatePaymentChannelFund = void 0;
  const errors_1$11 = require_errors();
  const common_1$16 = require_common();
  function validatePaymentChannelFund(tx2) {
    (0, common_1$16.validateBaseTransaction)(tx2);
    if (tx2.Channel === void 0) throw new errors_1$11.ValidationError("PaymentChannelFund: missing Channel");
    if (typeof tx2.Channel !== "string") throw new errors_1$11.ValidationError("PaymentChannelFund: Channel must be a string");
    if (tx2.Amount === void 0) throw new errors_1$11.ValidationError("PaymentChannelFund: missing Amount");
    if (typeof tx2.Amount !== "string") throw new errors_1$11.ValidationError("PaymentChannelFund: Amount must be a string");
    if (tx2.Expiration !== void 0 && typeof tx2.Expiration !== "number") throw new errors_1$11.ValidationError("PaymentChannelFund: Expiration must be a number");
  }
  exports.validatePaymentChannelFund = validatePaymentChannelFund;
} });
var require_permissionedDomainDelete = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/permissionedDomainDelete.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validatePermissionedDomainDelete = void 0;
  const common_1$15 = require_common();
  function validatePermissionedDomainDelete(tx2) {
    (0, common_1$15.validateBaseTransaction)(tx2);
    (0, common_1$15.validateRequiredField)(tx2, "DomainID", common_1$15.isString);
  }
  exports.validatePermissionedDomainDelete = validatePermissionedDomainDelete;
} });
var require_permissionedDomainSet = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/permissionedDomainSet.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validatePermissionedDomainSet = void 0;
  const common_1$14 = require_common();
  const MAX_ACCEPTED_CREDENTIALS = 10;
  function validatePermissionedDomainSet(tx2) {
    (0, common_1$14.validateBaseTransaction)(tx2);
    (0, common_1$14.validateOptionalField)(tx2, "DomainID", common_1$14.isString);
    (0, common_1$14.validateRequiredField)(tx2, "AcceptedCredentials", common_1$14.isArray);
    (0, common_1$14.validateCredentialsList)(tx2.AcceptedCredentials, tx2.TransactionType, false, MAX_ACCEPTED_CREDENTIALS);
  }
  exports.validatePermissionedDomainSet = validatePermissionedDomainSet;
} });
var require_setRegularKey = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/setRegularKey.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateSetRegularKey = void 0;
  const errors_1$10 = require_errors();
  const common_1$13 = require_common();
  function validateSetRegularKey(tx2) {
    (0, common_1$13.validateBaseTransaction)(tx2);
    if (tx2.RegularKey !== void 0 && typeof tx2.RegularKey !== "string") throw new errors_1$10.ValidationError("SetRegularKey: RegularKey must be a string");
  }
  exports.validateSetRegularKey = validateSetRegularKey;
} });
var require_signerListSet = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/signerListSet.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateSignerListSet = void 0;
  const errors_1$9 = require_errors();
  const common_1$12 = require_common();
  const MAX_SIGNERS = 32;
  const HEX_WALLET_LOCATOR_REGEX = /^[0-9A-Fa-f]{64}$/u;
  function validateSignerListSet(tx2) {
    (0, common_1$12.validateBaseTransaction)(tx2);
    if (tx2.SignerQuorum === void 0) throw new errors_1$9.ValidationError("SignerListSet: missing field SignerQuorum");
    if (typeof tx2.SignerQuorum !== "number") throw new errors_1$9.ValidationError("SignerListSet: invalid SignerQuorum");
    if (tx2.SignerQuorum === 0) return;
    if (tx2.SignerEntries === void 0) throw new errors_1$9.ValidationError("SignerListSet: missing field SignerEntries");
    if (!(0, common_1$12.isArray)(tx2.SignerEntries)) throw new errors_1$9.ValidationError("SignerListSet: invalid SignerEntries");
    if (tx2.SignerEntries.length === 0) throw new errors_1$9.ValidationError("SignerListSet: need at least 1 member in SignerEntries");
    if (tx2.SignerEntries.length > MAX_SIGNERS) throw new errors_1$9.ValidationError(`SignerListSet: maximum of ${MAX_SIGNERS} members allowed in SignerEntries`);
    for (const entry2 of tx2.SignerEntries) {
      const signerEntry = entry2;
      const { WalletLocator } = signerEntry.SignerEntry;
      if (WalletLocator !== void 0 && !HEX_WALLET_LOCATOR_REGEX.test(WalletLocator)) throw new errors_1$9.ValidationError(`SignerListSet: WalletLocator in SignerEntry must be a 256-bit (32-byte) hexadecimal value`);
    }
  }
  exports.validateSignerListSet = validateSignerListSet;
} });
var require_ticketCreate = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/ticketCreate.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateTicketCreate = void 0;
  const errors_1$8 = require_errors();
  const common_1$11 = require_common();
  const MAX_TICKETS = 250;
  function validateTicketCreate(tx2) {
    (0, common_1$11.validateBaseTransaction)(tx2);
    const { TicketCount } = tx2;
    if (TicketCount === void 0) throw new errors_1$8.ValidationError("TicketCreate: missing field TicketCount");
    if (typeof TicketCount !== "number") throw new errors_1$8.ValidationError("TicketCreate: TicketCount must be a number");
    if (!Number.isInteger(TicketCount) || TicketCount < 1 || TicketCount > MAX_TICKETS) throw new errors_1$8.ValidationError("TicketCreate: TicketCount must be an integer from 1 to 250");
  }
  exports.validateTicketCreate = validateTicketCreate;
} });
var require_XChainAccountCreateCommit = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainAccountCreateCommit.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateXChainAccountCreateCommit = void 0;
  const common_1$10 = require_common();
  function validateXChainAccountCreateCommit(tx2) {
    (0, common_1$10.validateBaseTransaction)(tx2);
    (0, common_1$10.validateRequiredField)(tx2, "XChainBridge", common_1$10.isXChainBridge);
    (0, common_1$10.validateRequiredField)(tx2, "SignatureReward", common_1$10.isAmount);
    (0, common_1$10.validateRequiredField)(tx2, "Destination", common_1$10.isAccount);
    (0, common_1$10.validateRequiredField)(tx2, "Amount", common_1$10.isAmount);
  }
  exports.validateXChainAccountCreateCommit = validateXChainAccountCreateCommit;
} });
var require_XChainAddAccountCreateAttestation = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainAddAccountCreateAttestation.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateXChainAddAccountCreateAttestation = void 0;
  const common_1$9 = require_common();
  function validateXChainAddAccountCreateAttestation(tx2) {
    (0, common_1$9.validateBaseTransaction)(tx2);
    (0, common_1$9.validateRequiredField)(tx2, "Amount", common_1$9.isAmount);
    (0, common_1$9.validateRequiredField)(tx2, "AttestationRewardAccount", common_1$9.isAccount);
    (0, common_1$9.validateRequiredField)(tx2, "AttestationSignerAccount", common_1$9.isAccount);
    (0, common_1$9.validateRequiredField)(tx2, "Destination", common_1$9.isAccount);
    (0, common_1$9.validateRequiredField)(tx2, "OtherChainSource", common_1$9.isAccount);
    (0, common_1$9.validateRequiredField)(tx2, "PublicKey", common_1$9.isString);
    (0, common_1$9.validateRequiredField)(tx2, "Signature", common_1$9.isString);
    (0, common_1$9.validateRequiredField)(tx2, "SignatureReward", common_1$9.isAmount);
    (0, common_1$9.validateRequiredField)(tx2, "WasLockingChainSend", (inp) => inp === 0 || inp === 1);
    (0, common_1$9.validateRequiredField)(tx2, "XChainAccountCreateCount", (inp) => (0, common_1$9.isNumber)(inp) || (0, common_1$9.isString)(inp));
    (0, common_1$9.validateRequiredField)(tx2, "XChainBridge", common_1$9.isXChainBridge);
  }
  exports.validateXChainAddAccountCreateAttestation = validateXChainAddAccountCreateAttestation;
} });
var require_XChainAddClaimAttestation = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainAddClaimAttestation.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateXChainAddClaimAttestation = void 0;
  const common_1$8 = require_common();
  function validateXChainAddClaimAttestation(tx2) {
    (0, common_1$8.validateBaseTransaction)(tx2);
    (0, common_1$8.validateRequiredField)(tx2, "Amount", common_1$8.isAmount);
    (0, common_1$8.validateRequiredField)(tx2, "AttestationRewardAccount", common_1$8.isAccount);
    (0, common_1$8.validateRequiredField)(tx2, "AttestationSignerAccount", common_1$8.isAccount);
    (0, common_1$8.validateOptionalField)(tx2, "Destination", common_1$8.isAccount);
    (0, common_1$8.validateRequiredField)(tx2, "OtherChainSource", common_1$8.isAccount);
    (0, common_1$8.validateRequiredField)(tx2, "PublicKey", common_1$8.isString);
    (0, common_1$8.validateRequiredField)(tx2, "Signature", common_1$8.isString);
    (0, common_1$8.validateRequiredField)(tx2, "WasLockingChainSend", (inp) => inp === 0 || inp === 1);
    (0, common_1$8.validateRequiredField)(tx2, "XChainBridge", common_1$8.isXChainBridge);
    (0, common_1$8.validateRequiredField)(tx2, "XChainClaimID", (inp) => (0, common_1$8.isNumber)(inp) || (0, common_1$8.isString)(inp));
  }
  exports.validateXChainAddClaimAttestation = validateXChainAddClaimAttestation;
} });
var require_XChainClaim = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainClaim.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateXChainClaim = void 0;
  const common_1$7 = require_common();
  function validateXChainClaim(tx2) {
    (0, common_1$7.validateBaseTransaction)(tx2);
    (0, common_1$7.validateRequiredField)(tx2, "XChainBridge", common_1$7.isXChainBridge);
    (0, common_1$7.validateRequiredField)(tx2, "XChainClaimID", (inp) => (0, common_1$7.isNumber)(inp) || (0, common_1$7.isString)(inp));
    (0, common_1$7.validateRequiredField)(tx2, "Destination", common_1$7.isAccount);
    (0, common_1$7.validateOptionalField)(tx2, "DestinationTag", common_1$7.isNumber);
    (0, common_1$7.validateRequiredField)(tx2, "Amount", common_1$7.isAmount);
  }
  exports.validateXChainClaim = validateXChainClaim;
} });
var require_XChainCommit = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainCommit.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateXChainCommit = void 0;
  const common_1$6 = require_common();
  function validateXChainCommit(tx2) {
    (0, common_1$6.validateBaseTransaction)(tx2);
    (0, common_1$6.validateRequiredField)(tx2, "XChainBridge", common_1$6.isXChainBridge);
    (0, common_1$6.validateRequiredField)(tx2, "XChainClaimID", (inp) => (0, common_1$6.isNumber)(inp) || (0, common_1$6.isString)(inp));
    (0, common_1$6.validateOptionalField)(tx2, "OtherChainDestination", common_1$6.isAccount);
    (0, common_1$6.validateRequiredField)(tx2, "Amount", common_1$6.isAmount);
  }
  exports.validateXChainCommit = validateXChainCommit;
} });
var require_XChainCreateBridge = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainCreateBridge.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateXChainCreateBridge = void 0;
  const common_1$5 = require_common();
  function validateXChainCreateBridge(tx2) {
    (0, common_1$5.validateBaseTransaction)(tx2);
    (0, common_1$5.validateRequiredField)(tx2, "XChainBridge", common_1$5.isXChainBridge);
    (0, common_1$5.validateRequiredField)(tx2, "SignatureReward", common_1$5.isAmount);
    (0, common_1$5.validateOptionalField)(tx2, "MinAccountCreateAmount", common_1$5.isAmount);
  }
  exports.validateXChainCreateBridge = validateXChainCreateBridge;
} });
var require_XChainCreateClaimID = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/XChainCreateClaimID.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateXChainCreateClaimID = void 0;
  const common_1$4 = require_common();
  function validateXChainCreateClaimID(tx2) {
    (0, common_1$4.validateBaseTransaction)(tx2);
    (0, common_1$4.validateRequiredField)(tx2, "XChainBridge", common_1$4.isXChainBridge);
    (0, common_1$4.validateRequiredField)(tx2, "SignatureReward", common_1$4.isAmount);
    (0, common_1$4.validateRequiredField)(tx2, "OtherChainSource", common_1$4.isAccount);
  }
  exports.validateXChainCreateClaimID = validateXChainCreateClaimID;
} });
var require_transaction = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/transaction.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validate = void 0;
  const errors_1$7 = require_errors();
  const utils_1$9 = require_utils$4$1();
  const flags_1$2 = require_flags();
  const accountDelete_1 = require_accountDelete();
  const accountSet_1$1 = require_accountSet();
  const AMMBid_1 = require_AMMBid();
  const AMMClawback_1$1 = require_AMMClawback();
  const AMMCreate_1 = require_AMMCreate();
  const AMMDelete_1 = require_AMMDelete();
  const AMMDeposit_1$1 = require_AMMDeposit();
  const AMMVote_1 = require_AMMVote();
  const AMMWithdraw_1$1 = require_AMMWithdraw();
  const batch_1 = require_batch();
  const checkCancel_1 = require_checkCancel();
  const checkCash_1 = require_checkCash();
  const checkCreate_1 = require_checkCreate();
  const clawback_1 = require_clawback();
  const common_1$3 = require_common();
  const CredentialAccept_1 = require_CredentialAccept();
  const CredentialCreate_1 = require_CredentialCreate();
  const CredentialDelete_1 = require_CredentialDelete();
  const delegateSet_1 = require_delegateSet();
  const depositPreauth_1 = require_depositPreauth();
  const DIDDelete_1 = require_DIDDelete();
  const DIDSet_1 = require_DIDSet();
  const escrowCancel_1 = require_escrowCancel();
  const escrowCreate_1 = require_escrowCreate();
  const escrowFinish_1 = require_escrowFinish();
  const MPTokenAuthorize_1$1 = require_MPTokenAuthorize();
  const MPTokenIssuanceCreate_1$1 = require_MPTokenIssuanceCreate();
  const MPTokenIssuanceDestroy_1 = require_MPTokenIssuanceDestroy();
  const MPTokenIssuanceSet_1$1 = require_MPTokenIssuanceSet();
  const NFTokenAcceptOffer_1 = require_NFTokenAcceptOffer();
  const NFTokenBurn_1 = require_NFTokenBurn();
  const NFTokenCancelOffer_1 = require_NFTokenCancelOffer();
  const NFTokenCreateOffer_1$1 = require_NFTokenCreateOffer();
  const NFTokenMint_1$1 = require_NFTokenMint();
  const NFTokenModify_1$1 = require_NFTokenModify();
  const offerCancel_1 = require_offerCancel();
  const offerCreate_1$1 = require_offerCreate();
  const oracleDelete_1 = require_oracleDelete();
  const oracleSet_1 = require_oracleSet();
  const payment_1$1 = require_payment();
  const paymentChannelClaim_1$1 = require_paymentChannelClaim();
  const paymentChannelCreate_1 = require_paymentChannelCreate();
  const paymentChannelFund_1 = require_paymentChannelFund();
  const permissionedDomainDelete_1 = require_permissionedDomainDelete();
  const permissionedDomainSet_1 = require_permissionedDomainSet();
  const setRegularKey_1 = require_setRegularKey();
  const signerListSet_1 = require_signerListSet();
  const ticketCreate_1 = require_ticketCreate();
  const trustSet_1$1 = require_trustSet();
  const XChainAccountCreateCommit_1 = require_XChainAccountCreateCommit();
  const XChainAddAccountCreateAttestation_1 = require_XChainAddAccountCreateAttestation();
  const XChainAddClaimAttestation_1 = require_XChainAddClaimAttestation();
  const XChainClaim_1 = require_XChainClaim();
  const XChainCommit_1 = require_XChainCommit();
  const XChainCreateBridge_1 = require_XChainCreateBridge();
  const XChainCreateClaimID_1 = require_XChainCreateClaimID();
  const XChainModifyBridge_1$1 = require_XChainModifyBridge();
  function validate2(transaction) {
    const tx2 = Object.assign({}, transaction);
    if (tx2.TransactionType == null) throw new errors_1$7.ValidationError("Object does not have a `TransactionType`");
    if (typeof tx2.TransactionType !== "string") throw new errors_1$7.ValidationError("Object's `TransactionType` is not a string");
    if (tx2.Memos != null && typeof tx2.Memos !== "object") throw new errors_1$7.ValidationError("Memo must be array");
    if (tx2.Memos != null) tx2.Memos.forEach((memo) => {
      if ((memo === null || memo === void 0 ? void 0 : memo.Memo) == null) throw new errors_1$7.ValidationError("Memo data must be in a `Memo` field");
      if (memo.Memo.MemoData) {
        if (!(0, utils_1$9.isHex)(memo.Memo.MemoData)) throw new errors_1$7.ValidationError("MemoData field must be a hex value");
      }
      if (memo.Memo.MemoType) {
        if (!(0, utils_1$9.isHex)(memo.Memo.MemoType)) throw new errors_1$7.ValidationError("MemoType field must be a hex value");
      }
      if (memo.Memo.MemoFormat) {
        if (!(0, utils_1$9.isHex)(memo.Memo.MemoFormat)) throw new errors_1$7.ValidationError("MemoFormat field must be a hex value");
      }
    });
    Object.keys(tx2).forEach((key) => {
      const standard_currency_code_len = 3;
      if (tx2[key] && (0, common_1$3.isIssuedCurrency)(tx2[key])) {
        const txCurrency = tx2[key].currency;
        if (txCurrency.length === standard_currency_code_len && txCurrency.toUpperCase() === "XRP") throw new errors_1$7.ValidationError(`Cannot have an issued currency with a similar standard code to XRP (received '${txCurrency}'). XRP is not an issued currency.`);
      }
    });
    tx2.Flags = (0, flags_1$2.convertTxFlagsToNumber)(tx2);
    switch (tx2.TransactionType) {
      case "AMMBid":
        (0, AMMBid_1.validateAMMBid)(tx2);
        break;
      case "AMMClawback":
        (0, AMMClawback_1$1.validateAMMClawback)(tx2);
        break;
      case "AMMCreate":
        (0, AMMCreate_1.validateAMMCreate)(tx2);
        break;
      case "AMMDelete":
        (0, AMMDelete_1.validateAMMDelete)(tx2);
        break;
      case "AMMDeposit":
        (0, AMMDeposit_1$1.validateAMMDeposit)(tx2);
        break;
      case "AMMVote":
        (0, AMMVote_1.validateAMMVote)(tx2);
        break;
      case "AMMWithdraw":
        (0, AMMWithdraw_1$1.validateAMMWithdraw)(tx2);
        break;
      case "AccountDelete":
        (0, accountDelete_1.validateAccountDelete)(tx2);
        break;
      case "AccountSet":
        (0, accountSet_1$1.validateAccountSet)(tx2);
        break;
      case "Batch":
        (0, batch_1.validateBatch)(tx2);
        tx2.RawTransactions.forEach((innerTx) => {
          validate2(innerTx.RawTransaction);
        });
        break;
      case "CheckCancel":
        (0, checkCancel_1.validateCheckCancel)(tx2);
        break;
      case "CheckCash":
        (0, checkCash_1.validateCheckCash)(tx2);
        break;
      case "CheckCreate":
        (0, checkCreate_1.validateCheckCreate)(tx2);
        break;
      case "Clawback":
        (0, clawback_1.validateClawback)(tx2);
        break;
      case "CredentialAccept":
        (0, CredentialAccept_1.validateCredentialAccept)(tx2);
        break;
      case "CredentialCreate":
        (0, CredentialCreate_1.validateCredentialCreate)(tx2);
        break;
      case "CredentialDelete":
        (0, CredentialDelete_1.validateCredentialDelete)(tx2);
        break;
      case "DIDDelete":
        (0, DIDDelete_1.validateDIDDelete)(tx2);
        break;
      case "DIDSet":
        (0, DIDSet_1.validateDIDSet)(tx2);
        break;
      case "DelegateSet":
        (0, delegateSet_1.validateDelegateSet)(tx2);
        break;
      case "DepositPreauth":
        (0, depositPreauth_1.validateDepositPreauth)(tx2);
        break;
      case "EscrowCancel":
        (0, escrowCancel_1.validateEscrowCancel)(tx2);
        break;
      case "EscrowCreate":
        (0, escrowCreate_1.validateEscrowCreate)(tx2);
        break;
      case "EscrowFinish":
        (0, escrowFinish_1.validateEscrowFinish)(tx2);
        break;
      case "MPTokenAuthorize":
        (0, MPTokenAuthorize_1$1.validateMPTokenAuthorize)(tx2);
        break;
      case "MPTokenIssuanceCreate":
        (0, MPTokenIssuanceCreate_1$1.validateMPTokenIssuanceCreate)(tx2);
        break;
      case "MPTokenIssuanceDestroy":
        (0, MPTokenIssuanceDestroy_1.validateMPTokenIssuanceDestroy)(tx2);
        break;
      case "MPTokenIssuanceSet":
        (0, MPTokenIssuanceSet_1$1.validateMPTokenIssuanceSet)(tx2);
        break;
      case "NFTokenAcceptOffer":
        (0, NFTokenAcceptOffer_1.validateNFTokenAcceptOffer)(tx2);
        break;
      case "NFTokenBurn":
        (0, NFTokenBurn_1.validateNFTokenBurn)(tx2);
        break;
      case "NFTokenCancelOffer":
        (0, NFTokenCancelOffer_1.validateNFTokenCancelOffer)(tx2);
        break;
      case "NFTokenCreateOffer":
        (0, NFTokenCreateOffer_1$1.validateNFTokenCreateOffer)(tx2);
        break;
      case "NFTokenMint":
        (0, NFTokenMint_1$1.validateNFTokenMint)(tx2);
        break;
      case "NFTokenModify":
        (0, NFTokenModify_1$1.validateNFTokenModify)(tx2);
        break;
      case "OfferCancel":
        (0, offerCancel_1.validateOfferCancel)(tx2);
        break;
      case "OfferCreate":
        (0, offerCreate_1$1.validateOfferCreate)(tx2);
        break;
      case "OracleDelete":
        (0, oracleDelete_1.validateOracleDelete)(tx2);
        break;
      case "OracleSet":
        (0, oracleSet_1.validateOracleSet)(tx2);
        break;
      case "Payment":
        (0, payment_1$1.validatePayment)(tx2);
        break;
      case "PaymentChannelClaim":
        (0, paymentChannelClaim_1$1.validatePaymentChannelClaim)(tx2);
        break;
      case "PaymentChannelCreate":
        (0, paymentChannelCreate_1.validatePaymentChannelCreate)(tx2);
        break;
      case "PaymentChannelFund":
        (0, paymentChannelFund_1.validatePaymentChannelFund)(tx2);
        break;
      case "PermissionedDomainSet":
        (0, permissionedDomainSet_1.validatePermissionedDomainSet)(tx2);
        break;
      case "PermissionedDomainDelete":
        (0, permissionedDomainDelete_1.validatePermissionedDomainDelete)(tx2);
        break;
      case "SetRegularKey":
        (0, setRegularKey_1.validateSetRegularKey)(tx2);
        break;
      case "SignerListSet":
        (0, signerListSet_1.validateSignerListSet)(tx2);
        break;
      case "TicketCreate":
        (0, ticketCreate_1.validateTicketCreate)(tx2);
        break;
      case "TrustSet":
        (0, trustSet_1$1.validateTrustSet)(tx2);
        break;
      case "XChainAccountCreateCommit":
        (0, XChainAccountCreateCommit_1.validateXChainAccountCreateCommit)(tx2);
        break;
      case "XChainAddAccountCreateAttestation":
        (0, XChainAddAccountCreateAttestation_1.validateXChainAddAccountCreateAttestation)(tx2);
        break;
      case "XChainAddClaimAttestation":
        (0, XChainAddClaimAttestation_1.validateXChainAddClaimAttestation)(tx2);
        break;
      case "XChainClaim":
        (0, XChainClaim_1.validateXChainClaim)(tx2);
        break;
      case "XChainCommit":
        (0, XChainCommit_1.validateXChainCommit)(tx2);
        break;
      case "XChainCreateBridge":
        (0, XChainCreateBridge_1.validateXChainCreateBridge)(tx2);
        break;
      case "XChainCreateClaimID":
        (0, XChainCreateClaimID_1.validateXChainCreateClaimID)(tx2);
        break;
      case "XChainModifyBridge":
        (0, XChainModifyBridge_1$1.validateXChainModifyBridge)(tx2);
        break;
      default:
        throw new errors_1$7.ValidationError(`Invalid field TransactionType: ${tx2.TransactionType}`);
    }
  }
  exports.validate = validate2;
} });
var require_enableAmendment = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/enableAmendment.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EnableAmendmentFlags = void 0;
  var EnableAmendmentFlags;
  (function(EnableAmendmentFlags$1) {
    EnableAmendmentFlags$1[EnableAmendmentFlags$1["tfGotMajority"] = 65536] = "tfGotMajority";
    EnableAmendmentFlags$1[EnableAmendmentFlags$1["tfLostMajority"] = 131072] = "tfLostMajority";
  })(EnableAmendmentFlags || (exports.EnableAmendmentFlags = EnableAmendmentFlags = {}));
} });
var require_transactions = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/transactions/index.js"(exports) {
  var __createBinding$3 = Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
      enumerable: true,
      get: function() {
        return m[k];
      }
    };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  };
  var __exportStar$3 = function(m, exports$1) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding$3(exports$1, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XChainModifyBridgeFlags = exports.TrustSetFlags = exports.PaymentChannelClaimFlags = exports.PaymentFlags = exports.OfferCreateFlags = exports.validateNFTokenModify = exports.NFTokenMintFlags = exports.NFTokenCreateOfferFlags = exports.MPTokenIssuanceSetFlags = exports.MPTokenIssuanceCreateFlags = exports.MPTokenAuthorizeFlags = exports.EnableAmendmentFlags = exports.AMMWithdrawFlags = exports.AMMDepositFlags = exports.AMMClawbackFlags = exports.AccountSetTfFlags = exports.AccountSetAsfFlags = exports.validate = exports.isMPTAmount = void 0;
  var common_1$2 = require_common();
  Object.defineProperty(exports, "isMPTAmount", {
    enumerable: true,
    get: function() {
      return common_1$2.isMPTAmount;
    }
  });
  var transaction_1 = require_transaction();
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return transaction_1.validate;
    }
  });
  __exportStar$3(require_metadata(), exports);
  var accountSet_1 = require_accountSet();
  Object.defineProperty(exports, "AccountSetAsfFlags", {
    enumerable: true,
    get: function() {
      return accountSet_1.AccountSetAsfFlags;
    }
  });
  Object.defineProperty(exports, "AccountSetTfFlags", {
    enumerable: true,
    get: function() {
      return accountSet_1.AccountSetTfFlags;
    }
  });
  var AMMClawback_1 = require_AMMClawback();
  Object.defineProperty(exports, "AMMClawbackFlags", {
    enumerable: true,
    get: function() {
      return AMMClawback_1.AMMClawbackFlags;
    }
  });
  var AMMDeposit_1 = require_AMMDeposit();
  Object.defineProperty(exports, "AMMDepositFlags", {
    enumerable: true,
    get: function() {
      return AMMDeposit_1.AMMDepositFlags;
    }
  });
  var AMMWithdraw_1 = require_AMMWithdraw();
  Object.defineProperty(exports, "AMMWithdrawFlags", {
    enumerable: true,
    get: function() {
      return AMMWithdraw_1.AMMWithdrawFlags;
    }
  });
  var enableAmendment_1 = require_enableAmendment();
  Object.defineProperty(exports, "EnableAmendmentFlags", {
    enumerable: true,
    get: function() {
      return enableAmendment_1.EnableAmendmentFlags;
    }
  });
  var MPTokenAuthorize_1 = require_MPTokenAuthorize();
  Object.defineProperty(exports, "MPTokenAuthorizeFlags", {
    enumerable: true,
    get: function() {
      return MPTokenAuthorize_1.MPTokenAuthorizeFlags;
    }
  });
  var MPTokenIssuanceCreate_1 = require_MPTokenIssuanceCreate();
  Object.defineProperty(exports, "MPTokenIssuanceCreateFlags", {
    enumerable: true,
    get: function() {
      return MPTokenIssuanceCreate_1.MPTokenIssuanceCreateFlags;
    }
  });
  var MPTokenIssuanceSet_1 = require_MPTokenIssuanceSet();
  Object.defineProperty(exports, "MPTokenIssuanceSetFlags", {
    enumerable: true,
    get: function() {
      return MPTokenIssuanceSet_1.MPTokenIssuanceSetFlags;
    }
  });
  var NFTokenCreateOffer_1 = require_NFTokenCreateOffer();
  Object.defineProperty(exports, "NFTokenCreateOfferFlags", {
    enumerable: true,
    get: function() {
      return NFTokenCreateOffer_1.NFTokenCreateOfferFlags;
    }
  });
  var NFTokenMint_1 = require_NFTokenMint();
  Object.defineProperty(exports, "NFTokenMintFlags", {
    enumerable: true,
    get: function() {
      return NFTokenMint_1.NFTokenMintFlags;
    }
  });
  var NFTokenModify_1 = require_NFTokenModify();
  Object.defineProperty(exports, "validateNFTokenModify", {
    enumerable: true,
    get: function() {
      return NFTokenModify_1.validateNFTokenModify;
    }
  });
  var offerCreate_1 = require_offerCreate();
  Object.defineProperty(exports, "OfferCreateFlags", {
    enumerable: true,
    get: function() {
      return offerCreate_1.OfferCreateFlags;
    }
  });
  var payment_1 = require_payment();
  Object.defineProperty(exports, "PaymentFlags", {
    enumerable: true,
    get: function() {
      return payment_1.PaymentFlags;
    }
  });
  var paymentChannelClaim_1 = require_paymentChannelClaim();
  Object.defineProperty(exports, "PaymentChannelClaimFlags", {
    enumerable: true,
    get: function() {
      return paymentChannelClaim_1.PaymentChannelClaimFlags;
    }
  });
  var trustSet_1 = require_trustSet();
  Object.defineProperty(exports, "TrustSetFlags", {
    enumerable: true,
    get: function() {
      return trustSet_1.TrustSetFlags;
    }
  });
  var XChainModifyBridge_1 = require_XChainModifyBridge();
  Object.defineProperty(exports, "XChainModifyBridgeFlags", {
    enumerable: true,
    get: function() {
      return XChainModifyBridge_1.XChainModifyBridgeFlags;
    }
  });
} });
var require_rfc1751Words = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/rfc1751Words.json"(exports, module) {
  module.exports = [
    "A",
    "ABE",
    "ACE",
    "ACT",
    "AD",
    "ADA",
    "ADD",
    "AGO",
    "AID",
    "AIM",
    "AIR",
    "ALL",
    "ALP",
    "AM",
    "AMY",
    "AN",
    "ANA",
    "AND",
    "ANN",
    "ANT",
    "ANY",
    "APE",
    "APS",
    "APT",
    "ARC",
    "ARE",
    "ARK",
    "ARM",
    "ART",
    "AS",
    "ASH",
    "ASK",
    "AT",
    "ATE",
    "AUG",
    "AUK",
    "AVE",
    "AWE",
    "AWK",
    "AWL",
    "AWN",
    "AX",
    "AYE",
    "BAD",
    "BAG",
    "BAH",
    "BAM",
    "BAN",
    "BAR",
    "BAT",
    "BAY",
    "BE",
    "BED",
    "BEE",
    "BEG",
    "BEN",
    "BET",
    "BEY",
    "BIB",
    "BID",
    "BIG",
    "BIN",
    "BIT",
    "BOB",
    "BOG",
    "BON",
    "BOO",
    "BOP",
    "BOW",
    "BOY",
    "BUB",
    "BUD",
    "BUG",
    "BUM",
    "BUN",
    "BUS",
    "BUT",
    "BUY",
    "BY",
    "BYE",
    "CAB",
    "CAL",
    "CAM",
    "CAN",
    "CAP",
    "CAR",
    "CAT",
    "CAW",
    "COD",
    "COG",
    "COL",
    "CON",
    "COO",
    "COP",
    "COT",
    "COW",
    "COY",
    "CRY",
    "CUB",
    "CUE",
    "CUP",
    "CUR",
    "CUT",
    "DAB",
    "DAD",
    "DAM",
    "DAN",
    "DAR",
    "DAY",
    "DEE",
    "DEL",
    "DEN",
    "DES",
    "DEW",
    "DID",
    "DIE",
    "DIG",
    "DIN",
    "DIP",
    "DO",
    "DOE",
    "DOG",
    "DON",
    "DOT",
    "DOW",
    "DRY",
    "DUB",
    "DUD",
    "DUE",
    "DUG",
    "DUN",
    "EAR",
    "EAT",
    "ED",
    "EEL",
    "EGG",
    "EGO",
    "ELI",
    "ELK",
    "ELM",
    "ELY",
    "EM",
    "END",
    "EST",
    "ETC",
    "EVA",
    "EVE",
    "EWE",
    "EYE",
    "FAD",
    "FAN",
    "FAR",
    "FAT",
    "FAY",
    "FED",
    "FEE",
    "FEW",
    "FIB",
    "FIG",
    "FIN",
    "FIR",
    "FIT",
    "FLO",
    "FLY",
    "FOE",
    "FOG",
    "FOR",
    "FRY",
    "FUM",
    "FUN",
    "FUR",
    "GAB",
    "GAD",
    "GAG",
    "GAL",
    "GAM",
    "GAP",
    "GAS",
    "GAY",
    "GEE",
    "GEL",
    "GEM",
    "GET",
    "GIG",
    "GIL",
    "GIN",
    "GO",
    "GOT",
    "GUM",
    "GUN",
    "GUS",
    "GUT",
    "GUY",
    "GYM",
    "GYP",
    "HA",
    "HAD",
    "HAL",
    "HAM",
    "HAN",
    "HAP",
    "HAS",
    "HAT",
    "HAW",
    "HAY",
    "HE",
    "HEM",
    "HEN",
    "HER",
    "HEW",
    "HEY",
    "HI",
    "HID",
    "HIM",
    "HIP",
    "HIS",
    "HIT",
    "HO",
    "HOB",
    "HOC",
    "HOE",
    "HOG",
    "HOP",
    "HOT",
    "HOW",
    "HUB",
    "HUE",
    "HUG",
    "HUH",
    "HUM",
    "HUT",
    "I",
    "ICY",
    "IDA",
    "IF",
    "IKE",
    "ILL",
    "INK",
    "INN",
    "IO",
    "ION",
    "IQ",
    "IRA",
    "IRE",
    "IRK",
    "IS",
    "IT",
    "ITS",
    "IVY",
    "JAB",
    "JAG",
    "JAM",
    "JAN",
    "JAR",
    "JAW",
    "JAY",
    "JET",
    "JIG",
    "JIM",
    "JO",
    "JOB",
    "JOE",
    "JOG",
    "JOT",
    "JOY",
    "JUG",
    "JUT",
    "KAY",
    "KEG",
    "KEN",
    "KEY",
    "KID",
    "KIM",
    "KIN",
    "KIT",
    "LA",
    "LAB",
    "LAC",
    "LAD",
    "LAG",
    "LAM",
    "LAP",
    "LAW",
    "LAY",
    "LEA",
    "LED",
    "LEE",
    "LEG",
    "LEN",
    "LEO",
    "LET",
    "LEW",
    "LID",
    "LIE",
    "LIN",
    "LIP",
    "LIT",
    "LO",
    "LOB",
    "LOG",
    "LOP",
    "LOS",
    "LOT",
    "LOU",
    "LOW",
    "LOY",
    "LUG",
    "LYE",
    "MA",
    "MAC",
    "MAD",
    "MAE",
    "MAN",
    "MAO",
    "MAP",
    "MAT",
    "MAW",
    "MAY",
    "ME",
    "MEG",
    "MEL",
    "MEN",
    "MET",
    "MEW",
    "MID",
    "MIN",
    "MIT",
    "MOB",
    "MOD",
    "MOE",
    "MOO",
    "MOP",
    "MOS",
    "MOT",
    "MOW",
    "MUD",
    "MUG",
    "MUM",
    "MY",
    "NAB",
    "NAG",
    "NAN",
    "NAP",
    "NAT",
    "NAY",
    "NE",
    "NED",
    "NEE",
    "NET",
    "NEW",
    "NIB",
    "NIL",
    "NIP",
    "NIT",
    "NO",
    "NOB",
    "NOD",
    "NON",
    "NOR",
    "NOT",
    "NOV",
    "NOW",
    "NU",
    "NUN",
    "NUT",
    "O",
    "OAF",
    "OAK",
    "OAR",
    "OAT",
    "ODD",
    "ODE",
    "OF",
    "OFF",
    "OFT",
    "OH",
    "OIL",
    "OK",
    "OLD",
    "ON",
    "ONE",
    "OR",
    "ORB",
    "ORE",
    "ORR",
    "OS",
    "OTT",
    "OUR",
    "OUT",
    "OVA",
    "OW",
    "OWE",
    "OWL",
    "OWN",
    "OX",
    "PA",
    "PAD",
    "PAL",
    "PAM",
    "PAN",
    "PAP",
    "PAR",
    "PAT",
    "PAW",
    "PAY",
    "PEA",
    "PEG",
    "PEN",
    "PEP",
    "PER",
    "PET",
    "PEW",
    "PHI",
    "PI",
    "PIE",
    "PIN",
    "PIT",
    "PLY",
    "PO",
    "POD",
    "POE",
    "POP",
    "POT",
    "POW",
    "PRO",
    "PRY",
    "PUB",
    "PUG",
    "PUN",
    "PUP",
    "PUT",
    "QUO",
    "RAG",
    "RAM",
    "RAN",
    "RAP",
    "RAT",
    "RAW",
    "RAY",
    "REB",
    "RED",
    "REP",
    "RET",
    "RIB",
    "RID",
    "RIG",
    "RIM",
    "RIO",
    "RIP",
    "ROB",
    "ROD",
    "ROE",
    "RON",
    "ROT",
    "ROW",
    "ROY",
    "RUB",
    "RUE",
    "RUG",
    "RUM",
    "RUN",
    "RYE",
    "SAC",
    "SAD",
    "SAG",
    "SAL",
    "SAM",
    "SAN",
    "SAP",
    "SAT",
    "SAW",
    "SAY",
    "SEA",
    "SEC",
    "SEE",
    "SEN",
    "SET",
    "SEW",
    "SHE",
    "SHY",
    "SIN",
    "SIP",
    "SIR",
    "SIS",
    "SIT",
    "SKI",
    "SKY",
    "SLY",
    "SO",
    "SOB",
    "SOD",
    "SON",
    "SOP",
    "SOW",
    "SOY",
    "SPA",
    "SPY",
    "SUB",
    "SUD",
    "SUE",
    "SUM",
    "SUN",
    "SUP",
    "TAB",
    "TAD",
    "TAG",
    "TAN",
    "TAP",
    "TAR",
    "TEA",
    "TED",
    "TEE",
    "TEN",
    "THE",
    "THY",
    "TIC",
    "TIE",
    "TIM",
    "TIN",
    "TIP",
    "TO",
    "TOE",
    "TOG",
    "TOM",
    "TON",
    "TOO",
    "TOP",
    "TOW",
    "TOY",
    "TRY",
    "TUB",
    "TUG",
    "TUM",
    "TUN",
    "TWO",
    "UN",
    "UP",
    "US",
    "USE",
    "VAN",
    "VAT",
    "VET",
    "VIE",
    "WAD",
    "WAG",
    "WAR",
    "WAS",
    "WAY",
    "WE",
    "WEB",
    "WED",
    "WEE",
    "WET",
    "WHO",
    "WHY",
    "WIN",
    "WIT",
    "WOK",
    "WON",
    "WOO",
    "WOW",
    "WRY",
    "WU",
    "YAM",
    "YAP",
    "YAW",
    "YE",
    "YEA",
    "YES",
    "YET",
    "YOU",
    "ABED",
    "ABEL",
    "ABET",
    "ABLE",
    "ABUT",
    "ACHE",
    "ACID",
    "ACME",
    "ACRE",
    "ACTA",
    "ACTS",
    "ADAM",
    "ADDS",
    "ADEN",
    "AFAR",
    "AFRO",
    "AGEE",
    "AHEM",
    "AHOY",
    "AIDA",
    "AIDE",
    "AIDS",
    "AIRY",
    "AJAR",
    "AKIN",
    "ALAN",
    "ALEC",
    "ALGA",
    "ALIA",
    "ALLY",
    "ALMA",
    "ALOE",
    "ALSO",
    "ALTO",
    "ALUM",
    "ALVA",
    "AMEN",
    "AMES",
    "AMID",
    "AMMO",
    "AMOK",
    "AMOS",
    "AMRA",
    "ANDY",
    "ANEW",
    "ANNA",
    "ANNE",
    "ANTE",
    "ANTI",
    "AQUA",
    "ARAB",
    "ARCH",
    "AREA",
    "ARGO",
    "ARID",
    "ARMY",
    "ARTS",
    "ARTY",
    "ASIA",
    "ASKS",
    "ATOM",
    "AUNT",
    "AURA",
    "AUTO",
    "AVER",
    "AVID",
    "AVIS",
    "AVON",
    "AVOW",
    "AWAY",
    "AWRY",
    "BABE",
    "BABY",
    "BACH",
    "BACK",
    "BADE",
    "BAIL",
    "BAIT",
    "BAKE",
    "BALD",
    "BALE",
    "BALI",
    "BALK",
    "BALL",
    "BALM",
    "BAND",
    "BANE",
    "BANG",
    "BANK",
    "BARB",
    "BARD",
    "BARE",
    "BARK",
    "BARN",
    "BARR",
    "BASE",
    "BASH",
    "BASK",
    "BASS",
    "BATE",
    "BATH",
    "BAWD",
    "BAWL",
    "BEAD",
    "BEAK",
    "BEAM",
    "BEAN",
    "BEAR",
    "BEAT",
    "BEAU",
    "BECK",
    "BEEF",
    "BEEN",
    "BEER",
    "BEET",
    "BELA",
    "BELL",
    "BELT",
    "BEND",
    "BENT",
    "BERG",
    "BERN",
    "BERT",
    "BESS",
    "BEST",
    "BETA",
    "BETH",
    "BHOY",
    "BIAS",
    "BIDE",
    "BIEN",
    "BILE",
    "BILK",
    "BILL",
    "BIND",
    "BING",
    "BIRD",
    "BITE",
    "BITS",
    "BLAB",
    "BLAT",
    "BLED",
    "BLEW",
    "BLOB",
    "BLOC",
    "BLOT",
    "BLOW",
    "BLUE",
    "BLUM",
    "BLUR",
    "BOAR",
    "BOAT",
    "BOCA",
    "BOCK",
    "BODE",
    "BODY",
    "BOGY",
    "BOHR",
    "BOIL",
    "BOLD",
    "BOLO",
    "BOLT",
    "BOMB",
    "BONA",
    "BOND",
    "BONE",
    "BONG",
    "BONN",
    "BONY",
    "BOOK",
    "BOOM",
    "BOON",
    "BOOT",
    "BORE",
    "BORG",
    "BORN",
    "BOSE",
    "BOSS",
    "BOTH",
    "BOUT",
    "BOWL",
    "BOYD",
    "BRAD",
    "BRAE",
    "BRAG",
    "BRAN",
    "BRAY",
    "BRED",
    "BREW",
    "BRIG",
    "BRIM",
    "BROW",
    "BUCK",
    "BUDD",
    "BUFF",
    "BULB",
    "BULK",
    "BULL",
    "BUNK",
    "BUNT",
    "BUOY",
    "BURG",
    "BURL",
    "BURN",
    "BURR",
    "BURT",
    "BURY",
    "BUSH",
    "BUSS",
    "BUST",
    "BUSY",
    "BYTE",
    "CADY",
    "CAFE",
    "CAGE",
    "CAIN",
    "CAKE",
    "CALF",
    "CALL",
    "CALM",
    "CAME",
    "CANE",
    "CANT",
    "CARD",
    "CARE",
    "CARL",
    "CARR",
    "CART",
    "CASE",
    "CASH",
    "CASK",
    "CAST",
    "CAVE",
    "CEIL",
    "CELL",
    "CENT",
    "CERN",
    "CHAD",
    "CHAR",
    "CHAT",
    "CHAW",
    "CHEF",
    "CHEN",
    "CHEW",
    "CHIC",
    "CHIN",
    "CHOU",
    "CHOW",
    "CHUB",
    "CHUG",
    "CHUM",
    "CITE",
    "CITY",
    "CLAD",
    "CLAM",
    "CLAN",
    "CLAW",
    "CLAY",
    "CLOD",
    "CLOG",
    "CLOT",
    "CLUB",
    "CLUE",
    "COAL",
    "COAT",
    "COCA",
    "COCK",
    "COCO",
    "CODA",
    "CODE",
    "CODY",
    "COED",
    "COIL",
    "COIN",
    "COKE",
    "COLA",
    "COLD",
    "COLT",
    "COMA",
    "COMB",
    "COME",
    "COOK",
    "COOL",
    "COON",
    "COOT",
    "CORD",
    "CORE",
    "CORK",
    "CORN",
    "COST",
    "COVE",
    "COWL",
    "CRAB",
    "CRAG",
    "CRAM",
    "CRAY",
    "CREW",
    "CRIB",
    "CROW",
    "CRUD",
    "CUBA",
    "CUBE",
    "CUFF",
    "CULL",
    "CULT",
    "CUNY",
    "CURB",
    "CURD",
    "CURE",
    "CURL",
    "CURT",
    "CUTS",
    "DADE",
    "DALE",
    "DAME",
    "DANA",
    "DANE",
    "DANG",
    "DANK",
    "DARE",
    "DARK",
    "DARN",
    "DART",
    "DASH",
    "DATA",
    "DATE",
    "DAVE",
    "DAVY",
    "DAWN",
    "DAYS",
    "DEAD",
    "DEAF",
    "DEAL",
    "DEAN",
    "DEAR",
    "DEBT",
    "DECK",
    "DEED",
    "DEEM",
    "DEER",
    "DEFT",
    "DEFY",
    "DELL",
    "DENT",
    "DENY",
    "DESK",
    "DIAL",
    "DICE",
    "DIED",
    "DIET",
    "DIME",
    "DINE",
    "DING",
    "DINT",
    "DIRE",
    "DIRT",
    "DISC",
    "DISH",
    "DISK",
    "DIVE",
    "DOCK",
    "DOES",
    "DOLE",
    "DOLL",
    "DOLT",
    "DOME",
    "DONE",
    "DOOM",
    "DOOR",
    "DORA",
    "DOSE",
    "DOTE",
    "DOUG",
    "DOUR",
    "DOVE",
    "DOWN",
    "DRAB",
    "DRAG",
    "DRAM",
    "DRAW",
    "DREW",
    "DRUB",
    "DRUG",
    "DRUM",
    "DUAL",
    "DUCK",
    "DUCT",
    "DUEL",
    "DUET",
    "DUKE",
    "DULL",
    "DUMB",
    "DUNE",
    "DUNK",
    "DUSK",
    "DUST",
    "DUTY",
    "EACH",
    "EARL",
    "EARN",
    "EASE",
    "EAST",
    "EASY",
    "EBEN",
    "ECHO",
    "EDDY",
    "EDEN",
    "EDGE",
    "EDGY",
    "EDIT",
    "EDNA",
    "EGAN",
    "ELAN",
    "ELBA",
    "ELLA",
    "ELSE",
    "EMIL",
    "EMIT",
    "EMMA",
    "ENDS",
    "ERIC",
    "EROS",
    "EVEN",
    "EVER",
    "EVIL",
    "EYED",
    "FACE",
    "FACT",
    "FADE",
    "FAIL",
    "FAIN",
    "FAIR",
    "FAKE",
    "FALL",
    "FAME",
    "FANG",
    "FARM",
    "FAST",
    "FATE",
    "FAWN",
    "FEAR",
    "FEAT",
    "FEED",
    "FEEL",
    "FEET",
    "FELL",
    "FELT",
    "FEND",
    "FERN",
    "FEST",
    "FEUD",
    "FIEF",
    "FIGS",
    "FILE",
    "FILL",
    "FILM",
    "FIND",
    "FINE",
    "FINK",
    "FIRE",
    "FIRM",
    "FISH",
    "FISK",
    "FIST",
    "FITS",
    "FIVE",
    "FLAG",
    "FLAK",
    "FLAM",
    "FLAT",
    "FLAW",
    "FLEA",
    "FLED",
    "FLEW",
    "FLIT",
    "FLOC",
    "FLOG",
    "FLOW",
    "FLUB",
    "FLUE",
    "FOAL",
    "FOAM",
    "FOGY",
    "FOIL",
    "FOLD",
    "FOLK",
    "FOND",
    "FONT",
    "FOOD",
    "FOOL",
    "FOOT",
    "FORD",
    "FORE",
    "FORK",
    "FORM",
    "FORT",
    "FOSS",
    "FOUL",
    "FOUR",
    "FOWL",
    "FRAU",
    "FRAY",
    "FRED",
    "FREE",
    "FRET",
    "FREY",
    "FROG",
    "FROM",
    "FUEL",
    "FULL",
    "FUME",
    "FUND",
    "FUNK",
    "FURY",
    "FUSE",
    "FUSS",
    "GAFF",
    "GAGE",
    "GAIL",
    "GAIN",
    "GAIT",
    "GALA",
    "GALE",
    "GALL",
    "GALT",
    "GAME",
    "GANG",
    "GARB",
    "GARY",
    "GASH",
    "GATE",
    "GAUL",
    "GAUR",
    "GAVE",
    "GAWK",
    "GEAR",
    "GELD",
    "GENE",
    "GENT",
    "GERM",
    "GETS",
    "GIBE",
    "GIFT",
    "GILD",
    "GILL",
    "GILT",
    "GINA",
    "GIRD",
    "GIRL",
    "GIST",
    "GIVE",
    "GLAD",
    "GLEE",
    "GLEN",
    "GLIB",
    "GLOB",
    "GLOM",
    "GLOW",
    "GLUE",
    "GLUM",
    "GLUT",
    "GOAD",
    "GOAL",
    "GOAT",
    "GOER",
    "GOES",
    "GOLD",
    "GOLF",
    "GONE",
    "GONG",
    "GOOD",
    "GOOF",
    "GORE",
    "GORY",
    "GOSH",
    "GOUT",
    "GOWN",
    "GRAB",
    "GRAD",
    "GRAY",
    "GREG",
    "GREW",
    "GREY",
    "GRID",
    "GRIM",
    "GRIN",
    "GRIT",
    "GROW",
    "GRUB",
    "GULF",
    "GULL",
    "GUNK",
    "GURU",
    "GUSH",
    "GUST",
    "GWEN",
    "GWYN",
    "HAAG",
    "HAAS",
    "HACK",
    "HAIL",
    "HAIR",
    "HALE",
    "HALF",
    "HALL",
    "HALO",
    "HALT",
    "HAND",
    "HANG",
    "HANK",
    "HANS",
    "HARD",
    "HARK",
    "HARM",
    "HART",
    "HASH",
    "HAST",
    "HATE",
    "HATH",
    "HAUL",
    "HAVE",
    "HAWK",
    "HAYS",
    "HEAD",
    "HEAL",
    "HEAR",
    "HEAT",
    "HEBE",
    "HECK",
    "HEED",
    "HEEL",
    "HEFT",
    "HELD",
    "HELL",
    "HELM",
    "HERB",
    "HERD",
    "HERE",
    "HERO",
    "HERS",
    "HESS",
    "HEWN",
    "HICK",
    "HIDE",
    "HIGH",
    "HIKE",
    "HILL",
    "HILT",
    "HIND",
    "HINT",
    "HIRE",
    "HISS",
    "HIVE",
    "HOBO",
    "HOCK",
    "HOFF",
    "HOLD",
    "HOLE",
    "HOLM",
    "HOLT",
    "HOME",
    "HONE",
    "HONK",
    "HOOD",
    "HOOF",
    "HOOK",
    "HOOT",
    "HORN",
    "HOSE",
    "HOST",
    "HOUR",
    "HOVE",
    "HOWE",
    "HOWL",
    "HOYT",
    "HUCK",
    "HUED",
    "HUFF",
    "HUGE",
    "HUGH",
    "HUGO",
    "HULK",
    "HULL",
    "HUNK",
    "HUNT",
    "HURD",
    "HURL",
    "HURT",
    "HUSH",
    "HYDE",
    "HYMN",
    "IBIS",
    "ICON",
    "IDEA",
    "IDLE",
    "IFFY",
    "INCA",
    "INCH",
    "INTO",
    "IONS",
    "IOTA",
    "IOWA",
    "IRIS",
    "IRMA",
    "IRON",
    "ISLE",
    "ITCH",
    "ITEM",
    "IVAN",
    "JACK",
    "JADE",
    "JAIL",
    "JAKE",
    "JANE",
    "JAVA",
    "JEAN",
    "JEFF",
    "JERK",
    "JESS",
    "JEST",
    "JIBE",
    "JILL",
    "JILT",
    "JIVE",
    "JOAN",
    "JOBS",
    "JOCK",
    "JOEL",
    "JOEY",
    "JOHN",
    "JOIN",
    "JOKE",
    "JOLT",
    "JOVE",
    "JUDD",
    "JUDE",
    "JUDO",
    "JUDY",
    "JUJU",
    "JUKE",
    "JULY",
    "JUNE",
    "JUNK",
    "JUNO",
    "JURY",
    "JUST",
    "JUTE",
    "KAHN",
    "KALE",
    "KANE",
    "KANT",
    "KARL",
    "KATE",
    "KEEL",
    "KEEN",
    "KENO",
    "KENT",
    "KERN",
    "KERR",
    "KEYS",
    "KICK",
    "KILL",
    "KIND",
    "KING",
    "KIRK",
    "KISS",
    "KITE",
    "KLAN",
    "KNEE",
    "KNEW",
    "KNIT",
    "KNOB",
    "KNOT",
    "KNOW",
    "KOCH",
    "KONG",
    "KUDO",
    "KURD",
    "KURT",
    "KYLE",
    "LACE",
    "LACK",
    "LACY",
    "LADY",
    "LAID",
    "LAIN",
    "LAIR",
    "LAKE",
    "LAMB",
    "LAME",
    "LAND",
    "LANE",
    "LANG",
    "LARD",
    "LARK",
    "LASS",
    "LAST",
    "LATE",
    "LAUD",
    "LAVA",
    "LAWN",
    "LAWS",
    "LAYS",
    "LEAD",
    "LEAF",
    "LEAK",
    "LEAN",
    "LEAR",
    "LEEK",
    "LEER",
    "LEFT",
    "LEND",
    "LENS",
    "LENT",
    "LEON",
    "LESK",
    "LESS",
    "LEST",
    "LETS",
    "LIAR",
    "LICE",
    "LICK",
    "LIED",
    "LIEN",
    "LIES",
    "LIEU",
    "LIFE",
    "LIFT",
    "LIKE",
    "LILA",
    "LILT",
    "LILY",
    "LIMA",
    "LIMB",
    "LIME",
    "LIND",
    "LINE",
    "LINK",
    "LINT",
    "LION",
    "LISA",
    "LIST",
    "LIVE",
    "LOAD",
    "LOAF",
    "LOAM",
    "LOAN",
    "LOCK",
    "LOFT",
    "LOGE",
    "LOIS",
    "LOLA",
    "LONE",
    "LONG",
    "LOOK",
    "LOON",
    "LOOT",
    "LORD",
    "LORE",
    "LOSE",
    "LOSS",
    "LOST",
    "LOUD",
    "LOVE",
    "LOWE",
    "LUCK",
    "LUCY",
    "LUGE",
    "LUKE",
    "LULU",
    "LUND",
    "LUNG",
    "LURA",
    "LURE",
    "LURK",
    "LUSH",
    "LUST",
    "LYLE",
    "LYNN",
    "LYON",
    "LYRA",
    "MACE",
    "MADE",
    "MAGI",
    "MAID",
    "MAIL",
    "MAIN",
    "MAKE",
    "MALE",
    "MALI",
    "MALL",
    "MALT",
    "MANA",
    "MANN",
    "MANY",
    "MARC",
    "MARE",
    "MARK",
    "MARS",
    "MART",
    "MARY",
    "MASH",
    "MASK",
    "MASS",
    "MAST",
    "MATE",
    "MATH",
    "MAUL",
    "MAYO",
    "MEAD",
    "MEAL",
    "MEAN",
    "MEAT",
    "MEEK",
    "MEET",
    "MELD",
    "MELT",
    "MEMO",
    "MEND",
    "MENU",
    "MERT",
    "MESH",
    "MESS",
    "MICE",
    "MIKE",
    "MILD",
    "MILE",
    "MILK",
    "MILL",
    "MILT",
    "MIMI",
    "MIND",
    "MINE",
    "MINI",
    "MINK",
    "MINT",
    "MIRE",
    "MISS",
    "MIST",
    "MITE",
    "MITT",
    "MOAN",
    "MOAT",
    "MOCK",
    "MODE",
    "MOLD",
    "MOLE",
    "MOLL",
    "MOLT",
    "MONA",
    "MONK",
    "MONT",
    "MOOD",
    "MOON",
    "MOOR",
    "MOOT",
    "MORE",
    "MORN",
    "MORT",
    "MOSS",
    "MOST",
    "MOTH",
    "MOVE",
    "MUCH",
    "MUCK",
    "MUDD",
    "MUFF",
    "MULE",
    "MULL",
    "MURK",
    "MUSH",
    "MUST",
    "MUTE",
    "MUTT",
    "MYRA",
    "MYTH",
    "NAGY",
    "NAIL",
    "NAIR",
    "NAME",
    "NARY",
    "NASH",
    "NAVE",
    "NAVY",
    "NEAL",
    "NEAR",
    "NEAT",
    "NECK",
    "NEED",
    "NEIL",
    "NELL",
    "NEON",
    "NERO",
    "NESS",
    "NEST",
    "NEWS",
    "NEWT",
    "NIBS",
    "NICE",
    "NICK",
    "NILE",
    "NINA",
    "NINE",
    "NOAH",
    "NODE",
    "NOEL",
    "NOLL",
    "NONE",
    "NOOK",
    "NOON",
    "NORM",
    "NOSE",
    "NOTE",
    "NOUN",
    "NOVA",
    "NUDE",
    "NULL",
    "NUMB",
    "OATH",
    "OBEY",
    "OBOE",
    "ODIN",
    "OHIO",
    "OILY",
    "OINT",
    "OKAY",
    "OLAF",
    "OLDY",
    "OLGA",
    "OLIN",
    "OMAN",
    "OMEN",
    "OMIT",
    "ONCE",
    "ONES",
    "ONLY",
    "ONTO",
    "ONUS",
    "ORAL",
    "ORGY",
    "OSLO",
    "OTIS",
    "OTTO",
    "OUCH",
    "OUST",
    "OUTS",
    "OVAL",
    "OVEN",
    "OVER",
    "OWLY",
    "OWNS",
    "QUAD",
    "QUIT",
    "QUOD",
    "RACE",
    "RACK",
    "RACY",
    "RAFT",
    "RAGE",
    "RAID",
    "RAIL",
    "RAIN",
    "RAKE",
    "RANK",
    "RANT",
    "RARE",
    "RASH",
    "RATE",
    "RAVE",
    "RAYS",
    "READ",
    "REAL",
    "REAM",
    "REAR",
    "RECK",
    "REED",
    "REEF",
    "REEK",
    "REEL",
    "REID",
    "REIN",
    "RENA",
    "REND",
    "RENT",
    "REST",
    "RICE",
    "RICH",
    "RICK",
    "RIDE",
    "RIFT",
    "RILL",
    "RIME",
    "RING",
    "RINK",
    "RISE",
    "RISK",
    "RITE",
    "ROAD",
    "ROAM",
    "ROAR",
    "ROBE",
    "ROCK",
    "RODE",
    "ROIL",
    "ROLL",
    "ROME",
    "ROOD",
    "ROOF",
    "ROOK",
    "ROOM",
    "ROOT",
    "ROSA",
    "ROSE",
    "ROSS",
    "ROSY",
    "ROTH",
    "ROUT",
    "ROVE",
    "ROWE",
    "ROWS",
    "RUBE",
    "RUBY",
    "RUDE",
    "RUDY",
    "RUIN",
    "RULE",
    "RUNG",
    "RUNS",
    "RUNT",
    "RUSE",
    "RUSH",
    "RUSK",
    "RUSS",
    "RUST",
    "RUTH",
    "SACK",
    "SAFE",
    "SAGE",
    "SAID",
    "SAIL",
    "SALE",
    "SALK",
    "SALT",
    "SAME",
    "SAND",
    "SANE",
    "SANG",
    "SANK",
    "SARA",
    "SAUL",
    "SAVE",
    "SAYS",
    "SCAN",
    "SCAR",
    "SCAT",
    "SCOT",
    "SEAL",
    "SEAM",
    "SEAR",
    "SEAT",
    "SEED",
    "SEEK",
    "SEEM",
    "SEEN",
    "SEES",
    "SELF",
    "SELL",
    "SEND",
    "SENT",
    "SETS",
    "SEWN",
    "SHAG",
    "SHAM",
    "SHAW",
    "SHAY",
    "SHED",
    "SHIM",
    "SHIN",
    "SHOD",
    "SHOE",
    "SHOT",
    "SHOW",
    "SHUN",
    "SHUT",
    "SICK",
    "SIDE",
    "SIFT",
    "SIGH",
    "SIGN",
    "SILK",
    "SILL",
    "SILO",
    "SILT",
    "SINE",
    "SING",
    "SINK",
    "SIRE",
    "SITE",
    "SITS",
    "SITU",
    "SKAT",
    "SKEW",
    "SKID",
    "SKIM",
    "SKIN",
    "SKIT",
    "SLAB",
    "SLAM",
    "SLAT",
    "SLAY",
    "SLED",
    "SLEW",
    "SLID",
    "SLIM",
    "SLIT",
    "SLOB",
    "SLOG",
    "SLOT",
    "SLOW",
    "SLUG",
    "SLUM",
    "SLUR",
    "SMOG",
    "SMUG",
    "SNAG",
    "SNOB",
    "SNOW",
    "SNUB",
    "SNUG",
    "SOAK",
    "SOAR",
    "SOCK",
    "SODA",
    "SOFA",
    "SOFT",
    "SOIL",
    "SOLD",
    "SOME",
    "SONG",
    "SOON",
    "SOOT",
    "SORE",
    "SORT",
    "SOUL",
    "SOUR",
    "SOWN",
    "STAB",
    "STAG",
    "STAN",
    "STAR",
    "STAY",
    "STEM",
    "STEW",
    "STIR",
    "STOW",
    "STUB",
    "STUN",
    "SUCH",
    "SUDS",
    "SUIT",
    "SULK",
    "SUMS",
    "SUNG",
    "SUNK",
    "SURE",
    "SURF",
    "SWAB",
    "SWAG",
    "SWAM",
    "SWAN",
    "SWAT",
    "SWAY",
    "SWIM",
    "SWUM",
    "TACK",
    "TACT",
    "TAIL",
    "TAKE",
    "TALE",
    "TALK",
    "TALL",
    "TANK",
    "TASK",
    "TATE",
    "TAUT",
    "TEAL",
    "TEAM",
    "TEAR",
    "TECH",
    "TEEM",
    "TEEN",
    "TEET",
    "TELL",
    "TEND",
    "TENT",
    "TERM",
    "TERN",
    "TESS",
    "TEST",
    "THAN",
    "THAT",
    "THEE",
    "THEM",
    "THEN",
    "THEY",
    "THIN",
    "THIS",
    "THUD",
    "THUG",
    "TICK",
    "TIDE",
    "TIDY",
    "TIED",
    "TIER",
    "TILE",
    "TILL",
    "TILT",
    "TIME",
    "TINA",
    "TINE",
    "TINT",
    "TINY",
    "TIRE",
    "TOAD",
    "TOGO",
    "TOIL",
    "TOLD",
    "TOLL",
    "TONE",
    "TONG",
    "TONY",
    "TOOK",
    "TOOL",
    "TOOT",
    "TORE",
    "TORN",
    "TOTE",
    "TOUR",
    "TOUT",
    "TOWN",
    "TRAG",
    "TRAM",
    "TRAY",
    "TREE",
    "TREK",
    "TRIG",
    "TRIM",
    "TRIO",
    "TROD",
    "TROT",
    "TROY",
    "TRUE",
    "TUBA",
    "TUBE",
    "TUCK",
    "TUFT",
    "TUNA",
    "TUNE",
    "TUNG",
    "TURF",
    "TURN",
    "TUSK",
    "TWIG",
    "TWIN",
    "TWIT",
    "ULAN",
    "UNIT",
    "URGE",
    "USED",
    "USER",
    "USES",
    "UTAH",
    "VAIL",
    "VAIN",
    "VALE",
    "VARY",
    "VASE",
    "VAST",
    "VEAL",
    "VEDA",
    "VEIL",
    "VEIN",
    "VEND",
    "VENT",
    "VERB",
    "VERY",
    "VETO",
    "VICE",
    "VIEW",
    "VINE",
    "VISE",
    "VOID",
    "VOLT",
    "VOTE",
    "WACK",
    "WADE",
    "WAGE",
    "WAIL",
    "WAIT",
    "WAKE",
    "WALE",
    "WALK",
    "WALL",
    "WALT",
    "WAND",
    "WANE",
    "WANG",
    "WANT",
    "WARD",
    "WARM",
    "WARN",
    "WART",
    "WASH",
    "WAST",
    "WATS",
    "WATT",
    "WAVE",
    "WAVY",
    "WAYS",
    "WEAK",
    "WEAL",
    "WEAN",
    "WEAR",
    "WEED",
    "WEEK",
    "WEIR",
    "WELD",
    "WELL",
    "WELT",
    "WENT",
    "WERE",
    "WERT",
    "WEST",
    "WHAM",
    "WHAT",
    "WHEE",
    "WHEN",
    "WHET",
    "WHOA",
    "WHOM",
    "WICK",
    "WIFE",
    "WILD",
    "WILL",
    "WIND",
    "WINE",
    "WING",
    "WINK",
    "WINO",
    "WIRE",
    "WISE",
    "WISH",
    "WITH",
    "WOLF",
    "WONT",
    "WOOD",
    "WOOL",
    "WORD",
    "WORE",
    "WORK",
    "WORM",
    "WORN",
    "WOVE",
    "WRIT",
    "WYNN",
    "YALE",
    "YANG",
    "YANK",
    "YARD",
    "YARN",
    "YAWL",
    "YAWN",
    "YEAH",
    "YEAR",
    "YELL",
    "YOGA",
    "YOKE"
  ];
} });
var require_rfc1751 = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/rfc1751.js"(exports) {
  var __importDefault$6 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.keyToRFC1751Mnemonic = exports.rfc1751MnemonicToKey = void 0;
  const utils_1$8 = require_browser$4();
  const rfc1751Words_json_1 = __importDefault$6(require_rfc1751Words());
  const rfc1751WordList = rfc1751Words_json_1.default;
  const BINARY = [
    "0000",
    "0001",
    "0010",
    "0011",
    "0100",
    "0101",
    "0110",
    "0111",
    "1000",
    "1001",
    "1010",
    "1011",
    "1100",
    "1101",
    "1110",
    "1111"
  ];
  function keyToBinary(key) {
    let res = "";
    for (const num$1 of key) res += BINARY[num$1 >> 4] + BINARY[num$1 & 15];
    return res;
  }
  function extract(key, start, length) {
    const subKey = key.substring(start, start + length);
    let acc = 0;
    for (let index = 0; index < subKey.length; index++) acc = acc * 2 + subKey.charCodeAt(index) - 48;
    return acc;
  }
  function keyToRFC1751Mnemonic(hex_key) {
    const buf = (0, utils_1$8.hexToBytes)(hex_key.replace(/\s+/gu, ""));
    let key = bufferToArray(swap128(buf));
    const padding$1 = [];
    for (let index = 0; index < (8 - key.length % 8) % 8; index++) padding$1.push(0);
    key = padding$1.concat(key);
    const english = [];
    for (let index = 0; index < key.length; index += 8) {
      const subKey = key.slice(index, index + 8);
      let skbin = keyToBinary(subKey);
      let parity = 0;
      for (let j = 0; j < 64; j += 2) parity += extract(skbin, j, 2);
      subKey.push(parity << 6 & 255);
      skbin = keyToBinary(subKey);
      for (let j = 0; j < 64; j += 11) english.push(rfc1751WordList[extract(skbin, j, 11)]);
    }
    return english.join(" ");
  }
  exports.keyToRFC1751Mnemonic = keyToRFC1751Mnemonic;
  function rfc1751MnemonicToKey(english) {
    const words = english.split(" ");
    let key = [];
    for (let index = 0; index < words.length; index += 6) {
      const { subKey, word } = getSubKey(words, index);
      const skbin = keyToBinary(subKey);
      let parity = 0;
      for (let j = 0; j < 64; j += 2) parity += extract(skbin, j, 2);
      const cs0 = extract(skbin, 64, 2);
      const cs1 = parity & 3;
      if (cs0 !== cs1) throw new Error(`Parity error at ${word}`);
      key = key.concat(subKey.slice(0, 8));
    }
    const bufferKey = swap128(Uint8Array.from(key));
    return bufferKey;
  }
  exports.rfc1751MnemonicToKey = rfc1751MnemonicToKey;
  function getSubKey(words, index) {
    const sublist = words.slice(index, index + 6);
    let bits = 0;
    const ch = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    let word = "";
    for (word of sublist) {
      const idx = rfc1751WordList.indexOf(word.toUpperCase());
      if (idx === -1) throw new TypeError(`Expected an RFC1751 word, but received '${word}'. For the full list of words in the RFC1751 encoding see https://datatracker.ietf.org/doc/html/rfc1751`);
      const shift = (8 - (bits + 11) % 8) % 8;
      const y = idx << shift;
      const cl = y >> 16;
      const cc = y >> 8 & 255;
      const cr = y & 255;
      const t = Math.floor(bits / 8);
      if (shift > 5) {
        ch[t] |= cl;
        ch[t + 1] |= cc;
        ch[t + 2] |= cr;
      } else if (shift > -3) {
        ch[t] |= cc;
        ch[t + 1] |= cr;
      } else ch[t] |= cr;
      bits += 11;
    }
    const subKey = ch.slice();
    return {
      subKey,
      word
    };
  }
  function bufferToArray(buf) {
    return Array.prototype.slice.call(buf);
  }
  function swap(arr, n, m) {
    const i = arr[n];
    arr[n] = arr[m];
    arr[m] = i;
  }
  function swap64(arr) {
    const len = arr.length;
    for (let i = 0; i < len; i += 8) {
      swap(arr, i, i + 7);
      swap(arr, i + 1, i + 6);
      swap(arr, i + 2, i + 5);
      swap(arr, i + 3, i + 4);
    }
    return arr;
  }
  function swap128(arr) {
    const reversedBytes = swap64(arr);
    return (0, utils_1$8.concat)([reversedBytes.slice(8, 16), reversedBytes.slice(0, 8)]);
  }
} });
var require_utils$1$1 = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/utils.js"(exports) {
  var __importDefault$5 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getDecodedTransaction = exports.addressToBigNumber = exports.NUM_BITS_IN_HEX = exports.compareSigners = void 0;
  const utils_1$7 = require_browser$4();
  const bignumber_js_1$2 = __importDefault$5(require_bignumber());
  const ripple_address_codec_1$2 = require_dist$3();
  const ripple_binary_codec_1$3 = require_dist$1$1();
  function compareSigners(left, right) {
    return addressToBigNumber(left.Account).comparedTo(addressToBigNumber(right.Account));
  }
  exports.compareSigners = compareSigners;
  exports.NUM_BITS_IN_HEX = 16;
  function addressToBigNumber(address) {
    const hex = (0, utils_1$7.bytesToHex)((0, ripple_address_codec_1$2.decodeAccountID)(address));
    return new bignumber_js_1$2.default(hex, exports.NUM_BITS_IN_HEX);
  }
  exports.addressToBigNumber = addressToBigNumber;
  function getDecodedTransaction(txOrBlob) {
    if (typeof txOrBlob === "object") return (0, ripple_binary_codec_1$3.decode)((0, ripple_binary_codec_1$3.encode)(txOrBlob));
    return (0, ripple_binary_codec_1$3.decode)(txOrBlob);
  }
  exports.getDecodedTransaction = getDecodedTransaction;
} });
var require_signer = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/signer.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.multisign = exports.verifySignature = void 0;
  const ripple_binary_codec_1$2 = require_dist$1$1();
  const ripple_keypairs_1$2 = require_dist$2();
  const errors_1$6 = require_errors();
  const transactions_1$2 = require_transactions();
  const utils_1$6 = require_utils$1$1();
  function multisign(transactions) {
    if (transactions.length === 0) throw new errors_1$6.ValidationError("There were 0 transactions to multisign");
    const decodedTransactions = transactions.map((txOrBlob) => {
      return (0, utils_1$6.getDecodedTransaction)(txOrBlob);
    });
    decodedTransactions.forEach((tx2) => {
      (0, transactions_1$2.validate)(tx2);
      if (tx2.Signers == null || tx2.Signers.length === 0) throw new errors_1$6.ValidationError("For multisigning all transactions must include a Signers field containing an array of signatures. You may have forgotten to pass the 'forMultisign' parameter when signing.");
      if (tx2.SigningPubKey !== "") throw new errors_1$6.ValidationError("SigningPubKey must be an empty string for all transactions when multisigning.");
    });
    validateTransactionEquivalence(decodedTransactions);
    return (0, ripple_binary_codec_1$2.encode)(getTransactionWithAllSigners(decodedTransactions));
  }
  exports.multisign = multisign;
  function verifySignature(tx2, publicKey) {
    const decodedTx = (0, utils_1$6.getDecodedTransaction)(tx2);
    let key = publicKey;
    if (typeof decodedTx.TxnSignature !== "string" || !decodedTx.TxnSignature) throw new Error("Transaction is missing a signature, TxnSignature");
    if (!key) {
      if (typeof decodedTx.SigningPubKey !== "string" || !decodedTx.SigningPubKey) throw new Error("Transaction is missing a public key, SigningPubKey");
      key = decodedTx.SigningPubKey;
    }
    return (0, ripple_keypairs_1$2.verify)((0, ripple_binary_codec_1$2.encodeForSigning)(decodedTx), decodedTx.TxnSignature, key);
  }
  exports.verifySignature = verifySignature;
  function validateTransactionEquivalence(transactions) {
    const exampleTransaction = JSON.stringify(Object.assign(Object.assign({}, transactions[0]), { Signers: null }));
    if (transactions.slice(1).some((tx2) => JSON.stringify(Object.assign(Object.assign({}, tx2), { Signers: null })) !== exampleTransaction)) throw new errors_1$6.ValidationError("txJSON is not the same for all signedTransactions");
  }
  function getTransactionWithAllSigners(transactions) {
    const sortedSigners = transactions.flatMap((tx2) => {
      var _a;
      return (_a = tx2.Signers) !== null && _a !== void 0 ? _a : [];
    }).sort((signer1, signer2) => (0, utils_1$6.compareSigners)(signer1.Signer, signer2.Signer));
    return Object.assign(Object.assign({}, transactions[0]), { Signers: sortedSigners });
  }
} });
var require_Wallet = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/index.js"(exports) {
  var __importDefault$4 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Wallet = void 0;
  const bip32_1 = require_lib$2();
  const bip39_1 = require_bip39();
  const english_1 = require_english();
  const utils_1$5 = require_browser$4();
  const bignumber_js_1$1 = __importDefault$4(require_bignumber());
  const ripple_address_codec_1$1 = require_dist$3();
  const ripple_binary_codec_1$1 = require_dist$1$1();
  const ripple_keypairs_1$1 = require_dist$2();
  const ECDSA_1$2 = __importDefault$4(require_ECDSA());
  const errors_1$5 = require_errors();
  const transactions_1$1 = require_transactions();
  const common_1$1 = require_common();
  const utils_2 = require_utils$4$1();
  const utils_3 = require_utils$2$1();
  const collections_1 = require_collections();
  const hashLedger_1 = require_hashLedger();
  const rfc1751_1$1 = require_rfc1751();
  const signer_1 = require_signer();
  const DEFAULT_ALGORITHM = ECDSA_1$2.default.ed25519;
  const DEFAULT_DERIVATION_PATH = "m/44'/144'/0'/0/0";
  function validateKey(node2) {
    if (!(node2.privateKey instanceof Uint8Array)) throw new errors_1$5.ValidationError("Unable to derive privateKey from mnemonic input");
    if (!(node2.publicKey instanceof Uint8Array)) throw new errors_1$5.ValidationError("Unable to derive publicKey from mnemonic input");
  }
  var Wallet = class Wallet2 {
    constructor(publicKey, privateKey, opts = {}) {
      this.publicKey = publicKey;
      this.privateKey = privateKey;
      this.classicAddress = opts.masterAddress ? (0, utils_3.ensureClassicAddress)(opts.masterAddress) : (0, ripple_keypairs_1$1.deriveAddress)(publicKey);
      this.seed = opts.seed;
    }
    get address() {
      return this.classicAddress;
    }
    static generate(algorithm = DEFAULT_ALGORITHM) {
      if (!Object.values(ECDSA_1$2.default).includes(algorithm)) throw new errors_1$5.ValidationError("Invalid cryptographic signing algorithm");
      const seed = (0, ripple_keypairs_1$1.generateSeed)({ algorithm });
      return Wallet2.fromSeed(seed, { algorithm });
    }
    static fromSeed(seed, opts = {}) {
      return Wallet2.deriveWallet(seed, {
        algorithm: opts.algorithm,
        masterAddress: opts.masterAddress
      });
    }
    static fromEntropy(entropy, opts = {}) {
      var _a;
      const algorithm = (_a = opts.algorithm) !== null && _a !== void 0 ? _a : DEFAULT_ALGORITHM;
      const options = {
        entropy: Uint8Array.from(entropy),
        algorithm
      };
      const seed = (0, ripple_keypairs_1$1.generateSeed)(options);
      return Wallet2.deriveWallet(seed, {
        algorithm,
        masterAddress: opts.masterAddress
      });
    }
    static fromMnemonic(mnemonic, opts = {}) {
      var _a;
      if (opts.mnemonicEncoding === "rfc1751") return Wallet2.fromRFC1751Mnemonic(mnemonic, {
        masterAddress: opts.masterAddress,
        algorithm: opts.algorithm
      });
      if (!(0, bip39_1.validateMnemonic)(mnemonic, english_1.wordlist)) throw new errors_1$5.ValidationError("Unable to parse the given mnemonic using bip39 encoding");
      const seed = (0, bip39_1.mnemonicToSeedSync)(mnemonic);
      const masterNode = bip32_1.HDKey.fromMasterSeed(seed);
      const node2 = masterNode.derive((_a = opts.derivationPath) !== null && _a !== void 0 ? _a : DEFAULT_DERIVATION_PATH);
      validateKey(node2);
      const publicKey = (0, utils_1$5.bytesToHex)(node2.publicKey);
      const privateKey = (0, utils_1$5.bytesToHex)(node2.privateKey);
      return new Wallet2(publicKey, `00${privateKey}`, { masterAddress: opts.masterAddress });
    }
    static fromRFC1751Mnemonic(mnemonic, opts) {
      const seed = (0, rfc1751_1$1.rfc1751MnemonicToKey)(mnemonic);
      let encodeAlgorithm;
      if (opts.algorithm === ECDSA_1$2.default.ed25519) encodeAlgorithm = "ed25519";
      else encodeAlgorithm = "secp256k1";
      const encodedSeed = (0, ripple_address_codec_1$1.encodeSeed)(seed, encodeAlgorithm);
      return Wallet2.fromSeed(encodedSeed, {
        masterAddress: opts.masterAddress,
        algorithm: opts.algorithm
      });
    }
    static deriveWallet(seed, opts = {}) {
      var _a;
      const { publicKey, privateKey } = (0, ripple_keypairs_1$1.deriveKeypair)(seed, { algorithm: (_a = opts.algorithm) !== null && _a !== void 0 ? _a : DEFAULT_ALGORITHM });
      return new Wallet2(publicKey, privateKey, {
        seed,
        masterAddress: opts.masterAddress
      });
    }
    sign(transaction, multisign$1) {
      let multisignAddress = false;
      if (typeof multisign$1 === "string") multisignAddress = multisign$1;
      else if (multisign$1) multisignAddress = this.classicAddress;
      const tx2 = (0, collections_1.omitBy)(Object.assign({}, transaction), (value) => value == null);
      if (tx2.TxnSignature || tx2.Signers) throw new errors_1$5.ValidationError('txJSON must not contain "TxnSignature" or "Signers" properties');
      removeTrailingZeros(tx2);
      (0, transactions_1$1.validate)(tx2);
      if ((0, utils_2.hasFlag)(tx2, common_1$1.GlobalFlags.tfInnerBatchTxn, "tfInnerBatchTxn")) throw new errors_1$5.ValidationError("Cannot sign a Batch inner transaction.");
      const txToSignAndEncode = Object.assign({}, tx2);
      if (multisignAddress) {
        txToSignAndEncode.SigningPubKey = "";
        const signer = {
          Account: multisignAddress,
          SigningPubKey: this.publicKey,
          TxnSignature: computeSignature(txToSignAndEncode, this.privateKey, multisignAddress)
        };
        txToSignAndEncode.Signers = [{ Signer: signer }];
      } else {
        txToSignAndEncode.SigningPubKey = this.publicKey;
        txToSignAndEncode.TxnSignature = computeSignature(txToSignAndEncode, this.privateKey);
      }
      const serialized = (0, ripple_binary_codec_1$1.encode)(txToSignAndEncode);
      return {
        tx_blob: serialized,
        hash: (0, hashLedger_1.hashSignedTx)(serialized)
      };
    }
    verifyTransaction(signedTransaction) {
      return (0, signer_1.verifySignature)(signedTransaction, this.publicKey);
    }
    getXAddress(tag = false, isTestnet = false) {
      return (0, ripple_address_codec_1$1.classicAddressToXAddress)(this.classicAddress, tag, isTestnet);
    }
  };
  exports.Wallet = Wallet;
  Wallet.fromSecret = Wallet.fromSeed;
  function computeSignature(tx2, privateKey, signAs) {
    if (signAs) {
      const classicAddress = (0, ripple_address_codec_1$1.isValidXAddress)(signAs) ? (0, ripple_address_codec_1$1.xAddressToClassicAddress)(signAs).classicAddress : signAs;
      return (0, ripple_keypairs_1$1.sign)((0, ripple_binary_codec_1$1.encodeForMultisigning)(tx2, classicAddress), privateKey);
    }
    return (0, ripple_keypairs_1$1.sign)((0, ripple_binary_codec_1$1.encodeForSigning)(tx2), privateKey);
  }
  function removeTrailingZeros(tx2) {
    if (tx2.TransactionType === "Payment" && typeof tx2.Amount !== "string" && tx2.Amount.value.includes(".") && tx2.Amount.value.endsWith("0")) {
      tx2.Amount = Object.assign({}, tx2.Amount);
      tx2.Amount.value = new bignumber_js_1$1.default(tx2.Amount.value).toString();
    }
  }
} });
var require_defaultFaucets = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/defaultFaucets.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getFaucetPath = exports.getFaucetHost = exports.faucetNetworkIDs = exports.faucetNetworkPaths = exports.FaucetNetwork = void 0;
  const errors_1$4 = require_errors();
  var FaucetNetwork;
  (function(FaucetNetwork$1) {
    FaucetNetwork$1["Testnet"] = "faucet.altnet.rippletest.net";
    FaucetNetwork$1["Devnet"] = "faucet.devnet.rippletest.net";
  })(FaucetNetwork || (exports.FaucetNetwork = FaucetNetwork = {}));
  exports.faucetNetworkPaths = {
    [FaucetNetwork.Testnet]: "/accounts",
    [FaucetNetwork.Devnet]: "/accounts"
  };
  exports.faucetNetworkIDs = /* @__PURE__ */ new Map([[1, FaucetNetwork.Testnet], [2, FaucetNetwork.Devnet]]);
  function getFaucetHost(client2) {
    if (client2.networkID == null) throw new errors_1$4.XRPLFaucetError("Cannot create faucet URL without networkID or the faucetHost information");
    if (exports.faucetNetworkIDs.has(client2.networkID)) return exports.faucetNetworkIDs.get(client2.networkID);
    if (client2.networkID === 0) throw new errors_1$4.XRPLFaucetError("Faucet is not available for mainnet.");
    throw new errors_1$4.XRPLFaucetError("Faucet URL is not defined or inferrable.");
  }
  exports.getFaucetHost = getFaucetHost;
  function getFaucetPath(hostname) {
    if (hostname === void 0) return "/accounts";
    return exports.faucetNetworkPaths[hostname] || "/accounts";
  }
  exports.getFaucetPath = getFaucetPath;
} });
var require_fundWallet = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/fundWallet.js"(exports) {
  var __awaiter$4 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.requestFunding = exports.getStartingBalance = exports.generateWalletToFund = void 0;
  const ripple_address_codec_1 = require_dist$3();
  const errors_1$3 = require_errors();
  const defaultFaucets_1 = require_defaultFaucets();
  const _1$1 = require_Wallet();
  const INTERVAL_SECONDS = 1;
  const MAX_ATTEMPTS = 20;
  function generateWalletToFund(wallet) {
    if (wallet && (0, ripple_address_codec_1.isValidClassicAddress)(wallet.classicAddress)) return wallet;
    return _1$1.Wallet.generate();
  }
  exports.generateWalletToFund = generateWalletToFund;
  function getStartingBalance(client2, classicAddress) {
    return __awaiter$4(this, void 0, void 0, function* () {
      let startingBalance = 0;
      try {
        startingBalance = Number(yield client2.getXrpBalance(classicAddress));
      } catch (_a) {
      }
      return startingBalance;
    });
  }
  exports.getStartingBalance = getStartingBalance;
  function requestFunding(options, client2, startingBalance, walletToFund, postBody) {
    var _a, _b, _c;
    return __awaiter$4(this, void 0, void 0, function* () {
      const hostname = (_a = options.faucetHost) !== null && _a !== void 0 ? _a : (0, defaultFaucets_1.getFaucetHost)(client2);
      if (!hostname) throw new errors_1$3.XRPLFaucetError("No faucet hostname could be derived");
      const pathname = (_b = options.faucetPath) !== null && _b !== void 0 ? _b : (0, defaultFaucets_1.getFaucetPath)(hostname);
      const response = yield fetch(`https://${hostname}${pathname}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(postBody)
      });
      const body = yield response.json();
      if (response.ok && ((_c = response.headers.get("Content-Type")) === null || _c === void 0 ? void 0 : _c.startsWith("application/json"))) {
        const classicAddress = body.account.classicAddress;
        return processSuccessfulResponse(client2, classicAddress, walletToFund, startingBalance);
      }
      return processError(response, body);
    });
  }
  exports.requestFunding = requestFunding;
  function processSuccessfulResponse(client2, classicAddress, walletToFund, startingBalance) {
    return __awaiter$4(this, void 0, void 0, function* () {
      if (!classicAddress) return Promise.reject(new errors_1$3.XRPLFaucetError(`The faucet account is undefined`));
      const updatedBalance = yield getUpdatedBalance(client2, classicAddress, startingBalance);
      if (updatedBalance > startingBalance) return {
        wallet: walletToFund,
        balance: updatedBalance
      };
      throw new errors_1$3.XRPLFaucetError(`Unable to fund address with faucet after waiting ${INTERVAL_SECONDS * MAX_ATTEMPTS} seconds`);
    });
  }
  function processError(response, body) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return Promise.reject(new errors_1$3.XRPLFaucetError(`Request failed: ${JSON.stringify({
        body: body || {},
        contentType: response.headers.get("Content-Type"),
        statusCode: response.status
      })}`));
    });
  }
  function getUpdatedBalance(client2, address, originalBalance) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return new Promise((resolve, reject) => {
        let attempts = MAX_ATTEMPTS;
        const interval = setInterval(() => __awaiter$4(this, void 0, void 0, function* () {
          if (attempts < 0) {
            clearInterval(interval);
            resolve(originalBalance);
          } else attempts -= 1;
          try {
            let newBalance;
            try {
              newBalance = Number(yield client2.getXrpBalance(address));
            } catch (_a) {
            }
            if (newBalance > originalBalance) {
              clearInterval(interval);
              resolve(newBalance);
            }
          } catch (err) {
            clearInterval(interval);
            if (err instanceof Error) reject(new errors_1$3.XRPLFaucetError(`Unable to check if the address ${address} balance has increased. Error: ${err.message}`));
            reject(err);
          }
        }), INTERVAL_SECONDS * 1e3);
      });
    });
  }
} });
var require_browser = __commonJS$1({ "../../node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/ws/browser.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const eventemitter3_1$2 = require_eventemitter3();
  var WSWrapper = class extends eventemitter3_1$2.EventEmitter {
    /**
    * Constructs a browser-safe websocket.
    *
    * @param url - URL to connect to.
    * @param _protocols - Not used.
    * @param _websocketOptions - Not used.
    */
    constructor(url, _protocols, _websocketOptions) {
      super();
      this.ws = new WebSocket(url);
      this.ws.onclose = (closeEvent) => {
        let reason;
        if (closeEvent.reason) {
          const enc = new TextEncoder();
          reason = enc.encode(closeEvent.reason);
        }
        this.emit("close", closeEvent.code, reason);
      };
      this.ws.onopen = () => {
        this.emit("open");
      };
      this.ws.onerror = (error) => {
        this.emit("error", error);
      };
      this.ws.onmessage = (message2) => {
        this.emit("message", message2.data);
      };
    }
    /**
    * Get the ready state of the websocket.
    *
    * @returns The Websocket's ready state.
    */
    get readyState() {
      return this.ws.readyState;
    }
    /**
    * Closes the websocket.
    *
    * @param code - Close code.
    * @param reason - Close reason.
    */
    close(code, reason) {
      if (this.readyState === 1) this.ws.close(code, reason);
    }
    /**
    * Sends a message over the Websocket connection.
    *
    * @param message - Message to send.
    */
    send(message2) {
      this.ws.send(message2);
    }
  };
  WSWrapper.CONNECTING = 0;
  WSWrapper.OPEN = 1;
  WSWrapper.CLOSING = 2;
  WSWrapper.CLOSED = 3;
  exports.default = WSWrapper;
} });
var require_ConnectionManager = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/client/ConnectionManager.js"(exports) {
  var __awaiter$3 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ConnectionManager = class {
    constructor() {
      this.promisesAwaitingConnection = [];
    }
    resolveAllAwaiting() {
      this.promisesAwaitingConnection.map(({ resolve }) => resolve());
      this.promisesAwaitingConnection = [];
    }
    rejectAllAwaiting(error) {
      this.promisesAwaitingConnection.map(({ reject }) => reject(error));
      this.promisesAwaitingConnection = [];
    }
    awaitConnection() {
      return __awaiter$3(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
          this.promisesAwaitingConnection.push({
            resolve,
            reject
          });
        });
      });
    }
  };
  exports.default = ConnectionManager;
} });
var require_ExponentialBackoff = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/client/ExponentialBackoff.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const DEFAULT_MIN = 100;
  const DEFAULT_MAX = 1e3;
  var ExponentialBackoff = class {
    constructor(opts = {}) {
      var _a, _b;
      this.factor = 2;
      this.numAttempts = 0;
      this.ms = (_a = opts.min) !== null && _a !== void 0 ? _a : DEFAULT_MIN;
      this.max = (_b = opts.max) !== null && _b !== void 0 ? _b : DEFAULT_MAX;
    }
    get attempts() {
      return this.numAttempts;
    }
    duration() {
      const ms2 = this.ms * Math.pow(this.factor, this.numAttempts);
      this.numAttempts += 1;
      return Math.floor(Math.min(ms2, this.max));
    }
    reset() {
      this.numAttempts = 0;
    }
  };
  exports.default = ExponentialBackoff;
} });
var require_RequestManager = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/client/RequestManager.js"(exports) {
  var __awaiter$2 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const errors_1$2 = require_errors();
  var RequestManager = class {
    constructor() {
      this.nextId = 0;
      this.promisesAwaitingResponse = /* @__PURE__ */ new Map();
    }
    addPromise(newId, timer) {
      return __awaiter$2(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
          this.promisesAwaitingResponse.set(newId, {
            resolve,
            reject,
            timer
          });
        });
      });
    }
    resolve(id, response) {
      const promise = this.promisesAwaitingResponse.get(id);
      if (promise == null) throw new errors_1$2.XrplError(`No existing promise with id ${id}`, {
        type: "resolve",
        response
      });
      clearTimeout(promise.timer);
      promise.resolve(response);
      this.deletePromise(id);
    }
    reject(id, error) {
      const promise = this.promisesAwaitingResponse.get(id);
      if (promise == null) throw new errors_1$2.XrplError(`No existing promise with id ${id}`, {
        type: "reject",
        error
      });
      clearTimeout(promise.timer);
      promise.reject(error);
      this.deletePromise(id);
    }
    rejectAll(error) {
      this.promisesAwaitingResponse.forEach((_promise, id, _map) => {
        this.reject(id, error);
        this.deletePromise(id);
      });
    }
    createRequest(request, timeout) {
      let newId;
      if (request.id == null) {
        newId = this.nextId;
        this.nextId += 1;
      } else newId = request.id;
      const newRequest = JSON.stringify(Object.assign(Object.assign({}, request), { id: newId }));
      const timer = setTimeout(() => {
        this.reject(newId, new errors_1$2.TimeoutError(`Timeout for request: ${JSON.stringify(request)} with id ${newId}`, request));
      }, timeout);
      if (timer.unref) timer.unref();
      if (this.promisesAwaitingResponse.has(newId)) {
        clearTimeout(timer);
        throw new errors_1$2.XrplError(`Response with id '${newId}' is already pending`, request);
      }
      const newPromise = new Promise((resolve, reject) => {
        this.promisesAwaitingResponse.set(newId, {
          resolve,
          reject,
          timer
        });
      });
      return [
        newId,
        newRequest,
        newPromise
      ];
    }
    handleResponse(response) {
      var _a, _b, _c;
      if (response.id == null || !(typeof response.id === "string" || typeof response.id === "number")) throw new errors_1$2.ResponseFormatError("valid id not found in response", response);
      if (!this.promisesAwaitingResponse.has(response.id)) return;
      if (response.status == null) {
        const error = new errors_1$2.ResponseFormatError("Response has no status");
        this.reject(response.id, error);
      }
      if (response.status === "error") {
        const errorResponse = response;
        const error = new errors_1$2.RippledError((_b = (_a = errorResponse.error_message) !== null && _a !== void 0 ? _a : errorResponse.error_exception) !== null && _b !== void 0 ? _b : errorResponse.error, errorResponse);
        this.reject(response.id, error);
        return;
      }
      if (response.status !== "success") {
        const error = new errors_1$2.ResponseFormatError(`unrecognized response.status: ${(_c = response.status) !== null && _c !== void 0 ? _c : ""}`, response);
        this.reject(response.id, error);
        return;
      }
      delete response.status;
      this.resolve(response.id, response);
    }
    deletePromise(id) {
      this.promisesAwaitingResponse.delete(id);
    }
  };
  exports.default = RequestManager;
} });
var require_connection = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/client/connection.js"(exports) {
  var __awaiter$1 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault$3 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Connection = exports.INTENTIONAL_DISCONNECT_CODE = void 0;
  const utils_1$4 = require_browser$4();
  const ws_1 = __importDefault$3(require_browser());
  const eventemitter3_1$1 = require_eventemitter3();
  const errors_1$1 = require_errors();
  const ConnectionManager_1 = __importDefault$3(require_ConnectionManager());
  const ExponentialBackoff_1 = __importDefault$3(require_ExponentialBackoff());
  const RequestManager_1 = __importDefault$3(require_RequestManager());
  const SECONDS_PER_MINUTE = 60;
  const TIMEOUT = 20;
  const CONNECTION_TIMEOUT = 5;
  exports.INTENTIONAL_DISCONNECT_CODE = 4e3;
  function createWebSocket(url, config) {
    const options = { agent: config.agent };
    if (config.headers) options.headers = config.headers;
    if (config.authorization != null) options.headers = Object.assign(Object.assign({}, options.headers), { Authorization: `Basic ${btoa(config.authorization)}` });
    const websocketOptions = Object.assign({}, options);
    return new ws_1.default(url, websocketOptions);
  }
  function websocketSendAsync(ws, message2) {
    return __awaiter$1(this, void 0, void 0, function* () {
      return new Promise((resolve, reject) => {
        ws.send(message2, (error) => {
          if (error) reject(new errors_1$1.DisconnectedError(error.message, error));
          else resolve();
        });
      });
    });
  }
  var Connection = class extends eventemitter3_1$1.EventEmitter {
    constructor(url, options = {}) {
      super();
      this.ws = null;
      this.reconnectTimeoutID = null;
      this.heartbeatIntervalID = null;
      this.retryConnectionBackoff = new ExponentialBackoff_1.default({
        min: 100,
        max: SECONDS_PER_MINUTE * 1e3
      });
      this.requestManager = new RequestManager_1.default();
      this.connectionManager = new ConnectionManager_1.default();
      this.trace = () => {
      };
      this.url = url;
      this.config = Object.assign({
        timeout: TIMEOUT * 1e3,
        connectionTimeout: CONNECTION_TIMEOUT * 1e3
      }, options);
      if (typeof options.trace === "function") this.trace = options.trace;
      else if (options.trace) this.trace = console.log;
    }
    get state() {
      return this.ws ? this.ws.readyState : ws_1.default.CLOSED;
    }
    get shouldBeConnected() {
      return this.ws !== null;
    }
    isConnected() {
      return this.state === ws_1.default.OPEN;
    }
    connect() {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (this.isConnected()) return Promise.resolve();
        if (this.state === ws_1.default.CONNECTING) return this.connectionManager.awaitConnection();
        if (!this.url) return Promise.reject(new errors_1$1.ConnectionError("Cannot connect because no server was specified"));
        if (this.ws != null) return Promise.reject(new errors_1$1.XrplError("Websocket connection never cleaned up.", { state: this.state }));
        const connectionTimeoutID = setTimeout(() => {
          this.onConnectionFailed(new errors_1$1.ConnectionError(`Error: connect() timed out after ${this.config.connectionTimeout} ms. If your internet connection is working, the rippled server may be blocked or inaccessible. You can also try setting the 'connectionTimeout' option in the Client constructor.`));
        }, this.config.connectionTimeout);
        this.ws = createWebSocket(this.url, this.config);
        if (this.ws == null) throw new errors_1$1.XrplError("Connect: created null websocket");
        this.ws.on("error", (error) => this.onConnectionFailed(error));
        this.ws.on("error", () => clearTimeout(connectionTimeoutID));
        this.ws.on("close", (reason) => this.onConnectionFailed(reason));
        this.ws.on("close", () => clearTimeout(connectionTimeoutID));
        this.ws.once("open", () => {
          this.onceOpen(connectionTimeoutID);
        });
        return this.connectionManager.awaitConnection();
      });
    }
    disconnect() {
      return __awaiter$1(this, void 0, void 0, function* () {
        this.clearHeartbeatInterval();
        if (this.reconnectTimeoutID !== null) {
          clearTimeout(this.reconnectTimeoutID);
          this.reconnectTimeoutID = null;
        }
        if (this.state === ws_1.default.CLOSED) return Promise.resolve(void 0);
        if (this.ws == null) return Promise.resolve(void 0);
        return new Promise((resolve) => {
          if (this.ws == null) resolve(void 0);
          if (this.ws != null) this.ws.once("close", (code) => resolve(code));
          if (this.ws != null && this.state !== ws_1.default.CLOSING) this.ws.close(exports.INTENTIONAL_DISCONNECT_CODE);
        });
      });
    }
    reconnect() {
      return __awaiter$1(this, void 0, void 0, function* () {
        this.emit("reconnect");
        yield this.disconnect();
        yield this.connect();
      });
    }
    request(request, timeout) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (!this.shouldBeConnected || this.ws == null) throw new errors_1$1.NotConnectedError(JSON.stringify(request), request);
        const [id, message2, responsePromise] = this.requestManager.createRequest(request, timeout !== null && timeout !== void 0 ? timeout : this.config.timeout);
        this.trace("send", message2);
        websocketSendAsync(this.ws, message2).catch((error) => {
          this.requestManager.reject(id, error);
        });
        return responsePromise;
      });
    }
    getUrl() {
      var _a;
      return (_a = this.url) !== null && _a !== void 0 ? _a : "";
    }
    onMessage(message2) {
      this.trace("receive", message2);
      let data2;
      try {
        data2 = JSON.parse(message2);
      } catch (error) {
        if (error instanceof Error) this.emit("error", "badMessage", error.message, message2);
        return;
      }
      if (data2.type == null && data2.error) {
        this.emit("error", data2.error, data2.error_message, data2);
        return;
      }
      if (data2.type) this.emit(data2.type, data2);
      if (data2.type === "response") try {
        this.requestManager.handleResponse(data2);
      } catch (error) {
        if (error instanceof Error) this.emit("error", "badMessage", error.message, message2);
        else this.emit("error", "badMessage", error, error);
      }
    }
    onceOpen(connectionTimeoutID) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (this.ws == null) throw new errors_1$1.XrplError("onceOpen: ws is null");
        this.ws.removeAllListeners();
        clearTimeout(connectionTimeoutID);
        this.ws.on("message", (message2) => this.onMessage(message2));
        this.ws.on("error", (error) => this.emit("error", "websocket", error.message, error));
        this.ws.once("close", (code, reason) => {
          if (this.ws == null) throw new errors_1$1.XrplError("onceClose: ws is null");
          this.clearHeartbeatInterval();
          this.requestManager.rejectAll(new errors_1$1.DisconnectedError(`websocket was closed, ${reason ? (0, utils_1$4.hexToString)((0, utils_1$4.bytesToHex)(reason)) : ""}`));
          this.ws.removeAllListeners();
          this.ws = null;
          if (code === void 0) {
            const internalErrorCode = 1011;
            this.emit("disconnected", internalErrorCode);
          } else this.emit("disconnected", code);
          if (code !== exports.INTENTIONAL_DISCONNECT_CODE && code !== void 0) this.intentionalDisconnect();
        });
        try {
          this.retryConnectionBackoff.reset();
          this.startHeartbeatInterval();
          this.connectionManager.resolveAllAwaiting();
          this.emit("connected");
        } catch (error) {
          if (error instanceof Error) {
            this.connectionManager.rejectAllAwaiting(error);
            yield this.disconnect().catch(() => {
            });
          }
        }
      });
    }
    intentionalDisconnect() {
      const retryTimeout = this.retryConnectionBackoff.duration();
      this.trace("reconnect", `Retrying connection in ${retryTimeout}ms.`);
      this.emit("reconnecting", this.retryConnectionBackoff.attempts);
      this.reconnectTimeoutID = setTimeout(() => {
        this.reconnect().catch((error) => {
          this.emit("error", "reconnect", error.message, error);
        });
      }, retryTimeout);
    }
    clearHeartbeatInterval() {
      if (this.heartbeatIntervalID) clearInterval(this.heartbeatIntervalID);
    }
    startHeartbeatInterval() {
      this.clearHeartbeatInterval();
      this.heartbeatIntervalID = setInterval(() => {
        this.heartbeat();
      }, this.config.timeout);
    }
    heartbeat() {
      return __awaiter$1(this, void 0, void 0, function* () {
        this.request({ command: "ping" }).catch(() => __awaiter$1(this, void 0, void 0, function* () {
          return this.reconnect().catch((error) => {
            this.emit("error", "reconnect", error.message, error);
          });
        }));
      });
    }
    onConnectionFailed(errorOrCode) {
      if (this.ws) {
        this.ws.removeAllListeners();
        this.ws.on("error", () => {
        });
        this.ws.close();
        this.ws = null;
      }
      if (typeof errorOrCode === "number") this.connectionManager.rejectAllAwaiting(new errors_1$1.NotConnectedError(`Connection failed with code ${errorOrCode}.`, { code: errorOrCode }));
      else if (errorOrCode === null || errorOrCode === void 0 ? void 0 : errorOrCode.message) this.connectionManager.rejectAllAwaiting(new errors_1$1.NotConnectedError(errorOrCode.message, errorOrCode));
      else this.connectionManager.rejectAllAwaiting(new errors_1$1.NotConnectedError("Connection failed."));
    }
  };
  exports.Connection = Connection;
} });
var require_partialPayment = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/client/partialPayment.js"(exports) {
  var __importDefault$2 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.handleStreamPartialPayment = exports.handlePartialPayment = void 0;
  const bignumber_js_1 = __importDefault$2(require_bignumber());
  const ripple_binary_codec_1 = require_dist$1$1();
  const transactions_1 = require_transactions();
  const utils_1$3 = require_utils$4$1();
  const WARN_PARTIAL_PAYMENT_CODE = 2001;
  function amountsEqual(amt1, amt2) {
    if (typeof amt1 === "string" && typeof amt2 === "string") return amt1 === amt2;
    if (typeof amt1 === "string" || typeof amt2 === "string") return false;
    if ((0, transactions_1.isMPTAmount)(amt1) && (0, transactions_1.isMPTAmount)(amt2)) {
      const aValue$1 = new bignumber_js_1.default(amt1.value);
      const bValue$1 = new bignumber_js_1.default(amt2.value);
      return amt1.mpt_issuance_id === amt2.mpt_issuance_id && aValue$1.isEqualTo(bValue$1);
    }
    if ((0, transactions_1.isMPTAmount)(amt1) || (0, transactions_1.isMPTAmount)(amt2)) return false;
    const aValue = new bignumber_js_1.default(amt1.value);
    const bValue = new bignumber_js_1.default(amt2.value);
    return amt1.currency === amt2.currency && amt1.issuer === amt2.issuer && aValue.isEqualTo(bValue);
  }
  function isPartialPayment(tx2, metadata) {
    var _a;
    if (tx2 == null || metadata == null || tx2.TransactionType !== "Payment") return false;
    let meta2 = metadata;
    if (typeof meta2 === "string") {
      if (meta2 === "unavailable") return false;
      meta2 = (0, ripple_binary_codec_1.decode)(meta2);
    }
    const tfPartial = typeof tx2.Flags === "number" ? (0, utils_1$3.isFlagEnabled)(tx2.Flags, transactions_1.PaymentFlags.tfPartialPayment) : (_a = tx2.Flags) === null || _a === void 0 ? void 0 : _a.tfPartialPayment;
    if (!tfPartial) return false;
    const delivered = meta2.delivered_amount;
    const amount = tx2.DeliverMax;
    if (delivered === void 0) return false;
    return !amountsEqual(delivered, amount);
  }
  function txHasPartialPayment(response) {
    return isPartialPayment(response.result.tx_json, response.result.meta);
  }
  function txEntryHasPartialPayment(response) {
    return isPartialPayment(response.result.tx_json, response.result.metadata);
  }
  function accountTxHasPartialPayment(response) {
    const { transactions } = response.result;
    const foo = transactions.some((tx2) => {
      if (tx2.tx_json != null) {
        const transaction$1 = tx2;
        return isPartialPayment(transaction$1.tx_json, transaction$1.meta);
      }
      const transaction = tx2;
      return isPartialPayment(transaction.tx, transaction.meta);
    });
    return foo;
  }
  function hasPartialPayment(command, response) {
    switch (command) {
      case "tx":
        return txHasPartialPayment(response);
      case "transaction_entry":
        return txEntryHasPartialPayment(response);
      case "account_tx":
        return accountTxHasPartialPayment(response);
      default:
        return false;
    }
  }
  function handlePartialPayment(command, response) {
    var _a;
    if (hasPartialPayment(command, response)) {
      const warnings = (_a = response.warnings) !== null && _a !== void 0 ? _a : [];
      const warning = {
        id: WARN_PARTIAL_PAYMENT_CODE,
        message: "This response contains a Partial Payment"
      };
      warnings.push(warning);
      response.warnings = warnings;
    }
  }
  exports.handlePartialPayment = handlePartialPayment;
  function handleStreamPartialPayment(stream, log) {
    var _a, _b;
    if (isPartialPayment((_a = stream.tx_json) !== null && _a !== void 0 ? _a : stream.transaction, stream.meta)) {
      const warnings = (_b = stream.warnings) !== null && _b !== void 0 ? _b : [];
      const warning = {
        id: WARN_PARTIAL_PAYMENT_CODE,
        message: "This response contains a Partial Payment"
      };
      warnings.push(warning);
      stream.warnings = warnings;
      log("Partial payment received", JSON.stringify(stream));
    }
  }
  exports.handleStreamPartialPayment = handleStreamPartialPayment;
} });
var require_client = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/client/index.js"(exports) {
  var __awaiter = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Client = void 0;
  const eventemitter3_1 = require_eventemitter3();
  const errors_1 = require_errors();
  const common_1 = require_common$1();
  const flags_1$1 = require_flags();
  const sugar_1 = require_sugar();
  const autofill_1 = require_autofill();
  const balances_1 = require_balances();
  const getOrderbook_1 = require_getOrderbook();
  const utils_1$2 = require_utils$3$1();
  const Wallet_1$1 = require_Wallet();
  const fundWallet_1 = require_fundWallet();
  const connection_1 = require_connection();
  const partialPayment_1 = require_partialPayment();
  function getCollectKeyFromCommand(command) {
    switch (command) {
      case "account_channels":
        return "channels";
      case "account_lines":
        return "lines";
      case "account_objects":
        return "account_objects";
      case "account_tx":
        return "transactions";
      case "account_offers":
      case "book_offers":
        return "offers";
      case "ledger_data":
        return "state";
      default:
        return null;
    }
  }
  function clamp(value, min2, max2) {
    return Math.min(Math.max(value, min2), max2);
  }
  const DEFAULT_FEE_CUSHION = 1.2;
  const DEFAULT_MAX_FEE_XRP = "2";
  const MIN_LIMIT = 10;
  const MAX_LIMIT = 400;
  const NORMAL_DISCONNECT_CODE = 1e3;
  var Client = class extends eventemitter3_1.EventEmitter {
    constructor(server, options = {}) {
      var _a, _b;
      super();
      this.apiVersion = common_1.DEFAULT_API_VERSION;
      if (typeof server !== "string" || !/wss?(?:\+unix)?:\/\//u.exec(server)) throw new errors_1.ValidationError("server URI must start with `wss://`, `ws://`, `wss+unix://`, or `ws+unix://`.");
      this.feeCushion = (_a = options.feeCushion) !== null && _a !== void 0 ? _a : DEFAULT_FEE_CUSHION;
      this.maxFeeXRP = (_b = options.maxFeeXRP) !== null && _b !== void 0 ? _b : DEFAULT_MAX_FEE_XRP;
      this.connection = new connection_1.Connection(server, options);
      this.connection.on("error", (errorCode, errorMessage, data2) => {
        this.emit("error", errorCode, errorMessage, data2);
      });
      this.connection.on("reconnect", () => {
        this.connection.on("connected", () => this.emit("connected"));
      });
      this.connection.on("disconnected", (code) => {
        let finalCode = code;
        if (finalCode === connection_1.INTENTIONAL_DISCONNECT_CODE) finalCode = NORMAL_DISCONNECT_CODE;
        this.emit("disconnected", finalCode);
      });
      this.connection.on("ledgerClosed", (ledger) => {
        this.emit("ledgerClosed", ledger);
      });
      this.connection.on("transaction", (tx2) => {
        (0, partialPayment_1.handleStreamPartialPayment)(tx2, this.connection.trace);
        this.emit("transaction", tx2);
      });
      this.connection.on("validationReceived", (validation) => {
        this.emit("validationReceived", validation);
      });
      this.connection.on("manifestReceived", (manifest) => {
        this.emit("manifestReceived", manifest);
      });
      this.connection.on("peerStatusChange", (status) => {
        this.emit("peerStatusChange", status);
      });
      this.connection.on("consensusPhase", (consensus) => {
        this.emit("consensusPhase", consensus);
      });
      this.connection.on("path_find", (path) => {
        this.emit("path_find", path);
      });
    }
    get url() {
      return this.connection.getUrl();
    }
    request(req) {
      var _a;
      return __awaiter(this, void 0, void 0, function* () {
        const request = Object.assign(Object.assign({}, req), {
          account: typeof req.account === "string" ? (0, sugar_1.ensureClassicAddress)(req.account) : void 0,
          api_version: (_a = req.api_version) !== null && _a !== void 0 ? _a : this.apiVersion
        });
        const response = yield this.connection.request(request);
        (0, partialPayment_1.handlePartialPayment)(req.command, response);
        return response;
      });
    }
    requestNextPage(req, resp) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!resp.result.marker) return Promise.reject(new errors_1.NotFoundError("response does not have a next page"));
        const nextPageRequest = Object.assign(Object.assign({}, req), { marker: resp.result.marker });
        return this.request(nextPageRequest);
      });
    }
    on(eventName, listener) {
      return super.on(eventName, listener);
    }
    requestAll(request, collect) {
      return __awaiter(this, void 0, void 0, function* () {
        const collectKey = collect !== null && collect !== void 0 ? collect : getCollectKeyFromCommand(request.command);
        if (!collectKey) throw new errors_1.ValidationError(`no collect key for command ${request.command}`);
        const countTo = request.limit == null ? Infinity : request.limit;
        let count = 0;
        let marker = request.marker;
        const results = [];
        do {
          const countRemaining = clamp(countTo - count, MIN_LIMIT, MAX_LIMIT);
          const repeatProps = Object.assign(Object.assign({}, request), {
            limit: countRemaining,
            marker
          });
          const singleResponse = yield this.connection.request(repeatProps);
          const singleResult = singleResponse.result;
          if (!(collectKey in singleResult)) throw new errors_1.XrplError(`${collectKey} not in result`);
          const collectedData = singleResult[collectKey];
          marker = singleResult.marker;
          results.push(singleResponse);
          if (Array.isArray(collectedData)) count += collectedData.length;
        } while (Boolean(marker) && count < countTo);
        return results;
      });
    }
    getServerInfo() {
      var _a;
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const response = yield this.request({ command: "server_info" });
          this.networkID = (_a = response.result.info.network_id) !== null && _a !== void 0 ? _a : void 0;
          this.buildVersion = response.result.info.build_version;
        } catch (error) {
          console.error(error);
        }
      });
    }
    connect() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.connection.connect().then(() => __awaiter(this, void 0, void 0, function* () {
          yield this.getServerInfo();
          this.emit("connected");
        }));
      });
    }
    disconnect() {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.connection.disconnect();
      });
    }
    isConnected() {
      return this.connection.isConnected();
    }
    autofill(transaction, signersCount) {
      return __awaiter(this, void 0, void 0, function* () {
        const tx2 = Object.assign({}, transaction);
        (0, autofill_1.setValidAddresses)(tx2);
        tx2.Flags = (0, flags_1$1.convertTxFlagsToNumber)(tx2);
        const promises = [];
        if (tx2.NetworkID == null) tx2.NetworkID = (0, autofill_1.txNeedsNetworkID)(this) ? this.networkID : void 0;
        if (tx2.Sequence == null) promises.push((0, autofill_1.setNextValidSequenceNumber)(this, tx2));
        if (tx2.Fee == null) promises.push((0, autofill_1.getTransactionFee)(this, tx2, signersCount));
        if (tx2.LastLedgerSequence == null) promises.push((0, autofill_1.setLatestValidatedLedgerSequence)(this, tx2));
        if (tx2.TransactionType === "AccountDelete") promises.push((0, autofill_1.checkAccountDeleteBlockers)(this, tx2));
        if (tx2.TransactionType === "Batch") promises.push((0, autofill_1.autofillBatchTxn)(this, tx2));
        if (tx2.TransactionType === "Payment") (0, autofill_1.handleDeliverMax)(tx2);
        return Promise.all(promises).then(() => tx2);
      });
    }
    submit(transaction, opts) {
      return __awaiter(this, void 0, void 0, function* () {
        const signedTx = yield (0, sugar_1.getSignedTx)(this, transaction, opts);
        return (0, sugar_1.submitRequest)(this, signedTx, opts === null || opts === void 0 ? void 0 : opts.failHard);
      });
    }
    simulate(transaction, opts) {
      var _a;
      return __awaiter(this, void 0, void 0, function* () {
        const binary$1 = (_a = opts === null || opts === void 0 ? void 0 : opts.binary) !== null && _a !== void 0 ? _a : false;
        const request = typeof transaction === "string" ? {
          command: "simulate",
          tx_blob: transaction,
          binary: binary$1
        } : {
          command: "simulate",
          tx_json: transaction,
          binary: binary$1
        };
        return this.request(request);
      });
    }
    submitAndWait(transaction, opts) {
      return __awaiter(this, void 0, void 0, function* () {
        const signedTx = yield (0, sugar_1.getSignedTx)(this, transaction, opts);
        const lastLedger = (0, sugar_1.getLastLedgerSequence)(signedTx);
        if (lastLedger == null) throw new errors_1.ValidationError("Transaction must contain a LastLedgerSequence value for reliable submission.");
        const response = yield (0, sugar_1.submitRequest)(this, signedTx, opts === null || opts === void 0 ? void 0 : opts.failHard);
        const txHash = utils_1$2.hashes.hashSignedTx(signedTx);
        return (0, sugar_1.waitForFinalTransactionOutcome)(this, txHash, lastLedger, response.result.engine_result);
      });
    }
    prepareTransaction(transaction, signersCount) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.autofill(transaction, signersCount);
      });
    }
    getXrpBalance(address, options = {}) {
      var _a;
      return __awaiter(this, void 0, void 0, function* () {
        const xrpRequest = {
          command: "account_info",
          account: address,
          ledger_index: (_a = options.ledger_index) !== null && _a !== void 0 ? _a : "validated",
          ledger_hash: options.ledger_hash
        };
        const response = yield this.request(xrpRequest);
        return (0, utils_1$2.dropsToXrp)(response.result.account_data.Balance);
      });
    }
    getBalances(address, options = {}) {
      var _a;
      return __awaiter(this, void 0, void 0, function* () {
        const balances = [];
        let xrpPromise = Promise.resolve(0);
        if (!options.peer) xrpPromise = this.getXrpBalance(address, {
          ledger_hash: options.ledger_hash,
          ledger_index: options.ledger_index
        });
        const linesRequest = {
          command: "account_lines",
          account: address,
          ledger_index: (_a = options.ledger_index) !== null && _a !== void 0 ? _a : "validated",
          ledger_hash: options.ledger_hash,
          peer: options.peer,
          limit: options.limit
        };
        const linesPromise = this.requestAll(linesRequest);
        yield Promise.all([xrpPromise, linesPromise]).then(([xrpBalance, linesResponses]) => {
          const accountLinesBalance = linesResponses.flatMap((response) => (0, balances_1.formatBalances)(response.result.lines));
          if (xrpBalance !== 0) balances.push({
            currency: "XRP",
            value: xrpBalance.toString()
          });
          balances.push(...accountLinesBalance);
        });
        return balances.slice(0, options.limit);
      });
    }
    getOrderbook(currency1, currency2, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        (0, getOrderbook_1.validateOrderbookOptions)(options);
        const request = (0, getOrderbook_1.createBookOffersRequest)(currency1, currency2, options);
        const directOfferResults = yield (0, getOrderbook_1.requestAllOffers)(this, request);
        const reverseOfferResults = yield (0, getOrderbook_1.requestAllOffers)(this, (0, getOrderbook_1.reverseRequest)(request));
        const directOffers = (0, getOrderbook_1.extractOffers)(directOfferResults);
        const reverseOffers = (0, getOrderbook_1.extractOffers)(reverseOfferResults);
        const orders = (0, getOrderbook_1.combineOrders)(directOffers, reverseOffers);
        const { buy, sell } = (0, getOrderbook_1.separateBuySellOrders)(orders);
        return {
          buy: (0, getOrderbook_1.sortAndLimitOffers)(buy, options.limit),
          sell: (0, getOrderbook_1.sortAndLimitOffers)(sell, options.limit)
        };
      });
    }
    getLedgerIndex() {
      return __awaiter(this, void 0, void 0, function* () {
        const ledgerResponse = yield this.request({
          command: "ledger",
          ledger_index: "validated"
        });
        return ledgerResponse.result.ledger_index;
      });
    }
    fundWallet(wallet, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.isConnected()) throw new errors_1.RippledError("Client not connected, cannot call faucet");
        const existingWallet = Boolean(wallet);
        const walletToFund = wallet && (0, utils_1$2.isValidClassicAddress)(wallet.classicAddress) ? wallet : Wallet_1$1.Wallet.generate();
        const postBody = {
          destination: walletToFund.classicAddress,
          xrpAmount: options.amount,
          usageContext: options.usageContext,
          userAgent: "xrpl.js"
        };
        let startingBalance = 0;
        if (existingWallet) try {
          startingBalance = Number(yield this.getXrpBalance(walletToFund.classicAddress));
        } catch (_a) {
        }
        return (0, fundWallet_1.requestFunding)(options, this, startingBalance, walletToFund, postBody);
      });
    }
  };
  exports.Client = Client;
} });
var require_Amendments = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/Amendments.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AMENDMENTS_ID = void 0;
  exports.AMENDMENTS_ID = "7DB0788C020F02780A673DC74757F23823FA3014C1866E72CC4CD8B226CD6EF4";
} });
var require_FeeSettings = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/FeeSettings.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FEE_SETTINGS_ID = void 0;
  exports.FEE_SETTINGS_ID = "4BC50C9B0D8515D3EAAE1E74B29A95804346C491EE1A95BF25E4AAB854A6A651";
} });
var require_NegativeUNL = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/NegativeUNL.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NEGATIVE_UNL_ID = void 0;
  exports.NEGATIVE_UNL_ID = "2E8A59AA9D3B5B186B0B9E0F62E6C02587CA74A4D778938E957B6357D364B244";
} });
var require_RippleState = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/RippleState.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RippleStateFlags = void 0;
  var RippleStateFlags;
  (function(RippleStateFlags$1) {
    RippleStateFlags$1[RippleStateFlags$1["lsfLowReserve"] = 65536] = "lsfLowReserve";
    RippleStateFlags$1[RippleStateFlags$1["lsfHighReserve"] = 131072] = "lsfHighReserve";
    RippleStateFlags$1[RippleStateFlags$1["lsfLowAuth"] = 262144] = "lsfLowAuth";
    RippleStateFlags$1[RippleStateFlags$1["lsfHighAuth"] = 524288] = "lsfHighAuth";
    RippleStateFlags$1[RippleStateFlags$1["lsfLowNoRipple"] = 1048576] = "lsfLowNoRipple";
    RippleStateFlags$1[RippleStateFlags$1["lsfHighNoRipple"] = 2097152] = "lsfHighNoRipple";
    RippleStateFlags$1[RippleStateFlags$1["lsfLowFreeze"] = 4194304] = "lsfLowFreeze";
    RippleStateFlags$1[RippleStateFlags$1["lsfHighFreeze"] = 8388608] = "lsfHighFreeze";
    RippleStateFlags$1[RippleStateFlags$1["lsfAMMNode"] = 16777216] = "lsfAMMNode";
    RippleStateFlags$1[RippleStateFlags$1["lsfLowDeepFreeze"] = 33554432] = "lsfLowDeepFreeze";
    RippleStateFlags$1[RippleStateFlags$1["lsfHighDeepFreeze"] = 67108864] = "lsfHighDeepFreeze";
  })(RippleStateFlags || (exports.RippleStateFlags = RippleStateFlags = {}));
} });
var require_SignerList = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/SignerList.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SignerListFlags = void 0;
  var SignerListFlags;
  (function(SignerListFlags$1) {
    SignerListFlags$1[SignerListFlags$1["lsfOneOwnerCount"] = 65536] = "lsfOneOwnerCount";
  })(SignerListFlags || (exports.SignerListFlags = SignerListFlags = {}));
} });
var require_ledger = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/ledger/index.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SignerListFlags = exports.RippleStateFlags = exports.OfferFlags = exports.NEGATIVE_UNL_ID = exports.FEE_SETTINGS_ID = exports.AMENDMENTS_ID = exports.AccountRootFlags = void 0;
  const AccountRoot_1 = require_AccountRoot();
  Object.defineProperty(exports, "AccountRootFlags", {
    enumerable: true,
    get: function() {
      return AccountRoot_1.AccountRootFlags;
    }
  });
  const Amendments_1 = require_Amendments();
  Object.defineProperty(exports, "AMENDMENTS_ID", {
    enumerable: true,
    get: function() {
      return Amendments_1.AMENDMENTS_ID;
    }
  });
  const FeeSettings_1 = require_FeeSettings();
  Object.defineProperty(exports, "FEE_SETTINGS_ID", {
    enumerable: true,
    get: function() {
      return FeeSettings_1.FEE_SETTINGS_ID;
    }
  });
  const NegativeUNL_1 = require_NegativeUNL();
  Object.defineProperty(exports, "NEGATIVE_UNL_ID", {
    enumerable: true,
    get: function() {
      return NegativeUNL_1.NEGATIVE_UNL_ID;
    }
  });
  const Offer_1 = require_Offer();
  Object.defineProperty(exports, "OfferFlags", {
    enumerable: true,
    get: function() {
      return Offer_1.OfferFlags;
    }
  });
  const RippleState_1 = require_RippleState();
  Object.defineProperty(exports, "RippleStateFlags", {
    enumerable: true,
    get: function() {
      return RippleState_1.RippleStateFlags;
    }
  });
  const SignerList_1 = require_SignerList();
  Object.defineProperty(exports, "SignerListFlags", {
    enumerable: true,
    get: function() {
      return SignerList_1.SignerListFlags;
    }
  });
} });
var require_methods = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/methods/index.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
} });
var require_models = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/models/index.js"(exports) {
  var __createBinding$2 = Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
      enumerable: true,
      get: function() {
        return m[k];
      }
    };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  };
  var __setModuleDefault = Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function(o, v) {
    o["default"] = v;
  };
  var __importStar = function(mod$1) {
    if (mod$1 && mod$1.__esModule) return mod$1;
    var result = {};
    if (mod$1 != null) {
      for (var k in mod$1) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod$1, k)) __createBinding$2(result, mod$1, k);
    }
    __setModuleDefault(result, mod$1);
    return result;
  };
  var __exportStar$2 = function(m, exports$1) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding$2(exports$1, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseTransactionFlags = exports.convertTxFlagsToNumber = exports.setTransactionFlagsToNumber = exports.parseAccountRootFlags = exports.LedgerEntry = void 0;
  exports.LedgerEntry = __importStar(require_ledger());
  var flags_1 = require_flags();
  Object.defineProperty(exports, "parseAccountRootFlags", {
    enumerable: true,
    get: function() {
      return flags_1.parseAccountRootFlags;
    }
  });
  Object.defineProperty(exports, "setTransactionFlagsToNumber", {
    enumerable: true,
    get: function() {
      return flags_1.setTransactionFlagsToNumber;
    }
  });
  Object.defineProperty(exports, "convertTxFlagsToNumber", {
    enumerable: true,
    get: function() {
      return flags_1.convertTxFlagsToNumber;
    }
  });
  Object.defineProperty(exports, "parseTransactionFlags", {
    enumerable: true,
    get: function() {
      return flags_1.parseTransactionFlags;
    }
  });
  __exportStar$2(require_methods(), exports);
  __exportStar$2(require_transactions(), exports);
  __exportStar$2(require_common$1(), exports);
} });
var require_utils$a = __commonJS$1({ "../../node_modules/.pnpm/@xrplf+secret-numbers@1.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@xrplf/secret-numbers/dist/utils/index.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseSecretString = exports.checkChecksum = exports.calculateChecksum = exports.secretToEntropy = exports.entropyToSecret = exports.randomSecret = exports.randomEntropy = void 0;
  const utils_1$1 = require_browser$4();
  function randomEntropy() {
    return (0, utils_1$1.randomBytes)(16);
  }
  exports.randomEntropy = randomEntropy;
  function calculateChecksum(position, value) {
    return value * (position * 2 + 1) % 9;
  }
  exports.calculateChecksum = calculateChecksum;
  function checkChecksum(position, value, checksum$1) {
    let normalizedChecksum;
    let normalizedValue;
    if (typeof value === "string") {
      if (value.length !== 6) throw new Error("value must have a length of 6");
      normalizedChecksum = parseInt(value.slice(5), 10);
      normalizedValue = parseInt(value.slice(0, 5), 10);
    } else {
      if (typeof checksum$1 !== "number") throw new Error("checksum must be a number when value is a number");
      normalizedChecksum = checksum$1;
      normalizedValue = value;
    }
    return normalizedValue * (position * 2 + 1) % 9 === normalizedChecksum;
  }
  exports.checkChecksum = checkChecksum;
  function entropyToSecret(entropy) {
    const len = new Array(Math.ceil(entropy.length / 2));
    const chunks = Array.from(len, (_a, chunk) => {
      const buffChunk = entropy.slice(chunk * 2, (chunk + 1) * 2);
      const no = parseInt((0, utils_1$1.bytesToHex)(buffChunk), 16);
      const fill = "0".repeat(5 - String(no).length);
      return fill + String(no) + String(calculateChecksum(chunk, no));
    });
    if (chunks.length !== 8) throw new Error("Chucks must have 8 digits");
    return chunks;
  }
  exports.entropyToSecret = entropyToSecret;
  function randomSecret() {
    return entropyToSecret(randomEntropy());
  }
  exports.randomSecret = randomSecret;
  function secretToEntropy(secret) {
    return (0, utils_1$1.concat)(secret.map((chunk, i) => {
      const no = Number(chunk.slice(0, 5));
      const checksum$1 = Number(chunk.slice(5));
      if (chunk.length !== 6) throw new Error("Invalid secret: number invalid");
      if (!checkChecksum(i, no, checksum$1)) throw new Error("Invalid secret part: checksum invalid");
      const hex = `0000${no.toString(16)}`.slice(-4);
      return (0, utils_1$1.hexToBytes)(hex);
    }));
  }
  exports.secretToEntropy = secretToEntropy;
  function parseSecretString(secret) {
    const normalizedSecret = secret.replace(/[^0-9]/gu, "");
    if (normalizedSecret.length !== 48) throw new Error("Invalid secret string (should contain 8 blocks of 6 digits");
    return Array.from(new Array(8), (_a, index) => {
      return normalizedSecret.slice(index * 6, (index + 1) * 6);
    });
  }
  exports.parseSecretString = parseSecretString;
} });
var require_Account = __commonJS$1({ "../../node_modules/.pnpm/@xrplf+secret-numbers@1.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@xrplf/secret-numbers/dist/schema/Account.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Account = void 0;
  const ripple_keypairs_1 = require_dist$2();
  const utils_1 = require_utils$a();
  var Account = class {
    constructor(secretNumbers) {
      this._account = {
        familySeed: "",
        address: "",
        keypair: {
          publicKey: "",
          privateKey: ""
        }
      };
      if (typeof secretNumbers === "string") this._secret = (0, utils_1.parseSecretString)(secretNumbers);
      else if (Array.isArray(secretNumbers)) this._secret = secretNumbers;
      else if (secretNumbers instanceof Uint8Array) this._secret = (0, utils_1.entropyToSecret)(secretNumbers);
      else this._secret = (0, utils_1.randomSecret)();
      validateLengths(this._secret);
      this.derive();
    }
    getSecret() {
      return this._secret;
    }
    getSecretString() {
      return this._secret.join(" ");
    }
    getAddress() {
      return this._account.address;
    }
    getFamilySeed() {
      return this._account.familySeed;
    }
    getKeypair() {
      return this._account.keypair;
    }
    toString() {
      return this.getSecretString();
    }
    derive() {
      try {
        const entropy = (0, utils_1.secretToEntropy)(this._secret);
        this._account.familySeed = (0, ripple_keypairs_1.generateSeed)({ entropy });
        this._account.keypair = (0, ripple_keypairs_1.deriveKeypair)(this._account.familySeed);
        this._account.address = (0, ripple_keypairs_1.deriveAddress)(this._account.keypair.publicKey);
      } catch (error) {
        let message2 = "Unknown Error";
        if (error instanceof Error) message2 = error.message;
        throw new Error(message2);
      }
    }
  };
  exports.Account = Account;
  function validateLengths(secretNumbers) {
    if (secretNumbers.length !== 8) throw new Error("Secret must have 8 numbers");
    secretNumbers.forEach((num$1) => {
      if (num$1.length !== 6) throw new Error("Each secret number must be 6 digits");
    });
  }
} });
var require_dist$4 = __commonJS$1({ "../../node_modules/.pnpm/@xrplf+secret-numbers@1.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@xrplf/secret-numbers/dist/index.js"(exports) {
  var __createBinding$1 = Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
      enumerable: true,
      get: function() {
        return m[k];
      }
    };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  };
  var __exportStar$1 = function(m, exports$1) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding$1(exports$1, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar$1(require_Account(), exports);
  __exportStar$1(require_utils$a(), exports);
} });
var require_walletFromSecretNumbers = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/Wallet/walletFromSecretNumbers.js"(exports) {
  var __importDefault$1 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.walletFromSecretNumbers = void 0;
  const secret_numbers_1 = require_dist$4();
  const ECDSA_1$1 = __importDefault$1(require_ECDSA());
  const _1 = require_Wallet();
  function walletFromSecretNumbers(secretNumbers, opts) {
    var _a;
    const secret = new secret_numbers_1.Account(secretNumbers).getFamilySeed();
    const updatedOpts = {
      masterAddress: void 0,
      algorithm: void 0
    };
    if (opts === void 0) updatedOpts.algorithm = ECDSA_1$1.default.secp256k1;
    else {
      updatedOpts.masterAddress = opts.masterAddress;
      updatedOpts.algorithm = (_a = opts.algorithm) !== null && _a !== void 0 ? _a : ECDSA_1$1.default.secp256k1;
    }
    return _1.Wallet.fromSecret(secret, updatedOpts);
  }
  exports.walletFromSecretNumbers = walletFromSecretNumbers;
} });
var require_npm = __commonJS$1({ "../../node_modules/.pnpm/xrpl@4.3.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/xrpl/dist/npm/index.js"(exports) {
  var __createBinding = Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
      enumerable: true,
      get: function() {
        return m[k];
      }
    };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  };
  var __exportStar = function(m, exports$1) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
  };
  var __importDefault = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.rfc1751MnemonicToKey = exports.keyToRFC1751Mnemonic = exports.walletFromSecretNumbers = exports.Wallet = exports.ECDSA = exports.Client = void 0;
  var client_1 = require_client();
  Object.defineProperty(exports, "Client", {
    enumerable: true,
    get: function() {
      return client_1.Client;
    }
  });
  __exportStar(require_models(), exports);
  __exportStar(require_utils$3$1(), exports);
  var ECDSA_1 = require_ECDSA();
  Object.defineProperty(exports, "ECDSA", {
    enumerable: true,
    get: function() {
      return __importDefault(ECDSA_1).default;
    }
  });
  __exportStar(require_errors(), exports);
  var Wallet_1 = require_Wallet();
  Object.defineProperty(exports, "Wallet", {
    enumerable: true,
    get: function() {
      return Wallet_1.Wallet;
    }
  });
  var walletFromSecretNumbers_1 = require_walletFromSecretNumbers();
  Object.defineProperty(exports, "walletFromSecretNumbers", {
    enumerable: true,
    get: function() {
      return walletFromSecretNumbers_1.walletFromSecretNumbers;
    }
  });
  var rfc1751_1 = require_rfc1751();
  Object.defineProperty(exports, "keyToRFC1751Mnemonic", {
    enumerable: true,
    get: function() {
      return rfc1751_1.keyToRFC1751Mnemonic;
    }
  });
  Object.defineProperty(exports, "rfc1751MnemonicToKey", {
    enumerable: true,
    get: function() {
      return rfc1751_1.rfc1751MnemonicToKey;
    }
  });
  __exportStar(require_signer(), exports);
} });
var import_npm = __toESM$1(require_npm());
function createXummPayload(message2) {
  const memoData = Buffer.from(message2).toString("hex");
  return {
    custom_meta: { instruction: message2 },
    txjson: {
      TransactionType: "SignIn",
      Memos: [{ Memo: {
        MemoData: memoData,
        MemoType: Buffer.from("idOS").toString("hex")
      } }]
    }
  };
}
function signXummTx(xummInstance, payload) {
  return new Promise((resolve) => {
    xummInstance.payload?.createAndSubscribe(payload, async (event) => {
      if (!event.payload.response.hex) return;
      const hex = event.payload.response.hex;
      resolve(hex);
    });
  });
}
async function getXummPublicKey(wallet) {
  const payload = createXummPayload("Sign request from idOS");
  const txHash = await signXummTx(wallet, payload);
  const decodedTx = (0, import_npm.decode)(txHash);
  return decodedTx.SigningPubKey;
}
function signGemWalletTx(gemWalletInstance, message2) {
  return gemWalletInstance.signMessage(message2).then((response) => response.result?.signedMessage);
}
async function getGemWalletPublicKey(wallet) {
  if ("isInstalled" in wallet) {
    await wallet.isInstalled();
    const { publicKey, address } = await wallet.getPublicKey().then((res) => res.result);
    return {
      address,
      publicKey
    };
  }
}
async function getXrpAddress(wallet) {
  if ("isInstalled" in wallet) {
    await wallet.isInstalled();
    return wallet.getAddress().then((response) => response.result?.address);
  }
  return wallet.user.account;
}
function looksLikeXrpWallet(wallet) {
  return wallet !== null && typeof wallet === "object" && ("authorize" in wallet || "isInstalled" in wallet);
}
async function getXrpWalletType(object) {
  if ("authorize" in object) return "Xumm";
  if ("isInstalled" in object) return "GemWallet";
  throw new Error("Unknown wallet type");
}
async function getXrpTxHash(message2, wallet) {
  let messageString;
  const xrpWalletType = await getXrpWalletType(wallet);
  messageString = typeof message2 === "string" ? message2 : Buffer.from(message2).toString("utf8");
  if (xrpWalletType === "Xumm") {
    const memoData = Buffer.from(messageString).toString("hex");
    const payload = {
      custom_meta: { instruction: messageString },
      txjson: {
        TransactionType: "SignIn",
        Memos: [{ Memo: {
          MemoData: memoData,
          MemoType: Buffer.from("idOS").toString("hex")
        } }]
      }
    };
    const xummTx = await signXummTx(wallet, payload);
    console.log("xummTx", xummTx);
  } else if (xrpWalletType === "GemWallet") {
    const signature2 = await signGemWalletTx(wallet, messageString);
    if (!signature2) throw new Error("Failed to sign transaction with GemWallet");
    return signature2;
  }
}
async function getXrpPublicKey(wallet) {
  const xrpWalletType = await getXrpWalletType(wallet);
  if (xrpWalletType === "Xumm") {
    const publicKey = await getXummPublicKey(wallet);
    const address = await getXrpAddress(wallet);
    return {
      address,
      publicKey
    };
  }
  return getGemWalletPublicKey(wallet);
}
async function createXrpKwilSigner(wallet, currentAddress, store, kwilClient, walletPublicKey) {
  const storedAddress = store.get("signer-address");
  const storePublicKey = store.get("signer-public-key");
  if (storedAddress !== currentAddress || storePublicKey && storePublicKey !== walletPublicKey) try {
    console.log("logoutKGW", kwilClient);
  } catch (error) {
    console.error("Failed to logout KGW:", error);
  }
  store.set("signer-address", currentAddress);
  store.set("signer-public-key", walletPublicKey);
  const signer = async (message2) => {
    const signature2 = await getXrpTxHash(message2, wallet);
    if (!signature2) throw new Error("Failed to sign transaction with XRP");
    return Buffer.from(signature2, "hex");
  };
  return new distExports.KwilSigner(signer, walletPublicKey, "xrpl");
}
__toESM$1(require_dist$2());
__toESM$1(require_nacl_fast());
async function createClientKwilSigner(store, kwilClient, wallet) {
  if ("connect" in wallet && "address" in wallet) {
    wallet = wallet;
    const currentAddress = await wallet.getAddress();
    const storedAddress = store.get("signer-address");
    if (storedAddress !== currentAddress) {
      store.set("signer-address", currentAddress);
      try {
        await kwilClient.client.auth.logoutKGW();
      } catch (error) {
        console.log("error logoutKGW", error);
      }
    }
    return [new distExports.KwilSigner(wallet, currentAddress), currentAddress];
  }
  if (looksLikeNearWallet(wallet)) {
    const accountId = (await wallet.getAccounts())[0].accountId;
    return [await createNearWalletKwilSigner(wallet, accountId, store, kwilClient), accountId];
  }
  if (looksLikeXrpWallet(wallet)) {
    const { address: currentAddress, publicKey: walletPublicKey } = await getXrpPublicKey(wallet);
    if (!currentAddress) throw new Error("Failed to get XRP address");
    return [await createXrpKwilSigner(wallet, currentAddress, store, kwilClient, walletPublicKey), currentAddress];
  }
  return ((_) => {
    throw new Error("Invalid `signer` type");
  })();
}
var Store = class {
  keyPrefix = "idOS-";
  storage;
  REMEMBER_DURATION_KEY = "storage-expiration";
  constructor(storage) {
    this.storage = storage;
    if (this.hasRememberDurationElapsed()) this.reset();
  }
  #setLocalStorage(key, value) {
    this.storage.setItem(`${this.keyPrefix}${key}`, value);
  }
  #getLocalStorage(key) {
    return this.storage.getItem(`${this.keyPrefix}${key}`);
  }
  #removeLocalStorage(key) {
    this.storage.removeItem(`${this.keyPrefix}${key}`);
  }
  pipeCodec({ encode: encode$5, decode: decode$5 }) {
    return {
      ...this,
      get: (key) => {
        const result = this.get(key);
        if (result) return decode$5(result);
      },
      set: (key, value) => this.set.call(this, key, encode$5(value))
    };
  }
  get(key) {
    const value = this.#getLocalStorage(key);
    if (!value) return void 0;
    return JSON.parse(value);
  }
  setRememberDuration(days) {
    const daysNumber = !days || Number.isNaN(Number(days)) ? void 0 : Number.parseInt(days.toString());
    if (!daysNumber) {
      this.#removeLocalStorage(this.REMEMBER_DURATION_KEY);
      return;
    }
    const date = /* @__PURE__ */ new Date();
    date.setTime(date.getTime() + daysNumber * 24 * 60 * 60 * 1e3);
    this.#setLocalStorage(this.REMEMBER_DURATION_KEY, JSON.stringify(date.toISOString()));
  }
  hasRememberDurationElapsed() {
    const value = this.#getLocalStorage(this.REMEMBER_DURATION_KEY);
    if (!value) return false;
    let str;
    try {
      str = JSON.parse(value);
    } catch (_) {
      this.#removeLocalStorage(this.REMEMBER_DURATION_KEY);
      return false;
    }
    const expires = Date.parse(str);
    if (Number.isNaN(expires)) {
      this.#removeLocalStorage(this.REMEMBER_DURATION_KEY);
      return false;
    }
    return expires < Date.now();
  }
  set(key, value) {
    if (!key || typeof key !== "string") throw new Error(`Bad key: ${key}`);
    if (!value) return;
    this.#setLocalStorage(key, JSON.stringify(value));
  }
  reset() {
    for (const key of Object.keys(this.storage)) if (key.startsWith(this.keyPrefix)) this.storage.removeItem(key);
  }
};
var import_nacl_fast = __toESM$1(require_nacl_fast());
async function buildInsertableIDOSCredential(userId, publicNotes, content, recipientEncryptionPublicKey, encryptorPublicKey) {
  invariant$1(recipientEncryptionPublicKey, "Missing `recipientEncryptionPublicKey`");
  invariant$1(encryptorPublicKey, "Missing `encryptorPublicKey`");
  const ephemeralAuthenticationKeyPair = import_nacl_fast.default.sign.keyPair();
  const publicNotesSignature = import_nacl_fast.default.sign.detached(encode$1$1(publicNotes), ephemeralAuthenticationKeyPair.secretKey);
  return {
    user_id: userId,
    content,
    public_notes: publicNotes,
    public_notes_signature: encode$3(publicNotesSignature),
    broader_signature: encode$3(import_nacl_fast.default.sign.detached(Uint8Array.from([...publicNotesSignature, ...decode$3(content)]), ephemeralAuthenticationKeyPair.secretKey)),
    issuer_auth_public_key: encode$2$1(ephemeralAuthenticationKeyPair.publicKey, true),
    encryptor_public_key: encryptorPublicKey
  };
}
var IframeEnclave = class {
  options;
  container;
  iframe;
  hostUrl;
  constructor(options) {
    const { container, ...other } = options;
    this.container = container;
    this.options = other;
    this.hostUrl = new URL(other.url ?? "https://enclave.idos.network");
    this.iframe = document.createElement("iframe");
    this.iframe.id = "idos-enclave-iframe";
  }
  async load() {
    await this.loadEnclave();
    await this.requestToEnclave({ configure: this.options });
  }
  async reconfigure(options) {
    Object.assign(this.options, options);
    await this.requestToEnclave({ configure: this.options });
  }
  async ready(userId, expectedUserEncryptionPublicKey) {
    let { encryptionPublicKey: userEncryptionPublicKey } = await this.requestToEnclave({ storage: {
      userId,
      expectedUserEncryptionPublicKey
    } });
    while (!userEncryptionPublicKey) {
      this.showEnclave();
      try {
        userEncryptionPublicKey = await this.requestToEnclave({ keys: {} });
      } catch (e) {
        if (this.options.throwOnUserCancelUnlock) throw e;
      } finally {
        this.hideEnclave();
      }
    }
    return userEncryptionPublicKey;
  }
  async reset() {
    this.requestToEnclave({ reset: {} });
  }
  async confirm(message2) {
    this.showEnclave();
    return this.requestToEnclave({ confirm: { message: message2 } }).then((response) => {
      this.hideEnclave();
      return response;
    });
  }
  async encrypt(message2, receiverPublicKey) {
    return this.requestToEnclave({ encrypt: {
      message: message2,
      receiverPublicKey
    } });
  }
  async decrypt(message2, senderPublicKey) {
    return this.requestToEnclave({ decrypt: {
      fullMessage: message2,
      senderPublicKey
    } });
  }
  filterCredentials(credentials, privateFieldFilters) {
    return this.requestToEnclave({ filterCredentials: {
      credentials,
      privateFieldFilters
    } });
  }
  async loadEnclave() {
    const container = document.querySelector(this.container) || throwNewError(Error, `Can't find container with selector ${this.container}`);
    const permissionsPolicies = ["publickey-credentials-get", "storage-access"];
    const liftedSandboxRestrictions = [
      "forms",
      "modals",
      "popups",
      "popups-to-escape-sandbox",
      "same-origin",
      "scripts"
    ].map((toLift) => `allow-${toLift}`);
    const referrerPolicy = "origin";
    const styles = {
      "aspect-ratio": "4/1",
      "background-color": "transparent",
      border: "none",
      display: "block",
      width: "100%"
    };
    this.iframe.allow = permissionsPolicies.join("; ");
    this.iframe.referrerPolicy = referrerPolicy;
    this.iframe.sandbox.add(...liftedSandboxRestrictions);
    this.iframe.src = this.hostUrl.toString();
    for (const [k, v] of Object.entries(styles)) this.iframe.style.setProperty(k, v);
    let el;
    while (el = document.getElementById(this.iframe.id)) {
      console.log("reinstalling idOS iframe...");
      container.removeChild(el);
    }
    container.appendChild(this.iframe);
    return new Promise((resolve) => this.iframe.addEventListener("load", () => {
      resolve();
    }, { once: true }));
  }
  showEnclave() {
    this.iframe.parentElement.classList.add("visible");
  }
  hideEnclave() {
    this.iframe.parentElement.classList.remove("visible");
  }
  async requestToEnclave(request) {
    return new Promise((resolve, reject) => {
      const { port1, port2 } = new MessageChannel();
      port1.onmessage = ({ data: data2 }) => {
        port1.close();
        data2.error ? reject(data2.error) : resolve(data2.result);
      };
      this.iframe.contentWindow.postMessage(request, this.hostUrl.origin, [port2]);
    });
  }
  async backupPasswordOrSecret() {
    const abortController = new AbortController();
    this.showEnclave();
    window.addEventListener("message", async (event) => {
      if (event.data.type !== "idOS:store" || event.origin !== this.hostUrl.origin) return;
      let status = "";
      try {
        status = "success";
        this.hideEnclave();
      } catch (_) {
        status = "failure";
        this.hideEnclave();
      }
      event.ports[0].postMessage({ result: {
        type: "idOS:store",
        status
      } });
      event.ports[0].close();
      abortController.abort();
    }, { signal: abortController.signal });
    try {
      await this.requestToEnclave({ backupPasswordOrSecret: {} });
    } catch (error) {
      console.error(error);
    } finally {
      this.hideEnclave();
    }
  }
  async discoverUserEncryptionPublicKey(userId) {
    if (this.options.mode !== "new") throw new Error("You can only call `discoverUserEncryptionPublicKey` when mode is `new`.");
    const userEncryptionPublicKey = await this.ready(userId);
    return {
      userId,
      userEncryptionPublicKey: encode$3(userEncryptionPublicKey)
    };
  }
};
function throwNewError(ErrorClass, ...args) {
  throw new ErrorClass(...args);
}
var idOSClientConfiguration = class {
  state;
  chainId;
  nodeUrl;
  enclaveOptions;
  constructor(params) {
    this.state = "configuration";
    this.chainId = params.chainId;
    this.nodeUrl = params.nodeUrl;
    this.enclaveOptions = params.enclaveOptions;
  }
  async createClient() {
    return idOSClientIdle.fromConfig(this);
  }
};
var idOSClientIdle = class idOSClientIdle2 {
  state;
  store;
  kwilClient;
  enclaveProvider;
  constructor(store, kwilClient, enclaveProvider) {
    this.state = "idle";
    this.store = store;
    this.kwilClient = kwilClient;
    this.enclaveProvider = enclaveProvider;
  }
  static async fromConfig(params) {
    const store = new Store(window.localStorage);
    const kwilClient = await createWebKwilClient({
      nodeUrl: params.nodeUrl,
      chainId: params.chainId
    });
    const enclaveProvider = new IframeEnclave({ ...params.enclaveOptions });
    await enclaveProvider.load();
    return new idOSClientIdle2(store, kwilClient, enclaveProvider);
  }
  async addressHasProfile(address) {
    return hasProfile(this.kwilClient, address);
  }
  async withUserSigner(signer) {
    const [kwilSigner2, walletIdentifier] = await createClientKwilSigner(this.store, this.kwilClient, signer);
    this.kwilClient.setSigner(kwilSigner2);
    return new idOSClientWithUserSigner(this, signer, kwilSigner2, walletIdentifier);
  }
  async logOut() {
    return this;
  }
};
var idOSClientWithUserSigner = class {
  state;
  store;
  kwilClient;
  enclaveProvider;
  signer;
  kwilSigner;
  walletIdentifier;
  constructor(idOSClientIdle$1, signer, kwilSigner2, walletIdentifier) {
    this.state = "with-user-signer";
    this.store = idOSClientIdle$1.store;
    this.kwilClient = idOSClientIdle$1.kwilClient;
    this.enclaveProvider = idOSClientIdle$1.enclaveProvider;
    this.signer = signer;
    this.kwilSigner = kwilSigner2;
    this.walletIdentifier = walletIdentifier;
  }
  async logOut() {
    this.kwilClient.setSigner(void 0);
    return new idOSClientIdle(this.store, this.kwilClient, this.enclaveProvider);
  }
  async hasProfile() {
    return hasProfile(this.kwilClient, this.walletIdentifier);
  }
  async getUserEncryptionPublicKey(userId) {
    await this.enclaveProvider.reconfigure({ mode: "new" });
    const { userEncryptionPublicKey } = await this.enclaveProvider.discoverUserEncryptionPublicKey(userId);
    return userEncryptionPublicKey;
  }
  async logIn() {
    if (!await this.hasProfile()) throw new Error("User does not have a profile");
    await this.enclaveProvider.reconfigure({ mode: "existing" });
    const kwilUser = await getUserProfile(this.kwilClient);
    return new idOSClientLoggedIn(this, kwilUser);
  }
};
var idOSClientLoggedIn = class {
  state;
  store;
  kwilClient;
  enclaveProvider;
  signer;
  kwilSigner;
  walletIdentifier;
  user;
  constructor(idOSClientWithUserSigner$1, user) {
    this.state = "logged-in";
    this.store = idOSClientWithUserSigner$1.store;
    this.kwilClient = idOSClientWithUserSigner$1.kwilClient;
    this.enclaveProvider = idOSClientWithUserSigner$1.enclaveProvider;
    this.signer = idOSClientWithUserSigner$1.signer;
    this.kwilSigner = idOSClientWithUserSigner$1.kwilSigner;
    this.walletIdentifier = idOSClientWithUserSigner$1.walletIdentifier;
    this.user = user;
  }
  async logOut() {
    this.kwilClient.setSigner(void 0);
    return new idOSClientIdle(this.store, this.kwilClient, this.enclaveProvider);
  }
  async requestDWGMessage(params) {
    return requestDWGMessage(this.kwilClient, params);
  }
  async removeCredential(id) {
    return await removeCredential(this.kwilClient, id);
  }
  async getCredentialById(id) {
    return getCredentialById(this.kwilClient, id);
  }
  async shareCredential(credential) {
    return shareCredential(this.kwilClient, credential);
  }
  async getAllCredentials() {
    return getAllCredentials(this.kwilClient);
  }
  async getAccessGrantsOwned() {
    return getAccessGrantsOwned(this.kwilClient);
  }
  async getCredentialOwned(id) {
    return getCredentialOwned(this.kwilClient, id);
  }
  async getAttributes() {
    return getAttributes(this.kwilClient);
  }
  async createAttribute(attribute) {
    return createAttribute(this.kwilClient, attribute);
  }
  async getCredentialContentSha256Hash(id) {
    const credential = await getCredentialById(this.kwilClient, id);
    invariant$1(credential, `"idOSCredential" with id ${id} not found`);
    await this.enclaveProvider.ready(this.user.id, this.user.recipient_encryption_public_key);
    const plaintext = await this.enclaveProvider.decrypt(decode$3(credential.content), decode$3(credential.encryptor_public_key));
    return hexEncodeSha256Hash$1(plaintext);
  }
  async createCredentialCopy(id, consumerRecipientEncryptionPublicKey, consumerAddress, lockedUntil) {
    const originalCredential = await getCredentialById(this.kwilClient, id);
    invariant$1(originalCredential, `"idOSCredential" with id ${id} not found`);
    await this.enclaveProvider.ready(this.user.id, this.user.recipient_encryption_public_key);
    const decryptedContent = await this.enclaveProvider.decrypt(decode$3(originalCredential.content), decode$3(originalCredential.encryptor_public_key));
    const { content, encryptorPublicKey } = await this.enclaveProvider.encrypt(decryptedContent, decode$3(consumerRecipientEncryptionPublicKey));
    const insertableCredential = {
      ...await buildInsertableIDOSCredential(originalCredential.user_id, "", encode$3(content), consumerRecipientEncryptionPublicKey, encode$3(encryptorPublicKey)),
      grantee_wallet_identifier: consumerAddress,
      locked_until: lockedUntil
    };
    const copyId = crypto.randomUUID();
    await createCredentialCopy(this.kwilClient, {
      original_credential_id: originalCredential.id,
      ...originalCredential,
      ...insertableCredential,
      id: copyId
    });
    return { id: copyId };
  }
  async requestDAGMessage(params) {
    return requestDAGMessage(this.kwilClient, params);
  }
  async getGrants(params) {
    return {
      grants: await getGrants$1(this.kwilClient, params),
      totalCount: await this.getGrantsCount()
    };
  }
  async addWallets(params) {
    return addWallets(this.kwilClient, params);
  }
  async getGrantsCount() {
    return getGrantsCount$1(this.kwilClient);
  }
  async getSharedCredential(id) {
    return getSharedCredential$2(this.kwilClient, id);
  }
  async revokeAccessGrant(grantId) {
    return revokeAccessGrant(this.kwilClient, grantId);
  }
  async addWallet(params) {
    return addWallet(this.kwilClient, params);
  }
  async getWallets() {
    return getWallets(this.kwilClient);
  }
  async removeWallet(id) {
    return removeWallet(this.kwilClient, id);
  }
  async removeWallets(ids) {
    return removeWallets(this.kwilClient, ids);
  }
  async filterCredentials(requirements) {
    const matchCriteria = (content, criteria) => every(Object.entries(criteria), ([path, targetSet]) => targetSet.includes(get(content, path)));
    const credentials = await this.getAllCredentials();
    const originalCredentials = credentials.filter((cred) => !cred.original_id && !!cred.public_notes);
    let result = originalCredentials.filter((cred) => {
      return requirements.acceptedIssuers?.some((issuer) => issuer.authPublicKey === cred.issuer_auth_public_key);
    });
    const publicNotesFieldFilters = requirements.publicNotesFieldFilters;
    if (publicNotesFieldFilters) result = result.filter((credential) => {
      let publicNotes;
      try {
        publicNotes = JSON.parse(credential.public_notes);
      } catch (_) {
        throw new Error(`Credential ${credential.id} has non-JSON public notes".replace("{}`);
      }
      return matchCriteria(publicNotes, publicNotesFieldFilters.pick) && negate(() => matchCriteria(publicNotes, publicNotesFieldFilters.omit));
    });
    const privateFieldFilters = requirements.privateFieldFilters;
    if (privateFieldFilters) result = await this.enclaveProvider.filterCredentials(result, privateFieldFilters);
    return result;
  }
  async requestAccessGrant(credentialId, { consumerEncryptionPublicKey, consumerAuthPublicKey }) {
    const credential = await getCredentialById(this.kwilClient, credentialId);
    const contentHash = await this.getCredentialContentSha256Hash(credentialId);
    invariant$1(credential, `"idOSCredential" with id ${credentialId} not found`);
    const plaintextContent = decode$1$1(await this.enclaveProvider.decrypt(decode$3(credential.content), decode$3(credential.encryptor_public_key)));
    await this.enclaveProvider.ready(this.user.id, this.user.recipient_encryption_public_key);
    const { content, encryptorPublicKey } = await this.enclaveProvider.encrypt(encode$1$1(plaintextContent), decode$3(consumerEncryptionPublicKey));
    const insertableCredential = {
      ...credential,
      ...await buildInsertableIDOSCredential(credential.user_id, "", encode$3(content), consumerAuthPublicKey, encode$3(encryptorPublicKey)),
      original_credential_id: credential.id,
      id: crypto.randomUUID(),
      grantee_wallet_identifier: consumerAuthPublicKey,
      locked_until: 0,
      content_hash: contentHash
    };
    await this.shareCredential(insertableCredential);
    return insertableCredential;
  }
};
function createIDOSClient(params) {
  return new idOSClientConfiguration({
    nodeUrl: params.nodeUrl,
    enclaveOptions: params.enclaveOptions
  });
}
const __vite_import_meta_env__ = { "BASE_URL": "/", "DEV": false, "MODE": "production", "PROD": true, "SSR": true };
const commonEnvSchema = z.object({
  IDOS_ENCRYPTION_PUBLIC_KEY: z.string(),
  IDOS_NODE_URL: z.string(),
  IDOS_PUBLIC_KEY: z.string(),
  KRAKEN_API_URL: z.string(),
  KRAKEN_ISSUER_PUBLIC_KEY: z.string(),
  KRAKEN_LEVEL: z.string()
});
function buildEnv$1() {
  try {
    const envWithoutPrefix = Object.entries(__vite_import_meta_env__).reduce(
      (acc, [key, value]) => {
        if (key.startsWith("VITE_")) {
          acc[key.replace("VITE_", "")] = value;
        }
        return acc;
      },
      {}
    );
    return commonEnvSchema.parse({
      ...envWithoutPrefix,
      KRAKEN_LEVEL: envWithoutPrefix.KRAKEN_LEVEL ?? "plus+liveness+idos"
    });
  } catch (error) {
    console.error("Warning: invalid client env vars!");
    console.error(error);
    return {};
  }
}
const COMMON_ENV = buildEnv$1();
const actors = {
  createClient: fromPromise(async () => {
    const config = await createIDOSClient({
      enclaveOptions: { container: "#idOS-enclave" },
      nodeUrl: COMMON_ENV.IDOS_NODE_URL
    });
    const idleClient = await config.createClient();
    const signer = await new ethers.BrowserProvider(window.ethereum).getSigner();
    const withUserSigner = await idleClient.withUserSigner(signer);
    return withUserSigner;
  }),
  checkProfile: fromPromise(async ({ input }) => {
    if (!input) {
      throw new Error("Client not found");
    }
    const hasProfile2 = await input.hasProfile();
    if (!hasProfile2) {
      throw new Error("No profile found");
    }
    return hasProfile2;
  }),
  loginClient: fromPromise(async ({ input }) => {
    if (!input) {
      throw new Error("Client not found");
    }
    return await input.logIn();
  }),
  startKYC: fromPromise(async () => {
    const kycUrl = await fetch("/app/kyc/link");
    const kycUrlData = await kycUrl.json();
    return kycUrlData.url;
  }),
  createSharableToken: fromPromise(async ({ input }) => {
    if (!input) {
      throw new Error("Credential not found");
    }
    const kycUrl = await fetch(`/app/kyc/token?credentialId=${input.id}`);
    if (kycUrl.status !== 200) {
      throw new Error("KYC API is not available. Please try again later.");
    }
    const tokenData = await kycUrl.json();
    return tokenData.token;
  }),
  findCredential: fromPromise(async ({ input }) => {
    if (!input) {
      throw new Error("Client not found");
    }
    const credentials = await input.filterCredentials({
      acceptedIssuers: [
        {
          // Kraken
          authPublicKey: COMMON_ENV.KRAKEN_ISSUER_PUBLIC_KEY
        }
      ],
      publicNotesFieldFilters: {
        pick: { level: [COMMON_ENV.KRAKEN_LEVEL] },
        omit: {}
      }
    });
    if (credentials.length === 0) {
      throw new Error("No credentials found, start the KYC process");
    }
    return credentials[0];
  }),
  requestAccessGrant: fromPromise(
    async ({
      input
    }) => {
      if (!input.client) {
        throw new Error("Client not found");
      }
      if (!input.credential) {
        throw new Error("No credential found");
      }
      const id = input.credential.id;
      await input.client.enclaveProvider.reset();
      const sharedCredential = await input.client.requestAccessGrant(id, {
        consumerEncryptionPublicKey: COMMON_ENV.IDOS_ENCRYPTION_PUBLIC_KEY,
        consumerAuthPublicKey: COMMON_ENV.IDOS_PUBLIC_KEY
      });
      return sharedCredential;
    }
  ),
  revokeAccessGrant: fromPromise(
    async ({
      input
    }) => {
      if (!input.client || !input.sharedCredential) {
        throw new Error("Client or access grant not found");
      }
      const accessGrants = await input.client.getAccessGrantsOwned();
      const accessGrant = accessGrants.find((ag) => ag.data_id === input.sharedCredential?.id);
      if (!accessGrant) {
        throw new Error("Access grant not found");
      }
      await input.client.revokeAccessGrant(accessGrant.id);
      return true;
    }
  ),
  createHifiTocLink: fromPromise(async () => {
    const hifiTocLink = await fetch("/app/kyc/hifi/tos");
    if (hifiTocLink.status !== 200) {
      throw new Error("Hifi API is not available. Please try again later.");
    }
    const data2 = await hifiTocLink.json();
    return data2.link;
  }),
  verifyHifiTos: fromPromise(
    async ({
      input
    }) => {
      if (!input.hifiTosId || !input.sharedCredential) {
        throw new Error("Hifi TOS ID or Shared credentials not found");
      }
      const hifiUrl = await fetch(
        `/app/kyc/hifi/link?credentialId=${input.sharedCredential.id}&signedAgreementId=${input.hifiTosId}`
      );
      if (hifiUrl.status !== 200) {
        const text = await hifiUrl.text();
        throw new Error(`Hifi API is not available. Please try again later. ${text}`);
      }
      const data2 = await hifiUrl.json();
      return data2.url;
    }
  ),
  getHifiKycStatus: fromPromise(async () => {
    const hifiKycStatus = await fetch("/app/kyc/hifi/status");
    if (hifiKycStatus.status !== 200) {
      throw new Error("Hifi API is not available. Please try again later.");
    }
    const data2 = await hifiKycStatus.json();
    if (data2.status !== "ACTIVE") {
      throw new Error("KYC is not active, please try again later.");
    }
    return data2.status;
  }),
  createOnRampAccount: fromPromise(async () => {
    const onRampAccount = await fetch("/app/kyc/hifi/account");
    if (onRampAccount.status !== 200) {
      throw new Error("Hifi API is not available. Please try again later.");
    }
    return await onRampAccount.json();
  }),
  createNoahCustomer: fromPromise(async ({ input }) => {
    if (!input) {
      throw new Error("Credential not found");
    }
    const customer = await fetch(`/app/kyc/noah/link?credentialId=${input.id}`);
    if (customer.status !== 200) {
      throw new Error("Noah API is not available. Please try again later.");
    }
    const data2 = await customer.json();
    return data2.url;
  }),
  fetchUserData: fromPromise(async ({ input }) => {
    if (!input) {
      throw new Error("Credential not found");
    }
    const data2 = await fetch(`/app/kyc/data?credentialId=${input.id}`);
    return await data2.json();
  })
};
const machine = setup({
  types: {
    context: {}
  },
  actors,
  actions
}).createMachine({
  id: "idos",
  initial: "notConfigured",
  context: {
    walletAddress: null,
    provider: null,
    kycUrl: null,
    client: null,
    profile: null,
    loggedInClient: null,
    sharableToken: null,
    credential: null,
    sharedCredential: null,
    findCredentialAttempts: 0,
    data: null,
    noahUrl: null,
    hifiTosUrl: null,
    hifiTosId: null,
    hifiUrl: null,
    hifiKycStatus: null,
    getHifiKycStatusAttempts: 0,
    onRampAccount: null
  },
  states: {
    notConfigured: {
      on: {
        configure: {
          actions: ["configure"],
          target: "createClient"
        }
      }
    },
    createClient: {
      invoke: {
        id: "createClient",
        src: "createClient",
        onDone: {
          target: "checkProfile",
          actions: ["setClient"]
        },
        onError: {
          target: "error",
          actions: ["setErrorMessage"]
        }
      }
    },
    checkProfile: {
      invoke: {
        id: "checkProfile",
        src: "checkProfile",
        input: ({ context }) => context.client,
        onDone: {
          target: "login",
          actions: assign({
            profile: true
          })
        },
        onError: {
          target: "startKYC",
          actions: assign({
            profile: false
          })
        }
      }
    },
    startKYC: {
      invoke: {
        id: "startKYC",
        src: "startKYC",
        onDone: {
          target: "waitForKYC",
          actions: "setKycUrl"
        },
        onError: {
          target: "error",
          actions: ["setErrorMessage"]
        }
      }
    },
    waitForKYC: {
      on: {
        kycCompleted: {
          target: "login",
          actions: "setKycUrl"
        }
      }
    },
    login: {
      invoke: {
        id: "loginClient",
        src: "loginClient",
        input: ({ context }) => context.client,
        onDone: {
          target: "findCredential",
          actions: ["setLoggedInClient"]
        },
        onError: {
          target: "error",
          actions: ["setErrorMessage"]
        }
      }
    },
    findCredential: {
      invoke: {
        id: "findCredential",
        src: "findCredential",
        input: ({ context }) => context.loggedInClient,
        onDone: [
          {
            actions: ["setCredential"],
            target: "requestAccessGrant"
          }
        ],
        onError: [
          {
            guard: ({ context }) => context.kycUrl !== null,
            target: "waitForCredential",
            actions: ["incrementFindCredentialAttempts"]
          },
          {
            guard: ({ context }) => context.kycUrl === null,
            target: "startKYC"
          }
        ]
      }
    },
    waitForCredential: {
      after: {
        2e3: "findCredential"
      },
      always: {
        guard: ({ context }) => context.findCredentialAttempts >= 40,
        target: "error",
        actions: ["setErrorMessage"]
      }
    },
    requestAccessGrant: {
      invoke: {
        id: "requestAccessGrant",
        src: "requestAccessGrant",
        input: ({ context }) => ({
          client: context.loggedInClient,
          credential: context.credential
        }),
        onDone: {
          actions: ["setSharedCredential"],
          target: "accessGranted"
        },
        onError: {
          target: "error",
          actions: ["setErrorMessage"]
        }
      }
    },
    accessGranted: {
      on: {
        getSharableToken: {
          target: "createSharableToken"
        },
        fetchUserData: {
          target: "fetchUserData"
        },
        createNoahCustomer: {
          target: "createNoahCustomer"
        },
        startHifi: {
          target: "startHifi"
        }
      }
    },
    startHifi: {
      invoke: {
        id: "createHifiTocLink",
        src: "createHifiTocLink",
        onDone: {
          target: "hifiTosFetched",
          actions: ["setHifiTosUrl"]
        },
        onError: {
          target: "error",
          actions: ["setErrorMessage"]
        }
      }
    },
    hifiTosFetched: {
      on: {
        acceptHifiTos: {
          target: "verifyHifiTos",
          actions: ["setHifiTosId"]
        }
      }
    },
    verifyHifiTos: {
      invoke: {
        id: "verifyHifiTos",
        src: "verifyHifiTos",
        input: ({ context }) => ({
          hifiTosId: context.hifiTosId,
          sharedCredential: context.sharedCredential
        }),
        onDone: {
          target: "getHifiKycStatus",
          actions: ["setHifiUrl"]
        },
        onError: {
          target: "error",
          actions: ["setErrorMessage"]
        }
      }
    },
    getHifiKycStatus: {
      invoke: {
        id: "getHifiKycStatus",
        src: "getHifiKycStatus",
        onDone: [
          {
            target: "createOnRampAccount"
          }
        ],
        onError: [
          {
            target: "waitForHifiKycStatus",
            actions: ["incrementGetHifiKycStatusAttempts"]
          }
        ]
      }
    },
    waitForHifiKycStatus: {
      after: {
        2e3: "getHifiKycStatus"
      },
      always: {
        guard: ({ context }) => context.getHifiKycStatusAttempts >= 40,
        target: "error",
        actions: ["setErrorMessage"]
      }
    },
    createOnRampAccount: {
      invoke: {
        id: "createOnRampAccount",
        src: "createOnRampAccount",
        onDone: {
          target: "dataOrTokenFetched",
          actions: ["setOnRampAccount"]
        },
        onError: {
          target: "error",
          actions: ["setErrorMessage"]
        }
      }
    },
    createNoahCustomer: {
      invoke: {
        id: "createNoahCustomer",
        src: "createNoahCustomer",
        input: ({ context }) => context.sharedCredential,
        onDone: {
          target: "dataOrTokenFetched",
          actions: ["setNoahUrl"]
        },
        onError: {
          target: "error",
          actions: ["setErrorMessage"]
        }
      }
    },
    createSharableToken: {
      invoke: {
        id: "createSharableToken",
        src: "createSharableToken",
        input: ({ context }) => context.sharedCredential,
        onDone: {
          target: "dataOrTokenFetched",
          actions: ["setSharableToken"]
        },
        onError: {
          target: "error",
          actions: ["setErrorMessage"]
        }
      }
    },
    fetchUserData: {
      invoke: {
        src: "createSharableToken",
        input: ({ context }) => context.sharedCredential,
        onDone: {
          target: "dataOrTokenFetched",
          actions: ["setUserData"]
        },
        onError: {
          target: "error",
          actions: ["setErrorMessage"]
        }
      }
    },
    dataOrTokenFetched: {
      on: {
        revokeAccessGrant: {
          target: "revokeAccessGrant"
        }
      }
    },
    revokeAccessGrant: {
      invoke: {
        id: "revokeAccessGrant",
        src: "revokeAccessGrant",
        input: ({ context }) => ({
          client: context.loggedInClient,
          sharedCredential: context.sharedCredential
        }),
        onDone: {
          target: "notConfigured",
          actions: ["reset"]
        },
        onError: {
          target: "error",
          actions: ["setErrorMessage"]
        }
      }
    },
    done: {
      // todo
    },
    error: {
      type: "final"
    }
  },
  on: {
    RESET: {
      actions: ["reset"],
      target: ".notConfigured"
    }
  }
});
const MachineContext = createActorContext(machine);
function MachineProvider({ children }) {
  return /* @__PURE__ */ jsx(MachineContext.Provider, { children });
}
const links = () => [{
  rel: "preconnect",
  href: "https://fonts.googleapis.com"
}, {
  rel: "preconnect",
  href: "https://fonts.gstatic.com",
  crossOrigin: "anonymous"
}, {
  rel: "stylesheet",
  href: "https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap"
}];
function Layout({
  children
}) {
  return /* @__PURE__ */ jsxs("html", {
    lang: "en",
    children: [/* @__PURE__ */ jsxs("head", {
      children: [/* @__PURE__ */ jsx("meta", {
        charSet: "utf-8"
      }), /* @__PURE__ */ jsx("meta", {
        name: "viewport",
        content: "width=device-width, initial-scale=1"
      }), /* @__PURE__ */ jsx(Meta, {}), /* @__PURE__ */ jsx(Links, {})]
    }), /* @__PURE__ */ jsxs("body", {
      children: [children, /* @__PURE__ */ jsx(ScrollRestoration, {}), /* @__PURE__ */ jsx(Scripts, {})]
    })]
  });
}
const root = UNSAFE_withComponentProps(function App() {
  return /* @__PURE__ */ jsx(SiweProvider, {
    children: /* @__PURE__ */ jsx(MachineProvider, {
      children: /* @__PURE__ */ jsx(Outlet, {})
    })
  });
});
const ErrorBoundary = UNSAFE_withErrorBoundaryProps(function ErrorBoundary2({
  error
}) {
  let message2 = "Oops!";
  let details = "An unexpected error occurred.";
  let stack;
  if (isRouteErrorResponse(error)) {
    message2 = error.status === 404 ? "404" : "Error";
    details = error.status === 404 ? "The requested page could not be found." : error.statusText || details;
  }
  return /* @__PURE__ */ jsxs("main", {
    className: "container mx-auto p-4 pt-16",
    children: [/* @__PURE__ */ jsx("h1", {
      children: message2
    }), /* @__PURE__ */ jsx("p", {
      children: details
    }), stack]
  });
});
const route0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ErrorBoundary,
  Layout,
  default: root,
  links
}, Symbol.toStringTag, { value: "Module" }));
const serverEnvSchema = z.object({
  IDOS_CONSUMER_SIGNER: z.string(),
  IDOS_RECIPIENT_ENC_PRIVATE_KEY: z.string(),
  NOAH_API_URL: z.string(),
  NOAH_API_KEY: z.string(),
  KRAKEN_API_URL: z.string(),
  KRAKEN_CLIENT_ID: z.string(),
  KRAKEN_ISSUER: z.string(),
  KRAKEN_PRIVATE_KEY: z.string(),
  KRAKEN_PUBLIC_KEY_MULTIBASE: z.string(),
  NODE_ENV: z.enum(["development", "test", "production"]),
  SECRET_KEY_BASE: z.string(),
  SECURE_AUTH_COOKIE: z.enum(["true", "false"]).transform((v) => v === "true"),
  HIFI_API_URL: z.string(),
  HIFI_API_KEY: z.string(),
  FILES_PRIVATE_KEY: z.string(),
  FILES_PUBLIC_KEY: z.string()
});
function buildEnv() {
  try {
    return serverEnvSchema.parse(process.env);
  } catch (error) {
    console.error("Warning: invalid server env vars!");
    console.error(error);
    return {};
  }
}
const SERVER_ENV = buildEnv();
const sessionStorage = createCookieSessionStorage({
  cookie: {
    name: "__session",
    secrets: [SERVER_ENV.SECRET_KEY_BASE],
    sameSite: "lax",
    path: "/",
    secure: SERVER_ENV.SECURE_AUTH_COOKIE,
    httpOnly: true
  }
});
function Welcome() {
  const { address, isAuthenticated, signIn, signOut } = useSiwe();
  return /* @__PURE__ */ jsx("main", { className: "flex min-h-screen items-center justify-center bg-white dark:bg-gray-950", children: /* @__PURE__ */ jsxs("div", { className: "flex flex-col items-center gap-8 p-8", children: [
    /* @__PURE__ */ jsxs("header", { className: "flex flex-col items-center gap-6", children: [
      /* @__PURE__ */ jsx("h1", { className: "text-center font-bold text-3xl text-gray-900 dark:text-white", children: "Welcome to Foxy Demo" }),
      /* @__PURE__ */ jsx("p", { className: "text-center text-gray-600 dark:text-gray-300", children: "Get started by logging in to your account" })
    ] }),
    /* @__PURE__ */ jsx(
      "button",
      {
        type: "button",
        className: "cursor-pointer rounded-lg bg-blue-600 px-8 py-4 font-semibold text-lg text-white transition-colors hover:bg-blue-700",
        onClick: () => isAuthenticated ? signOut() : signIn(),
        children: isAuthenticated ? `Disconnect (${address?.slice(0, 6)}...${address?.slice(-4)})` : "Login to continue"
      }
    )
  ] }) });
}
function meta({}) {
  return [{
    title: "Foxy Demo"
  }, {
    name: "description",
    content: "Welcome to Foxy Demo!"
  }];
}
async function loader$b({
  request
}) {
  const session = await sessionStorage.getSession(request.headers.get("Cookie"));
  const user = session.get("user");
  if (user?.isAuthenticated) {
    throw redirect("/app");
  }
  return null;
}
const home = UNSAFE_withComponentProps(function Home() {
  return /* @__PURE__ */ jsx("div", {
    className: "flex flex-col items-center gap-4",
    children: /* @__PURE__ */ jsx(Welcome, {})
  });
});
const route1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: home,
  loader: loader$b,
  meta
}, Symbol.toStringTag, { value: "Module" }));
async function loader$a({
  request
}) {
  const session = await sessionStorage.getSession(request.headers.get("Cookie"));
  const url = new URL(request.url);
  const address = url.searchParams.get("address");
  if (!address) {
    throw new Error("Address query parameter is required");
  }
  const uri2 = new URL(request.url);
  uri2.hash = "";
  uri2.search = "";
  uri2.pathname = "";
  const message2 = new SiweMessage({
    domain: url.hostname,
    address,
    statement: "Sign in with Ethereum to the app.",
    uri: uri2.toString(),
    version: "1",
    chainId: 1
  });
  const user = {
    address,
    message: message2.prepareMessage(),
    isAuthenticated: false
  };
  session.set("user", user);
  return new Response(JSON.stringify({
    user
  }), {
    headers: {
      "Content-Type": "application/json",
      "Set-Cookie": await sessionStorage.commitSession(session)
    }
  });
}
async function action({
  request
}) {
  const session = await sessionStorage.getSession(request.headers.get("Cookie"));
  const user = session.get("user");
  if (request.method === "DELETE") {
    session.unset("user");
    return redirect("/", {
      headers: {
        "Set-Cookie": await sessionStorage.commitSession(session)
      }
    });
  }
  if (!user) {
    throw new Error("No session found");
  }
  const {
    signature: signature2,
    address
  } = await request.json();
  if (!signature2 || !address) {
    throw new Error("Signature and address are required");
  }
  if (address.toLowerCase() !== user.address.toLowerCase()) {
    throw new Error("Address mismatch");
  }
  try {
    const message2 = new SiweMessage(user.message);
    const isValid = await message2.verify({
      signature: signature2
    });
    if (!isValid) {
      throw new Error("Invalid signature");
    }
    session.set("user", {
      ...user,
      signature: signature2,
      isAuthenticated: true
    });
    return redirect("/app", {
      headers: {
        "Set-Cookie": await sessionStorage.commitSession(session)
      }
    });
  } catch (error) {
    throw new Error("Signature verification failed");
  }
}
const route2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  action,
  loader: loader$a
}, Symbol.toStringTag, { value: "Module" }));
const generateFileUrl = (url, credentialId, fileType) => {
  const jwtData = {
    credentialId,
    fileType
  };
  const token = jwt.sign(jwtData, SERVER_ENV.FILES_PRIVATE_KEY, {
    algorithm: "ES512",
    expiresIn: "30m"
  });
  const fileUrl = new URL(url.toString());
  fileUrl.protocol = "https";
  fileUrl.pathname = "/file";
  fileUrl.searchParams.forEach((_value, key) => {
    fileUrl.searchParams.delete(key);
  });
  fileUrl.searchParams.delete("signedAgreementId");
  fileUrl.searchParams.set("token", token);
  return fileUrl.toString();
};
const verifyFileUrl = async (token) => {
  const decoded = jwt.verify(token, SERVER_ENV.FILES_PUBLIC_KEY, {
    algorithms: ["ES512"]
  });
  return decoded;
};
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod$1) => function() {
  return mod$1 || (0, cb[__getOwnPropNames(cb)[0]])((mod$1 = { exports: {} }).exports, mod$1), mod$1.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") for (var keys2 = __getOwnPropNames(from), i = 0, n = keys2.length, key; i < n; i++) {
    key = keys2[i];
    if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
      get: ((k) => from[k]).bind(null, key),
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    });
  }
  return to;
};
var __toESM = (mod$1, isNodeMode, target) => (target = mod$1 != null ? __create(__getProtoOf(mod$1)) : {}, __copyProps(__defProp(target, "default", {
  value: mod$1,
  enumerable: true
}), mod$1));
var __require = /* @__PURE__ */ createRequire(import.meta.url);
function encodeNibble(b) {
  let result = b + 48;
  result += 9 - b >>> 8 & 7;
  return String.fromCharCode(result);
}
function encodeNibbleLower(b) {
  let result = b + 48;
  result += 9 - b >>> 8 & 39;
  return String.fromCharCode(result);
}
const INVALID_HEX_NIBBLE = 256;
function decodeNibble(c) {
  let result = INVALID_HEX_NIBBLE;
  result += (47 - c & c - 58) >> 8 & -256 + c - 48;
  result += (64 - c & c - 71) >> 8 & -256 + c - 65 + 10;
  result += (96 - c & c - 103) >> 8 & -256 + c - 97 + 10;
  return result;
}
function encode$2(data2, lowerCase = false) {
  const enc = lowerCase ? encodeNibbleLower : encodeNibble;
  let s = "";
  for (let i = 0; i < data2.length; i++) {
    s += enc(data2[i] >>> 4);
    s += enc(data2[i] & 15);
  }
  return s;
}
function decode(hex) {
  if (hex.length === 0) return new Uint8Array(0);
  if (hex.length % 2 !== 0) throw new Error("hex: input string must be divisible by two");
  const result = new Uint8Array(hex.length / 2);
  let haveBad = 0;
  for (let i = 0; i < hex.length; i += 2) {
    let v0 = decodeNibble(hex.charCodeAt(i));
    let v12 = decodeNibble(hex.charCodeAt(i + 1));
    result[i / 2] = v0 << 4 | v12;
    haveBad |= v0 & INVALID_HEX_NIBBLE;
    haveBad |= v12 & INVALID_HEX_NIBBLE;
  }
  if (haveBad !== 0) throw new Error("hex: incorrect characters for decoding");
  return result;
}
function writeUint16BE(value, out = new Uint8Array(2), offset = 0) {
  out[offset + 0] = value >>> 8;
  out[offset + 1] = value >>> 0;
  return out;
}
function readUint32BE(array, offset = 0) {
  return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
}
function writeUint32BE(value, out = new Uint8Array(4), offset = 0) {
  out[offset + 0] = value >>> 24;
  out[offset + 1] = value >>> 16;
  out[offset + 2] = value >>> 8;
  out[offset + 3] = value >>> 0;
  return out;
}
function wipe(array) {
  for (let i = 0; i < array.length; i++) array[i] = 0;
  return array;
}
const DIGEST_LENGTH = 32;
const BLOCK_SIZE = 64;
var SHA256$12 = class {
  /** Length of hash output */
  digestLength = DIGEST_LENGTH;
  /** Block size */
  blockSize = BLOCK_SIZE;
  _state = new Int32Array(8);
  _temp = new Int32Array(64);
  _buffer = new Uint8Array(128);
  _bufferLength = 0;
  _bytesHashed = 0;
  _finished = false;
  constructor() {
    this.reset();
  }
  _initState() {
    this._state[0] = 1779033703;
    this._state[1] = 3144134277;
    this._state[2] = 1013904242;
    this._state[3] = 2773480762;
    this._state[4] = 1359893119;
    this._state[5] = 2600822924;
    this._state[6] = 528734635;
    this._state[7] = 1541459225;
  }
  /**
  * Resets hash state making it possible
  * to re-use this instance to hash other data.
  */
  reset() {
    this._initState();
    this._bufferLength = 0;
    this._bytesHashed = 0;
    this._finished = false;
    return this;
  }
  /**
  * Cleans internal buffers and resets hash state.
  */
  clean() {
    wipe(this._buffer);
    wipe(this._temp);
    this.reset();
  }
  /**
  * Updates hash state with the given data.
  *
  * Throws error when trying to update already finalized hash:
  * instance must be reset to update it again.
  */
  update(data2, dataLength = data2.length) {
    if (this._finished) throw new Error("SHA256: can't update because hash was finished.");
    let dataPos = 0;
    this._bytesHashed += dataLength;
    if (this._bufferLength > 0) {
      while (this._bufferLength < this.blockSize && dataLength > 0) {
        this._buffer[this._bufferLength++] = data2[dataPos++];
        dataLength--;
      }
      if (this._bufferLength === this.blockSize) {
        hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
        this._bufferLength = 0;
      }
    }
    if (dataLength >= this.blockSize) {
      dataPos = hashBlocks(this._temp, this._state, data2, dataPos, dataLength);
      dataLength %= this.blockSize;
    }
    while (dataLength > 0) {
      this._buffer[this._bufferLength++] = data2[dataPos++];
      dataLength--;
    }
    return this;
  }
  /**
  * Finalizes hash state and puts hash into out.
  * If hash was already finalized, puts the same value.
  */
  finish(out) {
    if (!this._finished) {
      const bytesHashed = this._bytesHashed;
      const left = this._bufferLength;
      const bitLenHi = bytesHashed / 536870912 | 0;
      const bitLenLo = bytesHashed << 3;
      const padLength = bytesHashed % 64 < 56 ? 64 : 128;
      this._buffer[left] = 128;
      for (let i = left + 1; i < padLength - 8; i++) this._buffer[i] = 0;
      writeUint32BE(bitLenHi, this._buffer, padLength - 8);
      writeUint32BE(bitLenLo, this._buffer, padLength - 4);
      hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
      this._finished = true;
    }
    for (let i = 0; i < this.digestLength / 4; i++) writeUint32BE(this._state[i], out, i * 4);
    return this;
  }
  /**
  * Returns the final hash digest.
  */
  digest() {
    const out = new Uint8Array(this.digestLength);
    this.finish(out);
    return out;
  }
  /**
  * Function useful for HMAC/PBKDF2 optimization.
  * Returns hash state to be used with restoreState().
  * Only chain value is saved, not buffers or other
  * state variables.
  */
  saveState() {
    if (this._finished) throw new Error("SHA256: cannot save finished state");
    return {
      state: new Int32Array(this._state),
      buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
      bufferLength: this._bufferLength,
      bytesHashed: this._bytesHashed
    };
  }
  /**
  * Function useful for HMAC/PBKDF2 optimization.
  * Restores state saved by saveState() and sets bytesHashed
  * to the given value.
  */
  restoreState(savedState) {
    this._state.set(savedState.state);
    this._bufferLength = savedState.bufferLength;
    if (savedState.buffer) this._buffer.set(savedState.buffer);
    this._bytesHashed = savedState.bytesHashed;
    this._finished = false;
    return this;
  }
  /**
  * Cleans state returned by saveState().
  */
  cleanSavedState(savedState) {
    wipe(savedState.state);
    if (savedState.buffer) wipe(savedState.buffer);
    savedState.bufferLength = 0;
    savedState.bytesHashed = 0;
  }
};
const K = new Int32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
function hashBlocks(w, v, p, pos, len) {
  while (len >= 64) {
    let a = v[0];
    let b = v[1];
    let c = v[2];
    let d = v[3];
    let e = v[4];
    let f = v[5];
    let g = v[6];
    let h = v[7];
    for (let i = 0; i < 16; i++) {
      let j = pos + i * 4;
      w[i] = readUint32BE(p, j);
    }
    for (let i = 16; i < 64; i++) {
      let u = w[i - 2];
      let t1 = (u >>> 17 | u << 15) ^ (u >>> 19 | u << 13) ^ u >>> 10;
      u = w[i - 15];
      let t2 = (u >>> 7 | u << 25) ^ (u >>> 18 | u << 14) ^ u >>> 3;
      w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);
    }
    for (let i = 0; i < 64; i++) {
      let t1 = (((e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7)) + (e & f ^ ~e & g) | 0) + (h + (K[i] + w[i] | 0) | 0) | 0;
      let t2 = ((a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10)) + (a & b ^ a & c ^ b & c) | 0;
      h = g;
      g = f;
      f = e;
      e = d + t1 | 0;
      d = c;
      c = b;
      b = a;
      a = t1 + t2 | 0;
    }
    v[0] += a;
    v[1] += b;
    v[2] += c;
    v[3] += d;
    v[4] += e;
    v[5] += f;
    v[6] += g;
    v[7] += h;
    pos += 64;
    len -= 64;
  }
  return pos;
}
function hash(data2) {
  const h = new SHA256$12();
  h.update(data2);
  const digest = h.digest();
  h.clean();
  return digest;
}
const INVALID_UTF16 = "utf8: invalid string";
const INVALID_UTF8 = "utf8: invalid source encoding";
function encode$1(s) {
  const arr = new Uint8Array(encodedLength(s));
  let pos = 0;
  for (let i = 0; i < s.length; i++) {
    let c = s.charCodeAt(i);
    if (c >= 55296 && c <= 56319) c = (c - 55296 << 10) + (s.charCodeAt(++i) - 56320) + 65536;
    if (c < 128) arr[pos++] = c;
    else if (c < 2048) {
      arr[pos++] = 192 | c >> 6;
      arr[pos++] = 128 | c & 63;
    } else if (c < 65536) {
      arr[pos++] = 224 | c >> 12;
      arr[pos++] = 128 | c >> 6 & 63;
      arr[pos++] = 128 | c & 63;
    } else {
      arr[pos++] = 240 | c >> 18;
      arr[pos++] = 128 | c >> 12 & 63;
      arr[pos++] = 128 | c >> 6 & 63;
      arr[pos++] = 128 | c & 63;
    }
  }
  return arr;
}
function encodedLength(s) {
  let result = 0;
  for (let i = 0; i < s.length; i++) {
    let c = s.charCodeAt(i);
    if (c >= 55296 && c <= 56319) {
      if (i === s.length - 1) throw new Error(INVALID_UTF16);
      i++;
      const c2 = s.charCodeAt(i);
      if (c2 < 56320 || c2 > 57343) throw new Error(INVALID_UTF16);
      c = (c - 55296 << 10) + (c2 - 56320) + 65536;
    }
    if (c < 128) result += 1;
    else if (c < 2048) result += 2;
    else if (c < 65536) result += 3;
    else result += 4;
  }
  return result;
}
function decode$1(arr) {
  const chars = [];
  for (let i = 0; i < arr.length; i++) {
    let b = arr[i];
    if (b & 128) {
      let min2;
      if (b < 224) {
        if (i >= arr.length) throw new Error(INVALID_UTF8);
        const n1 = arr[++i];
        if ((n1 & 192) !== 128) throw new Error(INVALID_UTF8);
        b = (b & 31) << 6 | n1 & 63;
        min2 = 128;
      } else if (b < 240) {
        if (i >= arr.length - 1) throw new Error(INVALID_UTF8);
        const n1 = arr[++i];
        const n2 = arr[++i];
        if ((n1 & 192) !== 128 || (n2 & 192) !== 128) throw new Error(INVALID_UTF8);
        b = (b & 15) << 12 | (n1 & 63) << 6 | n2 & 63;
        min2 = 2048;
      } else if (b < 248) {
        if (i >= arr.length - 2) throw new Error(INVALID_UTF8);
        const n1 = arr[++i];
        const n2 = arr[++i];
        const n3 = arr[++i];
        if ((n1 & 192) !== 128 || (n2 & 192) !== 128 || (n3 & 192) !== 128) throw new Error(INVALID_UTF8);
        b = (b & 15) << 18 | (n1 & 63) << 12 | (n2 & 63) << 6 | n3 & 63;
        min2 = 65536;
      } else throw new Error(INVALID_UTF8);
      if (b < min2 || b >= 55296 && b <= 57343) throw new Error(INVALID_UTF8);
      if (b >= 65536) {
        if (b > 1114111) throw new Error(INVALID_UTF8);
        b -= 65536;
        chars.push(String.fromCharCode(55296 | b >> 10));
        b = 56320 | b & 1023;
      }
    }
    chars.push(String.fromCharCode(b));
  }
  return chars.join("");
}
function base(ALPHABET$12) {
  if (ALPHABET$12.length >= 255) throw new TypeError("Alphabet too long");
  const BASE_MAP = new Uint8Array(256);
  for (let j = 0; j < BASE_MAP.length; j++) BASE_MAP[j] = 255;
  for (let i = 0; i < ALPHABET$12.length; i++) {
    const x = ALPHABET$12.charAt(i);
    const xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) throw new TypeError(x + " is ambiguous");
    BASE_MAP[xc] = i;
  }
  const BASE = ALPHABET$12.length;
  const LEADER = ALPHABET$12.charAt(0);
  const FACTOR = Math.log(BASE) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE);
  function encode$32(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    else if (Array.isArray(source)) source = Uint8Array.from(source);
    if (!(source instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (source.length === 0) return "";
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i = 0;
      for (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) throw new Error("Non-zero carry");
      length = i;
      pbegin++;
    }
    let it2 = size - length;
    while (it2 !== size && b58[it2] === 0) it2++;
    let str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) str += ALPHABET$12.charAt(b58[it2]);
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") throw new TypeError("Expected String");
    if (source.length === 0) return new Uint8Array();
    let psz = 0;
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size);
    while (source[psz]) {
      let carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) return;
      let i = 0;
      for (let it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) throw new Error("Non-zero carry");
      length = i;
      psz++;
    }
    let it4 = size - length;
    while (it4 !== size && b256[it4] === 0) it4++;
    const vch = new Uint8Array(zeroes + (size - it4));
    let j = zeroes;
    while (it4 !== size) vch[j++] = b256[it4++];
    return vch;
  }
  function decode$32(string) {
    const buffer = decodeUnsafe(string);
    if (buffer) return buffer;
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode: encode$32,
    decodeUnsafe,
    decode: decode$32
  };
}
var esm_default$1 = base;
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default = esm_default$1(ALPHABET);
const INVALID_BYTE = 256;
var Coder2 = class {
  _paddingCharacter;
  constructor(_paddingCharacter = "=") {
    this._paddingCharacter = _paddingCharacter;
  }
  encodedLength(length) {
    if (!this._paddingCharacter) return (length * 8 + 5) / 6 | 0;
    return (length + 2) / 3 * 4 | 0;
  }
  encode(data2) {
    let out = "";
    let i = 0;
    for (; i < data2.length - 2; i += 3) {
      let c = data2[i] << 16 | data2[i + 1] << 8 | data2[i + 2];
      out += this._encodeByte(c >>> 3 * 6 & 63);
      out += this._encodeByte(c >>> 2 * 6 & 63);
      out += this._encodeByte(c >>> 1 * 6 & 63);
      out += this._encodeByte(c >>> 0 & 63);
    }
    const left = data2.length - i;
    if (left > 0) {
      let c = data2[i] << 16 | (left === 2 ? data2[i + 1] << 8 : 0);
      out += this._encodeByte(c >>> 3 * 6 & 63);
      out += this._encodeByte(c >>> 2 * 6 & 63);
      if (left === 2) out += this._encodeByte(c >>> 1 * 6 & 63);
      else out += this._paddingCharacter || "";
      out += this._paddingCharacter || "";
    }
    return out;
  }
  maxDecodedLength(length) {
    if (!this._paddingCharacter) return (length * 6 + 7) / 8 | 0;
    return length / 4 * 3 | 0;
  }
  decodedLength(s) {
    return this.maxDecodedLength(s.length - this._getPaddingLength(s));
  }
  decode(s) {
    if (s.length === 0) return new Uint8Array(0);
    const paddingLength = this._getPaddingLength(s);
    const length = s.length - paddingLength;
    const out = new Uint8Array(this.maxDecodedLength(length));
    let op = 0;
    let i = 0;
    let haveBad = 0;
    let v0 = 0, v12 = 0, v2 = 0, v32 = 0;
    for (; i < length - 4; i += 4) {
      v0 = this._decodeChar(s.charCodeAt(i + 0));
      v12 = this._decodeChar(s.charCodeAt(i + 1));
      v2 = this._decodeChar(s.charCodeAt(i + 2));
      v32 = this._decodeChar(s.charCodeAt(i + 3));
      out[op++] = v0 << 2 | v12 >>> 4;
      out[op++] = v12 << 4 | v2 >>> 2;
      out[op++] = v2 << 6 | v32;
      haveBad |= v0 & INVALID_BYTE;
      haveBad |= v12 & INVALID_BYTE;
      haveBad |= v2 & INVALID_BYTE;
      haveBad |= v32 & INVALID_BYTE;
    }
    if (i < length - 1) {
      v0 = this._decodeChar(s.charCodeAt(i));
      v12 = this._decodeChar(s.charCodeAt(i + 1));
      out[op++] = v0 << 2 | v12 >>> 4;
      haveBad |= v0 & INVALID_BYTE;
      haveBad |= v12 & INVALID_BYTE;
    }
    if (i < length - 2) {
      v2 = this._decodeChar(s.charCodeAt(i + 2));
      out[op++] = v12 << 4 | v2 >>> 2;
      haveBad |= v2 & INVALID_BYTE;
    }
    if (i < length - 3) {
      v32 = this._decodeChar(s.charCodeAt(i + 3));
      out[op++] = v2 << 6 | v32;
      haveBad |= v32 & INVALID_BYTE;
    }
    if (haveBad !== 0) throw new Error("Base64Coder: incorrect characters for decoding");
    return out;
  }
  _encodeByte(b) {
    let result = b;
    result += 65;
    result += 25 - b >>> 8 & 6;
    result += 51 - b >>> 8 & -75;
    result += 61 - b >>> 8 & -15;
    result += 62 - b >>> 8 & 3;
    return String.fromCharCode(result);
  }
  _decodeChar(c) {
    let result = INVALID_BYTE;
    result += (42 - c & c - 44) >>> 8 & -256 + c - 43 + 62;
    result += (46 - c & c - 48) >>> 8 & -256 + c - 47 + 63;
    result += (47 - c & c - 58) >>> 8 & -256 + c - 48 + 52;
    result += (64 - c & c - 91) >>> 8 & -256 + c - 65 + 0;
    result += (96 - c & c - 123) >>> 8 & -256 + c - 97 + 26;
    return result;
  }
  _getPaddingLength(s) {
    let paddingLength = 0;
    if (this._paddingCharacter) {
      for (let i = s.length - 1; i >= 0; i--) {
        if (s[i] !== this._paddingCharacter) break;
        paddingLength++;
      }
      if (s.length < 4 || paddingLength > 2) throw new Error("Base64Coder: incorrect padding");
    }
    return paddingLength;
  }
};
const stdCoder = new Coder2();
function encode(data2) {
  return stdCoder.encode(data2);
}
function decode$2(s) {
  return stdCoder.decode(s);
}
function concat(...arrays) {
  let totalLength = 0;
  for (let i = 0; i < arrays.length; i++) totalLength += arrays[i].length;
  const result = new Uint8Array(totalLength);
  let offset = 0;
  for (let i = 0; i < arrays.length; i++) {
    const arg = arrays[i];
    result.set(arg, offset);
    offset += arg.length;
  }
  return result;
}
var integers = [
  "u8",
  "u16",
  "u32",
  "u64",
  "u128",
  "i8",
  "i16",
  "i32",
  "i64",
  "i128",
  "f32",
  "f64"
];
var EncodeBuffer = function() {
  function EncodeBuffer$12() {
    this.offset = 0;
    this.buffer_size = 256;
    this.buffer = new ArrayBuffer(this.buffer_size);
    this.view = new DataView(this.buffer);
  }
  EncodeBuffer$12.prototype.resize_if_necessary = function(needed_space) {
    if (this.buffer_size - this.offset < needed_space) {
      this.buffer_size = Math.max(this.buffer_size * 2, this.buffer_size + needed_space);
      var new_buffer = new ArrayBuffer(this.buffer_size);
      new Uint8Array(new_buffer).set(new Uint8Array(this.buffer));
      this.buffer = new_buffer;
      this.view = new DataView(new_buffer);
    }
  };
  EncodeBuffer$12.prototype.get_used_buffer = function() {
    return new Uint8Array(this.buffer).slice(0, this.offset);
  };
  EncodeBuffer$12.prototype.store_value = function(value, type2) {
    var bSize = type2.substring(1);
    var size = parseInt(bSize) / 8;
    this.resize_if_necessary(size);
    var toCall = type2[0] === "f" ? "setFloat".concat(bSize) : type2[0] === "i" ? "setInt".concat(bSize) : "setUint".concat(bSize);
    this.view[toCall](this.offset, value, true);
    this.offset += size;
  };
  EncodeBuffer$12.prototype.store_bytes = function(from) {
    this.resize_if_necessary(from.length);
    new Uint8Array(this.buffer).set(new Uint8Array(from), this.offset);
    this.offset += from.length;
  };
  return EncodeBuffer$12;
}();
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$1, b$1) {
      d$1.__proto__ = b$1;
    } || function(d$1, b$1) {
      for (var p in b$1) if (Object.prototype.hasOwnProperty.call(b$1, p)) d$1[p] = b$1[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
function isArrayLike(value) {
  return Array.isArray(value) || !!value && typeof value === "object" && "length" in value && typeof value.length === "number" && (value.length === 0 || value.length > 0 && value.length - 1 in value);
}
function expect_type(value, type2, fieldPath) {
  if (typeof value !== type2) throw new Error("Expected ".concat(type2, " not ").concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
}
function expect_bigint(value, fieldPath) {
  var basicType = [
    "number",
    "string",
    "bigint",
    "boolean"
  ].includes(typeof value);
  var strObject = typeof value === "object" && value !== null && "toString" in value;
  if (!basicType && !strObject) throw new Error("Expected bigint, number, boolean or string not ".concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
}
function expect_same_size(length, expected, fieldPath) {
  if (length !== expected) throw new Error("Array length ".concat(length, " does not match schema length ").concat(expected, " at ").concat(fieldPath.join(".")));
}
function expect_enum(value, fieldPath) {
  if (typeof value !== "object" || value === null) throw new Error("Expected object not ".concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
}
var VALID_STRING_TYPES = integers.concat(["bool", "string"]);
var VALID_OBJECT_KEYS = [
  "option",
  "enum",
  "array",
  "set",
  "map",
  "struct"
];
var ErrorSchema = function(_super) {
  __extends(ErrorSchema$12, _super);
  function ErrorSchema$12(schema, expected) {
    var message2 = "Invalid schema: ".concat(JSON.stringify(schema), " expected ").concat(expected);
    return _super.call(this, message2) || this;
  }
  return ErrorSchema$12;
}(Error);
function validate_schema(schema) {
  if (typeof schema === "string" && VALID_STRING_TYPES.includes(schema)) return;
  if (schema && typeof schema === "object") {
    var keys2 = Object.keys(schema);
    if (keys2.length === 1 && VALID_OBJECT_KEYS.includes(keys2[0])) {
      var key = keys2[0];
      if (key === "option") return validate_schema(schema[key]);
      if (key === "enum") return validate_enum_schema(schema[key]);
      if (key === "array") return validate_array_schema(schema[key]);
      if (key === "set") return validate_schema(schema[key]);
      if (key === "map") return validate_map_schema(schema[key]);
      if (key === "struct") return validate_struct_schema(schema[key]);
    }
  }
  throw new ErrorSchema(schema, VALID_OBJECT_KEYS.join(", ") + " or " + VALID_STRING_TYPES.join(", "));
}
function validate_enum_schema(schema) {
  if (!Array.isArray(schema)) throw new ErrorSchema(schema, "Array");
  for (var _i = 0, schema_1 = schema; _i < schema_1.length; _i++) {
    var sch = schema_1[_i];
    if (typeof sch !== "object" || !("struct" in sch)) throw new Error('Missing "struct" key in enum schema');
    if (typeof sch.struct !== "object" || Object.keys(sch.struct).length !== 1) throw new Error('The "struct" in each enum must have a single key');
    validate_schema({ struct: sch.struct });
  }
}
function validate_array_schema(schema) {
  if (typeof schema !== "object") throw new ErrorSchema(schema, "{ type, len? }");
  if (schema.len && typeof schema.len !== "number") throw new Error("Invalid schema: ".concat(schema));
  if ("type" in schema) return validate_schema(schema.type);
  throw new ErrorSchema(schema, "{ type, len? }");
}
function validate_map_schema(schema) {
  if (typeof schema === "object" && "key" in schema && "value" in schema) {
    validate_schema(schema.key);
    validate_schema(schema.value);
  } else throw new ErrorSchema(schema, "{ key, value }");
}
function validate_struct_schema(schema) {
  if (typeof schema !== "object") throw new ErrorSchema(schema, "object");
  for (var key in schema) validate_schema(schema[key]);
}
var BorshSerializer = function() {
  function BorshSerializer$12(checkTypes) {
    this.encoded = new EncodeBuffer();
    this.fieldPath = ["value"];
    this.checkTypes = checkTypes;
  }
  BorshSerializer$12.prototype.encode = function(value, schema) {
    this.encode_value(value, schema);
    return this.encoded.get_used_buffer();
  };
  BorshSerializer$12.prototype.encode_value = function(value, schema) {
    if (typeof schema === "string") {
      if (integers.includes(schema)) return this.encode_integer(value, schema);
      if (schema === "string") return this.encode_string(value);
      if (schema === "bool") return this.encode_boolean(value);
    }
    if (typeof schema === "object") {
      if ("option" in schema) return this.encode_option(value, schema);
      if ("enum" in schema) return this.encode_enum(value, schema);
      if ("array" in schema) return this.encode_array(value, schema);
      if ("set" in schema) return this.encode_set(value, schema);
      if ("map" in schema) return this.encode_map(value, schema);
      if ("struct" in schema) return this.encode_struct(value, schema);
    }
  };
  BorshSerializer$12.prototype.encode_integer = function(value, schema) {
    var size = parseInt(schema.substring(1));
    if (size <= 32 || schema == "f64") {
      this.checkTypes && expect_type(value, "number", this.fieldPath);
      this.encoded.store_value(value, schema);
    } else {
      this.checkTypes && expect_bigint(value, this.fieldPath);
      this.encode_bigint(BigInt(value), size);
    }
  };
  BorshSerializer$12.prototype.encode_bigint = function(value, size) {
    var buffer_len = size / 8;
    var buffer = new Uint8Array(buffer_len);
    for (var i = 0; i < buffer_len; i++) {
      buffer[i] = Number(value & BigInt(255));
      value = value >> BigInt(8);
    }
    this.encoded.store_bytes(new Uint8Array(buffer));
  };
  BorshSerializer$12.prototype.encode_string = function(value) {
    this.checkTypes && expect_type(value, "string", this.fieldPath);
    var _value = value;
    var utf8Bytes = [];
    for (var i = 0; i < _value.length; i++) {
      var charCode = _value.charCodeAt(i);
      if (charCode < 128) utf8Bytes.push(charCode);
      else if (charCode < 2048) utf8Bytes.push(192 | charCode >> 6, 128 | charCode & 63);
      else if (charCode < 55296 || charCode >= 57344) utf8Bytes.push(224 | charCode >> 12, 128 | charCode >> 6 & 63, 128 | charCode & 63);
      else {
        i++;
        charCode = 65536 + ((charCode & 1023) << 10 | _value.charCodeAt(i) & 1023);
        utf8Bytes.push(240 | charCode >> 18, 128 | charCode >> 12 & 63, 128 | charCode >> 6 & 63, 128 | charCode & 63);
      }
    }
    this.encoded.store_value(utf8Bytes.length, "u32");
    this.encoded.store_bytes(new Uint8Array(utf8Bytes));
  };
  BorshSerializer$12.prototype.encode_boolean = function(value) {
    this.checkTypes && expect_type(value, "boolean", this.fieldPath);
    this.encoded.store_value(value ? 1 : 0, "u8");
  };
  BorshSerializer$12.prototype.encode_option = function(value, schema) {
    if (value === null || value === void 0) this.encoded.store_value(0, "u8");
    else {
      this.encoded.store_value(1, "u8");
      this.encode_value(value, schema.option);
    }
  };
  BorshSerializer$12.prototype.encode_enum = function(value, schema) {
    this.checkTypes && expect_enum(value, this.fieldPath);
    var valueKey = Object.keys(value)[0];
    for (var i = 0; i < schema["enum"].length; i++) {
      var valueSchema = schema["enum"][i];
      if (valueKey === Object.keys(valueSchema.struct)[0]) {
        this.encoded.store_value(i, "u8");
        return this.encode_struct(value, valueSchema);
      }
    }
    throw new Error("Enum key (".concat(valueKey, ") not found in enum schema: ").concat(JSON.stringify(schema), " at ").concat(this.fieldPath.join(".")));
  };
  BorshSerializer$12.prototype.encode_array = function(value, schema) {
    if (isArrayLike(value)) return this.encode_arraylike(value, schema);
    if (value instanceof ArrayBuffer) return this.encode_buffer(value, schema);
    throw new Error("Expected Array-like not ".concat(typeof value, "(").concat(value, ") at ").concat(this.fieldPath.join(".")));
  };
  BorshSerializer$12.prototype.encode_arraylike = function(value, schema) {
    if (schema.array.len) expect_same_size(value.length, schema.array.len, this.fieldPath);
    else this.encoded.store_value(value.length, "u32");
    for (var i = 0; i < value.length; i++) this.encode_value(value[i], schema.array.type);
  };
  BorshSerializer$12.prototype.encode_buffer = function(value, schema) {
    if (schema.array.len) expect_same_size(value.byteLength, schema.array.len, this.fieldPath);
    else this.encoded.store_value(value.byteLength, "u32");
    this.encoded.store_bytes(new Uint8Array(value));
  };
  BorshSerializer$12.prototype.encode_set = function(value, schema) {
    this.checkTypes && expect_type(value, "object", this.fieldPath);
    var isSet = value instanceof Set;
    var values = isSet ? Array.from(value.values()) : Object.values(value);
    this.encoded.store_value(values.length, "u32");
    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
      var value_1 = values_1[_i];
      this.encode_value(value_1, schema.set);
    }
  };
  BorshSerializer$12.prototype.encode_map = function(value, schema) {
    this.checkTypes && expect_type(value, "object", this.fieldPath);
    var isMap = value instanceof Map;
    var keys2 = isMap ? Array.from(value.keys()) : Object.keys(value);
    this.encoded.store_value(keys2.length, "u32");
    for (var _i = 0, keys_1 = keys2; _i < keys_1.length; _i++) {
      var key = keys_1[_i];
      this.encode_value(key, schema.map.key);
      this.encode_value(isMap ? value.get(key) : value[key], schema.map.value);
    }
  };
  BorshSerializer$12.prototype.encode_struct = function(value, schema) {
    this.checkTypes && expect_type(value, "object", this.fieldPath);
    for (var _i = 0, _a = Object.keys(schema.struct); _i < _a.length; _i++) {
      var key = _a[_i];
      this.fieldPath.push(key);
      this.encode_value(value[key], schema.struct[key]);
      this.fieldPath.pop();
    }
  };
  return BorshSerializer$12;
}();
function serialize(schema, value, validate2) {
  if (validate2 === void 0) validate2 = true;
  if (validate2) validate_schema(schema);
  var serializer = new BorshSerializer(validate2);
  return serializer.encode(value, schema);
}
function hexEncodeSha256Hash(data2) {
  return encode$2(hash(data2), true);
}
function bs58Encode(data2) {
  return esm_default.encode(data2);
}
function bs58Decode(data2) {
  return esm_default.decode(data2);
}
function decryptContent(message2, nonce, senderEncryptionPublicKey, recipientEncryptionSecretKey) {
  const decrypted = nacl.box.open(message2, nonce, senderEncryptionPublicKey, recipientEncryptionSecretKey);
  if (decrypted === null) throw Error(`Couldn't decrypt the provided message. ${JSON.stringify({
    message: encode(message2),
    nonce: encode(nonce),
    senderEncryptionPublicKey: encode(senderEncryptionPublicKey),
    recipientEncryptionSecretKey: encode(recipientEncryptionSecretKey)
  }, null, 2)}`);
  return decrypted;
}
var NoncedBox = class NoncedBox2 {
  keyPair;
  constructor(keyPair) {
    this.keyPair = keyPair;
  }
  static nonceFromBase64SecretKey(secret) {
    return new NoncedBox2(nacl.box.keyPair.fromSecretKey(decode$2(secret)));
  }
  async decrypt(b64FullMessage, b64SenderPublicKey) {
    const decodedMessage = decode$2(b64FullMessage);
    const senderEncryptionPublicKey = decode$2(b64SenderPublicKey);
    const message2 = decodedMessage.slice(nacl.box.nonceLength, decodedMessage.length);
    const nonce = decodedMessage.slice(0, nacl.box.nonceLength);
    const content = decryptContent(message2, nonce, senderEncryptionPublicKey, this.keyPair.secretKey);
    return decode$1(content);
  }
};
async function getSharedCredential$1(kwilClient, id) {
  const [credential] = await kwilClient.call({
    name: "get_credential_shared",
    inputs: { id }
  });
  return credential;
}
async function getAccessGrantsForCredential(kwilClient, params) {
  return kwilClient.call({
    name: "get_access_grants_for_credential",
    inputs: params
  });
}
async function getCredentialsSharedByUser(kwilClient, userId) {
  return kwilClient.call({
    name: "get_credentials_shared_by_user",
    inputs: {
      user_id: userId,
      issuer_auth_public_key: null
    }
  });
}
async function getGrantsCount(kwilClient, params = { user_id: null }) {
  const [{ count }] = await kwilClient.call({
    name: "get_access_grants_granted_count",
    inputs: params
  });
  return count;
}
const GET_GRANTS_DEFAULT_RECORDS_PER_PAGE = 10;
async function getGrants(kwilClient, params = {
  page: 1,
  size: GET_GRANTS_DEFAULT_RECORDS_PER_PAGE,
  user_id: null
}) {
  return kwilClient.call({
    name: "get_access_grants_granted",
    inputs: {
      page: params.page ?? 1,
      size: params.size ?? 10,
      user_id: params.user_id ?? null
    }
  });
}
async function createAccessGrantByDag(kwilClient, params) {
  await kwilClient.execute({
    name: "create_ag_by_dag_for_copy",
    description: "Create an Access Grant in idOS",
    inputs: params
  });
  return params;
}
async function getPassportingPeers(kwilClient) {
  return kwilClient.call({
    name: "get_passporting_peers",
    inputs: {}
  });
}
const DataType = distExports.Utils.DataType;
const actionSchema = {
  add_user_as_inserter: [{
    name: "id",
    type: DataType.Uuid
  }, {
    name: "recipient_encryption_public_key",
    type: DataType.Text
  }],
  update_user_pub_key_as_inserter: [{
    name: "id",
    type: DataType.Uuid
  }, {
    name: "recipient_encryption_public_key",
    type: DataType.Text
  }],
  get_user: [],
  get_user_as_inserter: [{
    name: "id",
    type: DataType.Uuid
  }],
  upsert_wallet_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "user_id",
      type: DataType.Uuid
    },
    {
      name: "address",
      type: DataType.Text
    },
    {
      name: "public_key",
      type: DataType.Text
    },
    {
      name: "wallet_type",
      type: DataType.Text
    },
    {
      name: "message",
      type: DataType.Text
    },
    {
      name: "signature",
      type: DataType.Text
    }
  ],
  add_wallet: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "address",
      type: DataType.Text
    },
    {
      name: "public_key",
      type: DataType.Text
    },
    {
      name: "message",
      type: DataType.Text
    },
    {
      name: "signature",
      type: DataType.Text
    }
  ],
  get_wallets: [],
  remove_wallet: [{
    name: "id",
    type: DataType.Uuid
  }],
  upsert_credential_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "user_id",
      type: DataType.Uuid
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text
    },
    {
      name: "encryptor_public_key",
      type: DataType.Text
    },
    {
      name: "content",
      type: DataType.Text
    },
    {
      name: "public_notes",
      type: DataType.Text
    },
    {
      name: "public_notes_signature",
      type: DataType.Text
    },
    {
      name: "broader_signature",
      type: DataType.Text
    }
  ],
  add_credential: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text
    },
    {
      name: "encryptor_public_key",
      type: DataType.Text
    },
    {
      name: "content",
      type: DataType.Text
    },
    {
      name: "public_notes",
      type: DataType.Text
    },
    {
      name: "public_notes_signature",
      type: DataType.Text
    },
    {
      name: "broader_signature",
      type: DataType.Text
    }
  ],
  get_credentials: [],
  get_credentials_shared_by_user: [{
    name: "user_id",
    type: DataType.Uuid
  }, {
    name: "issuer_auth_public_key",
    type: DataType.Text
  }],
  edit_public_notes_as_issuer: [{
    name: "public_notes_id",
    type: DataType.Text
  }, {
    name: "public_notes",
    type: DataType.Text
  }],
  remove_credential: [{
    name: "id",
    type: DataType.Uuid
  }],
  share_credential: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "original_credential_id",
      type: DataType.Uuid
    },
    {
      name: "public_notes",
      type: DataType.Text
    },
    {
      name: "public_notes_signature",
      type: DataType.Text
    },
    {
      name: "broader_signature",
      type: DataType.Text
    },
    {
      name: "content",
      type: DataType.Text
    },
    {
      name: "content_hash",
      type: DataType.Text
    },
    {
      name: "encryptor_public_key",
      type: DataType.Text
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text
    },
    {
      name: "grantee_wallet_identifier",
      type: DataType.Text
    },
    {
      name: "locked_until",
      type: DataType.Int
    }
  ],
  create_credential_copy: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "original_credential_id",
      type: DataType.Uuid
    },
    {
      name: "public_notes",
      type: DataType.Text
    },
    {
      name: "public_notes_signature",
      type: DataType.Text
    },
    {
      name: "broader_signature",
      type: DataType.Text
    },
    {
      name: "content",
      type: DataType.Text
    },
    {
      name: "encryptor_public_key",
      type: DataType.Text
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text
    }
  ],
  share_credential_through_dag: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "user_id",
      type: DataType.Uuid
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text
    },
    {
      name: "encryptor_public_key",
      type: DataType.Text
    },
    {
      name: "content",
      type: DataType.Text
    },
    {
      name: "content_hash",
      type: DataType.Text
    },
    {
      name: "public_notes",
      type: DataType.Text
    },
    {
      name: "public_notes_signature",
      type: DataType.Text
    },
    {
      name: "broader_signature",
      type: DataType.Text
    },
    {
      name: "original_credential_id",
      type: DataType.Uuid
    },
    {
      name: "dag_owner_wallet_identifier",
      type: DataType.Text
    },
    {
      name: "dag_grantee_wallet_identifier",
      type: DataType.Text
    },
    {
      name: "dag_locked_until",
      type: DataType.Int
    },
    {
      name: "dag_signature",
      type: DataType.Text
    }
  ],
  create_credentials_by_dwg: [
    {
      name: "issuer_auth_public_key",
      type: DataType.Text
    },
    {
      name: "original_encryptor_public_key",
      type: DataType.Text
    },
    {
      name: "original_credential_id",
      type: DataType.Uuid
    },
    {
      name: "original_content",
      type: DataType.Text
    },
    {
      name: "original_public_notes",
      type: DataType.Text
    },
    {
      name: "original_public_notes_signature",
      type: DataType.Text
    },
    {
      name: "original_broader_signature",
      type: DataType.Text
    },
    {
      name: "copy_encryptor_public_key",
      type: DataType.Text
    },
    {
      name: "copy_credential_id",
      type: DataType.Uuid
    },
    {
      name: "copy_content",
      type: DataType.Text
    },
    {
      name: "copy_public_notes_signature",
      type: DataType.Text
    },
    {
      name: "copy_broader_signature",
      type: DataType.Text
    },
    {
      name: "content_hash",
      type: DataType.Text
    },
    {
      name: "dwg_owner",
      type: DataType.Text
    },
    {
      name: "dwg_grantee",
      type: DataType.Text
    },
    {
      name: "dwg_issuer_public_key",
      type: DataType.Text
    },
    {
      name: "dwg_id",
      type: DataType.Uuid
    },
    {
      name: "dwg_access_grant_timelock",
      type: DataType.Text
    },
    {
      name: "dwg_not_before",
      type: DataType.Text
    },
    {
      name: "dwg_not_after",
      type: DataType.Text
    },
    {
      name: "dwg_signature",
      type: DataType.Text
    }
  ],
  get_credential_owned: [{
    name: "id",
    type: DataType.Uuid
  }],
  get_credential_shared: [{
    name: "id",
    type: DataType.Uuid
  }],
  get_sibling_credential_id: [{
    name: "content_hash",
    type: DataType.Text
  }],
  add_attribute: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "attribute_key",
      type: DataType.Text
    },
    {
      name: "value",
      type: DataType.Text
    }
  ],
  get_attributes: [],
  edit_attribute: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "attribute_key",
      type: DataType.Text
    },
    {
      name: "value",
      type: DataType.Text
    }
  ],
  remove_attribute: [{
    name: "id",
    type: DataType.Uuid
  }],
  share_attribute: [
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "original_attribute_id",
      type: DataType.Uuid
    },
    {
      name: "attribute_key",
      type: DataType.Text
    },
    {
      name: "value",
      type: DataType.Text
    }
  ],
  dwg_message: [
    {
      name: "owner_wallet_identifier",
      type: DataType.Text
    },
    {
      name: "grantee_wallet_identifier",
      type: DataType.Text
    },
    {
      name: "issuer_public_key",
      type: DataType.Text
    },
    {
      name: "id",
      type: DataType.Uuid
    },
    {
      name: "access_grant_timelock",
      type: DataType.Text
    },
    {
      name: "not_usable_before",
      type: DataType.Text
    },
    {
      name: "not_usable_after",
      type: DataType.Text
    }
  ],
  revoke_access_grant: [{
    name: "id",
    type: DataType.Uuid
  }],
  get_access_grants_owned: [],
  get_access_grants_granted: [
    {
      name: "user_id",
      type: DataType.Uuid
    },
    {
      name: "page",
      type: DataType.Int
    },
    {
      name: "size",
      type: DataType.Int
    }
  ],
  get_access_grants_granted_count: [{
    name: "user_id",
    type: DataType.Uuid
  }],
  has_locked_access_grants: [{
    name: "id",
    type: DataType.Uuid
  }],
  dag_message: [
    {
      name: "dag_owner_wallet_identifier",
      type: DataType.Text
    },
    {
      name: "dag_grantee_wallet_identifier",
      type: DataType.Text
    },
    {
      name: "dag_data_id",
      type: DataType.Uuid
    },
    {
      name: "dag_locked_until",
      type: DataType.Int
    },
    {
      name: "dag_content_hash",
      type: DataType.Text
    }
  ],
  create_ag_by_dag_for_copy: [
    {
      name: "dag_owner_wallet_identifier",
      type: DataType.Text
    },
    {
      name: "dag_grantee_wallet_identifier",
      type: DataType.Text
    },
    {
      name: "dag_data_id",
      type: DataType.Uuid
    },
    {
      name: "dag_locked_until",
      type: DataType.Int
    },
    {
      name: "dag_content_hash",
      type: DataType.Text
    },
    {
      name: "dag_signature",
      type: DataType.Text
    }
  ],
  get_access_grants_for_credential: [{
    name: "credential_id",
    type: DataType.Uuid
  }],
  has_profile: [{
    name: "address",
    type: DataType.Text
  }],
  get_passporting_peers: [],
  get_caller: []
};
var isProduction = process.env.NODE_ENV === "production";
var prefix = "Invariant failed";
function invariant(condition, message2) {
  if (condition) return;
  if (isProduction) throw new Error(prefix);
  var provided = typeof message2 === "function" ? message2() : message2;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}
var KwilActionClient2 = class {
  signer;
  client;
  constructor(client2) {
    this.client = client2;
  }
  #createActionInputs(actionName, params = {}) {
    if (!params || !Object.keys(params).length) return [];
    const args = actionSchema[actionName];
    return args.map(({ name }) => {
      const value = params[name];
      if (value === "" || value === 0) return value;
      return value ?? null;
    });
  }
  #actionTypes(actionName) {
    const args = actionSchema[actionName];
    return args.map((arg) => arg.type);
  }
  /**
  * Calls an action on the kwil nodes. This similar to `GET` like request.
  */
  async call(params, signer = this.signer) {
    const action2 = {
      name: params.name,
      namespace: "main",
      inputs: this.#createActionInputs(params.name, params.inputs),
      types: this.#actionTypes(params.name)
    };
    const response = await this.client.call(action2, signer);
    return response?.data?.result;
  }
  /**
  * Executes an action on the kwil nodes. This similar to `POST` like request.
  */
  async execute(params, signer = this.signer, synchronous = true) {
    invariant(signer, "Signer is not set, you must set it before executing an action");
    const action2 = {
      name: params.name,
      namespace: "main",
      description: params.description,
      inputs: [this.#createActionInputs(params.name, params.inputs)],
      types: this.#actionTypes(params.name)
    };
    const response = await this.client.execute(action2, signer, synchronous);
    return response.data?.tx_hash;
  }
  setSigner(signer) {
    this.signer = signer;
  }
};
const DEFAULT_TIMEOUT = 3e4;
const createKwilClient = (Cls) => async ({ nodeUrl: kwilProvider, chainId }) => {
  const _kwil = new Cls({
    kwilProvider,
    chainId: ""
  });
  chainId ||= (await _kwil.chainInfo({ disableWarning: true })).data?.chain_id;
  invariant(chainId, "Can't discover `chainId`. You must pass it explicitly.");
  return new KwilActionClient2(new Cls({
    kwilProvider,
    chainId,
    timeout: DEFAULT_TIMEOUT
  }));
};
const createNodeKwilClient = createKwilClient(distExports.NodeKwil);
var require_cryptoNode = __commonJS({ "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/cryptoNode.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.crypto = void 0;
  const nc = __require("node:crypto");
  exports.crypto = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : nc && typeof nc === "object" && "randomBytes" in nc ? nc : void 0;
} });
var require_utils$5 = __commonJS({ "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/utils.js"(exports) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
  exports.isBytes = isBytes$1;
  exports.anumber = anumber$1;
  exports.abytes = abytes$1;
  exports.ahash = ahash;
  exports.aexists = aexists;
  exports.aoutput = aoutput;
  exports.u8 = u8;
  exports.u32 = u32;
  exports.clean = clean;
  exports.createView = createView;
  exports.rotr = rotr;
  exports.rotl = rotl;
  exports.byteSwap = byteSwap;
  exports.byteSwap32 = byteSwap32;
  exports.bytesToHex = bytesToHex$1;
  exports.hexToBytes = hexToBytes$1;
  exports.asyncLoop = asyncLoop;
  exports.utf8ToBytes = utf8ToBytes;
  exports.bytesToUtf8 = bytesToUtf8;
  exports.toBytes = toBytes;
  exports.kdfInputToBytes = kdfInputToBytes;
  exports.concatBytes = concatBytes;
  exports.checkOpts = checkOpts;
  exports.createHasher = createHasher$1;
  exports.createOptHasher = createOptHasher;
  exports.createXOFer = createXOFer;
  exports.randomBytes = randomBytes$1;
  const crypto_1$4 = require_cryptoNode();
  function isBytes$1(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function anumber$1(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error("positive integer expected, got " + n);
  }
  function abytes$1(b, ...lengths) {
    if (!isBytes$1(b)) throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
  }
  function ahash(h) {
    if (typeof h !== "function" || typeof h.create !== "function") throw new Error("Hash should be wrapped by utils.createHasher");
    anumber$1(h.outputLen);
    anumber$1(h.blockLen);
  }
  function aexists(instance, checkFinished = true) {
    if (instance.destroyed) throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished) throw new Error("Hash#digest() has already been called");
  }
  function aoutput(out, instance) {
    abytes$1(out);
    const min2 = instance.outputLen;
    if (out.length < min2) throw new Error("digestInto() expects output buffer of length at least " + min2);
  }
  function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  }
  function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) arrays[i].fill(0);
  }
  function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function rotr(word, shift) {
    return word << 32 - shift | word >>> shift;
  }
  function rotl(word, shift) {
    return word << shift | word >>> 32 - shift >>> 0;
  }
  exports.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
  function byteSwap(word) {
    return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
  }
  exports.swap8IfBE = exports.isLE ? (n) => n : (n) => byteSwap(n);
  exports.byteSwapIfBE = exports.swap8IfBE;
  function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) arr[i] = byteSwap(arr[i]);
    return arr;
  }
  exports.swap32IfBE = exports.isLE ? (u) => u : byteSwap32;
  const hasHexBuiltin$1 = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
  const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex$1(bytes2) {
    abytes$1(bytes2);
    if (hasHexBuiltin$1) return bytes2.toHex();
    let hex = "";
    for (let i = 0; i < bytes2.length; i++) hex += hexes[bytes2[i]];
    return hex;
  }
  const asciis = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
  };
  function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0;
    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10);
    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10);
    return;
  }
  function hexToBytes$1(hex) {
    if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
    if (hasHexBuiltin$1) return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw new Error("hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
      const n1 = asciiToBase16(hex.charCodeAt(hi));
      const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
      if (n1 === void 0 || n2 === void 0) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array[ai] = n1 * 16 + n2;
    }
    return array;
  }
  const nextTick = async () => {
  };
  exports.nextTick = nextTick;
  async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
      cb(i);
      const diff = Date.now() - ts;
      if (diff >= 0 && diff < tick) continue;
      await (0, exports.nextTick)();
      ts += diff;
    }
  }
  function utf8ToBytes(str) {
    if (typeof str !== "string") throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function bytesToUtf8(bytes2) {
    return new TextDecoder().decode(bytes2);
  }
  function toBytes(data2) {
    if (typeof data2 === "string") data2 = utf8ToBytes(data2);
    abytes$1(data2);
    return data2;
  }
  function kdfInputToBytes(data2) {
    if (typeof data2 === "string") data2 = utf8ToBytes(data2);
    abytes$1(data2);
    return data2;
  }
  function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      abytes$1(a);
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad);
      pad += a.length;
    }
    return res;
  }
  function checkOpts(defaults, opts) {
    if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]") throw new Error("options should be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
  }
  var Hash = class {
  };
  exports.Hash = Hash;
  function createHasher$1(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function createOptHasher(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  function createXOFer(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  exports.wrapConstructor = createHasher$1;
  exports.wrapConstructorWithOpts = createOptHasher;
  exports.wrapXOFConstructorWithOpts = createXOFer;
  function randomBytes$1(bytesLength = 32) {
    if (crypto_1$4.crypto && typeof crypto_1$4.crypto.getRandomValues === "function") return crypto_1$4.crypto.getRandomValues(new Uint8Array(bytesLength));
    if (crypto_1$4.crypto && typeof crypto_1$4.crypto.randomBytes === "function") return Uint8Array.from(crypto_1$4.crypto.randomBytes(bytesLength));
    throw new Error("crypto.getRandomValues must be defined");
  }
} });
var require_shared = __commonJS({ "../../node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/utils/shared.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.equal = exports.concat = exports.HEX_REGEX = void 0;
  const utils_1$6 = require_utils$5();
  exports.HEX_REGEX = /^[A-F0-9]*$/iu;
  function concat$12(views) {
    return (0, utils_1$6.concatBytes)(...views);
  }
  exports.concat = concat$12;
  function equal(buf1, buf2) {
    if (buf1.byteLength !== buf2.byteLength) return false;
    const dv1 = new Int8Array(buf1);
    const dv2 = new Int8Array(buf2);
    for (let i = 0; i !== buf1.byteLength; i++) if (dv1[i] !== dv2[i]) return false;
    return true;
  }
  exports.equal = equal;
} });
var require_utils$4 = __commonJS({ "../../node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/utils/index.js"(exports) {
  var __createBinding$1 = Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
      enumerable: true,
      get: function() {
        return m[k];
      }
    };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  };
  var __exportStar$1 = function(m, exports$1) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding$1(exports$1, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stringToHex = exports.hexToString = exports.randomBytes = exports.hexToBytes = exports.bytesToHex = void 0;
  const crypto_1$3 = __require("crypto");
  const shared_1 = require_shared();
  const OriginalBuffer = Symbol("OriginalBuffer");
  function toUint8Array(buffer) {
    const u8Array = new Uint8Array(buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength));
    u8Array[OriginalBuffer] = buffer;
    return u8Array;
  }
  const bytesToHex = (bytes2) => {
    const buf = Buffer.from(bytes2);
    return buf.toString("hex").toUpperCase();
  };
  exports.bytesToHex = bytesToHex;
  const hexToBytes = (hex) => {
    if (!shared_1.HEX_REGEX.test(hex)) throw new Error("Invalid hex string");
    return toUint8Array(Buffer.from(hex, "hex"));
  };
  exports.hexToBytes = hexToBytes;
  const randomBytes = (size) => {
    return toUint8Array((0, crypto_1$3.randomBytes)(size));
  };
  exports.randomBytes = randomBytes;
  const hexToString = (hex, encoding = "utf8") => {
    if (!shared_1.HEX_REGEX.test(hex)) throw new Error("Invalid hex string");
    return new TextDecoder(encoding).decode((0, exports.hexToBytes)(hex));
  };
  exports.hexToString = hexToString;
  const stringToHex = (string) => {
    return (0, exports.bytesToHex)(new TextEncoder().encode(string));
  };
  exports.stringToHex = stringToHex;
  __exportStar$1(require_shared(), exports);
} });
var require_lib = __commonJS({ "../../node_modules/.pnpm/@scure+base@1.2.6/node_modules/@scure/base/lib/index.js"(exports) {
  /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.createBase58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64nopad = exports.base64 = exports.base32crockford = exports.base32hexnopad = exports.base32hex = exports.base32nopad = exports.base32 = exports.base16 = exports.utils = void 0;
  function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function abytes(b, ...lengths) {
    if (!isBytes(b)) throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
  }
  function isArrayOf(isString, arr) {
    if (!Array.isArray(arr)) return false;
    if (arr.length === 0) return true;
    if (isString) return arr.every((item) => typeof item === "string");
    else return arr.every((item) => Number.isSafeInteger(item));
  }
  function afn(input) {
    if (typeof input !== "function") throw new Error("function expected");
    return true;
  }
  function astr(label, input) {
    if (typeof input !== "string") throw new Error(`${label}: string expected`);
    return true;
  }
  function anumber(n) {
    if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);
  }
  function aArr(input) {
    if (!Array.isArray(input)) throw new Error("array expected");
  }
  function astrArr(label, input) {
    if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);
  }
  function anumArr(label, input) {
    if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);
  }
  // @__NO_SIDE_EFFECTS__
  function chain(...args) {
    const id = (a) => a;
    const wrap = (a, b) => (c) => a(b(c));
    const encode$32 = args.map((x) => x.encode).reduceRight(wrap, id);
    const decode$32 = args.map((x) => x.decode).reduce(wrap, id);
    return {
      encode: encode$32,
      decode: decode$32
    };
  }
  // @__NO_SIDE_EFFECTS__
  function alphabet(letters) {
    const lettersA = typeof letters === "string" ? letters.split("") : letters;
    const len = lettersA.length;
    astrArr("alphabet", lettersA);
    const indexes = new Map(lettersA.map((l, i) => [l, i]));
    return {
      encode: (digits) => {
        aArr(digits);
        return digits.map((i) => {
          if (!Number.isSafeInteger(i) || i < 0 || i >= len) throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
          return lettersA[i];
        });
      },
      decode: (input) => {
        aArr(input);
        return input.map((letter) => {
          astr("alphabet.decode", letter);
          const i = indexes.get(letter);
          if (i === void 0) throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
          return i;
        });
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function join(separator = "") {
    astr("join", separator);
    return {
      encode: (from) => {
        astrArr("join.decode", from);
        return from.join(separator);
      },
      decode: (to) => {
        astr("join.decode", to);
        return to.split(separator);
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function padding(bits, chr = "=") {
    anumber(bits);
    astr("padding", chr);
    return {
      encode(data2) {
        astrArr("padding.encode", data2);
        while (data2.length * bits % 8) data2.push(chr);
        return data2;
      },
      decode(input) {
        astrArr("padding.decode", input);
        let end = input.length;
        if (end * bits % 8) throw new Error("padding: invalid, string should have whole number of bytes");
        for (; end > 0 && input[end - 1] === chr; end--) {
          const last = end - 1;
          const byte = last * bits;
          if (byte % 8 === 0) throw new Error("padding: invalid, string has too much padding");
        }
        return input.slice(0, end);
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function normalize(fn) {
    afn(fn);
    return {
      encode: (from) => from,
      decode: (to) => fn(to)
    };
  }
  function convertRadix(data2, from, to) {
    if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
    if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
    aArr(data2);
    if (!data2.length) return [];
    let pos = 0;
    const res = [];
    const digits = Array.from(data2, (d) => {
      anumber(d);
      if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);
      return d;
    });
    const dlen = digits.length;
    while (true) {
      let carry = 0;
      let done = true;
      for (let i = pos; i < dlen; i++) {
        const digit = digits[i];
        const fromCarry = from * carry;
        const digitBase = fromCarry + digit;
        if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) throw new Error("convertRadix: carry overflow");
        const div = digitBase / to;
        carry = digitBase % to;
        const rounded = Math.floor(div);
        digits[i] = rounded;
        if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error("convertRadix: carry overflow");
        if (!done) continue;
        else if (!rounded) pos = i;
        else done = false;
      }
      res.push(carry);
      if (done) break;
    }
    for (let i = 0; i < data2.length - 1 && data2[i] === 0; i++) res.push(0);
    return res.reverse();
  }
  const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
  const radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));
  const powers = /* @__PURE__ */ (() => {
    let res = [];
    for (let i = 0; i < 40; i++) res.push(2 ** i);
    return res;
  })();
  function convertRadix2(data2, from, to, padding$1) {
    aArr(data2);
    if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);
    if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);
    if (/* @__PURE__ */ radix2carry(from, to) > 32) throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${/* @__PURE__ */ radix2carry(from, to)}`);
    let carry = 0;
    let pos = 0;
    const max2 = powers[from];
    const mask = powers[to] - 1;
    const res = [];
    for (const n of data2) {
      anumber(n);
      if (n >= max2) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
      carry = carry << from | n;
      if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
      pos += from;
      for (; pos >= to; pos -= to) res.push((carry >> pos - to & mask) >>> 0);
      const pow$1 = powers[pos];
      if (pow$1 === void 0) throw new Error("invalid carry");
      carry &= pow$1 - 1;
    }
    carry = carry << to - pos & mask;
    if (!padding$1 && pos >= from) throw new Error("Excess padding");
    if (!padding$1 && carry > 0) throw new Error(`Non-zero padding: ${carry}`);
    if (padding$1 && pos > 0) res.push(carry >>> 0);
    return res;
  }
  // @__NO_SIDE_EFFECTS__
  function radix(num$1) {
    anumber(num$1);
    const _256 = 2 ** 8;
    return {
      encode: (bytes2) => {
        if (!isBytes(bytes2)) throw new Error("radix.encode input should be Uint8Array");
        return convertRadix(Array.from(bytes2), _256, num$1);
      },
      decode: (digits) => {
        anumArr("radix.decode", digits);
        return Uint8Array.from(convertRadix(digits, num$1, _256));
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function radix2(bits, revPadding = false) {
    anumber(bits);
    if (bits <= 0 || bits > 32) throw new Error("radix2: bits should be in (0..32]");
    if (/* @__PURE__ */ radix2carry(8, bits) > 32 || /* @__PURE__ */ radix2carry(bits, 8) > 32) throw new Error("radix2: carry overflow");
    return {
      encode: (bytes2) => {
        if (!isBytes(bytes2)) throw new Error("radix2.encode input should be Uint8Array");
        return convertRadix2(Array.from(bytes2), 8, bits, !revPadding);
      },
      decode: (digits) => {
        anumArr("radix2.decode", digits);
        return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
      }
    };
  }
  function unsafeWrapper(fn) {
    afn(fn);
    return function(...args) {
      try {
        return fn.apply(null, args);
      } catch (e) {
      }
    };
  }
  function checksum(len, fn) {
    anumber(len);
    afn(fn);
    return {
      encode(data2) {
        if (!isBytes(data2)) throw new Error("checksum.encode: input should be Uint8Array");
        const sum = fn(data2).slice(0, len);
        const res = new Uint8Array(data2.length + len);
        res.set(data2);
        res.set(sum, data2.length);
        return res;
      },
      decode(data2) {
        if (!isBytes(data2)) throw new Error("checksum.decode: input should be Uint8Array");
        const payload = data2.slice(0, -len);
        const oldChecksum = data2.slice(-len);
        const newChecksum = fn(payload).slice(0, len);
        for (let i = 0; i < len; i++) if (newChecksum[i] !== oldChecksum[i]) throw new Error("Invalid checksum");
        return payload;
      }
    };
  }
  exports.utils = {
    alphabet,
    chain,
    checksum,
    convertRadix,
    convertRadix2,
    radix,
    radix2,
    join,
    padding
  };
  exports.base16 = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(4), /* @__PURE__ */ alphabet("0123456789ABCDEF"), /* @__PURE__ */ join(""));
  exports.base32 = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ padding(5), /* @__PURE__ */ join(""));
  exports.base32nopad = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ join(""));
  exports.base32hex = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ padding(5), /* @__PURE__ */ join(""));
  exports.base32hexnopad = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ join(""));
  exports.base32crockford = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), /* @__PURE__ */ join(""), /* @__PURE__ */ normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
  const hasBase64Builtin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
  const decodeBase64Builtin = (s, isUrl) => {
    astr("base64", s);
    const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
    const alphabet$1 = isUrl ? "base64url" : "base64";
    if (s.length > 0 && !re.test(s)) throw new Error("invalid base64");
    return Uint8Array.fromBase64(s, {
      alphabet: alphabet$1,
      lastChunkHandling: "strict"
    });
  };
  exports.base64 = hasBase64Builtin ? {
    encode(b) {
      abytes(b);
      return b.toBase64();
    },
    decode(s) {
      return decodeBase64Builtin(s, false);
    }
  } : /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ padding(6), /* @__PURE__ */ join(""));
  exports.base64nopad = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ join(""));
  exports.base64url = hasBase64Builtin ? {
    encode(b) {
      abytes(b);
      return b.toBase64({ alphabet: "base64url" });
    },
    decode(s) {
      return decodeBase64Builtin(s, true);
    }
  } : /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ padding(6), /* @__PURE__ */ join(""));
  exports.base64urlnopad = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ join(""));
  const genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => /* @__PURE__ */ chain(/* @__PURE__ */ radix(58), /* @__PURE__ */ alphabet(abc), /* @__PURE__ */ join(""));
  exports.base58 = /* @__PURE__ */ genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
  exports.base58flickr = /* @__PURE__ */ genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
  exports.base58xrp = /* @__PURE__ */ genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
  const XMR_BLOCK_LEN = [
    0,
    2,
    3,
    5,
    6,
    7,
    9,
    10,
    11
  ];
  exports.base58xmr = {
    encode(data2) {
      let res = "";
      for (let i = 0; i < data2.length; i += 8) {
        const block = data2.subarray(i, i + 8);
        res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
      }
      return res;
    },
    decode(str) {
      let res = [];
      for (let i = 0; i < str.length; i += 11) {
        const slice = str.slice(i, i + 11);
        const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
        const block = exports.base58.decode(slice);
        for (let j = 0; j < block.length - blockLen; j++) if (block[j] !== 0) throw new Error("base58xmr: wrong padding");
        res = res.concat(Array.from(block.slice(block.length - blockLen)));
      }
      return Uint8Array.from(res);
    }
  };
  const createBase58check = (sha256) => /* @__PURE__ */ chain(checksum(4, (data2) => sha256(sha256(data2))), exports.base58);
  exports.createBase58check = createBase58check;
  exports.base58check = exports.createBase58check;
  const BECH_ALPHABET = /* @__PURE__ */ chain(/* @__PURE__ */ alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ join(""));
  const POLYMOD_GENERATORS = [
    996825010,
    642813549,
    513874426,
    1027748829,
    705979059
  ];
  function bech32Polymod(pre) {
    const b = pre >> 25;
    let chk = (pre & 33554431) << 5;
    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];
    return chk;
  }
  function bechChecksum(prefix$12, words, encodingConst = 1) {
    const len = prefix$12.length;
    let chk = 1;
    for (let i = 0; i < len; i++) {
      const c = prefix$12.charCodeAt(i);
      if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix$12})`);
      chk = bech32Polymod(chk) ^ c >> 5;
    }
    chk = bech32Polymod(chk);
    for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ prefix$12.charCodeAt(i) & 31;
    for (let v of words) chk = bech32Polymod(chk) ^ v;
    for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);
    chk ^= encodingConst;
    return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
  }
  // @__NO_SIDE_EFFECTS__
  function genBech32(encoding) {
    const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
    const _words = /* @__PURE__ */ radix2(5);
    const fromWords = _words.decode;
    const toWords = _words.encode;
    const fromWordsUnsafe = unsafeWrapper(fromWords);
    function encode$32(prefix$12, words, limit = 90) {
      astr("bech32.encode prefix", prefix$12);
      if (isBytes(words)) words = Array.from(words);
      anumArr("bech32.encode", words);
      const plen = prefix$12.length;
      if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);
      const actualLength = plen + 7 + words.length;
      if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
      const lowered = prefix$12.toLowerCase();
      const sum = bechChecksum(lowered, words, ENCODING_CONST);
      return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
    }
    function decode$32(str, limit = 90) {
      astr("bech32.decode input", str);
      const slen = str.length;
      if (slen < 8 || limit !== false && slen > limit) throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
      const lowered = str.toLowerCase();
      if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);
      const sepIndex = lowered.lastIndexOf("1");
      if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter "1" must be present between prefix and data only`);
      const prefix$12 = lowered.slice(0, sepIndex);
      const data2 = lowered.slice(sepIndex + 1);
      if (data2.length < 6) throw new Error("Data must be at least 6 characters long");
      const words = BECH_ALPHABET.decode(data2).slice(0, -6);
      const sum = bechChecksum(prefix$12, words, ENCODING_CONST);
      if (!data2.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
      return {
        prefix: prefix$12,
        words
      };
    }
    const decodeUnsafe = unsafeWrapper(decode$32);
    function decodeToBytes(str) {
      const { prefix: prefix$12, words } = decode$32(str, false);
      return {
        prefix: prefix$12,
        words,
        bytes: fromWords(words)
      };
    }
    function encodeFromBytes(prefix$12, bytes2) {
      return encode$32(prefix$12, toWords(bytes2));
    }
    return {
      encode: encode$32,
      decode: decode$32,
      encodeFromBytes,
      decodeToBytes,
      decodeUnsafe,
      fromWords,
      fromWordsUnsafe,
      toWords
    };
  }
  exports.bech32 = /* @__PURE__ */ genBech32("bech32");
  exports.bech32m = /* @__PURE__ */ genBech32("bech32m");
  exports.utf8 = {
    encode: (data2) => new TextDecoder().decode(data2),
    decode: (str) => new TextEncoder().encode(str)
  };
  const hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
  const hexBuiltin = {
    encode(data2) {
      abytes(data2);
      return data2.toHex();
    },
    decode(s) {
      astr("hex", s);
      return Uint8Array.fromHex(s);
    }
  };
  exports.hex = hasHexBuiltin ? hexBuiltin : /* @__PURE__ */ chain(/* @__PURE__ */ radix2(4), /* @__PURE__ */ alphabet("0123456789abcdef"), /* @__PURE__ */ join(""), /* @__PURE__ */ normalize((s) => {
    if (typeof s !== "string" || s.length % 2 !== 0) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
    return s.toLowerCase();
  }));
  const CODERS = {
    utf8: exports.utf8,
    hex: exports.hex,
    base16: exports.base16,
    base32: exports.base32,
    base64: exports.base64,
    base64url: exports.base64url,
    base58: exports.base58,
    base58xmr: exports.base58xmr
  };
  const coderTypeError = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr";
  const bytesToString = (type2, bytes2) => {
    if (typeof type2 !== "string" || !CODERS.hasOwnProperty(type2)) throw new TypeError(coderTypeError);
    if (!isBytes(bytes2)) throw new TypeError("bytesToString() expects Uint8Array");
    return CODERS[type2].encode(bytes2);
  };
  exports.bytesToString = bytesToString;
  exports.str = exports.bytesToString;
  const stringToBytes = (type2, str) => {
    if (!CODERS.hasOwnProperty(type2)) throw new TypeError(coderTypeError);
    if (typeof str !== "string") throw new TypeError("stringToBytes() expects string");
    return CODERS[type2].decode(str);
  };
  exports.stringToBytes = stringToBytes;
  exports.bytes = exports.stringToBytes;
} });
var require_normalizeInput = __commonJS({ "../../node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/internal/normalizeInput.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  function normalizeInput(input) {
    return Array.isArray(input) ? new Uint8Array(input) : input;
  }
  exports.default = normalizeInput;
} });
var require_wrapCryptoCreateHash = __commonJS({ "../../node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/internal/wrapCryptoCreateHash.js"(exports) {
  var __importDefault$7 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const normalizeInput_1 = __importDefault$7(require_normalizeInput());
  function wrapCryptoCreateHash(type2, fn) {
    function hashFn(input) {
      return fn(type2).update((0, normalizeInput_1.default)(input)).digest();
    }
    hashFn.create = () => {
      const hash$12 = fn(type2);
      return {
        update(input) {
          hash$12.update((0, normalizeInput_1.default)(input));
          return this;
        },
        digest() {
          return hash$12.digest();
        }
      };
    };
    return hashFn;
  }
  exports.default = wrapCryptoCreateHash;
} });
var require_sha256 = __commonJS({ "../../node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/sha256/index.js"(exports) {
  var __importDefault$6 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sha256 = void 0;
  const crypto_1$2 = __require("crypto");
  const wrapCryptoCreateHash_1$2 = __importDefault$6(require_wrapCryptoCreateHash());
  exports.sha256 = (0, wrapCryptoCreateHash_1$2.default)("sha256", crypto_1$2.createHash);
} });
var require_utils$3 = __commonJS({ "../../node_modules/.pnpm/ripple-address-codec@5.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-address-codec/dist/utils.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatArgs = exports.arrayEqual = void 0;
  function arrayEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) return false;
    return arr1.every((value, index) => value === arr2[index]);
  }
  exports.arrayEqual = arrayEqual;
  function isScalar(val) {
    return typeof val === "number";
  }
  function concatArgs(...args) {
    return args.flatMap((arg) => {
      return isScalar(arg) ? [arg] : Array.from(arg);
    });
  }
  exports.concatArgs = concatArgs;
} });
var require_xrp_codec = __commonJS({ "../../node_modules/.pnpm/ripple-address-codec@5.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-address-codec/dist/xrp-codec.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.encodeNodePublic = exports.decodeNodePublic = exports.decodeAddress = exports.decodeAccountID = exports.encodeAddress = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;
  const base_1 = require_lib();
  const sha256_1$1 = require_sha256();
  const utils_1$5 = require_utils$3();
  var Codec = class {
    constructor(options) {
      this._sha256 = options.sha256;
      this._codec = base_1.base58xrp;
    }
    /**
    * Encoder.
    *
    * @param bytes - Uint8Array of data to encode.
    * @param opts - Options object including the version bytes and the expected length of the data to encode.
    */
    encode(bytes2, opts) {
      const versions = opts.versions;
      return this._encodeVersioned(bytes2, versions, opts.expectedLength);
    }
    /**
    * Decoder.
    *
    * @param base58string - Base58Check-encoded string to decode.
    * @param opts - Options object including the version byte(s) and the expected length of the data after decoding.
    */
    decode(base58string, opts) {
      var _a;
      const versions = opts.versions;
      const types2 = opts.versionTypes;
      const withoutSum = this.decodeChecked(base58string);
      if (versions.length > 1 && !opts.expectedLength) throw new Error("expectedLength is required because there are >= 2 possible versions");
      const versionLengthGuess = typeof versions[0] === "number" ? 1 : versions[0].length;
      const payloadLength = (_a = opts.expectedLength) !== null && _a !== void 0 ? _a : withoutSum.length - versionLengthGuess;
      const versionBytes = withoutSum.slice(0, -payloadLength);
      const payload = withoutSum.slice(-payloadLength);
      for (let i = 0; i < versions.length; i++) {
        const version2 = Array.isArray(versions[i]) ? versions[i] : [versions[i]];
        if ((0, utils_1$5.arrayEqual)(versionBytes, version2)) return {
          version: version2,
          bytes: payload,
          type: types2 ? types2[i] : null
        };
      }
      throw new Error("version_invalid: version bytes do not match any of the provided version(s)");
    }
    encodeChecked(bytes2) {
      const check = this._sha256(this._sha256(bytes2)).slice(0, 4);
      return this._encodeRaw(Uint8Array.from((0, utils_1$5.concatArgs)(bytes2, check)));
    }
    decodeChecked(base58string) {
      const intArray = this._decodeRaw(base58string);
      if (intArray.byteLength < 5) throw new Error("invalid_input_size: decoded data must have length >= 5");
      if (!this._verifyCheckSum(intArray)) throw new Error("checksum_invalid");
      return intArray.slice(0, -4);
    }
    _encodeVersioned(bytes2, versions, expectedLength) {
      if (!checkByteLength(bytes2, expectedLength)) throw new Error("unexpected_payload_length: bytes.length does not match expectedLength. Ensure that the bytes are a Uint8Array.");
      return this.encodeChecked((0, utils_1$5.concatArgs)(versions, bytes2));
    }
    _encodeRaw(bytes2) {
      return this._codec.encode(Uint8Array.from(bytes2));
    }
    _decodeRaw(base58string) {
      return this._codec.decode(base58string);
    }
    _verifyCheckSum(bytes2) {
      const computed = this._sha256(this._sha256(bytes2.slice(0, -4))).slice(0, 4);
      const checksum$1 = bytes2.slice(-4);
      return (0, utils_1$5.arrayEqual)(computed, checksum$1);
    }
  };
  const ACCOUNT_ID = 0;
  const ACCOUNT_PUBLIC_KEY = 35;
  const FAMILY_SEED = 33;
  const NODE_PUBLIC = 28;
  const ED25519_SEED = [
    1,
    225,
    75
  ];
  const codecOptions = { sha256: sha256_1$1.sha256 };
  const codecWithXrpAlphabet = new Codec(codecOptions);
  exports.codec = codecWithXrpAlphabet;
  function encodeSeed(entropy, type2) {
    if (!checkByteLength(entropy, 16)) throw new Error("entropy must have length 16");
    const opts = {
      expectedLength: 16,
      versions: type2 === "ed25519" ? ED25519_SEED : [FAMILY_SEED]
    };
    return codecWithXrpAlphabet.encode(entropy, opts);
  }
  exports.encodeSeed = encodeSeed;
  function decodeSeed(seed, opts = {
    versionTypes: ["ed25519", "secp256k1"],
    versions: [ED25519_SEED, FAMILY_SEED],
    expectedLength: 16
  }) {
    return codecWithXrpAlphabet.decode(seed, opts);
  }
  exports.decodeSeed = decodeSeed;
  function encodeAccountID(bytes2) {
    const opts = {
      versions: [ACCOUNT_ID],
      expectedLength: 20
    };
    return codecWithXrpAlphabet.encode(bytes2, opts);
  }
  exports.encodeAccountID = encodeAccountID;
  exports.encodeAddress = encodeAccountID;
  function decodeAccountID(accountId) {
    const opts = {
      versions: [ACCOUNT_ID],
      expectedLength: 20
    };
    return codecWithXrpAlphabet.decode(accountId, opts).bytes;
  }
  exports.decodeAccountID = decodeAccountID;
  exports.decodeAddress = decodeAccountID;
  function decodeNodePublic(base58string) {
    const opts = {
      versions: [NODE_PUBLIC],
      expectedLength: 33
    };
    return codecWithXrpAlphabet.decode(base58string, opts).bytes;
  }
  exports.decodeNodePublic = decodeNodePublic;
  function encodeNodePublic(bytes2) {
    const opts = {
      versions: [NODE_PUBLIC],
      expectedLength: 33
    };
    return codecWithXrpAlphabet.encode(bytes2, opts);
  }
  exports.encodeNodePublic = encodeNodePublic;
  function encodeAccountPublic(bytes2) {
    const opts = {
      versions: [ACCOUNT_PUBLIC_KEY],
      expectedLength: 33
    };
    return codecWithXrpAlphabet.encode(bytes2, opts);
  }
  exports.encodeAccountPublic = encodeAccountPublic;
  function decodeAccountPublic(base58string) {
    const opts = {
      versions: [ACCOUNT_PUBLIC_KEY],
      expectedLength: 33
    };
    return codecWithXrpAlphabet.decode(base58string, opts).bytes;
  }
  exports.decodeAccountPublic = decodeAccountPublic;
  function isValidClassicAddress(address) {
    try {
      decodeAccountID(address);
    } catch (_error) {
      return false;
    }
    return true;
  }
  exports.isValidClassicAddress = isValidClassicAddress;
  function checkByteLength(bytes2, expectedLength) {
    return "byteLength" in bytes2 ? bytes2.byteLength === expectedLength : bytes2.length === expectedLength;
  }
} });
var require_dist$1 = __commonJS({ "../../node_modules/.pnpm/ripple-address-codec@5.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-address-codec/dist/index.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isValidXAddress = exports.decodeXAddress = exports.xAddressToClassicAddress = exports.encodeXAddress = exports.classicAddressToXAddress = exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.decodeNodePublic = exports.encodeNodePublic = exports.decodeAccountID = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;
  const utils_1$4 = require_utils$4();
  const xrp_codec_1 = require_xrp_codec();
  Object.defineProperty(exports, "codec", {
    enumerable: true,
    get: function() {
      return xrp_codec_1.codec;
    }
  });
  Object.defineProperty(exports, "encodeSeed", {
    enumerable: true,
    get: function() {
      return xrp_codec_1.encodeSeed;
    }
  });
  Object.defineProperty(exports, "decodeSeed", {
    enumerable: true,
    get: function() {
      return xrp_codec_1.decodeSeed;
    }
  });
  Object.defineProperty(exports, "encodeAccountID", {
    enumerable: true,
    get: function() {
      return xrp_codec_1.encodeAccountID;
    }
  });
  Object.defineProperty(exports, "decodeAccountID", {
    enumerable: true,
    get: function() {
      return xrp_codec_1.decodeAccountID;
    }
  });
  Object.defineProperty(exports, "encodeNodePublic", {
    enumerable: true,
    get: function() {
      return xrp_codec_1.encodeNodePublic;
    }
  });
  Object.defineProperty(exports, "decodeNodePublic", {
    enumerable: true,
    get: function() {
      return xrp_codec_1.decodeNodePublic;
    }
  });
  Object.defineProperty(exports, "encodeAccountPublic", {
    enumerable: true,
    get: function() {
      return xrp_codec_1.encodeAccountPublic;
    }
  });
  Object.defineProperty(exports, "decodeAccountPublic", {
    enumerable: true,
    get: function() {
      return xrp_codec_1.decodeAccountPublic;
    }
  });
  Object.defineProperty(exports, "isValidClassicAddress", {
    enumerable: true,
    get: function() {
      return xrp_codec_1.isValidClassicAddress;
    }
  });
  const PREFIX_BYTES = {
    main: Uint8Array.from([5, 68]),
    test: Uint8Array.from([4, 147])
  };
  const MAX_32_BIT_UNSIGNED_INT = 4294967295;
  function classicAddressToXAddress(classicAddress, tag, test) {
    const accountId = (0, xrp_codec_1.decodeAccountID)(classicAddress);
    return encodeXAddress(accountId, tag, test);
  }
  exports.classicAddressToXAddress = classicAddressToXAddress;
  function encodeXAddress(accountId, tag, test) {
    if (accountId.length !== 20) throw new Error("Account ID must be 20 bytes");
    if (tag !== false && tag > MAX_32_BIT_UNSIGNED_INT) throw new Error("Invalid tag");
    const theTag = tag || 0;
    const flag = tag === false || tag == null ? 0 : 1;
    const bytes2 = (0, utils_1$4.concat)([
      test ? PREFIX_BYTES.test : PREFIX_BYTES.main,
      accountId,
      Uint8Array.from([
        flag,
        theTag & 255,
        theTag >> 8 & 255,
        theTag >> 16 & 255,
        theTag >> 24 & 255,
        0,
        0,
        0,
        0
      ])
    ]);
    return xrp_codec_1.codec.encodeChecked(bytes2);
  }
  exports.encodeXAddress = encodeXAddress;
  function xAddressToClassicAddress(xAddress) {
    const { accountId, tag, test } = decodeXAddress(xAddress);
    const classicAddress = (0, xrp_codec_1.encodeAccountID)(accountId);
    return {
      classicAddress,
      tag,
      test
    };
  }
  exports.xAddressToClassicAddress = xAddressToClassicAddress;
  function decodeXAddress(xAddress) {
    const decoded = xrp_codec_1.codec.decodeChecked(xAddress);
    const test = isUint8ArrayForTestAddress(decoded);
    const accountId = decoded.slice(2, 22);
    const tag = tagFromUint8Array(decoded);
    return {
      accountId,
      tag,
      test
    };
  }
  exports.decodeXAddress = decodeXAddress;
  function isUint8ArrayForTestAddress(buf) {
    const decodedPrefix = buf.slice(0, 2);
    if ((0, utils_1$4.equal)(PREFIX_BYTES.main, decodedPrefix)) return false;
    if ((0, utils_1$4.equal)(PREFIX_BYTES.test, decodedPrefix)) return true;
    throw new Error("Invalid X-address: bad prefix");
  }
  function tagFromUint8Array(buf) {
    const flag = buf[22];
    if (flag >= 2) throw new Error("Unsupported X-address");
    if (flag === 1) return buf[23] + buf[24] * 256 + buf[25] * 65536 + buf[26] * 16777216;
    if (flag !== 0) throw new Error("flag must be zero to indicate no tag");
    if (!(0, utils_1$4.equal)((0, utils_1$4.hexToBytes)("0000000000000000"), buf.slice(23, 31))) throw new Error("remaining bytes must be zero");
    return false;
  }
  function isValidXAddress(xAddress) {
    try {
      decodeXAddress(xAddress);
    } catch (_error) {
      return false;
    }
    return true;
  }
  exports.isValidXAddress = isValidXAddress;
} });
var require_ripemd160 = __commonJS({ "../../node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/ripemd160/index.js"(exports) {
  var __importDefault$5 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ripemd160 = void 0;
  const crypto_1$1 = __require("crypto");
  const wrapCryptoCreateHash_1$1 = __importDefault$5(require_wrapCryptoCreateHash());
  exports.ripemd160 = (0, wrapCryptoCreateHash_1$1.default)("ripemd160", crypto_1$1.createHash);
} });
var require__md = __commonJS({ "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_md.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;
  exports.setBigUint64 = setBigUint64;
  exports.Chi = Chi;
  exports.Maj = Maj;
  const utils_ts_1$10 = require_utils$5();
  function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === "function") return view.setBigUint64(byteOffset, value, isLE);
    const _32n$1 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n$1 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
  }
  function Chi(a, b, c) {
    return a & b ^ ~a & c;
  }
  function Maj(a, b, c) {
    return a & b ^ a & c ^ b & c;
  }
  var HashMD = class extends utils_ts_1$10.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
      super();
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE;
      this.buffer = new Uint8Array(blockLen);
      this.view = (0, utils_ts_1$10.createView)(this.buffer);
    }
    update(data2) {
      (0, utils_ts_1$10.aexists)(this);
      data2 = (0, utils_ts_1$10.toBytes)(data2);
      (0, utils_ts_1$10.abytes)(data2);
      const { view, buffer, blockLen } = this;
      const len = data2.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = (0, utils_ts_1$10.createView)(data2);
          for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);
          continue;
        }
        buffer.set(data2.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data2.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      (0, utils_ts_1$10.aexists)(this);
      (0, utils_ts_1$10.aoutput)(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      (0, utils_ts_1$10.clean)(this.buffer.subarray(pos));
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++) buffer[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
      this.process(view, 0);
      const oview = (0, utils_ts_1$10.createView)(out);
      const len = this.outputLen;
      if (len % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length) throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.destroyed = destroyed;
      to.finished = finished;
      to.length = length;
      to.pos = pos;
      if (length % blockLen) to.buffer.set(buffer);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
  };
  exports.HashMD = HashMD;
  exports.SHA256_IV = Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  exports.SHA224_IV = Uint32Array.from([
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ]);
  exports.SHA384_IV = Uint32Array.from([
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ]);
  exports.SHA512_IV = Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ]);
} });
var require__u64 = __commonJS({ "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/_u64.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
  exports.add = add;
  exports.fromBig = fromBig;
  exports.split = split;
  const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  const _32n = /* @__PURE__ */ BigInt(32);
  function fromBig(n, le = false) {
    if (le) return {
      h: Number(n & U32_MASK64),
      l: Number(n >> _32n & U32_MASK64)
    };
    return {
      h: Number(n >> _32n & U32_MASK64) | 0,
      l: Number(n & U32_MASK64) | 0
    };
  }
  function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i = 0; i < len; i++) {
      const { h, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  const toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
  exports.toBig = toBig;
  const shrSH = (h, _l, s) => h >>> s;
  exports.shrSH = shrSH;
  const shrSL = (h, l, s) => h << 32 - s | l >>> s;
  exports.shrSL = shrSL;
  const rotrSH = (h, l, s) => h >>> s | l << 32 - s;
  exports.rotrSH = rotrSH;
  const rotrSL = (h, l, s) => h << 32 - s | l >>> s;
  exports.rotrSL = rotrSL;
  const rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
  exports.rotrBH = rotrBH;
  const rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
  exports.rotrBL = rotrBL;
  const rotr32H = (_h, l) => l;
  exports.rotr32H = rotr32H;
  const rotr32L = (h, _l) => h;
  exports.rotr32L = rotr32L;
  const rotlSH = (h, l, s) => h << s | l >>> 32 - s;
  exports.rotlSH = rotlSH;
  const rotlSL = (h, l, s) => l << s | h >>> 32 - s;
  exports.rotlSL = rotlSL;
  const rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
  exports.rotlBH = rotlBH;
  const rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
  exports.rotlBL = rotlBL;
  function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return {
      h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
      l: l | 0
    };
  }
  const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  exports.add3L = add3L;
  const add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  exports.add3H = add3H;
  const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  exports.add4L = add4L;
  const add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  exports.add4H = add4H;
  const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  exports.add5L = add5L;
  const add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  exports.add5H = add5H;
  const u64$1 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
  };
  exports.default = u64$1;
} });
var require_sha2 = __commonJS({ "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha2.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;
  const _md_ts_1 = require__md();
  const u64 = require__u64();
  const utils_ts_1$9 = require_utils$5();
  const SHA256_K = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  var SHA256 = class extends _md_ts_1.HashMD {
    constructor(outputLen = 32) {
      super(64, outputLen, 8, false);
      this.A = _md_ts_1.SHA256_IV[0] | 0;
      this.B = _md_ts_1.SHA256_IV[1] | 0;
      this.C = _md_ts_1.SHA256_IV[2] | 0;
      this.D = _md_ts_1.SHA256_IV[3] | 0;
      this.E = _md_ts_1.SHA256_IV[4] | 0;
      this.F = _md_ts_1.SHA256_IV[5] | 0;
      this.G = _md_ts_1.SHA256_IV[6] | 0;
      this.H = _md_ts_1.SHA256_IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [
        A,
        B,
        C,
        D,
        E,
        F,
        G,
        H
      ];
    }
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);
      for (let i = 16; i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = (0, utils_ts_1$9.rotr)(W15, 7) ^ (0, utils_ts_1$9.rotr)(W15, 18) ^ W15 >>> 3;
        const s1 = (0, utils_ts_1$9.rotr)(W2, 17) ^ (0, utils_ts_1$9.rotr)(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0; i < 64; i++) {
        const sigma1 = (0, utils_ts_1$9.rotr)(E, 6) ^ (0, utils_ts_1$9.rotr)(E, 11) ^ (0, utils_ts_1$9.rotr)(E, 25);
        const T1 = H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = (0, utils_ts_1$9.rotr)(A, 2) ^ (0, utils_ts_1$9.rotr)(A, 13) ^ (0, utils_ts_1$9.rotr)(A, 22);
        const T2 = sigma0 + (0, _md_ts_1.Maj)(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      (0, utils_ts_1$9.clean)(SHA256_W);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      (0, utils_ts_1$9.clean)(this.buffer);
    }
  };
  exports.SHA256 = SHA256;
  var SHA224 = class extends SHA256 {
    constructor() {
      super(28);
      this.A = _md_ts_1.SHA224_IV[0] | 0;
      this.B = _md_ts_1.SHA224_IV[1] | 0;
      this.C = _md_ts_1.SHA224_IV[2] | 0;
      this.D = _md_ts_1.SHA224_IV[3] | 0;
      this.E = _md_ts_1.SHA224_IV[4] | 0;
      this.F = _md_ts_1.SHA224_IV[5] | 0;
      this.G = _md_ts_1.SHA224_IV[6] | 0;
      this.H = _md_ts_1.SHA224_IV[7] | 0;
    }
  };
  exports.SHA224 = SHA224;
  const K512 = /* @__PURE__ */ (() => u64.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n) => BigInt(n))))();
  const SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
  const SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
  const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
  const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
  var SHA512 = class extends _md_ts_1.HashMD {
    constructor(outputLen = 64) {
      super(128, outputLen, 16, false);
      this.Ah = _md_ts_1.SHA512_IV[0] | 0;
      this.Al = _md_ts_1.SHA512_IV[1] | 0;
      this.Bh = _md_ts_1.SHA512_IV[2] | 0;
      this.Bl = _md_ts_1.SHA512_IV[3] | 0;
      this.Ch = _md_ts_1.SHA512_IV[4] | 0;
      this.Cl = _md_ts_1.SHA512_IV[5] | 0;
      this.Dh = _md_ts_1.SHA512_IV[6] | 0;
      this.Dl = _md_ts_1.SHA512_IV[7] | 0;
      this.Eh = _md_ts_1.SHA512_IV[8] | 0;
      this.El = _md_ts_1.SHA512_IV[9] | 0;
      this.Fh = _md_ts_1.SHA512_IV[10] | 0;
      this.Fl = _md_ts_1.SHA512_IV[11] | 0;
      this.Gh = _md_ts_1.SHA512_IV[12] | 0;
      this.Gl = _md_ts_1.SHA512_IV[13] | 0;
      this.Hh = _md_ts_1.SHA512_IV[14] | 0;
      this.Hl = _md_ts_1.SHA512_IV[15] | 0;
    }
    get() {
      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [
        Ah,
        Al,
        Bh,
        Bl,
        Ch,
        Cl,
        Dh,
        Dl,
        Eh,
        El,
        Fh,
        Fl,
        Gh,
        Gl,
        Hh,
        Hl
      ];
    }
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4) {
        SHA512_W_H[i] = view.getUint32(offset);
        SHA512_W_L[i] = view.getUint32(offset += 4);
      }
      for (let i = 16; i < 80; i++) {
        const W15h = SHA512_W_H[i - 15] | 0;
        const W15l = SHA512_W_L[i - 15] | 0;
        const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
        const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H[i - 2] | 0;
        const W2l = SHA512_W_L[i - 2] | 0;
        const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
        const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
        const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
        const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
        SHA512_W_H[i] = SUMh | 0;
        SHA512_W_L[i] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i = 0; i < 80; i++) {
        const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
        const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
        const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
        const T1l = T1ll | 0;
        const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
        const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        const All = u64.add3L(T1l, sigma0l, MAJl);
        Ah = u64.add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
      ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      (0, utils_ts_1$9.clean)(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
      (0, utils_ts_1$9.clean)(this.buffer);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  exports.SHA512 = SHA512;
  var SHA384 = class extends SHA512 {
    constructor() {
      super(48);
      this.Ah = _md_ts_1.SHA384_IV[0] | 0;
      this.Al = _md_ts_1.SHA384_IV[1] | 0;
      this.Bh = _md_ts_1.SHA384_IV[2] | 0;
      this.Bl = _md_ts_1.SHA384_IV[3] | 0;
      this.Ch = _md_ts_1.SHA384_IV[4] | 0;
      this.Cl = _md_ts_1.SHA384_IV[5] | 0;
      this.Dh = _md_ts_1.SHA384_IV[6] | 0;
      this.Dl = _md_ts_1.SHA384_IV[7] | 0;
      this.Eh = _md_ts_1.SHA384_IV[8] | 0;
      this.El = _md_ts_1.SHA384_IV[9] | 0;
      this.Fh = _md_ts_1.SHA384_IV[10] | 0;
      this.Fl = _md_ts_1.SHA384_IV[11] | 0;
      this.Gh = _md_ts_1.SHA384_IV[12] | 0;
      this.Gl = _md_ts_1.SHA384_IV[13] | 0;
      this.Hh = _md_ts_1.SHA384_IV[14] | 0;
      this.Hl = _md_ts_1.SHA384_IV[15] | 0;
    }
  };
  exports.SHA384 = SHA384;
  const T224_IV = /* @__PURE__ */ Uint32Array.from([
    2352822216,
    424955298,
    1944164710,
    2312950998,
    502970286,
    855612546,
    1738396948,
    1479516111,
    258812777,
    2077511080,
    2011393907,
    79989058,
    1067287976,
    1780299464,
    286451373,
    2446758561
  ]);
  const T256_IV = /* @__PURE__ */ Uint32Array.from([
    573645204,
    4230739756,
    2673172387,
    3360449730,
    596883563,
    1867755857,
    2520282905,
    1497426621,
    2519219938,
    2827943907,
    3193839141,
    1401305490,
    721525244,
    746961066,
    246885852,
    2177182882
  ]);
  var SHA512_224 = class extends SHA512 {
    constructor() {
      super(28);
      this.Ah = T224_IV[0] | 0;
      this.Al = T224_IV[1] | 0;
      this.Bh = T224_IV[2] | 0;
      this.Bl = T224_IV[3] | 0;
      this.Ch = T224_IV[4] | 0;
      this.Cl = T224_IV[5] | 0;
      this.Dh = T224_IV[6] | 0;
      this.Dl = T224_IV[7] | 0;
      this.Eh = T224_IV[8] | 0;
      this.El = T224_IV[9] | 0;
      this.Fh = T224_IV[10] | 0;
      this.Fl = T224_IV[11] | 0;
      this.Gh = T224_IV[12] | 0;
      this.Gl = T224_IV[13] | 0;
      this.Hh = T224_IV[14] | 0;
      this.Hl = T224_IV[15] | 0;
    }
  };
  exports.SHA512_224 = SHA512_224;
  var SHA512_256 = class extends SHA512 {
    constructor() {
      super(32);
      this.Ah = T256_IV[0] | 0;
      this.Al = T256_IV[1] | 0;
      this.Bh = T256_IV[2] | 0;
      this.Bl = T256_IV[3] | 0;
      this.Ch = T256_IV[4] | 0;
      this.Cl = T256_IV[5] | 0;
      this.Dh = T256_IV[6] | 0;
      this.Dl = T256_IV[7] | 0;
      this.Eh = T256_IV[8] | 0;
      this.El = T256_IV[9] | 0;
      this.Fh = T256_IV[10] | 0;
      this.Fl = T256_IV[11] | 0;
      this.Gh = T256_IV[12] | 0;
      this.Gl = T256_IV[13] | 0;
      this.Hh = T256_IV[14] | 0;
      this.Hl = T256_IV[15] | 0;
    }
  };
  exports.SHA512_256 = SHA512_256;
  exports.sha256 = (0, utils_ts_1$9.createHasher)(() => new SHA256());
  exports.sha224 = (0, utils_ts_1$9.createHasher)(() => new SHA224());
  exports.sha512 = (0, utils_ts_1$9.createHasher)(() => new SHA512());
  exports.sha384 = (0, utils_ts_1$9.createHasher)(() => new SHA384());
  exports.sha512_256 = (0, utils_ts_1$9.createHasher)(() => new SHA512_256());
  exports.sha512_224 = (0, utils_ts_1$9.createHasher)(() => new SHA512_224());
} });
var require_hmac = __commonJS({ "../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/hmac.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hmac = exports.HMAC = void 0;
  const utils_ts_1$8 = require_utils$5();
  var HMAC = class extends utils_ts_1$8.Hash {
    constructor(hash$12, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      (0, utils_ts_1$8.ahash)(hash$12);
      const key = (0, utils_ts_1$8.toBytes)(_key);
      this.iHash = hash$12.create();
      if (typeof this.iHash.update !== "function") throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > blockLen ? hash$12.create().update(key).digest() : key);
      for (let i = 0; i < pad.length; i++) pad[i] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash$12.create();
      for (let i = 0; i < pad.length; i++) pad[i] ^= 106;
      this.oHash.update(pad);
      (0, utils_ts_1$8.clean)(pad);
    }
    update(buf) {
      (0, utils_ts_1$8.aexists)(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      (0, utils_ts_1$8.aexists)(this);
      (0, utils_ts_1$8.abytes)(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  exports.HMAC = HMAC;
  const hmac = (hash$12, key, message2) => new HMAC(hash$12, key).update(message2).digest();
  exports.hmac = hmac;
  exports.hmac.create = (hash$12, key) => new HMAC(hash$12, key);
} });
var require_utils$2 = __commonJS({ "../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/utils.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;
  exports.abool = abool;
  exports.numberToHexUnpadded = numberToHexUnpadded;
  exports.hexToNumber = hexToNumber;
  exports.bytesToNumberBE = bytesToNumberBE;
  exports.bytesToNumberLE = bytesToNumberLE;
  exports.numberToBytesBE = numberToBytesBE;
  exports.numberToBytesLE = numberToBytesLE;
  exports.numberToVarBytesBE = numberToVarBytesBE;
  exports.ensureBytes = ensureBytes;
  exports.equalBytes = equalBytes;
  exports.inRange = inRange;
  exports.aInRange = aInRange;
  exports.bitLen = bitLen;
  exports.bitGet = bitGet;
  exports.bitSet = bitSet;
  exports.createHmacDrbg = createHmacDrbg;
  exports.validateObject = validateObject;
  exports.isHash = isHash;
  exports._validateObject = _validateObject;
  exports.memoized = memoized;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const utils_js_1$2 = require_utils$5();
  var utils_js_2 = require_utils$5();
  Object.defineProperty(exports, "abytes", {
    enumerable: true,
    get: function() {
      return utils_js_2.abytes;
    }
  });
  Object.defineProperty(exports, "anumber", {
    enumerable: true,
    get: function() {
      return utils_js_2.anumber;
    }
  });
  Object.defineProperty(exports, "bytesToHex", {
    enumerable: true,
    get: function() {
      return utils_js_2.bytesToHex;
    }
  });
  Object.defineProperty(exports, "bytesToUtf8", {
    enumerable: true,
    get: function() {
      return utils_js_2.bytesToUtf8;
    }
  });
  Object.defineProperty(exports, "concatBytes", {
    enumerable: true,
    get: function() {
      return utils_js_2.concatBytes;
    }
  });
  Object.defineProperty(exports, "hexToBytes", {
    enumerable: true,
    get: function() {
      return utils_js_2.hexToBytes;
    }
  });
  Object.defineProperty(exports, "isBytes", {
    enumerable: true,
    get: function() {
      return utils_js_2.isBytes;
    }
  });
  Object.defineProperty(exports, "randomBytes", {
    enumerable: true,
    get: function() {
      return utils_js_2.randomBytes;
    }
  });
  Object.defineProperty(exports, "utf8ToBytes", {
    enumerable: true,
    get: function() {
      return utils_js_2.utf8ToBytes;
    }
  });
  const _0n$7 = /* @__PURE__ */ BigInt(0);
  const _1n$7 = /* @__PURE__ */ BigInt(1);
  function abool(title, value) {
    if (typeof value !== "boolean") throw new Error(title + " boolean expected, got " + value);
  }
  function numberToHexUnpadded(num$1) {
    const hex = num$1.toString(16);
    return hex.length & 1 ? "0" + hex : hex;
  }
  function hexToNumber(hex) {
    if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
    return hex === "" ? _0n$7 : BigInt("0x" + hex);
  }
  function bytesToNumberBE(bytes2) {
    return hexToNumber((0, utils_js_1$2.bytesToHex)(bytes2));
  }
  function bytesToNumberLE(bytes2) {
    (0, utils_js_1$2.abytes)(bytes2);
    return hexToNumber((0, utils_js_1$2.bytesToHex)(Uint8Array.from(bytes2).reverse()));
  }
  function numberToBytesBE(n, len) {
    return (0, utils_js_1$2.hexToBytes)(n.toString(16).padStart(len * 2, "0"));
  }
  function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
  }
  function numberToVarBytesBE(n) {
    return (0, utils_js_1$2.hexToBytes)(numberToHexUnpadded(n));
  }
  function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") try {
      res = (0, utils_js_1$2.hexToBytes)(hex);
    } catch (e) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
    }
    else if ((0, utils_js_1$2.isBytes)(hex)) res = Uint8Array.from(hex);
    else throw new Error(title + " must be hex string or Uint8Array");
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength) throw new Error(title + " of length " + expectedLength + " expected, got " + len);
    return res;
  }
  function equalBytes(a, b) {
    if (a.length !== b.length) return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];
    return diff === 0;
  }
  const isPosBig = (n) => typeof n === "bigint" && _0n$7 <= n;
  function inRange(n, min2, max2) {
    return isPosBig(n) && isPosBig(min2) && isPosBig(max2) && min2 <= n && n < max2;
  }
  function aInRange(title, n, min2, max2) {
    if (!inRange(n, min2, max2)) throw new Error("expected valid " + title + ": " + min2 + " <= n < " + max2 + ", got " + n);
  }
  function bitLen(n) {
    let len;
    for (len = 0; n > _0n$7; n >>= _1n$7, len += 1) ;
    return len;
  }
  function bitGet(n, pos) {
    return n >> BigInt(pos) & _1n$7;
  }
  function bitSet(n, pos, value) {
    return n | (value ? _1n$7 : _0n$7) << BigInt(pos);
  }
  const bitMask = (n) => (_1n$7 << BigInt(n)) - _1n$7;
  exports.bitMask = bitMask;
  function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2) throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2) throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function") throw new Error("hmacFn must be a function");
    const u8n = (len) => new Uint8Array(len);
    const u8of = (byte) => Uint8Array.of(byte);
    let v = u8n(hashLen);
    let k = u8n(hashLen);
    let i = 0;
    const reset = () => {
      v.fill(1);
      k.fill(0);
      i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b);
    const reseed = (seed = u8n(0)) => {
      k = h(u8of(0), seed);
      v = h();
      if (seed.length === 0) return;
      k = h(u8of(1), seed);
      v = h();
    };
    const gen = () => {
      if (i++ >= 1e3) throw new Error("drbg: tried 1000 values");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v = h();
        const sl = v.slice();
        out.push(sl);
        len += v.length;
      }
      return (0, utils_js_1$2.concatBytes)(...out);
    };
    const genUntil = (seed, pred) => {
      reset();
      reseed(seed);
      let res = void 0;
      while (!(res = pred(gen()))) reseed();
      reset();
      return res;
    };
    return genUntil;
  }
  const validatorFns = {
    bigint: (val) => typeof val === "bigint",
    function: (val) => typeof val === "function",
    boolean: (val) => typeof val === "boolean",
    string: (val) => typeof val === "string",
    stringOrUint8Array: (val) => typeof val === "string" || (0, utils_js_1$2.isBytes)(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
  };
  function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type2, isOptional) => {
      const checkVal = validatorFns[type2];
      if (typeof checkVal !== "function") throw new Error("invalid validator function");
      const val = object[fieldName];
      if (isOptional && val === void 0) return;
      if (!checkVal(val, object)) throw new Error("param " + String(fieldName) + " is invalid. Expected " + type2 + ", got " + val);
    };
    for (const [fieldName, type2] of Object.entries(validators)) checkField(fieldName, type2, false);
    for (const [fieldName, type2] of Object.entries(optValidators)) checkField(fieldName, type2, true);
    return object;
  }
  function isHash(val) {
    return typeof val === "function" && Number.isSafeInteger(val.outputLen);
  }
  function _validateObject(object, fields, optFields = {}) {
    if (!object || typeof object !== "object") throw new Error("expected valid options object");
    function checkField(fieldName, expectedType, isOpt) {
      const val = object[fieldName];
      if (isOpt && val === void 0) return;
      const current = typeof val;
      if (current !== expectedType || val === null) throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
    }
    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
  }
  const notImplemented = () => {
    throw new Error("not implemented");
  };
  exports.notImplemented = notImplemented;
  function memoized(fn) {
    const map = /* @__PURE__ */ new WeakMap();
    return (arg, ...args) => {
      const val = map.get(arg);
      if (val !== void 0) return val;
      const computed = fn(arg, ...args);
      map.set(arg, computed);
      return computed;
    };
  }
} });
var require_modular = __commonJS({ "../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/modular.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isNegativeLE = void 0;
  exports.mod = mod;
  exports.pow = pow2;
  exports.pow2 = pow22;
  exports.invert = invert;
  exports.tonelliShanks = tonelliShanks;
  exports.FpSqrt = FpSqrt;
  exports.validateField = validateField;
  exports.FpPow = FpPow;
  exports.FpInvertBatch = FpInvertBatch;
  exports.FpDiv = FpDiv;
  exports.FpLegendre = FpLegendre;
  exports.FpIsSquare = FpIsSquare;
  exports.nLength = nLength;
  exports.Field = Field;
  exports.FpSqrtOdd = FpSqrtOdd;
  exports.FpSqrtEven = FpSqrtEven;
  exports.hashToPrivateScalar = hashToPrivateScalar;
  exports.getFieldBytesLength = getFieldBytesLength;
  exports.getMinHashLength = getMinHashLength;
  exports.mapHashToField = mapHashToField;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const utils_ts_1$7 = require_utils$2();
  const _0n$6 = BigInt(0), _1n$6 = BigInt(1), _2n$5 = /* @__PURE__ */ BigInt(2), _3n$2 = /* @__PURE__ */ BigInt(3);
  const _4n$1 = /* @__PURE__ */ BigInt(4), _5n$1 = /* @__PURE__ */ BigInt(5);
  const _8n$2 = /* @__PURE__ */ BigInt(8);
  function mod(a, b) {
    const result = a % b;
    return result >= _0n$6 ? result : b + result;
  }
  function pow2(num$1, power, modulo) {
    return FpPow(Field(modulo), num$1, power);
  }
  function pow22(x, power, modulo) {
    let res = x;
    while (power-- > _0n$6) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert(number, modulo) {
    if (number === _0n$6) throw new Error("invert: expected non-zero number");
    if (modulo <= _0n$6) throw new Error("invert: expected positive modulus, got " + modulo);
    let a = mod(number, modulo);
    let b = modulo;
    let x = _0n$6, u = _1n$6;
    while (a !== _0n$6) {
      const q = b / a;
      const r = b % a;
      const m = x - u * q;
      b = a, a = r, x = u, u = m;
    }
    const gcd$1 = b;
    if (gcd$1 !== _1n$6) throw new Error("invert: does not exist");
    return mod(x, modulo);
  }
  function sqrt3mod4(Fp$1, n) {
    const p1div4 = (Fp$1.ORDER + _1n$6) / _4n$1;
    const root2 = Fp$1.pow(n, p1div4);
    if (!Fp$1.eql(Fp$1.sqr(root2), n)) throw new Error("Cannot find square root");
    return root2;
  }
  function sqrt5mod8(Fp$1, n) {
    const p5div8 = (Fp$1.ORDER - _5n$1) / _8n$2;
    const n2 = Fp$1.mul(n, _2n$5);
    const v = Fp$1.pow(n2, p5div8);
    const nv = Fp$1.mul(n, v);
    const i = Fp$1.mul(Fp$1.mul(nv, _2n$5), v);
    const root2 = Fp$1.mul(nv, Fp$1.sub(i, Fp$1.ONE));
    if (!Fp$1.eql(Fp$1.sqr(root2), n)) throw new Error("Cannot find square root");
    return root2;
  }
  function tonelliShanks(P) {
    if (P < BigInt(3)) throw new Error("sqrt is not defined for small field");
    let Q = P - _1n$6;
    let S = 0;
    while (Q % _2n$5 === _0n$6) {
      Q /= _2n$5;
      S++;
    }
    let Z = _2n$5;
    const _Fp = Field(P);
    while (FpLegendre(_Fp, Z) === 1) if (Z++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
    if (S === 1) return sqrt3mod4;
    let cc = _Fp.pow(Z, Q);
    const Q1div2 = (Q + _1n$6) / _2n$5;
    return function tonelliSlow(Fp$1, n) {
      if (Fp$1.is0(n)) return n;
      if (FpLegendre(Fp$1, n) !== 1) throw new Error("Cannot find square root");
      let M = S;
      let c = Fp$1.mul(Fp$1.ONE, cc);
      let t = Fp$1.pow(n, Q);
      let R = Fp$1.pow(n, Q1div2);
      while (!Fp$1.eql(t, Fp$1.ONE)) {
        if (Fp$1.is0(t)) return Fp$1.ZERO;
        let i = 1;
        let t_tmp = Fp$1.sqr(t);
        while (!Fp$1.eql(t_tmp, Fp$1.ONE)) {
          i++;
          t_tmp = Fp$1.sqr(t_tmp);
          if (i === M) throw new Error("Cannot find square root");
        }
        const exponent = _1n$6 << BigInt(M - i - 1);
        const b = Fp$1.pow(c, exponent);
        M = i;
        c = Fp$1.sqr(b);
        t = Fp$1.mul(t, c);
        R = Fp$1.mul(R, b);
      }
      return R;
    };
  }
  function FpSqrt(P) {
    if (P % _4n$1 === _3n$2) return sqrt3mod4;
    if (P % _8n$2 === _5n$1) return sqrt5mod8;
    return tonelliShanks(P);
  }
  const isNegativeLE = (num$1, modulo) => (mod(num$1, modulo) & _1n$6) === _1n$6;
  exports.isNegativeLE = isNegativeLE;
  const FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  function validateField(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "number",
      BITS: "number"
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
      map[val] = "function";
      return map;
    }, initial);
    (0, utils_ts_1$7._validateObject)(field, opts);
    return field;
  }
  function FpPow(Fp$1, num$1, power) {
    if (power < _0n$6) throw new Error("invalid exponent, negatives unsupported");
    if (power === _0n$6) return Fp$1.ONE;
    if (power === _1n$6) return num$1;
    let p = Fp$1.ONE;
    let d = num$1;
    while (power > _0n$6) {
      if (power & _1n$6) p = Fp$1.mul(p, d);
      d = Fp$1.sqr(d);
      power >>= _1n$6;
    }
    return p;
  }
  function FpInvertBatch(Fp$1, nums, passZero = false) {
    const inverted = new Array(nums.length).fill(passZero ? Fp$1.ZERO : void 0);
    const multipliedAcc = nums.reduce((acc, num$1, i) => {
      if (Fp$1.is0(num$1)) return acc;
      inverted[i] = acc;
      return Fp$1.mul(acc, num$1);
    }, Fp$1.ONE);
    const invertedAcc = Fp$1.inv(multipliedAcc);
    nums.reduceRight((acc, num$1, i) => {
      if (Fp$1.is0(num$1)) return acc;
      inverted[i] = Fp$1.mul(acc, inverted[i]);
      return Fp$1.mul(acc, num$1);
    }, invertedAcc);
    return inverted;
  }
  function FpDiv(Fp$1, lhs, rhs) {
    return Fp$1.mul(lhs, typeof rhs === "bigint" ? invert(rhs, Fp$1.ORDER) : Fp$1.inv(rhs));
  }
  function FpLegendre(Fp$1, n) {
    const p1mod2 = (Fp$1.ORDER - _1n$6) / _2n$5;
    const powered = Fp$1.pow(n, p1mod2);
    const yes = Fp$1.eql(powered, Fp$1.ONE);
    const zero = Fp$1.eql(powered, Fp$1.ZERO);
    const no = Fp$1.eql(powered, Fp$1.neg(Fp$1.ONE));
    if (!yes && !zero && !no) throw new Error("invalid Legendre symbol result");
    return yes ? 1 : zero ? 0 : -1;
  }
  function FpIsSquare(Fp$1, n) {
    const l = FpLegendre(Fp$1, n);
    return l === 1;
  }
  function nLength(n, nBitLength) {
    if (nBitLength !== void 0) (0, utils_ts_1$7.anumber)(nBitLength);
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return {
      nBitLength: _nBitLength,
      nByteLength
    };
  }
  function Field(ORDER, bitLenOrOpts, isLE = false, opts = {}) {
    if (ORDER <= _0n$6) throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
    let _nbitLength = void 0;
    let _sqrt = void 0;
    if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
      if (opts.sqrt || isLE) throw new Error("cannot specify opts in two arguments");
      const _opts = bitLenOrOpts;
      if (_opts.BITS) _nbitLength = _opts.BITS;
      if (_opts.sqrt) _sqrt = _opts.sqrt;
      if (typeof _opts.isLE === "boolean") isLE = _opts.isLE;
    } else {
      if (typeof bitLenOrOpts === "number") _nbitLength = bitLenOrOpts;
      if (opts.sqrt) _sqrt = opts.sqrt;
    }
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
    if (BYTES > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let sqrtP;
    const f = Object.freeze({
      ORDER,
      isLE,
      BITS,
      BYTES,
      MASK: (0, utils_ts_1$7.bitMask)(BITS),
      ZERO: _0n$6,
      ONE: _1n$6,
      create: (num$1) => mod(num$1, ORDER),
      isValid: (num$1) => {
        if (typeof num$1 !== "bigint") throw new Error("invalid field element: expected bigint, got " + typeof num$1);
        return _0n$6 <= num$1 && num$1 < ORDER;
      },
      is0: (num$1) => num$1 === _0n$6,
      isValidNot0: (num$1) => !f.is0(num$1) && f.isValid(num$1),
      isOdd: (num$1) => (num$1 & _1n$6) === _1n$6,
      neg: (num$1) => mod(-num$1, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num$1) => mod(num$1 * num$1, ORDER),
      add: (lhs, rhs) => mod(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
      pow: (num$1, power) => FpPow(f, num$1, power),
      div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
      sqrN: (num$1) => num$1 * num$1,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num$1) => invert(num$1, ORDER),
      sqrt: _sqrt || ((n) => {
        if (!sqrtP) sqrtP = FpSqrt(ORDER);
        return sqrtP(f, n);
      }),
      toBytes: (num$1) => isLE ? (0, utils_ts_1$7.numberToBytesLE)(num$1, BYTES) : (0, utils_ts_1$7.numberToBytesBE)(num$1, BYTES),
      fromBytes: (bytes2) => {
        if (bytes2.length !== BYTES) throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes2.length);
        return isLE ? (0, utils_ts_1$7.bytesToNumberLE)(bytes2) : (0, utils_ts_1$7.bytesToNumberBE)(bytes2);
      },
      invertBatch: (lst) => FpInvertBatch(f, lst),
      cmov: (a, b, c) => c ? b : a
    });
    return Object.freeze(f);
  }
  function FpSqrtOdd(Fp$1, elm) {
    if (!Fp$1.isOdd) throw new Error("Field doesn't have isOdd");
    const root2 = Fp$1.sqrt(elm);
    return Fp$1.isOdd(root2) ? root2 : Fp$1.neg(root2);
  }
  function FpSqrtEven(Fp$1, elm) {
    if (!Fp$1.isOdd) throw new Error("Field doesn't have isOdd");
    const root2 = Fp$1.sqrt(elm);
    return Fp$1.isOdd(root2) ? Fp$1.neg(root2) : root2;
  }
  function hashToPrivateScalar(hash$12, groupOrder, isLE = false) {
    hash$12 = (0, utils_ts_1$7.ensureBytes)("privateHash", hash$12);
    const hashLen = hash$12.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error("hashToPrivateScalar: expected " + minLen + "-1024 bytes of input, got " + hashLen);
    const num$1 = isLE ? (0, utils_ts_1$7.bytesToNumberLE)(hash$12) : (0, utils_ts_1$7.bytesToNumberBE)(hash$12);
    return mod(num$1, groupOrder - _1n$6) + _1n$6;
  }
  function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== "bigint") throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
  }
  function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
  }
  function mapHashToField(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    if (len < 16 || len < minLen || len > 1024) throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
    const num$1 = isLE ? (0, utils_ts_1$7.bytesToNumberLE)(key) : (0, utils_ts_1$7.bytesToNumberBE)(key);
    const reduced = mod(num$1, fieldOrder - _1n$6) + _1n$6;
    return isLE ? (0, utils_ts_1$7.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1$7.numberToBytesBE)(reduced, fieldLen);
  }
} });
var require_curve = __commonJS({ "../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/curve.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.negateCt = negateCt;
  exports.normalizeZ = normalizeZ;
  exports.wNAF = wNAF;
  exports.mulEndoUnsafe = mulEndoUnsafe;
  exports.pippenger = pippenger;
  exports.precomputeMSMUnsafe = precomputeMSMUnsafe;
  exports.validateBasic = validateBasic;
  exports._createCurveFields = _createCurveFields;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const utils_ts_1$6 = require_utils$2();
  const modular_ts_1$6 = require_modular();
  const _0n$5 = BigInt(0);
  const _1n$5 = BigInt(1);
  function negateCt(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
  }
  function normalizeZ(c, property2, points) {
    const getz = property2 === "pz" ? (p) => p.pz : (p) => p.ez;
    const toInv = (0, modular_ts_1$6.FpInvertBatch)(c.Fp, points.map(getz));
    const affined = points.map((p, i) => p.toAffine(toInv[i]));
    return affined.map(c.fromAffine);
  }
  function validateW(W, bits) {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
  }
  function calcWOpts(W, scalarBits) {
    validateW(W, scalarBits);
    const windows = Math.ceil(scalarBits / W) + 1;
    const windowSize = 2 ** (W - 1);
    const maxNumber = 2 ** W;
    const mask = (0, utils_ts_1$6.bitMask)(W);
    const shiftBy = BigInt(W);
    return {
      windows,
      windowSize,
      mask,
      maxNumber,
      shiftBy
    };
  }
  function calcOffsets(n, window2, wOpts) {
    const { windowSize, mask, maxNumber, shiftBy } = wOpts;
    let wbits = Number(n & mask);
    let nextN = n >> shiftBy;
    if (wbits > windowSize) {
      wbits -= maxNumber;
      nextN += _1n$5;
    }
    const offsetStart = window2 * windowSize;
    const offset = offsetStart + Math.abs(wbits) - 1;
    const isZero = wbits === 0;
    const isNeg = wbits < 0;
    const isNegF = window2 % 2 !== 0;
    const offsetF = offsetStart;
    return {
      nextN,
      offset,
      isZero,
      isNeg,
      isNegF,
      offsetF
    };
  }
  function validateMSMPoints(points, c) {
    if (!Array.isArray(points)) throw new Error("array expected");
    points.forEach((p, i) => {
      if (!(p instanceof c)) throw new Error("invalid point at index " + i);
    });
  }
  function validateMSMScalars(scalars, field) {
    if (!Array.isArray(scalars)) throw new Error("array of scalars expected");
    scalars.forEach((s, i) => {
      if (!field.isValid(s)) throw new Error("invalid scalar at index " + i);
    });
  }
  const pointPrecomputes = /* @__PURE__ */ new WeakMap();
  const pointWindowSizes = /* @__PURE__ */ new WeakMap();
  function getW(P) {
    return pointWindowSizes.get(P) || 1;
  }
  function assert0(n) {
    if (n !== _0n$5) throw new Error("invalid wNAF");
  }
  function wNAF(c, bits) {
    return {
      constTimeNegate: negateCt,
      hasPrecomputes(elm) {
        return getW(elm) !== 1;
      },
      unsafeLadder(elm, n, p = c.ZERO) {
        let d = elm;
        while (n > _0n$5) {
          if (n & _1n$5) p = p.add(d);
          d = d.double();
          n >>= _1n$5;
        }
        return p;
      },
      precomputeWindow(elm, W) {
        const { windows, windowSize } = calcWOpts(W, bits);
        const points = [];
        let p = elm;
        let base$12 = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base$12 = p;
          points.push(base$12);
          for (let i = 1; i < windowSize; i++) {
            base$12 = base$12.add(p);
            points.push(base$12);
          }
          p = base$12.double();
        }
        return points;
      },
      wNAF(W, precomputes, n) {
        let p = c.ZERO;
        let f = c.BASE;
        const wo = calcWOpts(W, bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
          n = nextN;
          if (isZero) f = f.add(negateCt(isNegF, precomputes[offsetF]));
          else p = p.add(negateCt(isNeg, precomputes[offset]));
        }
        assert0(n);
        return {
          p,
          f
        };
      },
      wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {
        const wo = calcWOpts(W, bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          if (n === _0n$5) break;
          const { nextN, offset, isZero, isNeg } = calcOffsets(n, window2, wo);
          n = nextN;
          if (isZero) continue;
          else {
            const item = precomputes[offset];
            acc = acc.add(isNeg ? item.negate() : item);
          }
        }
        assert0(n);
        return acc;
      },
      getPrecomputes(W, P, transform) {
        let comp = pointPrecomputes.get(P);
        if (!comp) {
          comp = this.precomputeWindow(P, W);
          if (W !== 1) {
            if (typeof transform === "function") comp = transform(comp);
            pointPrecomputes.set(P, comp);
          }
        }
        return comp;
      },
      wNAFCached(P, n, transform) {
        const W = getW(P);
        return this.wNAF(W, this.getPrecomputes(W, P, transform), n);
      },
      wNAFCachedUnsafe(P, n, transform, prev) {
        const W = getW(P);
        if (W === 1) return this.unsafeLadder(P, n, prev);
        return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);
      },
      setWindowSize(P, W) {
        validateW(W, bits);
        pointWindowSizes.set(P, W);
        pointPrecomputes.delete(P);
      }
    };
  }
  function mulEndoUnsafe(c, point, k1, k2) {
    let acc = point;
    let p1 = c.ZERO;
    let p2 = c.ZERO;
    while (k1 > _0n$5 || k2 > _0n$5) {
      if (k1 & _1n$5) p1 = p1.add(acc);
      if (k2 & _1n$5) p2 = p2.add(acc);
      acc = acc.double();
      k1 >>= _1n$5;
      k2 >>= _1n$5;
    }
    return {
      p1,
      p2
    };
  }
  function pippenger(c, fieldN, points, scalars) {
    validateMSMPoints(points, c);
    validateMSMScalars(scalars, fieldN);
    const plength = points.length;
    const slength = scalars.length;
    if (plength !== slength) throw new Error("arrays of points and scalars must have equal length");
    const zero = c.ZERO;
    const wbits = (0, utils_ts_1$6.bitLen)(BigInt(plength));
    let windowSize = 1;
    if (wbits > 12) windowSize = wbits - 3;
    else if (wbits > 4) windowSize = wbits - 2;
    else if (wbits > 0) windowSize = 2;
    const MASK = (0, utils_ts_1$6.bitMask)(windowSize);
    const buckets = new Array(Number(MASK) + 1).fill(zero);
    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
    let sum = zero;
    for (let i = lastBits; i >= 0; i -= windowSize) {
      buckets.fill(zero);
      for (let j = 0; j < slength; j++) {
        const scalar = scalars[j];
        const wbits$1 = Number(scalar >> BigInt(i) & MASK);
        buckets[wbits$1] = buckets[wbits$1].add(points[j]);
      }
      let resI = zero;
      for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
        sumI = sumI.add(buckets[j]);
        resI = resI.add(sumI);
      }
      sum = sum.add(resI);
      if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();
    }
    return sum;
  }
  function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
    validateW(windowSize, fieldN.BITS);
    validateMSMPoints(points, c);
    const zero = c.ZERO;
    const tableSize = 2 ** windowSize - 1;
    const chunks = Math.ceil(fieldN.BITS / windowSize);
    const MASK = (0, utils_ts_1$6.bitMask)(windowSize);
    const tables = points.map((p) => {
      const res = [];
      for (let i = 0, acc = p; i < tableSize; i++) {
        res.push(acc);
        acc = acc.add(p);
      }
      return res;
    });
    return (scalars) => {
      validateMSMScalars(scalars, fieldN);
      if (scalars.length > points.length) throw new Error("array of scalars must be smaller than array of points");
      let res = zero;
      for (let i = 0; i < chunks; i++) {
        if (res !== zero) for (let j = 0; j < windowSize; j++) res = res.double();
        const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);
        for (let j = 0; j < scalars.length; j++) {
          const n = scalars[j];
          const curr = Number(n >> shiftBy & MASK);
          if (!curr) continue;
          res = res.add(tables[j][curr - 1]);
        }
      }
      return res;
    };
  }
  function validateBasic(curve) {
    (0, modular_ts_1$6.validateField)(curve.Fp);
    (0, utils_ts_1$6.validateObject)(curve, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    });
    return Object.freeze({
      ...(0, modular_ts_1$6.nLength)(curve.n, curve.nBitLength),
      ...curve,
      p: curve.Fp.ORDER
    });
  }
  function createField(order, field) {
    if (field) {
      if (field.ORDER !== order) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
      (0, modular_ts_1$6.validateField)(field);
      return field;
    } else return (0, modular_ts_1$6.Field)(order);
  }
  function _createCurveFields(type2, CURVE, curveOpts = {}) {
    if (!CURVE || typeof CURVE !== "object") throw new Error(`expected valid ${type2} CURVE object`);
    for (const p of [
      "p",
      "n",
      "h"
    ]) {
      const val = CURVE[p];
      if (!(typeof val === "bigint" && val > _0n$5)) throw new Error(`CURVE.${p} must be positive bigint`);
    }
    const Fp$1 = createField(CURVE.p, curveOpts.Fp);
    const Fn = createField(CURVE.n, curveOpts.Fn);
    const _b = type2 === "weierstrass" ? "b" : "d";
    const params = [
      "Gx",
      "Gy",
      "a",
      _b
    ];
    for (const p of params) if (!Fp$1.isValid(CURVE[p])) throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
    return {
      Fp: Fp$1,
      Fn
    };
  }
} });
var require_weierstrass = __commonJS({ "../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DER = exports.DERErr = void 0;
  exports._legacyHelperEquat = _legacyHelperEquat;
  exports._legacyHelperNormPriv = _legacyHelperNormPriv;
  exports.weierstrassN = weierstrassN;
  exports.weierstrassPoints = weierstrassPoints;
  exports.ecdsa = ecdsa;
  exports.weierstrass = weierstrass;
  exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
  exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const hmac_js_1 = require_hmac();
  const utils_ts_1$5 = require_utils$2();
  const curve_ts_1$2 = require_curve();
  const modular_ts_1$5 = require_modular();
  function validateSigVerOpts(opts) {
    if (opts.lowS !== void 0) (0, utils_ts_1$5.abool)("lowS", opts.lowS);
    if (opts.prehash !== void 0) (0, utils_ts_1$5.abool)("prehash", opts.prehash);
  }
  var DERErr = class extends Error {
    constructor(m = "") {
      super(m);
    }
  };
  exports.DERErr = DERErr;
  exports.DER = {
    Err: DERErr,
    _tlv: {
      encode: (tag, data2) => {
        const { Err: E } = exports.DER;
        if (tag < 0 || tag > 256) throw new E("tlv.encode: wrong tag");
        if (data2.length & 1) throw new E("tlv.encode: unpadded data");
        const dataLen = data2.length / 2;
        const len = (0, utils_ts_1$5.numberToHexUnpadded)(dataLen);
        if (len.length / 2 & 128) throw new E("tlv.encode: long form length too big");
        const lenLen = dataLen > 127 ? (0, utils_ts_1$5.numberToHexUnpadded)(len.length / 2 | 128) : "";
        const t = (0, utils_ts_1$5.numberToHexUnpadded)(tag);
        return t + lenLen + len + data2;
      },
      decode(tag, data2) {
        const { Err: E } = exports.DER;
        let pos = 0;
        if (tag < 0 || tag > 256) throw new E("tlv.encode: wrong tag");
        if (data2.length < 2 || data2[pos++] !== tag) throw new E("tlv.decode: wrong tlv");
        const first = data2[pos++];
        const isLong = !!(first & 128);
        let length = 0;
        if (!isLong) length = first;
        else {
          const lenLen = first & 127;
          if (!lenLen) throw new E("tlv.decode(long): indefinite length not supported");
          if (lenLen > 4) throw new E("tlv.decode(long): byte length is too big");
          const lengthBytes = data2.subarray(pos, pos + lenLen);
          if (lengthBytes.length !== lenLen) throw new E("tlv.decode: length bytes not complete");
          if (lengthBytes[0] === 0) throw new E("tlv.decode(long): zero leftmost byte");
          for (const b of lengthBytes) length = length << 8 | b;
          pos += lenLen;
          if (length < 128) throw new E("tlv.decode(long): not minimal encoding");
        }
        const v = data2.subarray(pos, pos + length);
        if (v.length !== length) throw new E("tlv.decode: wrong value length");
        return {
          v,
          l: data2.subarray(pos + length)
        };
      }
    },
    _int: {
      encode(num$1) {
        const { Err: E } = exports.DER;
        if (num$1 < _0n$4) throw new E("integer: negative integers are not allowed");
        let hex = (0, utils_ts_1$5.numberToHexUnpadded)(num$1);
        if (Number.parseInt(hex[0], 16) & 8) hex = "00" + hex;
        if (hex.length & 1) throw new E("unexpected DER parsing assertion: unpadded hex");
        return hex;
      },
      decode(data2) {
        const { Err: E } = exports.DER;
        if (data2[0] & 128) throw new E("invalid signature integer: negative");
        if (data2[0] === 0 && !(data2[1] & 128)) throw new E("invalid signature integer: unnecessary leading zero");
        return (0, utils_ts_1$5.bytesToNumberBE)(data2);
      }
    },
    toSig(hex) {
      const { Err: E, _int: int, _tlv: tlv } = exports.DER;
      const data2 = (0, utils_ts_1$5.ensureBytes)("signature", hex);
      const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data2);
      if (seqLeftBytes.length) throw new E("invalid signature: left bytes after parsing");
      const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
      const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
      if (sLeftBytes.length) throw new E("invalid signature: left bytes after parsing");
      return {
        r: int.decode(rBytes),
        s: int.decode(sBytes)
      };
    },
    hexFromSig(sig) {
      const { _tlv: tlv, _int: int } = exports.DER;
      const rs = tlv.encode(2, int.encode(sig.r));
      const ss = tlv.encode(2, int.encode(sig.s));
      const seq = rs + ss;
      return tlv.encode(48, seq);
    }
  };
  const _0n$4 = BigInt(0), _1n$4 = BigInt(1), _2n$4 = BigInt(2), _3n$1 = BigInt(3), _4n = BigInt(4);
  function _legacyHelperEquat(Fp$1, a, b) {
    function weierstrassEquation(x) {
      const x2 = Fp$1.sqr(x);
      const x3 = Fp$1.mul(x2, x);
      return Fp$1.add(Fp$1.add(x3, Fp$1.mul(x, a)), b);
    }
    return weierstrassEquation;
  }
  function _legacyHelperNormPriv(Fn, allowedPrivateKeyLengths, wrapPrivateKey) {
    const { BYTES: expected } = Fn;
    function normPrivateKeyToScalar(key) {
      let num$1;
      if (typeof key === "bigint") num$1 = key;
      else {
        let bytes2 = (0, utils_ts_1$5.ensureBytes)("private key", key);
        if (allowedPrivateKeyLengths) {
          if (!allowedPrivateKeyLengths.includes(bytes2.length * 2)) throw new Error("invalid private key");
          const padded = new Uint8Array(expected);
          padded.set(bytes2, padded.length - bytes2.length);
          bytes2 = padded;
        }
        try {
          num$1 = Fn.fromBytes(bytes2);
        } catch (error) {
          throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
        }
      }
      if (wrapPrivateKey) num$1 = Fn.create(num$1);
      if (!Fn.isValidNot0(num$1)) throw new Error("invalid private key: out of range [1..N-1]");
      return num$1;
    }
    return normPrivateKeyToScalar;
  }
  function weierstrassN(CURVE, curveOpts = {}) {
    const { Fp: Fp$1, Fn } = (0, curve_ts_1$2._createCurveFields)("weierstrass", CURVE, curveOpts);
    const { h: cofactor, n: CURVE_ORDER } = CURVE;
    (0, utils_ts_1$5._validateObject)(curveOpts, {}, {
      allowInfinityPoint: "boolean",
      clearCofactor: "function",
      isTorsionFree: "function",
      fromBytes: "function",
      toBytes: "function",
      endo: "object",
      wrapPrivateKey: "boolean"
    });
    const { endo } = curveOpts;
    if (endo) {
      if (!Fp$1.is0(CURVE.a) || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
    }
    function assertCompressionIsSupported() {
      if (!Fp$1.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
    }
    function pointToBytes$1(_c, point, isCompressed) {
      const { x, y } = point.toAffine();
      const bx = Fp$1.toBytes(x);
      (0, utils_ts_1$5.abool)("isCompressed", isCompressed);
      if (isCompressed) {
        assertCompressionIsSupported();
        const hasEvenY = !Fp$1.isOdd(y);
        return (0, utils_ts_1$5.concatBytes)(pprefix(hasEvenY), bx);
      } else return (0, utils_ts_1$5.concatBytes)(Uint8Array.of(4), bx, Fp$1.toBytes(y));
    }
    function pointFromBytes(bytes2) {
      (0, utils_ts_1$5.abytes)(bytes2);
      const L = Fp$1.BYTES;
      const LC2 = L + 1;
      const LU2 = 2 * L + 1;
      const length = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (length === LC2 && (head === 2 || head === 3)) {
        const x = Fp$1.fromBytes(tail);
        if (!Fp$1.isValid(x)) throw new Error("bad point: is not on curve, wrong x");
        const y2 = weierstrassEquation(x);
        let y;
        try {
          y = Fp$1.sqrt(y2);
        } catch (sqrtError) {
          const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("bad point: is not on curve, sqrt error" + err);
        }
        assertCompressionIsSupported();
        const isYOdd = Fp$1.isOdd(y);
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd) y = Fp$1.neg(y);
        return {
          x,
          y
        };
      } else if (length === LU2 && head === 4) {
        const x = Fp$1.fromBytes(tail.subarray(L * 0, L * 1));
        const y = Fp$1.fromBytes(tail.subarray(L * 1, L * 2));
        if (!isValidXY(x, y)) throw new Error("bad point: is not on curve");
        return {
          x,
          y
        };
      } else throw new Error(`bad point: got length ${length}, expected compressed=${LC2} or uncompressed=${LU2}`);
    }
    const toBytes$1 = curveOpts.toBytes || pointToBytes$1;
    const fromBytes = curveOpts.fromBytes || pointFromBytes;
    const weierstrassEquation = _legacyHelperEquat(Fp$1, CURVE.a, CURVE.b);
    function isValidXY(x, y) {
      const left = Fp$1.sqr(y);
      const right = weierstrassEquation(x);
      return Fp$1.eql(left, right);
    }
    if (!isValidXY(CURVE.Gx, CURVE.Gy)) throw new Error("bad curve params: generator point");
    const _4a3 = Fp$1.mul(Fp$1.pow(CURVE.a, _3n$1), _4n);
    const _27b2 = Fp$1.mul(Fp$1.sqr(CURVE.b), BigInt(27));
    if (Fp$1.is0(Fp$1.add(_4a3, _27b2))) throw new Error("bad curve params: a or b");
    function acoord(title, n, banZero = false) {
      if (!Fp$1.isValid(n) || banZero && Fp$1.is0(n)) throw new Error(`bad point coordinate ${title}`);
      return n;
    }
    function aprjpoint(other) {
      if (!(other instanceof Point$1)) throw new Error("ProjectivePoint expected");
    }
    const toAffineMemo = (0, utils_ts_1$5.memoized)((p, iz) => {
      const { px: x, py: y, pz: z2 } = p;
      if (Fp$1.eql(z2, Fp$1.ONE)) return {
        x,
        y
      };
      const is0 = p.is0();
      if (iz == null) iz = is0 ? Fp$1.ONE : Fp$1.inv(z2);
      const ax = Fp$1.mul(x, iz);
      const ay = Fp$1.mul(y, iz);
      const zz = Fp$1.mul(z2, iz);
      if (is0) return {
        x: Fp$1.ZERO,
        y: Fp$1.ZERO
      };
      if (!Fp$1.eql(zz, Fp$1.ONE)) throw new Error("invZ was invalid");
      return {
        x: ax,
        y: ay
      };
    });
    const assertValidMemo = (0, utils_ts_1$5.memoized)((p) => {
      if (p.is0()) {
        if (curveOpts.allowInfinityPoint && !Fp$1.is0(p.py)) return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = p.toAffine();
      if (!Fp$1.isValid(x) || !Fp$1.isValid(y)) throw new Error("bad point: x or y not field elements");
      if (!isValidXY(x, y)) throw new Error("bad point: equation left != right");
      if (!p.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
      return true;
    });
    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
      k2p = new Point$1(Fp$1.mul(k2p.px, endoBeta), k2p.py, k2p.pz);
      k1p = (0, curve_ts_1$2.negateCt)(k1neg, k1p);
      k2p = (0, curve_ts_1$2.negateCt)(k2neg, k2p);
      return k1p.add(k2p);
    }
    class Point$1 {
      /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
      constructor(px, py, pz) {
        this.px = acoord("x", px);
        this.py = acoord("y", py, true);
        this.pz = acoord("z", pz);
        Object.freeze(this);
      }
      /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
      static fromAffine(p) {
        const { x, y } = p || {};
        if (!p || !Fp$1.isValid(x) || !Fp$1.isValid(y)) throw new Error("invalid affine point");
        if (p instanceof Point$1) throw new Error("projective point not allowed");
        if (Fp$1.is0(x) && Fp$1.is0(y)) return Point$1.ZERO;
        return new Point$1(x, y, Fp$1.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(points) {
        return (0, curve_ts_1$2.normalizeZ)(Point$1, "pz", points);
      }
      static fromBytes(bytes2) {
        (0, utils_ts_1$5.abytes)(bytes2);
        return Point$1.fromHex(bytes2);
      }
      /** Converts hash string or Uint8Array to Point. */
      static fromHex(hex) {
        const P = Point$1.fromAffine(fromBytes((0, utils_ts_1$5.ensureBytes)("pointHex", hex)));
        P.assertValidity();
        return P;
      }
      /** Multiplies generator point by privateKey. */
      static fromPrivateKey(privateKey) {
        const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
        return Point$1.BASE.multiply(normPrivateKeyToScalar(privateKey));
      }
      /** Multiscalar Multiplication */
      static msm(points, scalars) {
        return (0, curve_ts_1$2.pippenger)(Point$1, Fn, points, scalars);
      }
      /**
      *
      * @param windowSize
      * @param isLazy true will defer table computation until the first multiplication
      * @returns
      */
      precompute(windowSize = 8, isLazy = true) {
        wnaf.setWindowSize(this, windowSize);
        if (!isLazy) this.multiply(_3n$1);
        return this;
      }
      /** "Private method", don't use it directly */
      _setWindowSize(windowSize) {
        this.precompute(windowSize);
      }
      /** A point on curve is valid if it conforms to equation. */
      assertValidity() {
        assertValidMemo(this);
      }
      hasEvenY() {
        const { y } = this.toAffine();
        if (!Fp$1.isOdd) throw new Error("Field doesn't support isOdd");
        return !Fp$1.isOdd(y);
      }
      /** Compare one point to another. */
      equals(other) {
        aprjpoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        const U1 = Fp$1.eql(Fp$1.mul(X1, Z2), Fp$1.mul(X2, Z1));
        const U2 = Fp$1.eql(Fp$1.mul(Y1, Z2), Fp$1.mul(Y2, Z1));
        return U1 && U2;
      }
      /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
      negate() {
        return new Point$1(this.px, Fp$1.neg(this.py), this.pz);
      }
      double() {
        const { a, b } = CURVE;
        const b3 = Fp$1.mul(b, _3n$1);
        const { px: X1, py: Y1, pz: Z1 } = this;
        let X3 = Fp$1.ZERO, Y3 = Fp$1.ZERO, Z3 = Fp$1.ZERO;
        let t0 = Fp$1.mul(X1, X1);
        let t1 = Fp$1.mul(Y1, Y1);
        let t2 = Fp$1.mul(Z1, Z1);
        let t3 = Fp$1.mul(X1, Y1);
        t3 = Fp$1.add(t3, t3);
        Z3 = Fp$1.mul(X1, Z1);
        Z3 = Fp$1.add(Z3, Z3);
        X3 = Fp$1.mul(a, Z3);
        Y3 = Fp$1.mul(b3, t2);
        Y3 = Fp$1.add(X3, Y3);
        X3 = Fp$1.sub(t1, Y3);
        Y3 = Fp$1.add(t1, Y3);
        Y3 = Fp$1.mul(X3, Y3);
        X3 = Fp$1.mul(t3, X3);
        Z3 = Fp$1.mul(b3, Z3);
        t2 = Fp$1.mul(a, t2);
        t3 = Fp$1.sub(t0, t2);
        t3 = Fp$1.mul(a, t3);
        t3 = Fp$1.add(t3, Z3);
        Z3 = Fp$1.add(t0, t0);
        t0 = Fp$1.add(Z3, t0);
        t0 = Fp$1.add(t0, t2);
        t0 = Fp$1.mul(t0, t3);
        Y3 = Fp$1.add(Y3, t0);
        t2 = Fp$1.mul(Y1, Z1);
        t2 = Fp$1.add(t2, t2);
        t0 = Fp$1.mul(t2, t3);
        X3 = Fp$1.sub(X3, t0);
        Z3 = Fp$1.mul(t2, t1);
        Z3 = Fp$1.add(Z3, Z3);
        Z3 = Fp$1.add(Z3, Z3);
        return new Point$1(X3, Y3, Z3);
      }
      add(other) {
        aprjpoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        let X3 = Fp$1.ZERO, Y3 = Fp$1.ZERO, Z3 = Fp$1.ZERO;
        const a = CURVE.a;
        const b3 = Fp$1.mul(CURVE.b, _3n$1);
        let t0 = Fp$1.mul(X1, X2);
        let t1 = Fp$1.mul(Y1, Y2);
        let t2 = Fp$1.mul(Z1, Z2);
        let t3 = Fp$1.add(X1, Y1);
        let t4 = Fp$1.add(X2, Y2);
        t3 = Fp$1.mul(t3, t4);
        t4 = Fp$1.add(t0, t1);
        t3 = Fp$1.sub(t3, t4);
        t4 = Fp$1.add(X1, Z1);
        let t5 = Fp$1.add(X2, Z2);
        t4 = Fp$1.mul(t4, t5);
        t5 = Fp$1.add(t0, t2);
        t4 = Fp$1.sub(t4, t5);
        t5 = Fp$1.add(Y1, Z1);
        X3 = Fp$1.add(Y2, Z2);
        t5 = Fp$1.mul(t5, X3);
        X3 = Fp$1.add(t1, t2);
        t5 = Fp$1.sub(t5, X3);
        Z3 = Fp$1.mul(a, t4);
        X3 = Fp$1.mul(b3, t2);
        Z3 = Fp$1.add(X3, Z3);
        X3 = Fp$1.sub(t1, Z3);
        Z3 = Fp$1.add(t1, Z3);
        Y3 = Fp$1.mul(X3, Z3);
        t1 = Fp$1.add(t0, t0);
        t1 = Fp$1.add(t1, t0);
        t2 = Fp$1.mul(a, t2);
        t4 = Fp$1.mul(b3, t4);
        t1 = Fp$1.add(t1, t2);
        t2 = Fp$1.sub(t0, t2);
        t2 = Fp$1.mul(a, t2);
        t4 = Fp$1.add(t4, t2);
        t0 = Fp$1.mul(t1, t4);
        Y3 = Fp$1.add(Y3, t0);
        t0 = Fp$1.mul(t5, t4);
        X3 = Fp$1.mul(t3, X3);
        X3 = Fp$1.sub(X3, t0);
        t0 = Fp$1.mul(t3, t1);
        Z3 = Fp$1.mul(t5, Z3);
        Z3 = Fp$1.add(Z3, t0);
        return new Point$1(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point$1.ZERO);
      }
      /**
      * Constant time multiplication.
      * Uses wNAF method. Windowed method may be 10% faster,
      * but takes 2x longer to generate and consumes 2x memory.
      * Uses precomputes when available.
      * Uses endomorphism for Koblitz curves.
      * @param scalar by which the point would be multiplied
      * @returns New point
      */
      multiply(scalar) {
        const { endo: endo$1 } = curveOpts;
        if (!Fn.isValidNot0(scalar)) throw new Error("invalid scalar: out of range");
        let point, fake;
        const mul = (n) => wnaf.wNAFCached(this, n, Point$1.normalizeZ);
        if (endo$1) {
          const { k1neg, k1, k2neg, k2 } = endo$1.splitScalar(scalar);
          const { p: k1p, f: k1f } = mul(k1);
          const { p: k2p, f: k2f } = mul(k2);
          fake = k1f.add(k2f);
          point = finishEndo(endo$1.beta, k1p, k2p, k1neg, k2neg);
        } else {
          const { p, f } = mul(scalar);
          point = p;
          fake = f;
        }
        return Point$1.normalizeZ([point, fake])[0];
      }
      /**
      * Non-constant-time multiplication. Uses double-and-add algorithm.
      * It's faster, but should only be used when you don't care about
      * an exposed private key e.g. sig verification, which works over *public* keys.
      */
      multiplyUnsafe(sc) {
        const { endo: endo$1 } = curveOpts;
        const p = this;
        if (!Fn.isValid(sc)) throw new Error("invalid scalar: out of range");
        if (sc === _0n$4 || p.is0()) return Point$1.ZERO;
        if (sc === _1n$4) return p;
        if (wnaf.hasPrecomputes(this)) return this.multiply(sc);
        if (endo$1) {
          const { k1neg, k1, k2neg, k2 } = endo$1.splitScalar(sc);
          const { p1, p2 } = (0, curve_ts_1$2.mulEndoUnsafe)(Point$1, p, k1, k2);
          return finishEndo(endo$1.beta, p1, p2, k1neg, k2neg);
        } else return wnaf.wNAFCachedUnsafe(p, sc);
      }
      multiplyAndAddUnsafe(Q, a, b) {
        const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
        return sum.is0() ? void 0 : sum;
      }
      /**
      * Converts Projective point to affine (x, y) coordinates.
      * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
      */
      toAffine(invertedZ) {
        return toAffineMemo(this, invertedZ);
      }
      /**
      * Checks whether Point is free of torsion elements (is in prime subgroup).
      * Always torsion-free for cofactor=1 curves.
      */
      isTorsionFree() {
        const { isTorsionFree } = curveOpts;
        if (cofactor === _1n$4) return true;
        if (isTorsionFree) return isTorsionFree(Point$1, this);
        return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
      }
      clearCofactor() {
        const { clearCofactor } = curveOpts;
        if (cofactor === _1n$4) return this;
        if (clearCofactor) return clearCofactor(Point$1, this);
        return this.multiplyUnsafe(cofactor);
      }
      toBytes(isCompressed = true) {
        (0, utils_ts_1$5.abool)("isCompressed", isCompressed);
        this.assertValidity();
        return toBytes$1(Point$1, this, isCompressed);
      }
      /** @deprecated use `toBytes` */
      toRawBytes(isCompressed = true) {
        return this.toBytes(isCompressed);
      }
      toHex(isCompressed = true) {
        return (0, utils_ts_1$5.bytesToHex)(this.toBytes(isCompressed));
      }
      toString() {
        return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
      }
    }
    Point$1.BASE = new Point$1(CURVE.Gx, CURVE.Gy, Fp$1.ONE);
    Point$1.ZERO = new Point$1(Fp$1.ZERO, Fp$1.ONE, Fp$1.ZERO);
    Point$1.Fp = Fp$1;
    Point$1.Fn = Fn;
    const bits = Fn.BITS;
    const wnaf = (0, curve_ts_1$2.wNAF)(Point$1, curveOpts.endo ? Math.ceil(bits / 2) : bits);
    return Point$1;
  }
  function weierstrassPoints(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const Point$1 = weierstrassN(CURVE, curveOpts);
    return _weierstrass_new_output_to_legacy(c, Point$1);
  }
  function pprefix(hasEvenY) {
    return Uint8Array.of(hasEvenY ? 2 : 3);
  }
  function ecdsa(Point$1, ecdsaOpts, curveOpts = {}) {
    (0, utils_ts_1$5._validateObject)(ecdsaOpts, { hash: "function" }, {
      hmac: "function",
      lowS: "boolean",
      randomBytes: "function",
      bits2int: "function",
      bits2int_modN: "function"
    });
    const randomBytes_ = ecdsaOpts.randomBytes || utils_ts_1$5.randomBytes;
    const hmac_ = ecdsaOpts.hmac || ((key, ...msgs) => (0, hmac_js_1.hmac)(ecdsaOpts.hash, key, (0, utils_ts_1$5.concatBytes)(...msgs)));
    const { Fp: Fp$1, Fn } = Point$1;
    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
    function isBiggerThanHalfOrder(number) {
      const HALF = CURVE_ORDER >> _1n$4;
      return number > HALF;
    }
    function normalizeS(s) {
      return isBiggerThanHalfOrder(s) ? Fn.neg(s) : s;
    }
    function aValidRS(title, num$1) {
      if (!Fn.isValidNot0(num$1)) throw new Error(`invalid signature ${title}: out of range 1..CURVE.n`);
    }
    class Signature {
      constructor(r, s, recovery) {
        aValidRS("r", r);
        aValidRS("s", s);
        this.r = r;
        this.s = s;
        if (recovery != null) this.recovery = recovery;
        Object.freeze(this);
      }
      static fromCompact(hex) {
        const L = Fn.BYTES;
        const b = (0, utils_ts_1$5.ensureBytes)("compactSignature", hex, L * 2);
        return new Signature(Fn.fromBytes(b.subarray(0, L)), Fn.fromBytes(b.subarray(L, L * 2)));
      }
      static fromDER(hex) {
        const { r, s } = exports.DER.toSig((0, utils_ts_1$5.ensureBytes)("DER", hex));
        return new Signature(r, s);
      }
      /**
      * @todo remove
      * @deprecated
      */
      assertValidity() {
      }
      addRecoveryBit(recovery) {
        return new Signature(this.r, this.s, recovery);
      }
      recoverPublicKey(msgHash) {
        const FIELD_ORDER = Fp$1.ORDER;
        const { r, s, recovery: rec } = this;
        if (rec == null || ![
          0,
          1,
          2,
          3
        ].includes(rec)) throw new Error("recovery id invalid");
        const hasCofactor = CURVE_ORDER * _2n$4 < FIELD_ORDER;
        if (hasCofactor && rec > 1) throw new Error("recovery id is ambiguous for h>1 curve");
        const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
        if (!Fp$1.isValid(radj)) throw new Error("recovery id 2 or 3 invalid");
        const x = Fp$1.toBytes(radj);
        const R = Point$1.fromHex((0, utils_ts_1$5.concatBytes)(pprefix((rec & 1) === 0), x));
        const ir = Fn.inv(radj);
        const h = bits2int_modN((0, utils_ts_1$5.ensureBytes)("msgHash", msgHash));
        const u1 = Fn.create(-h * ir);
        const u2 = Fn.create(s * ir);
        const Q = Point$1.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
        if (Q.is0()) throw new Error("point at infinify");
        Q.assertValidity();
        return Q;
      }
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;
      }
      toBytes(format) {
        if (format === "compact") return (0, utils_ts_1$5.concatBytes)(Fn.toBytes(this.r), Fn.toBytes(this.s));
        if (format === "der") return (0, utils_ts_1$5.hexToBytes)(exports.DER.hexFromSig(this));
        throw new Error("invalid format");
      }
      toDERRawBytes() {
        return this.toBytes("der");
      }
      toDERHex() {
        return (0, utils_ts_1$5.bytesToHex)(this.toBytes("der"));
      }
      toCompactRawBytes() {
        return this.toBytes("compact");
      }
      toCompactHex() {
        return (0, utils_ts_1$5.bytesToHex)(this.toBytes("compact"));
      }
    }
    const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
    const utils2 = {
      isValidPrivateKey(privateKey) {
        try {
          normPrivateKeyToScalar(privateKey);
          return true;
        } catch (error) {
          return false;
        }
      },
      normPrivateKeyToScalar,
      randomPrivateKey: () => {
        const n = CURVE_ORDER;
        return (0, modular_ts_1$5.mapHashToField)(randomBytes_((0, modular_ts_1$5.getMinHashLength)(n)), n);
      },
      precompute(windowSize = 8, point = Point$1.BASE) {
        return point.precompute(windowSize, false);
      }
    };
    function getPublicKey(privateKey, isCompressed = true) {
      return Point$1.fromPrivateKey(privateKey).toBytes(isCompressed);
    }
    function isProbPub(item) {
      if (typeof item === "bigint") return false;
      if (item instanceof Point$1) return true;
      const arr = (0, utils_ts_1$5.ensureBytes)("key", item);
      const length = arr.length;
      const L = Fp$1.BYTES;
      const LC2 = L + 1;
      const LU2 = 2 * L + 1;
      if (curveOpts.allowedPrivateKeyLengths || Fn.BYTES === LC2) return void 0;
      else return length === LC2 || length === LU2;
    }
    function getSharedSecret(privateA, publicB, isCompressed = true) {
      if (isProbPub(privateA) === true) throw new Error("first arg must be private key");
      if (isProbPub(publicB) === false) throw new Error("second arg must be public key");
      const b = Point$1.fromHex(publicB);
      return b.multiply(normPrivateKeyToScalar(privateA)).toBytes(isCompressed);
    }
    const bits2int = ecdsaOpts.bits2int || function(bytes2) {
      if (bytes2.length > 8192) throw new Error("input is too large");
      const num$1 = (0, utils_ts_1$5.bytesToNumberBE)(bytes2);
      const delta = bytes2.length * 8 - fnBits;
      return delta > 0 ? num$1 >> BigInt(delta) : num$1;
    };
    const bits2int_modN = ecdsaOpts.bits2int_modN || function(bytes2) {
      return Fn.create(bits2int(bytes2));
    };
    const ORDER_MASK = (0, utils_ts_1$5.bitMask)(fnBits);
    function int2octets(num$1) {
      (0, utils_ts_1$5.aInRange)("num < 2^" + fnBits, num$1, _0n$4, ORDER_MASK);
      return Fn.toBytes(num$1);
    }
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
      if (["recovered", "canonical"].some((k) => k in opts)) throw new Error("sign() legacy options not supported");
      const { hash: hash$12 } = ecdsaOpts;
      let { lowS, prehash, extraEntropy: ent } = opts;
      if (lowS == null) lowS = true;
      msgHash = (0, utils_ts_1$5.ensureBytes)("msgHash", msgHash);
      validateSigVerOpts(opts);
      if (prehash) msgHash = (0, utils_ts_1$5.ensureBytes)("prehashed msgHash", hash$12(msgHash));
      const h1int = bits2int_modN(msgHash);
      const d = normPrivateKeyToScalar(privateKey);
      const seedArgs = [int2octets(d), int2octets(h1int)];
      if (ent != null && ent !== false) {
        const e = ent === true ? randomBytes_(Fp$1.BYTES) : ent;
        seedArgs.push((0, utils_ts_1$5.ensureBytes)("extraEntropy", e));
      }
      const seed = (0, utils_ts_1$5.concatBytes)(...seedArgs);
      const m = h1int;
      function k2sig(kBytes) {
        const k = bits2int(kBytes);
        if (!Fn.isValidNot0(k)) return;
        const ik = Fn.inv(k);
        const q = Point$1.BASE.multiply(k).toAffine();
        const r = Fn.create(q.x);
        if (r === _0n$4) return;
        const s = Fn.create(ik * Fn.create(m + r * d));
        if (s === _0n$4) return;
        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n$4);
        let normS = s;
        if (lowS && isBiggerThanHalfOrder(s)) {
          normS = normalizeS(s);
          recovery ^= 1;
        }
        return new Signature(r, normS, recovery);
      }
      return {
        seed,
        k2sig
      };
    }
    const defaultSigOpts = {
      lowS: ecdsaOpts.lowS,
      prehash: false
    };
    const defaultVerOpts = {
      lowS: ecdsaOpts.lowS,
      prehash: false
    };
    function sign$1(msgHash, privKey, opts = defaultSigOpts) {
      const { seed, k2sig } = prepSig(msgHash, privKey, opts);
      const drbg = (0, utils_ts_1$5.createHmacDrbg)(ecdsaOpts.hash.outputLen, Fn.BYTES, hmac_);
      return drbg(seed, k2sig);
    }
    Point$1.BASE.precompute(8);
    function verify$1(signature2, msgHash, publicKey, opts = defaultVerOpts) {
      const sg = signature2;
      msgHash = (0, utils_ts_1$5.ensureBytes)("msgHash", msgHash);
      publicKey = (0, utils_ts_1$5.ensureBytes)("publicKey", publicKey);
      validateSigVerOpts(opts);
      const { lowS, prehash, format } = opts;
      if ("strict" in opts) throw new Error("options.strict was renamed to lowS");
      if (format !== void 0 && ![
        "compact",
        "der",
        "js"
      ].includes(format)) throw new Error('format must be "compact", "der" or "js"');
      const isHex = typeof sg === "string" || (0, utils_ts_1$5.isBytes)(sg);
      const isObj = !isHex && !format && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
      if (!isHex && !isObj) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
      let _sig = void 0;
      let P;
      try {
        if (isObj) if (format === void 0 || format === "js") _sig = new Signature(sg.r, sg.s);
        else throw new Error("invalid format");
        if (isHex) {
          try {
            if (format !== "compact") _sig = Signature.fromDER(sg);
          } catch (derError) {
            if (!(derError instanceof exports.DER.Err)) throw derError;
          }
          if (!_sig && format !== "der") _sig = Signature.fromCompact(sg);
        }
        P = Point$1.fromHex(publicKey);
      } catch (error) {
        return false;
      }
      if (!_sig) return false;
      if (lowS && _sig.hasHighS()) return false;
      if (prehash) msgHash = ecdsaOpts.hash(msgHash);
      const { r, s } = _sig;
      const h = bits2int_modN(msgHash);
      const is = Fn.inv(s);
      const u1 = Fn.create(h * is);
      const u2 = Fn.create(r * is);
      const R = Point$1.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
      if (R.is0()) return false;
      const v = Fn.create(R.x);
      return v === r;
    }
    return Object.freeze({
      getPublicKey,
      getSharedSecret,
      sign: sign$1,
      verify: verify$1,
      utils: utils2,
      Point: Point$1,
      Signature
    });
  }
  function _weierstrass_legacy_opts_to_new(c) {
    const CURVE = {
      a: c.a,
      b: c.b,
      p: c.Fp.ORDER,
      n: c.n,
      h: c.h,
      Gx: c.Gx,
      Gy: c.Gy
    };
    const Fp$1 = c.Fp;
    const Fn = (0, modular_ts_1$5.Field)(CURVE.n, c.nBitLength);
    const curveOpts = {
      Fp: Fp$1,
      Fn,
      allowedPrivateKeyLengths: c.allowedPrivateKeyLengths,
      allowInfinityPoint: c.allowInfinityPoint,
      endo: c.endo,
      wrapPrivateKey: c.wrapPrivateKey,
      isTorsionFree: c.isTorsionFree,
      clearCofactor: c.clearCofactor,
      fromBytes: c.fromBytes,
      toBytes: c.toBytes
    };
    return {
      CURVE,
      curveOpts
    };
  }
  function _ecdsa_legacy_opts_to_new(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const ecdsaOpts = {
      hash: c.hash,
      hmac: c.hmac,
      randomBytes: c.randomBytes,
      lowS: c.lowS,
      bits2int: c.bits2int,
      bits2int_modN: c.bits2int_modN
    };
    return {
      CURVE,
      curveOpts,
      ecdsaOpts
    };
  }
  function _weierstrass_new_output_to_legacy(c, Point$1) {
    const { Fp: Fp$1, Fn } = Point$1;
    function isWithinCurveOrder(num$1) {
      return (0, utils_ts_1$5.inRange)(num$1, _1n$4, Fn.ORDER);
    }
    const weierstrassEquation = _legacyHelperEquat(Fp$1, c.a, c.b);
    const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, c.allowedPrivateKeyLengths, c.wrapPrivateKey);
    return Object.assign({}, {
      CURVE: c,
      Point: Point$1,
      ProjectivePoint: Point$1,
      normPrivateKeyToScalar,
      weierstrassEquation,
      isWithinCurveOrder
    });
  }
  function _ecdsa_new_output_to_legacy(c, ecdsa$1) {
    return Object.assign({}, ecdsa$1, {
      ProjectivePoint: ecdsa$1.Point,
      CURVE: c
    });
  }
  function weierstrass(c) {
    const { CURVE, curveOpts, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
    const Point$1 = weierstrassN(CURVE, curveOpts);
    const signs = ecdsa(Point$1, ecdsaOpts, curveOpts);
    return _ecdsa_new_output_to_legacy(c, signs);
  }
  function SWUFpSqrtRatio(Fp$1, Z) {
    const q = Fp$1.ORDER;
    let l = _0n$4;
    for (let o = q - _1n$4; o % _2n$4 === _0n$4; o /= _2n$4) l += _1n$4;
    const c1 = l;
    const _2n_pow_c1_1 = _2n$4 << c1 - _1n$4 - _1n$4;
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n$4;
    const c2 = (q - _1n$4) / _2n_pow_c1;
    const c3 = (c2 - _1n$4) / _2n$4;
    const c4 = _2n_pow_c1 - _1n$4;
    const c5 = _2n_pow_c1_1;
    const c6 = Fp$1.pow(Z, c2);
    const c7 = Fp$1.pow(Z, (c2 + _1n$4) / _2n$4);
    let sqrtRatio = (u, v) => {
      let tv1 = c6;
      let tv2 = Fp$1.pow(v, c4);
      let tv3 = Fp$1.sqr(tv2);
      tv3 = Fp$1.mul(tv3, v);
      let tv5 = Fp$1.mul(u, tv3);
      tv5 = Fp$1.pow(tv5, c3);
      tv5 = Fp$1.mul(tv5, tv2);
      tv2 = Fp$1.mul(tv5, v);
      tv3 = Fp$1.mul(tv5, u);
      let tv4 = Fp$1.mul(tv3, tv2);
      tv5 = Fp$1.pow(tv4, c5);
      let isQR = Fp$1.eql(tv5, Fp$1.ONE);
      tv2 = Fp$1.mul(tv3, c7);
      tv5 = Fp$1.mul(tv4, tv1);
      tv3 = Fp$1.cmov(tv2, tv3, isQR);
      tv4 = Fp$1.cmov(tv5, tv4, isQR);
      for (let i = c1; i > _1n$4; i--) {
        let tv5$1 = i - _2n$4;
        tv5$1 = _2n$4 << tv5$1 - _1n$4;
        let tvv5 = Fp$1.pow(tv4, tv5$1);
        const e1 = Fp$1.eql(tvv5, Fp$1.ONE);
        tv2 = Fp$1.mul(tv3, tv1);
        tv1 = Fp$1.mul(tv1, tv1);
        tvv5 = Fp$1.mul(tv4, tv1);
        tv3 = Fp$1.cmov(tv2, tv3, e1);
        tv4 = Fp$1.cmov(tvv5, tv4, e1);
      }
      return {
        isValid: isQR,
        value: tv3
      };
    };
    if (Fp$1.ORDER % _4n === _3n$1) {
      const c1$1 = (Fp$1.ORDER - _3n$1) / _4n;
      const c2$1 = Fp$1.sqrt(Fp$1.neg(Z));
      sqrtRatio = (u, v) => {
        let tv1 = Fp$1.sqr(v);
        const tv2 = Fp$1.mul(u, v);
        tv1 = Fp$1.mul(tv1, tv2);
        let y1 = Fp$1.pow(tv1, c1$1);
        y1 = Fp$1.mul(y1, tv2);
        const y2 = Fp$1.mul(y1, c2$1);
        const tv3 = Fp$1.mul(Fp$1.sqr(y1), v);
        const isQR = Fp$1.eql(tv3, u);
        let y = Fp$1.cmov(y2, y1, isQR);
        return {
          isValid: isQR,
          value: y
        };
      };
    }
    return sqrtRatio;
  }
  function mapToCurveSimpleSWU(Fp$1, opts) {
    (0, modular_ts_1$5.validateField)(Fp$1);
    const { A, B, Z } = opts;
    if (!Fp$1.isValid(A) || !Fp$1.isValid(B) || !Fp$1.isValid(Z)) throw new Error("mapToCurveSimpleSWU: invalid opts");
    const sqrtRatio = SWUFpSqrtRatio(Fp$1, Z);
    if (!Fp$1.isOdd) throw new Error("Field does not have .isOdd()");
    return (u) => {
      let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
      tv1 = Fp$1.sqr(u);
      tv1 = Fp$1.mul(tv1, Z);
      tv2 = Fp$1.sqr(tv1);
      tv2 = Fp$1.add(tv2, tv1);
      tv3 = Fp$1.add(tv2, Fp$1.ONE);
      tv3 = Fp$1.mul(tv3, B);
      tv4 = Fp$1.cmov(Z, Fp$1.neg(tv2), !Fp$1.eql(tv2, Fp$1.ZERO));
      tv4 = Fp$1.mul(tv4, A);
      tv2 = Fp$1.sqr(tv3);
      tv6 = Fp$1.sqr(tv4);
      tv5 = Fp$1.mul(tv6, A);
      tv2 = Fp$1.add(tv2, tv5);
      tv2 = Fp$1.mul(tv2, tv3);
      tv6 = Fp$1.mul(tv6, tv4);
      tv5 = Fp$1.mul(tv6, B);
      tv2 = Fp$1.add(tv2, tv5);
      x = Fp$1.mul(tv1, tv3);
      const { isValid, value } = sqrtRatio(tv2, tv6);
      y = Fp$1.mul(tv1, u);
      y = Fp$1.mul(y, value);
      x = Fp$1.cmov(x, tv3, isValid);
      y = Fp$1.cmov(y, value, isValid);
      const e1 = Fp$1.isOdd(u) === Fp$1.isOdd(y);
      y = Fp$1.cmov(Fp$1.neg(y), y, e1);
      const tv4_inv = (0, modular_ts_1$5.FpInvertBatch)(Fp$1, [tv4], true)[0];
      x = Fp$1.mul(x, tv4_inv);
      return {
        x,
        y
      };
    };
  }
} });
var require__shortw_utils = __commonJS({ "../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/_shortw_utils.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getHash = getHash;
  exports.createCurve = createCurve;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const weierstrass_ts_1$1 = require_weierstrass();
  function getHash(hash$12) {
    return { hash: hash$12 };
  }
  function createCurve(curveDef, defHash) {
    const create = (hash$12) => (0, weierstrass_ts_1$1.weierstrass)({
      ...curveDef,
      hash: hash$12
    });
    return {
      ...create(defHash),
      create
    };
  }
} });
var require_hash_to_curve = __commonJS({ "../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/hash-to-curve.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.expand_message_xmd = expand_message_xmd;
  exports.expand_message_xof = expand_message_xof;
  exports.hash_to_field = hash_to_field;
  exports.isogenyMap = isogenyMap;
  exports.createHasher = createHasher;
  const utils_ts_1$4 = require_utils$2();
  const modular_ts_1$4 = require_modular();
  const os2ip = utils_ts_1$4.bytesToNumberBE;
  function i2osp(value, length) {
    anum(value);
    anum(length);
    if (value < 0 || value >= 1 << 8 * length) throw new Error("invalid I2OSP input: " + value);
    const res = Array.from({ length }).fill(0);
    for (let i = length - 1; i >= 0; i--) {
      res[i] = value & 255;
      value >>>= 8;
    }
    return new Uint8Array(res);
  }
  function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for (let i = 0; i < a.length; i++) arr[i] = a[i] ^ b[i];
    return arr;
  }
  function anum(item) {
    if (!Number.isSafeInteger(item)) throw new Error("number expected");
  }
  function expand_message_xmd(msg, DST, lenInBytes, H) {
    (0, utils_ts_1$4.abytes)(msg);
    (0, utils_ts_1$4.abytes)(DST);
    anum(lenInBytes);
    if (DST.length > 255) DST = H((0, utils_ts_1$4.concatBytes)((0, utils_ts_1$4.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (lenInBytes > 65535 || ell > 255) throw new Error("expand_message_xmd: invalid lenInBytes");
    const DST_prime = (0, utils_ts_1$4.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2);
    const b = new Array(ell);
    const b_0 = H((0, utils_ts_1$4.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_ts_1$4.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for (let i = 1; i <= ell; i++) {
      const args = [
        strxor(b_0, b[i - 1]),
        i2osp(i + 1, 1),
        DST_prime
      ];
      b[i] = H((0, utils_ts_1$4.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, utils_ts_1$4.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
  }
  function expand_message_xof(msg, DST, lenInBytes, k, H) {
    (0, utils_ts_1$4.abytes)(msg);
    (0, utils_ts_1$4.abytes)(DST);
    anum(lenInBytes);
    if (DST.length > 255) {
      const dkLen = Math.ceil(2 * k / 8);
      DST = H.create({ dkLen }).update((0, utils_ts_1$4.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255) throw new Error("expand_message_xof: invalid lenInBytes");
    return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
  }
  function hash_to_field(msg, count, options) {
    (0, utils_ts_1$4._validateObject)(options, {
      p: "bigint",
      m: "number",
      k: "number",
      hash: "function"
    });
    const { p, k, m, hash: hash$12, expand, DST: _DST } = options;
    if (!(0, utils_ts_1$4.isBytes)(_DST) && typeof _DST !== "string") throw new Error("DST must be string or uint8array");
    if (!(0, utils_ts_1$4.isHash)(options.hash)) throw new Error("expected valid hash");
    (0, utils_ts_1$4.abytes)(msg);
    anum(count);
    const DST = typeof _DST === "string" ? (0, utils_ts_1$4.utf8ToBytes)(_DST) : _DST;
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8);
    const len_in_bytes = count * m * L;
    let prb;
    if (expand === "xmd") prb = expand_message_xmd(msg, DST, len_in_bytes, hash$12);
    else if (expand === "xof") prb = expand_message_xof(msg, DST, len_in_bytes, k, hash$12);
    else if (expand === "_internal_pass") prb = msg;
    else throw new Error('expand must be "xmd" or "xof"');
    const u = new Array(count);
    for (let i = 0; i < count; i++) {
      const e = new Array(m);
      for (let j = 0; j < m; j++) {
        const elm_offset = L * (j + i * m);
        const tv = prb.subarray(elm_offset, elm_offset + L);
        e[j] = (0, modular_ts_1$4.mod)(os2ip(tv), p);
      }
      u[i] = e;
    }
    return u;
  }
  function isogenyMap(field, map) {
    const coeff = map.map((i) => Array.from(i).reverse());
    return (x, y) => {
      const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
      const [xd_inv, yd_inv] = (0, modular_ts_1$4.FpInvertBatch)(field, [xd, yd], true);
      x = field.mul(xn, xd_inv);
      y = field.mul(y, field.mul(yn, yd_inv));
      return {
        x,
        y
      };
    };
  }
  function createHasher(Point$1, mapToCurve, defaults) {
    if (typeof mapToCurve !== "function") throw new Error("mapToCurve() must be defined");
    function map(num$1) {
      return Point$1.fromAffine(mapToCurve(num$1));
    }
    function clear(initial) {
      const P = initial.clearCofactor();
      if (P.equals(Point$1.ZERO)) return Point$1.ZERO;
      P.assertValidity();
      return P;
    }
    return {
      defaults,
      hashToCurve(msg, options) {
        const dst = defaults.DST ? defaults.DST : {};
        const opts = Object.assign({}, defaults, dst, options);
        const u = hash_to_field(msg, 2, opts);
        const u0 = map(u[0]);
        const u1 = map(u[1]);
        return clear(u0.add(u1));
      },
      encodeToCurve(msg, options) {
        const dst = defaults.encodeDST ? defaults.encodeDST : {};
        const opts = Object.assign({}, defaults, dst, options);
        const u = hash_to_field(msg, 1, opts);
        return clear(map(u[0]));
      },
      mapToCurve(scalars) {
        if (!Array.isArray(scalars)) throw new Error("expected array of bigints");
        for (const i of scalars) if (typeof i !== "bigint") throw new Error("expected array of bigints");
        return clear(map(scalars));
      }
    };
  }
} });
var require_secp256k1$1 = __commonJS({ "../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/secp256k1.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodeToCurve = exports.hashToCurve = exports.secp256k1_hasher = exports.schnorr = exports.secp256k1 = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const sha2_js_1$1 = require_sha2();
  const utils_js_1$1 = require_utils$5();
  const _shortw_utils_ts_1 = require__shortw_utils();
  const hash_to_curve_ts_1$1 = require_hash_to_curve();
  const modular_ts_1$3 = require_modular();
  const weierstrass_ts_1 = require_weierstrass();
  const utils_ts_1$3 = require_utils$2();
  const secp256k1_CURVE = {
    p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
    Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
  };
  const _0n$3 = BigInt(0);
  const _1n$3 = BigInt(1);
  const _2n$3 = BigInt(2);
  const divNearest = (a, b) => (a + b / _2n$3) / b;
  function sqrtMod(y) {
    const P = secp256k1_CURVE.p;
    const _3n$3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P;
    const b3 = b2 * b2 * y % P;
    const b6 = (0, modular_ts_1$3.pow2)(b3, _3n$3, P) * b3 % P;
    const b9 = (0, modular_ts_1$3.pow2)(b6, _3n$3, P) * b3 % P;
    const b11 = (0, modular_ts_1$3.pow2)(b9, _2n$3, P) * b2 % P;
    const b22 = (0, modular_ts_1$3.pow2)(b11, _11n, P) * b11 % P;
    const b44 = (0, modular_ts_1$3.pow2)(b22, _22n, P) * b22 % P;
    const b88 = (0, modular_ts_1$3.pow2)(b44, _44n, P) * b44 % P;
    const b176 = (0, modular_ts_1$3.pow2)(b88, _88n, P) * b88 % P;
    const b220 = (0, modular_ts_1$3.pow2)(b176, _44n, P) * b44 % P;
    const b223 = (0, modular_ts_1$3.pow2)(b220, _3n$3, P) * b3 % P;
    const t1 = (0, modular_ts_1$3.pow2)(b223, _23n, P) * b22 % P;
    const t2 = (0, modular_ts_1$3.pow2)(t1, _6n, P) * b2 % P;
    const root2 = (0, modular_ts_1$3.pow2)(t2, _2n$3, P);
    if (!Fpk1.eql(Fpk1.sqr(root2), y)) throw new Error("Cannot find square root");
    return root2;
  }
  const Fpk1 = (0, modular_ts_1$3.Field)(secp256k1_CURVE.p, void 0, void 0, { sqrt: sqrtMod });
  exports.secp256k1 = (0, _shortw_utils_ts_1.createCurve)({
    ...secp256k1_CURVE,
    Fp: Fpk1,
    lowS: true,
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (k) => {
        const n = secp256k1_CURVE.n;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n$3 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b2 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = (0, modular_ts_1$3.mod)(k - c1 * a1 - c2 * a2, n);
        let k2 = (0, modular_ts_1$3.mod)(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg) k1 = n - k1;
        if (k2neg) k2 = n - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128) throw new Error("splitScalar: Endomorphism failed, k=" + k);
        return {
          k1neg,
          k1,
          k2neg,
          k2
        };
      }
    }
  }, sha2_js_1$1.sha256);
  const TAGGED_HASH_PREFIXES = {};
  function taggedHash(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = (0, sha2_js_1$1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = (0, utils_ts_1$3.concatBytes)(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return (0, sha2_js_1$1.sha256)((0, utils_ts_1$3.concatBytes)(tagP, ...messages));
  }
  const pointToBytes = (point) => point.toBytes(true).slice(1);
  const numTo32b = (n) => (0, utils_ts_1$3.numberToBytesBE)(n, 32);
  const modP = (x) => (0, modular_ts_1$3.mod)(x, secp256k1_CURVE.p);
  const modN = (x) => (0, modular_ts_1$3.mod)(x, secp256k1_CURVE.n);
  const Point = /* @__PURE__ */ (() => exports.secp256k1.Point)();
  const hasEven = (y) => y % _2n$3 === _0n$3;
  function schnorrGetExtPubKey(priv) {
    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv);
    let p = Point.fromPrivateKey(d_);
    const scalar = hasEven(p.y) ? d_ : modN(-d_);
    return {
      scalar,
      bytes: pointToBytes(p)
    };
  }
  function lift_x(x) {
    (0, utils_ts_1$3.aInRange)("x", x, _1n$3, secp256k1_CURVE.p);
    const xx = modP(x * x);
    const c = modP(xx * x + BigInt(7));
    let y = sqrtMod(c);
    if (!hasEven(y)) y = modP(-y);
    const p = Point.fromAffine({
      x,
      y
    });
    p.assertValidity();
    return p;
  }
  const num = utils_ts_1$3.bytesToNumberBE;
  function challenge(...args) {
    return modN(num(taggedHash("BIP0340/challenge", ...args)));
  }
  function schnorrGetPublicKey(privateKey) {
    return schnorrGetExtPubKey(privateKey).bytes;
  }
  function schnorrSign(message2, privateKey, auxRand = (0, utils_js_1$1.randomBytes)(32)) {
    const m = (0, utils_ts_1$3.ensureBytes)("message", message2);
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
    const a = (0, utils_ts_1$3.ensureBytes)("auxRand", auxRand, 32);
    const t = numTo32b(d ^ num(taggedHash("BIP0340/aux", a)));
    const rand = taggedHash("BIP0340/nonce", t, px, m);
    const k_ = modN(num(rand));
    if (k_ === _0n$3) throw new Error("sign failed: k is zero");
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
    const e = challenge(rx, px, m);
    const sig = new Uint8Array(64);
    sig.set(rx, 0);
    sig.set(numTo32b(modN(k + e * d)), 32);
    if (!schnorrVerify(sig, m, px)) throw new Error("sign: Invalid signature produced");
    return sig;
  }
  function schnorrVerify(signature2, message2, publicKey) {
    const sig = (0, utils_ts_1$3.ensureBytes)("signature", signature2, 64);
    const m = (0, utils_ts_1$3.ensureBytes)("message", message2);
    const pub = (0, utils_ts_1$3.ensureBytes)("publicKey", publicKey, 32);
    try {
      const P = lift_x(num(pub));
      const r = num(sig.subarray(0, 32));
      if (!(0, utils_ts_1$3.inRange)(r, _1n$3, secp256k1_CURVE.p)) return false;
      const s = num(sig.subarray(32, 64));
      if (!(0, utils_ts_1$3.inRange)(s, _1n$3, secp256k1_CURVE.n)) return false;
      const e = challenge(numTo32b(r), pointToBytes(P), m);
      const R = Point.BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(modN(-e)));
      const { x, y } = R.toAffine();
      if (R.is0() || !hasEven(y) || x !== r) return false;
      return true;
    } catch (error) {
      return false;
    }
  }
  exports.schnorr = (() => ({
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    utils: {
      randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
      lift_x,
      pointToBytes,
      numberToBytesBE: utils_ts_1$3.numberToBytesBE,
      bytesToNumberBE: utils_ts_1$3.bytesToNumberBE,
      taggedHash,
      mod: modular_ts_1$3.mod
    }
  }))();
  const isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_ts_1$1.isogenyMap)(Fpk1, [
    [
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
      "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
      "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
    ],
    [
      "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
      "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
    ],
    [
      "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
      "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
      "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
      "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
    ],
    [
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
      "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
      "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
    ]
  ].map((i) => i.map((j) => BigInt(j)))))();
  const mapSWU = /* @__PURE__ */ (() => (0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fpk1, {
    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
    B: BigInt("1771"),
    Z: Fpk1.create(BigInt("-11"))
  }))();
  exports.secp256k1_hasher = (() => (0, hash_to_curve_ts_1$1.createHasher)(exports.secp256k1.Point, (scalars) => {
    const { x, y } = mapSWU(Fpk1.create(scalars[0]));
    return isoMap(x, y);
  }, {
    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
    p: Fpk1.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: sha2_js_1$1.sha256
  }))();
  exports.hashToCurve = (() => exports.secp256k1_hasher.hashToCurve)();
  exports.encodeToCurve = (() => exports.secp256k1_hasher.encodeToCurve)();
} });
var require_sha512 = __commonJS({ "../../node_modules/.pnpm/@xrplf+isomorphic@1.0.1_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@xrplf/isomorphic/dist/sha512/index.js"(exports) {
  var __importDefault$4 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sha512 = void 0;
  const crypto_1 = __require("crypto");
  const wrapCryptoCreateHash_1 = __importDefault$4(require_wrapCryptoCreateHash());
  exports.sha512 = (0, wrapCryptoCreateHash_1.default)("sha512", crypto_1.createHash);
} });
var require_utils$1 = __commonJS({ "../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/utils.js"(exports) {
  var __createBinding = Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
      enumerable: true,
      get: function() {
        return m[k];
      }
    };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  };
  var __exportStar = function(m, exports$1) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_utils$2(), exports);
} });
var require_Sha512 = __commonJS({ "../../node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/utils/Sha512.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const sha512_1 = require_sha512();
  const utils_1$3 = require_utils$1();
  var Sha512 = class Sha5122 {
    constructor() {
      this.hash = sha512_1.sha512.create();
    }
    static half(input) {
      return new Sha5122().add(input).first256();
    }
    add(bytes2) {
      this.hash.update(bytes2);
      return this;
    }
    addU32(i) {
      const buffer = new Uint8Array(4);
      new DataView(buffer.buffer).setUint32(0, i);
      return this.add(buffer);
    }
    finish() {
      return this.hash.digest();
    }
    first256() {
      return this.finish().slice(0, 32);
    }
    first256BigInt() {
      return (0, utils_1$3.bytesToNumberBE)(this.first256());
    }
  };
  exports.default = Sha512;
} });
var require_utils = __commonJS({ "../../node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/utils.js"(exports) {
  var __importDefault$3 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.accountPublicFromPublicGenerator = exports.derivePrivateKey = void 0;
  const secp256k1_1$2 = require_secp256k1$1();
  const Sha512_1$3 = __importDefault$3(require_Sha512());
  const ZERO = BigInt(0);
  function deriveScalar(bytes2, discrim) {
    const order = secp256k1_1$2.secp256k1.CURVE.n;
    for (let i = 0; i <= 4294967295; i++) {
      const hasher = new Sha512_1$3.default().add(bytes2);
      if (discrim !== void 0) hasher.addU32(discrim);
      hasher.addU32(i);
      const key = hasher.first256BigInt();
      if (key > ZERO && key < order) return key;
    }
    throw new Error("impossible unicorn ;)");
  }
  function derivePrivateKey(seed, opts = {}) {
    const root2 = opts.validator;
    const order = secp256k1_1$2.secp256k1.CURVE.n;
    const privateGen = deriveScalar(seed);
    if (root2) return privateGen;
    const publicGen = secp256k1_1$2.secp256k1.ProjectivePoint.BASE.multiply(privateGen).toRawBytes(true);
    const accountIndex = opts.accountIndex || 0;
    return (deriveScalar(publicGen, accountIndex) + privateGen) % order;
  }
  exports.derivePrivateKey = derivePrivateKey;
  function accountPublicFromPublicGenerator(publicGenBytes) {
    const rootPubPoint = secp256k1_1$2.secp256k1.ProjectivePoint.fromHex(publicGenBytes);
    const scalar = deriveScalar(publicGenBytes, 0);
    const point = secp256k1_1$2.secp256k1.ProjectivePoint.BASE.multiply(scalar);
    const offset = rootPubPoint.add(point);
    return offset.toRawBytes(true);
  }
  exports.accountPublicFromPublicGenerator = accountPublicFromPublicGenerator;
} });
var require_assert = __commonJS({ "../../node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/utils/assert.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const assertHelper = { ok(cond, message2) {
    if (!cond) throw new Error(message2);
  } };
  exports.default = assertHelper;
} });
var require_getAlgorithmFromKey = __commonJS({ "../../node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/utils/getAlgorithmFromKey.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getAlgorithmFromPrivateKey = exports.getAlgorithmFromPublicKey = exports.getAlgorithmFromKey = void 0;
  var Prefix;
  (function(Prefix$1) {
    Prefix$1[Prefix$1["NONE"] = -1] = "NONE";
    Prefix$1[Prefix$1["ED25519"] = 237] = "ED25519";
    Prefix$1[Prefix$1["SECP256K1_PUB_X"] = 2] = "SECP256K1_PUB_X";
    Prefix$1[Prefix$1["SECP256K1_PUB_X_ODD_Y"] = 3] = "SECP256K1_PUB_X_ODD_Y";
    Prefix$1[Prefix$1["SECP256K1_PUB_XY"] = 4] = "SECP256K1_PUB_XY";
    Prefix$1[Prefix$1["SECP256K1_PRIVATE"] = 0] = "SECP256K1_PRIVATE";
  })(Prefix || (Prefix = {}));
  const KEY_TYPES = {
    [`private_${Prefix.NONE}_32`]: "ecdsa-secp256k1",
    [`private_${Prefix.SECP256K1_PRIVATE}_33`]: "ecdsa-secp256k1",
    [`private_${Prefix.ED25519}_33`]: "ed25519",
    [`public_${Prefix.ED25519}_33`]: "ed25519",
    [`public_${Prefix.SECP256K1_PUB_X}_33`]: "ecdsa-secp256k1",
    [`public_${Prefix.SECP256K1_PUB_X_ODD_Y}_33`]: "ecdsa-secp256k1",
    [`public_${Prefix.SECP256K1_PUB_XY}_65`]: "ecdsa-secp256k1"
  };
  function getKeyInfo(key) {
    return {
      prefix: key.length < 2 ? Prefix.NONE : parseInt(key.slice(0, 2), 16),
      len: key.length / 2
    };
  }
  function prefixRepr(prefix$12) {
    return prefix$12 === Prefix.NONE ? "None" : `0x${prefix$12.toString(16).padStart(2, "0")}`;
  }
  function getValidFormatsTable(type2) {
    const padding$1 = 2;
    const colWidth = {
      algorithm: 15 + padding$1,
      prefix: 4 + padding$1
    };
    return Object.entries(KEY_TYPES).filter(([key]) => key.startsWith(type2)).map(([key, algorithm]) => {
      const [, prefix$12, length] = key.split("_");
      const paddedAlgo = algorithm.padEnd(colWidth.algorithm);
      const paddedPrefix = prefixRepr(Number(prefix$12)).padEnd(colWidth.prefix);
      return `${paddedAlgo} - Prefix: ${paddedPrefix} Length: ${length} bytes`;
    }).join("\n");
  }
  function keyError({ key, type: type2, prefix: prefix$12, len }) {
    const validFormats = getValidFormatsTable(type2);
    return `invalid_key:

Type: ${type2}
Key: ${key}
Prefix: ${prefixRepr(prefix$12)} 
Length: ${len} bytes

Acceptable ${type2} formats are:
${validFormats}
`;
  }
  function getAlgorithmFromKey(key, type2) {
    const { prefix: prefix$12, len } = getKeyInfo(key);
    const usedPrefix = type2 === "private" && len === 32 ? Prefix.NONE : prefix$12;
    const algorithm = KEY_TYPES[`${type2}_${usedPrefix}_${len}`];
    if (!algorithm) throw new Error(keyError({
      key,
      type: type2,
      len,
      prefix: usedPrefix
    }));
    return algorithm;
  }
  exports.getAlgorithmFromKey = getAlgorithmFromKey;
  function getAlgorithmFromPublicKey(key) {
    return getAlgorithmFromKey(key, "public");
  }
  exports.getAlgorithmFromPublicKey = getAlgorithmFromPublicKey;
  function getAlgorithmFromPrivateKey(key) {
    return getAlgorithmFromKey(key, "private");
  }
  exports.getAlgorithmFromPrivateKey = getAlgorithmFromPrivateKey;
} });
var require_secp256k1 = __commonJS({ "../../node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/index.js"(exports) {
  var __importDefault$2 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const utils_1$2 = require_utils$1();
  const secp256k1_1$1 = require_secp256k1$1();
  const utils_2$1 = require_utils$4();
  const utils_3 = require_utils();
  const assert_1$2 = __importDefault$2(require_assert());
  const Sha512_1$2 = __importDefault$2(require_Sha512());
  const SECP256K1_PREFIX = "00";
  const secp256k1 = {
    deriveKeypair(entropy, options) {
      const derived = (0, utils_3.derivePrivateKey)(entropy, options);
      const privateKey = SECP256K1_PREFIX + (0, utils_2$1.bytesToHex)((0, utils_1$2.numberToBytesBE)(derived, 32));
      const publicKey = (0, utils_2$1.bytesToHex)(secp256k1_1$1.secp256k1.getPublicKey(derived, true));
      return {
        privateKey,
        publicKey
      };
    },
    sign(message2, privateKey) {
      assert_1$2.default.ok(privateKey.length === 66 && privateKey.startsWith(SECP256K1_PREFIX) || privateKey.length === 64);
      const normedPrivateKey = privateKey.length === 66 ? privateKey.slice(2) : privateKey;
      return secp256k1_1$1.secp256k1.sign(Sha512_1$2.default.half(message2), normedPrivateKey, {
        lowS: true,
        extraEntropy: void 0
      }).toDERHex(true).toUpperCase();
    },
    verify(message2, signature2, publicKey) {
      const decoded = secp256k1_1$1.secp256k1.Signature.fromDER(signature2);
      return secp256k1_1$1.secp256k1.verify(decoded, Sha512_1$2.default.half(message2), publicKey);
    }
  };
  exports.default = secp256k1;
} });
var require_edwards = __commonJS({ "../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/edwards.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.edwards = edwards;
  exports.eddsa = eddsa;
  exports.twistedEdwards = twistedEdwards;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const utils_ts_1$2 = require_utils$2();
  const curve_ts_1$1 = require_curve();
  const modular_ts_1$2 = require_modular();
  const _0n$2 = BigInt(0), _1n$2 = BigInt(1), _2n$2 = BigInt(2), _8n$1 = BigInt(8);
  const VERIFY_DEFAULT = { zip215: true };
  function isEdValidXY(Fp$1, CURVE, x, y) {
    const x2 = Fp$1.sqr(x);
    const y2 = Fp$1.sqr(y);
    const left = Fp$1.add(Fp$1.mul(CURVE.a, x2), y2);
    const right = Fp$1.add(Fp$1.ONE, Fp$1.mul(CURVE.d, Fp$1.mul(x2, y2)));
    return Fp$1.eql(left, right);
  }
  function edwards(CURVE, curveOpts = {}) {
    const { Fp: Fp$1, Fn } = (0, curve_ts_1$1._createCurveFields)("edwards", CURVE, curveOpts);
    const { h: cofactor, n: CURVE_ORDER } = CURVE;
    (0, utils_ts_1$2._validateObject)(curveOpts, {}, { uvRatio: "function" });
    const MASK = _2n$2 << BigInt(Fn.BYTES * 8) - _1n$2;
    const modP$1 = (n) => Fp$1.create(n);
    const uvRatio$1 = curveOpts.uvRatio || ((u, v) => {
      try {
        return {
          isValid: true,
          value: Fp$1.sqrt(Fp$1.div(u, v))
        };
      } catch (e) {
        return {
          isValid: false,
          value: _0n$2
        };
      }
    });
    if (!isEdValidXY(Fp$1, CURVE, CURVE.Gx, CURVE.Gy)) throw new Error("bad curve params: generator point");
    function acoord(title, n, banZero = false) {
      const min2 = banZero ? _1n$2 : _0n$2;
      (0, utils_ts_1$2.aInRange)("coordinate " + title, n, min2, MASK);
      return n;
    }
    function aextpoint(other) {
      if (!(other instanceof Point$1)) throw new Error("ExtendedPoint expected");
    }
    const toAffineMemo = (0, utils_ts_1$2.memoized)((p, iz) => {
      const { ex: x, ey: y, ez: z2 } = p;
      const is0 = p.is0();
      if (iz == null) iz = is0 ? _8n$1 : Fp$1.inv(z2);
      const ax = modP$1(x * iz);
      const ay = modP$1(y * iz);
      const zz = modP$1(z2 * iz);
      if (is0) return {
        x: _0n$2,
        y: _1n$2
      };
      if (zz !== _1n$2) throw new Error("invZ was invalid");
      return {
        x: ax,
        y: ay
      };
    });
    const assertValidMemo = (0, utils_ts_1$2.memoized)((p) => {
      const { a, d } = CURVE;
      if (p.is0()) throw new Error("bad point: ZERO");
      const { ex: X, ey: Y, ez: Z, et: T } = p;
      const X2 = modP$1(X * X);
      const Y2 = modP$1(Y * Y);
      const Z2 = modP$1(Z * Z);
      const Z4 = modP$1(Z2 * Z2);
      const aX2 = modP$1(X2 * a);
      const left = modP$1(Z2 * modP$1(aX2 + Y2));
      const right = modP$1(Z4 + modP$1(d * modP$1(X2 * Y2)));
      if (left !== right) throw new Error("bad point: equation left != right (1)");
      const XY = modP$1(X * Y);
      const ZT = modP$1(Z * T);
      if (XY !== ZT) throw new Error("bad point: equation left != right (2)");
      return true;
    });
    class Point$1 {
      constructor(ex, ey, ez, et) {
        this.ex = acoord("x", ex);
        this.ey = acoord("y", ey);
        this.ez = acoord("z", ez, true);
        this.et = acoord("t", et);
        Object.freeze(this);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static fromAffine(p) {
        if (p instanceof Point$1) throw new Error("extended point not allowed");
        const { x, y } = p || {};
        acoord("x", x);
        acoord("y", y);
        return new Point$1(x, y, _1n$2, modP$1(x * y));
      }
      static normalizeZ(points) {
        return (0, curve_ts_1$1.normalizeZ)(Point$1, "ez", points);
      }
      static msm(points, scalars) {
        return (0, curve_ts_1$1.pippenger)(Point$1, Fn, points, scalars);
      }
      _setWindowSize(windowSize) {
        this.precompute(windowSize);
      }
      precompute(windowSize = 8, isLazy = true) {
        wnaf.setWindowSize(this, windowSize);
        if (!isLazy) this.multiply(_2n$2);
        return this;
      }
      assertValidity() {
        assertValidMemo(this);
      }
      equals(other) {
        aextpoint(other);
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const { ex: X2, ey: Y2, ez: Z2 } = other;
        const X1Z2 = modP$1(X1 * Z2);
        const X2Z1 = modP$1(X2 * Z1);
        const Y1Z2 = modP$1(Y1 * Z2);
        const Y2Z1 = modP$1(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
      is0() {
        return this.equals(Point$1.ZERO);
      }
      negate() {
        return new Point$1(modP$1(-this.ex), this.ey, this.ez, modP$1(-this.et));
      }
      double() {
        const { a } = CURVE;
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const A = modP$1(X1 * X1);
        const B = modP$1(Y1 * Y1);
        const C = modP$1(_2n$2 * modP$1(Z1 * Z1));
        const D = modP$1(a * A);
        const x1y1 = X1 + Y1;
        const E = modP$1(modP$1(x1y1 * x1y1) - A - B);
        const G = D + B;
        const F = G - C;
        const H = D - B;
        const X3 = modP$1(E * F);
        const Y3 = modP$1(G * H);
        const T3 = modP$1(E * H);
        const Z3 = modP$1(F * G);
        return new Point$1(X3, Y3, Z3, T3);
      }
      add(other) {
        aextpoint(other);
        const { a, d } = CURVE;
        const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
        const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
        const A = modP$1(X1 * X2);
        const B = modP$1(Y1 * Y2);
        const C = modP$1(T1 * d * T2);
        const D = modP$1(Z1 * Z2);
        const E = modP$1((X1 + Y1) * (X2 + Y2) - A - B);
        const F = D - C;
        const G = D + C;
        const H = modP$1(B - a * A);
        const X3 = modP$1(E * F);
        const Y3 = modP$1(G * H);
        const T3 = modP$1(E * H);
        const Z3 = modP$1(F * G);
        return new Point$1(X3, Y3, Z3, T3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      multiply(scalar) {
        const n = scalar;
        (0, utils_ts_1$2.aInRange)("scalar", n, _1n$2, CURVE_ORDER);
        const { p, f } = wnaf.wNAFCached(this, n, Point$1.normalizeZ);
        return Point$1.normalizeZ([p, f])[0];
      }
      multiplyUnsafe(scalar, acc = Point$1.ZERO) {
        const n = scalar;
        (0, utils_ts_1$2.aInRange)("scalar", n, _0n$2, CURVE_ORDER);
        if (n === _0n$2) return Point$1.ZERO;
        if (this.is0() || n === _1n$2) return this;
        return wnaf.wNAFCachedUnsafe(this, n, Point$1.normalizeZ, acc);
      }
      isSmallOrder() {
        return this.multiplyUnsafe(cofactor).is0();
      }
      isTorsionFree() {
        return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
      }
      toAffine(invertedZ) {
        return toAffineMemo(this, invertedZ);
      }
      clearCofactor() {
        if (cofactor === _1n$2) return this;
        return this.multiplyUnsafe(cofactor);
      }
      static fromBytes(bytes2, zip215 = false) {
        (0, utils_ts_1$2.abytes)(bytes2);
        return this.fromHex(bytes2, zip215);
      }
      static fromHex(hex, zip215 = false) {
        const { d, a } = CURVE;
        const len = Fp$1.BYTES;
        hex = (0, utils_ts_1$2.ensureBytes)("pointHex", hex, len);
        (0, utils_ts_1$2.abool)("zip215", zip215);
        const normed = hex.slice();
        const lastByte = hex[len - 1];
        normed[len - 1] = lastByte & -129;
        const y = (0, utils_ts_1$2.bytesToNumberLE)(normed);
        const max2 = zip215 ? MASK : Fp$1.ORDER;
        (0, utils_ts_1$2.aInRange)("pointHex.y", y, _0n$2, max2);
        const y2 = modP$1(y * y);
        const u = modP$1(y2 - _1n$2);
        const v = modP$1(d * y2 - a);
        let { isValid, value: x } = uvRatio$1(u, v);
        if (!isValid) throw new Error("Point.fromHex: invalid y coordinate");
        const isXOdd = (x & _1n$2) === _1n$2;
        const isLastByteOdd = (lastByte & 128) !== 0;
        if (!zip215 && x === _0n$2 && isLastByteOdd) throw new Error("Point.fromHex: x=0 and x_0=1");
        if (isLastByteOdd !== isXOdd) x = modP$1(-x);
        return Point$1.fromAffine({
          x,
          y
        });
      }
      static fromPrivateScalar(scalar) {
        return Point$1.BASE.multiply(scalar);
      }
      toBytes() {
        const { x, y } = this.toAffine();
        const bytes2 = (0, utils_ts_1$2.numberToBytesLE)(y, Fp$1.BYTES);
        bytes2[bytes2.length - 1] |= x & _1n$2 ? 128 : 0;
        return bytes2;
      }
      /** @deprecated use `toBytes` */
      toRawBytes() {
        return this.toBytes();
      }
      toHex() {
        return (0, utils_ts_1$2.bytesToHex)(this.toBytes());
      }
      toString() {
        return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
      }
    }
    Point$1.BASE = new Point$1(CURVE.Gx, CURVE.Gy, _1n$2, modP$1(CURVE.Gx * CURVE.Gy));
    Point$1.ZERO = new Point$1(_0n$2, _1n$2, _1n$2, _0n$2);
    Point$1.Fp = Fp$1;
    Point$1.Fn = Fn;
    const wnaf = (0, curve_ts_1$1.wNAF)(Point$1, Fn.BYTES * 8);
    return Point$1;
  }
  function eddsa(Point$1, eddsaOpts) {
    (0, utils_ts_1$2._validateObject)(eddsaOpts, { hash: "function" }, {
      adjustScalarBytes: "function",
      randomBytes: "function",
      domain: "function",
      prehash: "function",
      mapToCurve: "function"
    });
    const { prehash, hash: cHash } = eddsaOpts;
    const { BASE: G, Fp: Fp$1, Fn } = Point$1;
    const CURVE_ORDER = Fn.ORDER;
    const randomBytes_ = eddsaOpts.randomBytes || utils_ts_1$2.randomBytes;
    const adjustScalarBytes$1 = eddsaOpts.adjustScalarBytes || ((bytes2) => bytes2);
    const domain = eddsaOpts.domain || ((data2, ctx, phflag) => {
      (0, utils_ts_1$2.abool)("phflag", phflag);
      if (ctx.length || phflag) throw new Error("Contexts/pre-hash are not supported");
      return data2;
    });
    function modN$1(a) {
      return Fn.create(a);
    }
    function modN_LE(hash$12) {
      return modN$1((0, utils_ts_1$2.bytesToNumberLE)(hash$12));
    }
    function getPrivateScalar(key) {
      const len = Fp$1.BYTES;
      key = (0, utils_ts_1$2.ensureBytes)("private key", key, len);
      const hashed = (0, utils_ts_1$2.ensureBytes)("hashed private key", cHash(key), 2 * len);
      const head = adjustScalarBytes$1(hashed.slice(0, len));
      const prefix$12 = hashed.slice(len, 2 * len);
      const scalar = modN_LE(head);
      return {
        head,
        prefix: prefix$12,
        scalar
      };
    }
    function getExtendedPublicKey(key) {
      const { head, prefix: prefix$12, scalar } = getPrivateScalar(key);
      const point = G.multiply(scalar);
      const pointBytes = point.toBytes();
      return {
        head,
        prefix: prefix$12,
        scalar,
        point,
        pointBytes
      };
    }
    function getPublicKey(privKey) {
      return getExtendedPublicKey(privKey).pointBytes;
    }
    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
      const msg = (0, utils_ts_1$2.concatBytes)(...msgs);
      return modN_LE(cHash(domain(msg, (0, utils_ts_1$2.ensureBytes)("context", context), !!prehash)));
    }
    function sign$1(msg, privKey, options = {}) {
      msg = (0, utils_ts_1$2.ensureBytes)("message", msg);
      if (prehash) msg = prehash(msg);
      const { prefix: prefix$12, scalar, pointBytes } = getExtendedPublicKey(privKey);
      const r = hashDomainToScalar(options.context, prefix$12, msg);
      const R = G.multiply(r).toBytes();
      const k = hashDomainToScalar(options.context, R, pointBytes, msg);
      const s = modN$1(r + k * scalar);
      (0, utils_ts_1$2.aInRange)("signature.s", s, _0n$2, CURVE_ORDER);
      const L = Fp$1.BYTES;
      const res = (0, utils_ts_1$2.concatBytes)(R, (0, utils_ts_1$2.numberToBytesLE)(s, L));
      return (0, utils_ts_1$2.ensureBytes)("result", res, L * 2);
    }
    const verifyOpts = VERIFY_DEFAULT;
    function verify$1(sig, msg, publicKey, options = verifyOpts) {
      const { context, zip215 } = options;
      const len = Fp$1.BYTES;
      sig = (0, utils_ts_1$2.ensureBytes)("signature", sig, 2 * len);
      msg = (0, utils_ts_1$2.ensureBytes)("message", msg);
      publicKey = (0, utils_ts_1$2.ensureBytes)("publicKey", publicKey, len);
      if (zip215 !== void 0) (0, utils_ts_1$2.abool)("zip215", zip215);
      if (prehash) msg = prehash(msg);
      const s = (0, utils_ts_1$2.bytesToNumberLE)(sig.slice(len, 2 * len));
      let A, R, SB2;
      try {
        A = Point$1.fromHex(publicKey, zip215);
        R = Point$1.fromHex(sig.slice(0, len), zip215);
        SB2 = G.multiplyUnsafe(s);
      } catch (error) {
        return false;
      }
      if (!zip215 && A.isSmallOrder()) return false;
      const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
      const RkA = R.add(A.multiplyUnsafe(k));
      return RkA.subtract(SB2).clearCofactor().is0();
    }
    G.precompute(8);
    const utils2 = {
      getExtendedPublicKey,
      randomPrivateKey: () => randomBytes_(Fp$1.BYTES),
      precompute(windowSize = 8, point = Point$1.BASE) {
        return point.precompute(windowSize, false);
      }
    };
    return {
      getPublicKey,
      sign: sign$1,
      verify: verify$1,
      utils: utils2,
      Point: Point$1
    };
  }
  function _eddsa_legacy_opts_to_new(c) {
    const CURVE = {
      a: c.a,
      d: c.d,
      p: c.Fp.ORDER,
      n: c.n,
      h: c.h,
      Gx: c.Gx,
      Gy: c.Gy
    };
    const Fp$1 = c.Fp;
    const Fn = (0, modular_ts_1$2.Field)(CURVE.n, c.nBitLength, true);
    const curveOpts = {
      Fp: Fp$1,
      Fn,
      uvRatio: c.uvRatio
    };
    const eddsaOpts = {
      hash: c.hash,
      randomBytes: c.randomBytes,
      adjustScalarBytes: c.adjustScalarBytes,
      domain: c.domain,
      prehash: c.prehash,
      mapToCurve: c.mapToCurve
    };
    return {
      CURVE,
      curveOpts,
      eddsaOpts
    };
  }
  function _eddsa_new_output_to_legacy(c, eddsa$1) {
    const legacy = Object.assign({}, eddsa$1, {
      ExtendedPoint: eddsa$1.Point,
      CURVE: c
    });
    return legacy;
  }
  function twistedEdwards(c) {
    const { CURVE, curveOpts, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
    const Point$1 = edwards(CURVE, curveOpts);
    const EDDSA = eddsa(Point$1, eddsaOpts);
    return _eddsa_new_output_to_legacy(c, EDDSA);
  }
} });
var require_montgomery = __commonJS({ "../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/abstract/montgomery.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.montgomery = montgomery;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const utils_ts_1$1 = require_utils$2();
  const modular_ts_1$1 = require_modular();
  const _0n$1 = BigInt(0);
  const _1n$1 = BigInt(1);
  const _2n$1 = BigInt(2);
  function validateOpts(curve) {
    (0, utils_ts_1$1._validateObject)(curve, {
      adjustScalarBytes: "function",
      powPminus2: "function"
    });
    return Object.freeze({ ...curve });
  }
  function montgomery(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { P, type: type2, adjustScalarBytes: adjustScalarBytes$1, powPminus2, randomBytes: rand } = CURVE;
    const is25519 = type2 === "x25519";
    if (!is25519 && type2 !== "x448") throw new Error("invalid type");
    const randomBytes_ = rand || utils_ts_1$1.randomBytes;
    const montgomeryBits = is25519 ? 255 : 448;
    const fieldLen = is25519 ? 32 : 56;
    const Gu = is25519 ? BigInt(9) : BigInt(5);
    const a24 = is25519 ? BigInt(121665) : BigInt(39081);
    const minScalar = is25519 ? _2n$1 ** BigInt(254) : _2n$1 ** BigInt(447);
    const maxAdded = is25519 ? BigInt(8) * _2n$1 ** BigInt(251) - _1n$1 : BigInt(4) * _2n$1 ** BigInt(445) - _1n$1;
    const maxScalar = minScalar + maxAdded + _1n$1;
    const modP$1 = (n) => (0, modular_ts_1$1.mod)(n, P);
    const GuBytes = encodeU(Gu);
    function encodeU(u) {
      return (0, utils_ts_1$1.numberToBytesLE)(modP$1(u), fieldLen);
    }
    function decodeU(u) {
      const _u = (0, utils_ts_1$1.ensureBytes)("u coordinate", u, fieldLen);
      if (is25519) _u[31] &= 127;
      return modP$1((0, utils_ts_1$1.bytesToNumberLE)(_u));
    }
    function decodeScalar(scalar) {
      return (0, utils_ts_1$1.bytesToNumberLE)(adjustScalarBytes$1((0, utils_ts_1$1.ensureBytes)("scalar", scalar, fieldLen)));
    }
    function scalarMult(scalar, u) {
      const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
      if (pu === _0n$1) throw new Error("invalid private or public key received");
      return encodeU(pu);
    }
    function scalarMultBase(scalar) {
      return scalarMult(scalar, GuBytes);
    }
    function cswap(swap, x_2, x_3) {
      const dummy = modP$1(swap * (x_2 - x_3));
      x_2 = modP$1(x_2 - dummy);
      x_3 = modP$1(x_3 + dummy);
      return {
        x_2,
        x_3
      };
    }
    function montgomeryLadder(u, scalar) {
      (0, utils_ts_1$1.aInRange)("u", u, _0n$1, P);
      (0, utils_ts_1$1.aInRange)("scalar", scalar, minScalar, maxScalar);
      const k = scalar;
      const x_1 = u;
      let x_2 = _1n$1;
      let z_2 = _0n$1;
      let x_3 = u;
      let z_3 = _1n$1;
      let swap = _0n$1;
      for (let t = BigInt(montgomeryBits - 1); t >= _0n$1; t--) {
        const k_t = k >> t & _1n$1;
        swap ^= k_t;
        ({ x_2, x_3 } = cswap(swap, x_2, x_3));
        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
        swap = k_t;
        const A = x_2 + z_2;
        const AA = modP$1(A * A);
        const B = x_2 - z_2;
        const BB2 = modP$1(B * B);
        const E = AA - BB2;
        const C = x_3 + z_3;
        const D = x_3 - z_3;
        const DA = modP$1(D * A);
        const CB = modP$1(C * B);
        const dacb = DA + CB;
        const da_cb = DA - CB;
        x_3 = modP$1(dacb * dacb);
        z_3 = modP$1(x_1 * modP$1(da_cb * da_cb));
        x_2 = modP$1(AA * BB2);
        z_2 = modP$1(E * (AA + modP$1(a24 * E)));
      }
      ({ x_2, x_3 } = cswap(swap, x_2, x_3));
      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
      const z2 = powPminus2(z_2);
      return modP$1(x_2 * z2);
    }
    return {
      scalarMult,
      scalarMultBase,
      getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
      getPublicKey: (privateKey) => scalarMultBase(privateKey),
      utils: { randomPrivateKey: () => randomBytes_(fieldLen) },
      GuBytes: GuBytes.slice()
    };
  }
} });
var require_ed25519$1 = __commonJS({ "../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/ed25519.js"(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hash_to_ristretto255 = exports.hashToRistretto255 = exports.RistrettoPoint = exports.encodeToCurve = exports.hashToCurve = exports.ed25519_hasher = exports.edwardsToMontgomery = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = exports.ED25519_TORSION_SUBGROUP = void 0;
  exports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
  exports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const sha2_js_1 = require_sha2();
  const utils_js_1 = require_utils$5();
  const curve_ts_1 = require_curve();
  const edwards_ts_1 = require_edwards();
  const hash_to_curve_ts_1 = require_hash_to_curve();
  const modular_ts_1 = require_modular();
  const montgomery_ts_1 = require_montgomery();
  const utils_ts_1 = require_utils$2();
  const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
  const _5n = BigInt(5), _8n = BigInt(8);
  const ed25519_CURVE = {
    p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),
    n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
    h: _8n,
    a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
    d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
    Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
    Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
  };
  function ed25519_pow_2_252_3(x) {
    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
    const P = ed25519_CURVE.p;
    const x2 = x * x % P;
    const b2 = x2 * x % P;
    const b4 = (0, modular_ts_1.pow2)(b2, _2n, P) * b2 % P;
    const b5 = (0, modular_ts_1.pow2)(b4, _1n, P) * x % P;
    const b10 = (0, modular_ts_1.pow2)(b5, _5n, P) * b5 % P;
    const b20 = (0, modular_ts_1.pow2)(b10, _10n, P) * b10 % P;
    const b40 = (0, modular_ts_1.pow2)(b20, _20n, P) * b20 % P;
    const b80 = (0, modular_ts_1.pow2)(b40, _40n, P) * b40 % P;
    const b160 = (0, modular_ts_1.pow2)(b80, _80n, P) * b80 % P;
    const b240 = (0, modular_ts_1.pow2)(b160, _80n, P) * b80 % P;
    const b250 = (0, modular_ts_1.pow2)(b240, _10n, P) * b10 % P;
    const pow_p_5_8 = (0, modular_ts_1.pow2)(b250, _2n, P) * x % P;
    return {
      pow_p_5_8,
      b2
    };
  }
  function adjustScalarBytes(bytes2) {
    bytes2[0] &= 248;
    bytes2[31] &= 127;
    bytes2[31] |= 64;
    return bytes2;
  }
  const ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
  function uvRatio(u, v) {
    const P = ed25519_CURVE.p;
    const v32 = (0, modular_ts_1.mod)(v * v * v, P);
    const v72 = (0, modular_ts_1.mod)(v32 * v32 * v, P);
    const pow$1 = ed25519_pow_2_252_3(u * v72).pow_p_5_8;
    let x = (0, modular_ts_1.mod)(u * v32 * pow$1, P);
    const vx2 = (0, modular_ts_1.mod)(v * x * x, P);
    const root1 = x;
    const root2 = (0, modular_ts_1.mod)(x * ED25519_SQRT_M1, P);
    const useRoot1 = vx2 === u;
    const useRoot2 = vx2 === (0, modular_ts_1.mod)(-u, P);
    const noRoot = vx2 === (0, modular_ts_1.mod)(-u * ED25519_SQRT_M1, P);
    if (useRoot1) x = root1;
    if (useRoot2 || noRoot) x = root2;
    if ((0, modular_ts_1.isNegativeLE)(x, P)) x = (0, modular_ts_1.mod)(-x, P);
    return {
      isValid: useRoot1 || useRoot2,
      value: x
    };
  }
  exports.ED25519_TORSION_SUBGROUP = [
    "0100000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
    "0000000000000000000000000000000000000000000000000000000000000080",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
    "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
  ];
  const Fp = /* @__PURE__ */ (() => (0, modular_ts_1.Field)(ed25519_CURVE.p, void 0, true))();
  const ed25519Defaults = /* @__PURE__ */ (() => ({
    ...ed25519_CURVE,
    Fp,
    hash: sha2_js_1.sha512,
    adjustScalarBytes,
    uvRatio
  }))();
  exports.ed25519 = (() => (0, edwards_ts_1.twistedEdwards)(ed25519Defaults))();
  function ed25519_domain(data2, ctx, phflag) {
    if (ctx.length > 255) throw new Error("Context is too big");
    return (0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data2);
  }
  exports.ed25519ctx = (() => (0, edwards_ts_1.twistedEdwards)({
    ...ed25519Defaults,
    domain: ed25519_domain
  }))();
  exports.ed25519ph = (() => (0, edwards_ts_1.twistedEdwards)(Object.assign({}, ed25519Defaults, {
    domain: ed25519_domain,
    prehash: sha2_js_1.sha512
  })))();
  exports.x25519 = (() => {
    const P = ed25519_CURVE.p;
    return (0, montgomery_ts_1.montgomery)({
      P,
      type: "x25519",
      powPminus2: (x) => {
        const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
        return (0, modular_ts_1.mod)((0, modular_ts_1.pow2)(pow_p_5_8, _3n, P) * b2, P);
      },
      adjustScalarBytes
    });
  })();
  function edwardsToMontgomeryPub(edwardsPub) {
    const bpub = (0, utils_ts_1.ensureBytes)("pub", edwardsPub);
    const { y } = exports.ed25519.Point.fromHex(bpub);
    const _1n$8 = BigInt(1);
    return Fp.toBytes(Fp.create((_1n$8 + y) * Fp.inv(_1n$8 - y)));
  }
  exports.edwardsToMontgomery = edwardsToMontgomeryPub;
  function edwardsToMontgomeryPriv(edwardsPriv) {
    const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));
    return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);
  }
  const ELL2_C1 = /* @__PURE__ */ (() => (Fp.ORDER + _3n) / _8n)();
  const ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))();
  const ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
  function map_to_curve_elligator2_curve25519(u) {
    const ELL2_C4 = (Fp.ORDER - _5n) / _8n;
    const ELL2_J = BigInt(486662);
    let tv1 = Fp.sqr(u);
    tv1 = Fp.mul(tv1, _2n);
    let xd = Fp.add(tv1, Fp.ONE);
    let x1n = Fp.neg(ELL2_J);
    let tv2 = Fp.sqr(xd);
    let gxd = Fp.mul(tv2, xd);
    let gx1 = Fp.mul(tv1, ELL2_J);
    gx1 = Fp.mul(gx1, x1n);
    gx1 = Fp.add(gx1, tv2);
    gx1 = Fp.mul(gx1, x1n);
    let tv3 = Fp.sqr(gxd);
    tv2 = Fp.sqr(tv3);
    tv3 = Fp.mul(tv3, gxd);
    tv3 = Fp.mul(tv3, gx1);
    tv2 = Fp.mul(tv2, tv3);
    let y11 = Fp.pow(tv2, ELL2_C4);
    y11 = Fp.mul(y11, tv3);
    let y12 = Fp.mul(y11, ELL2_C3);
    tv2 = Fp.sqr(y11);
    tv2 = Fp.mul(tv2, gxd);
    let e1 = Fp.eql(tv2, gx1);
    let y1 = Fp.cmov(y12, y11, e1);
    let x2n = Fp.mul(x1n, tv1);
    let y21 = Fp.mul(y11, u);
    y21 = Fp.mul(y21, ELL2_C2);
    let y22 = Fp.mul(y21, ELL2_C3);
    let gx2 = Fp.mul(gx1, tv1);
    tv2 = Fp.sqr(y21);
    tv2 = Fp.mul(tv2, gxd);
    let e2 = Fp.eql(tv2, gx2);
    let y2 = Fp.cmov(y22, y21, e2);
    tv2 = Fp.sqr(y1);
    tv2 = Fp.mul(tv2, gxd);
    let e3 = Fp.eql(tv2, gx1);
    let xn = Fp.cmov(x2n, x1n, e3);
    let y = Fp.cmov(y2, y1, e3);
    let e4 = Fp.isOdd(y);
    y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
    return {
      xMn: xn,
      xMd: xd,
      yMn: y,
      yMd: _1n
    };
  }
  const ELL2_C1_EDWARDS = /* @__PURE__ */ (() => (0, modular_ts_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))();
  function map_to_curve_elligator2_edwards25519(u) {
    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
    let xn = Fp.mul(xMn, yMd);
    xn = Fp.mul(xn, ELL2_C1_EDWARDS);
    let xd = Fp.mul(xMd, yMn);
    let yn = Fp.sub(xMn, xMd);
    let yd = Fp.add(xMn, xMd);
    let tv1 = Fp.mul(xd, yd);
    let e = Fp.eql(tv1, Fp.ZERO);
    xn = Fp.cmov(xn, Fp.ZERO, e);
    xd = Fp.cmov(xd, Fp.ONE, e);
    yn = Fp.cmov(yn, Fp.ONE, e);
    yd = Fp.cmov(yd, Fp.ONE, e);
    const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(Fp, [xd, yd], true);
    return {
      x: Fp.mul(xn, xd_inv),
      y: Fp.mul(yn, yd_inv)
    };
  }
  exports.ed25519_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.ed25519.Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
    DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
    encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
    p: Fp.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: sha2_js_1.sha512
  }))();
  exports.hashToCurve = (() => exports.ed25519_hasher.hashToCurve)();
  exports.encodeToCurve = (() => exports.ed25519_hasher.encodeToCurve)();
  function aristp(other) {
    if (!(other instanceof RistPoint)) throw new Error("RistrettoPoint expected");
  }
  const SQRT_M1 = ED25519_SQRT_M1;
  const SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
  const INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
  const ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
  const D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
  const invertSqrt = (number) => uvRatio(_1n, number);
  const MAX_255B = /* @__PURE__ */ BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  const bytes255ToNumberLE = (bytes2) => exports.ed25519.CURVE.Fp.create((0, utils_ts_1.bytesToNumberLE)(bytes2) & MAX_255B);
  function calcElligatorRistrettoMap(r0) {
    const { d } = exports.ed25519.CURVE;
    const P = exports.ed25519.CURVE.Fp.ORDER;
    const mod$1 = exports.ed25519.CURVE.Fp.create;
    const r = mod$1(SQRT_M1 * r0 * r0);
    const Ns = mod$1((r + _1n) * ONE_MINUS_D_SQ);
    let c = BigInt(-1);
    const D = mod$1((c - d * r) * mod$1(r + d));
    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
    let s_ = mod$1(s * r0);
    if (!(0, modular_ts_1.isNegativeLE)(s_, P)) s_ = mod$1(-s_);
    if (!Ns_D_is_sq) s = s_;
    if (!Ns_D_is_sq) c = r;
    const Nt = mod$1(c * (r - _1n) * D_MINUS_ONE_SQ - D);
    const s2 = s * s;
    const W0 = mod$1((s + s) * D);
    const W1 = mod$1(Nt * SQRT_AD_MINUS_ONE);
    const W2 = mod$1(_1n - s2);
    const W3 = mod$1(_1n + s2);
    return new exports.ed25519.Point(mod$1(W0 * W3), mod$1(W2 * W1), mod$1(W1 * W3), mod$1(W0 * W2));
  }
  var RistPoint = class RistPoint2 {
    constructor(ep) {
      this.ep = ep;
    }
    static fromAffine(ap) {
      return new RistPoint2(exports.ed25519.Point.fromAffine(ap));
    }
    /**
    * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
    * The hash-to-group operation applies Elligator twice and adds the results.
    * **Note:** this is one-way map, there is no conversion from point to hash.
    * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on
    * the [website](https://ristretto.group/formulas/elligator.html).
    * @param hex 64-byte output of a hash function
    */
    static hashToCurve(hex) {
      hex = (0, utils_ts_1.ensureBytes)("ristrettoHash", hex, 64);
      const r1 = bytes255ToNumberLE(hex.slice(0, 32));
      const R1 = calcElligatorRistrettoMap(r1);
      const r2 = bytes255ToNumberLE(hex.slice(32, 64));
      const R2 = calcElligatorRistrettoMap(r2);
      return new RistPoint2(R1.add(R2));
    }
    static fromBytes(bytes2) {
      (0, utils_js_1.abytes)(bytes2);
      return this.fromHex(bytes2);
    }
    /**
    * Converts ristretto-encoded string to ristretto point.
    * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
    * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
    */
    static fromHex(hex) {
      hex = (0, utils_ts_1.ensureBytes)("ristrettoHex", hex, 32);
      const { a, d } = exports.ed25519.CURVE;
      const P = Fp.ORDER;
      const mod$1 = Fp.create;
      const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
      const s = bytes255ToNumberLE(hex);
      if (!(0, utils_ts_1.equalBytes)((0, utils_ts_1.numberToBytesLE)(s, 32), hex) || (0, modular_ts_1.isNegativeLE)(s, P)) throw new Error(emsg);
      const s2 = mod$1(s * s);
      const u1 = mod$1(_1n + a * s2);
      const u2 = mod$1(_1n - a * s2);
      const u1_2 = mod$1(u1 * u1);
      const u2_2 = mod$1(u2 * u2);
      const v = mod$1(a * d * u1_2 - u2_2);
      const { isValid, value: I } = invertSqrt(mod$1(v * u2_2));
      const Dx = mod$1(I * u2);
      const Dy = mod$1(I * Dx * v);
      let x = mod$1((s + s) * Dx);
      if ((0, modular_ts_1.isNegativeLE)(x, P)) x = mod$1(-x);
      const y = mod$1(u1 * Dy);
      const t = mod$1(x * y);
      if (!isValid || (0, modular_ts_1.isNegativeLE)(t, P) || y === _0n) throw new Error(emsg);
      return new RistPoint2(new exports.ed25519.Point(x, y, _1n, t));
    }
    static msm(points, scalars) {
      const Fn = (0, modular_ts_1.Field)(exports.ed25519.CURVE.n, exports.ed25519.CURVE.nBitLength);
      return (0, curve_ts_1.pippenger)(RistPoint2, Fn, points, scalars);
    }
    /**
    * Encodes ristretto point to Uint8Array.
    * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
    */
    toBytes() {
      let { ex: x, ey: y, ez: z2, et: t } = this.ep;
      const P = Fp.ORDER;
      const mod$1 = Fp.create;
      const u1 = mod$1(mod$1(z2 + y) * mod$1(z2 - y));
      const u2 = mod$1(x * y);
      const u2sq = mod$1(u2 * u2);
      const { value: invsqrt } = invertSqrt(mod$1(u1 * u2sq));
      const D1 = mod$1(invsqrt * u1);
      const D2 = mod$1(invsqrt * u2);
      const zInv = mod$1(D1 * D2 * t);
      let D;
      if ((0, modular_ts_1.isNegativeLE)(t * zInv, P)) {
        let _x = mod$1(y * SQRT_M1);
        let _y = mod$1(x * SQRT_M1);
        x = _x;
        y = _y;
        D = mod$1(D1 * INVSQRT_A_MINUS_D);
      } else D = D2;
      if ((0, modular_ts_1.isNegativeLE)(x * zInv, P)) y = mod$1(-y);
      let s = mod$1((z2 - y) * D);
      if ((0, modular_ts_1.isNegativeLE)(s, P)) s = mod$1(-s);
      return (0, utils_ts_1.numberToBytesLE)(s, 32);
    }
    /** @deprecated use `toBytes` */
    toRawBytes() {
      return this.toBytes();
    }
    toHex() {
      return (0, utils_ts_1.bytesToHex)(this.toBytes());
    }
    toString() {
      return this.toHex();
    }
    /**
    * Compares two Ristretto points.
    * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
    */
    equals(other) {
      aristp(other);
      const { ex: X1, ey: Y1 } = this.ep;
      const { ex: X2, ey: Y2 } = other.ep;
      const mod$1 = Fp.create;
      const one = mod$1(X1 * Y2) === mod$1(Y1 * X2);
      const two = mod$1(Y1 * Y2) === mod$1(X1 * X2);
      return one || two;
    }
    add(other) {
      aristp(other);
      return new RistPoint2(this.ep.add(other.ep));
    }
    subtract(other) {
      aristp(other);
      return new RistPoint2(this.ep.subtract(other.ep));
    }
    multiply(scalar) {
      return new RistPoint2(this.ep.multiply(scalar));
    }
    multiplyUnsafe(scalar) {
      return new RistPoint2(this.ep.multiplyUnsafe(scalar));
    }
    double() {
      return new RistPoint2(this.ep.double());
    }
    negate() {
      return new RistPoint2(this.ep.negate());
    }
  };
  exports.RistrettoPoint = (() => {
    if (!RistPoint.BASE) RistPoint.BASE = new RistPoint(exports.ed25519.Point.BASE);
    if (!RistPoint.ZERO) RistPoint.ZERO = new RistPoint(exports.ed25519.Point.ZERO);
    return RistPoint;
  })();
  const hashToRistretto255 = (msg, options) => {
    const d = options.DST;
    const DST = typeof d === "string" ? (0, utils_js_1.utf8ToBytes)(d) : d;
    const uniform_bytes = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, DST, 64, sha2_js_1.sha512);
    const P = RistPoint.hashToCurve(uniform_bytes);
    return P;
  };
  exports.hashToRistretto255 = hashToRistretto255;
  exports.hash_to_ristretto255 = exports.hashToRistretto255;
} });
var require_ed25519 = __commonJS({ "../../node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/signing-schemes/ed25519/index.js"(exports) {
  var __importDefault$1 = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const ed25519_1$1 = require_ed25519$1();
  const utils_1$1 = require_utils$4();
  const assert_1$1 = __importDefault$1(require_assert());
  const Sha512_1$1 = __importDefault$1(require_Sha512());
  const ED_PREFIX = "ED";
  const ed25519 = {
    deriveKeypair(entropy) {
      const rawPrivateKey = Sha512_1$1.default.half(entropy);
      const privateKey = ED_PREFIX + (0, utils_1$1.bytesToHex)(rawPrivateKey);
      const publicKey = ED_PREFIX + (0, utils_1$1.bytesToHex)(ed25519_1$1.ed25519.getPublicKey(rawPrivateKey));
      return {
        privateKey,
        publicKey
      };
    },
    sign(message2, privateKey) {
      assert_1$1.default.ok(message2 instanceof Uint8Array, "message must be array of octets");
      assert_1$1.default.ok(privateKey.length === 66, "private key must be 33 bytes including prefix");
      return (0, utils_1$1.bytesToHex)(ed25519_1$1.ed25519.sign(message2, privateKey.slice(2)));
    },
    verify(message2, signature2, publicKey) {
      assert_1$1.default.ok(publicKey.length === 66, "public key must be 33 bytes including prefix");
      return ed25519_1$1.ed25519.verify(signature2, message2, publicKey.slice(2), { zip215: false });
    }
  };
  exports.default = ed25519;
} });
var require_dist = __commonJS({ "../../node_modules/.pnpm/ripple-keypairs@2.0.0_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/ripple-keypairs/dist/index.js"(exports) {
  var __importDefault = function(mod$1) {
    return mod$1 && mod$1.__esModule ? mod$1 : { "default": mod$1 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeSeed = exports.deriveNodeAddress = exports.deriveAddress = exports.verify = exports.sign = exports.deriveKeypair = exports.generateSeed = void 0;
  const ripple_address_codec_1 = require_dist$1();
  Object.defineProperty(exports, "decodeSeed", {
    enumerable: true,
    get: function() {
      return ripple_address_codec_1.decodeSeed;
    }
  });
  const ripemd160_1 = require_ripemd160();
  const sha256_1 = require_sha256();
  const utils_1 = require_utils$4();
  const utils_2 = require_utils();
  const Sha512_1 = __importDefault(require_Sha512());
  const assert_1 = __importDefault(require_assert());
  const getAlgorithmFromKey_1 = require_getAlgorithmFromKey();
  const secp256k1_1 = __importDefault(require_secp256k1());
  const ed25519_1 = __importDefault(require_ed25519());
  function getSigningScheme(algorithm) {
    const schemes = {
      "ecdsa-secp256k1": secp256k1_1.default,
      ed25519: ed25519_1.default
    };
    return schemes[algorithm];
  }
  function generateSeed(options = {}) {
    assert_1.default.ok(!options.entropy || options.entropy.length >= 16, "entropy too short");
    const entropy = options.entropy ? options.entropy.slice(0, 16) : (0, utils_1.randomBytes)(16);
    const type2 = options.algorithm === "ed25519" ? "ed25519" : "secp256k1";
    return (0, ripple_address_codec_1.encodeSeed)(entropy, type2);
  }
  exports.generateSeed = generateSeed;
  function deriveKeypair(seed, options) {
    var _a;
    const decoded = (0, ripple_address_codec_1.decodeSeed)(seed);
    const proposedAlgorithm = (_a = options === null || options === void 0 ? void 0 : options.algorithm) !== null && _a !== void 0 ? _a : decoded.type;
    const algorithm = proposedAlgorithm === "ed25519" ? "ed25519" : "ecdsa-secp256k1";
    const scheme = getSigningScheme(algorithm);
    const keypair = scheme.deriveKeypair(decoded.bytes, options);
    const messageToVerify = Sha512_1.default.half("This test message should verify.");
    const signature2 = scheme.sign(messageToVerify, keypair.privateKey);
    if (!scheme.verify(messageToVerify, signature2, keypair.publicKey)) throw new Error("derived keypair did not generate verifiable signature");
    return keypair;
  }
  exports.deriveKeypair = deriveKeypair;
  function sign2(messageHex, privateKey) {
    const algorithm = (0, getAlgorithmFromKey_1.getAlgorithmFromPrivateKey)(privateKey);
    return getSigningScheme(algorithm).sign((0, utils_1.hexToBytes)(messageHex), privateKey);
  }
  exports.sign = sign2;
  function verify(messageHex, signature2, publicKey) {
    const algorithm = (0, getAlgorithmFromKey_1.getAlgorithmFromPublicKey)(publicKey);
    return getSigningScheme(algorithm).verify((0, utils_1.hexToBytes)(messageHex), signature2, publicKey);
  }
  exports.verify = verify;
  function computePublicKeyHash(publicKeyBytes) {
    return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(publicKeyBytes));
  }
  function deriveAddressFromBytes(publicKeyBytes) {
    return (0, ripple_address_codec_1.encodeAccountID)(computePublicKeyHash(publicKeyBytes));
  }
  function deriveAddress(publicKey) {
    return deriveAddressFromBytes((0, utils_1.hexToBytes)(publicKey));
  }
  exports.deriveAddress = deriveAddress;
  function deriveNodeAddress(publicKey) {
    const generatorBytes = (0, ripple_address_codec_1.decodeNodePublic)(publicKey);
    const accountPublicBytes = (0, utils_2.accountPublicFromPublicGenerator)(generatorBytes);
    return deriveAddressFromBytes(accountPublicBytes);
  }
  exports.deriveNodeAddress = deriveNodeAddress;
} });
function implicitAddressFromPublicKey(publicKey) {
  const key_without_prefix = publicKey.replace(/^ed25519:/, "");
  return encode$2(bs58Decode(key_without_prefix));
}
function kwilNep413Signer(recipient) {
  return (keyPair) => async (messageBytes) => {
    const message2 = decode$1(messageBytes);
    const nonceLength = 32;
    const nonce = crypto.getRandomValues(new Uint8Array(nonceLength));
    const nep413BorschSchema = { struct: {
      message: "string",
      nonce: { array: {
        type: "u8",
        len: nonceLength
      } },
      recipient: "string",
      callbackUrl: { option: "string" }
    } };
    const tag = 2147484061;
    const { signature: signature2 } = keyPair.sign(hash(concat(serialize("u32", tag), serialize(nep413BorschSchema, {
      message: message2,
      nonce,
      recipient
    }))));
    const kwilNep413BorschSchema = { struct: {
      tag: "u32",
      ...nep413BorschSchema.struct
    } };
    const kwilNep413BorshParams = {
      tag,
      message: message2,
      nonce,
      recipient
    };
    const kwilNep413BorshPayload = serialize(kwilNep413BorschSchema, kwilNep413BorshParams);
    return concat(writeUint16BE(kwilNep413BorshPayload.length), kwilNep413BorshPayload, signature2);
  };
}
var import_dist = __toESM(require_dist());
function isNaclSignKeyPair(object) {
  return object !== null && typeof object === "object" && "publicKey" in object && object.publicKey instanceof Uint8Array && object.publicKey.length === nacl.sign.publicKeyLength && "secretKey" in object && object.secretKey instanceof Uint8Array && object.secretKey.length === nacl.sign.secretKeyLength;
}
function isNearKeyPair(object) {
  return object !== null && typeof object === "object" && "getPublicKey" in object && "sign" in object && typeof object.getPublicKey === "function" && typeof object.sign === "function";
}
function isStellarKeyPair(object) {
  return object !== null && typeof object === "object" && "publicKey" in object && "sign" in object && "canSign" in object && typeof object.publicKey === "function" && typeof object.sign === "function" && typeof object.canSign === "function";
}
function isXrplKeyPair(object) {
  return !!object && typeof object === "object" && "privateKey" in object && "publicKey" in object;
}
function createServerKwilSigner(signer) {
  if (isNaclSignKeyPair(signer)) return [new distExports.KwilSigner(async (msg) => nacl.sign.detached(msg, signer.secretKey), signer.publicKey, "ed25519"), implicitAddressFromPublicKey(bs58Encode(signer.publicKey))];
  if (isNearKeyPair(signer)) {
    const publicKey = implicitAddressFromPublicKey(signer.getPublicKey().toString());
    return [new distExports.KwilSigner(kwilNep413Signer("idos-issuer")(signer), publicKey, "nep413"), publicKey];
  }
  if (isStellarKeyPair(signer)) {
    const publicKeyString = signer.publicKey();
    const rawPublicKey = signer.rawPublicKey();
    return [new distExports.KwilSigner(async (msg) => signer.sign(Buffer.from(msg)), rawPublicKey, "ed25519"), publicKeyString];
  }
  if (isXrplKeyPair(signer)) return [new distExports.KwilSigner(async (msg) => decode(import_dist.sign(encode$2(msg), signer.privateKey)), signer.publicKey, "xrpl"), signer.publicKey];
  if ("address" in signer) return [new distExports.KwilSigner(signer, signer.address), signer.address];
  return ((_) => {
    throw new Error("Invalid `signer` type");
  })();
}
function isIssuerKey(issuer) {
  return typeof issuer === "object" && issuer !== null && "type" in issuer;
}
function isCustomIssuerType(issuer) {
  return typeof issuer === "object" && issuer !== null && "issuer" in issuer;
}
async function issuerToKey(issuer) {
  if (isIssuerKey(issuer)) return issuer;
  if (isCustomIssuerType(issuer)) return await Ed25519VerificationKey2020.from({
    id: `${issuer.issuer}/keys/1`,
    controller: `${issuer.issuer}/issuers/1`,
    publicKeyMultibase: issuer.publicKeyMultibase,
    type: "Ed25519VerificationKey2020"
  });
  return await Ed25519VerificationKey2020.from({
    ...issuer,
    type: "Ed25519VerificationKey2020"
  });
}
var __context$3 = {
  "id": "@id",
  "type": "@type",
  "@protected": true,
  "proof": {
    "@id": "https://w3id.org/security#proof",
    "@type": "@id",
    "@container": "@graph"
  },
  "Ed25519VerificationKey2020": {
    "@id": "https://w3id.org/security#Ed25519VerificationKey2020",
    "@context": {
      "@protected": true,
      "id": "@id",
      "type": "@type",
      "controller": {
        "@id": "https://w3id.org/security#controller",
        "@type": "@id"
      },
      "revoked": {
        "@id": "https://w3id.org/security#revoked",
        "@type": "http://www.w3.org/2001/XMLSchema#dateTime"
      },
      "publicKeyMultibase": {
        "@id": "https://w3id.org/security#publicKeyMultibase",
        "@type": "https://w3id.org/security#multibase"
      }
    }
  },
  "Ed25519Signature2020": {
    "@id": "https://w3id.org/security#Ed25519Signature2020",
    "@context": {
      "@protected": true,
      "id": "@id",
      "type": "@type",
      "challenge": "https://w3id.org/security#challenge",
      "created": {
        "@id": "http://purl.org/dc/terms/created",
        "@type": "http://www.w3.org/2001/XMLSchema#dateTime"
      },
      "domain": "https://w3id.org/security#domain",
      "expires": {
        "@id": "https://w3id.org/security#expiration",
        "@type": "http://www.w3.org/2001/XMLSchema#dateTime"
      },
      "nonce": "https://w3id.org/security#nonce",
      "proofPurpose": {
        "@id": "https://w3id.org/security#proofPurpose",
        "@type": "@vocab",
        "@context": {
          "@protected": true,
          "id": "@id",
          "type": "@type",
          "assertionMethod": {
            "@id": "https://w3id.org/security#assertionMethod",
            "@type": "@id",
            "@container": "@set"
          },
          "authentication": {
            "@id": "https://w3id.org/security#authenticationMethod",
            "@type": "@id",
            "@container": "@set"
          },
          "capabilityInvocation": {
            "@id": "https://w3id.org/security#capabilityInvocationMethod",
            "@type": "@id",
            "@container": "@set"
          },
          "capabilityDelegation": {
            "@id": "https://w3id.org/security#capabilityDelegationMethod",
            "@type": "@id",
            "@container": "@set"
          },
          "keyAgreement": {
            "@id": "https://w3id.org/security#keyAgreementMethod",
            "@type": "@id",
            "@container": "@set"
          }
        }
      },
      "proofValue": {
        "@id": "https://w3id.org/security#proofValue",
        "@type": "https://w3id.org/security#multibase"
      },
      "verificationMethod": {
        "@id": "https://w3id.org/security#verificationMethod",
        "@type": "@id"
      }
    }
  }
};
var ed25519_signature_2020_v1_default = { "@context": __context$3 };
var __context$2 = {
  "@version": 1.1,
  "@protected": true,
  "xsd": "http://www.w3.org/2001/XMLSchema#",
  "aux": "https://raw.githubusercontent.com/idos-network/idos-sdk-js/168f449a799620123bc7b01fc224423739500f94/packages/issuer-sdk-js/assets/country-codes.xml",
  "applicantId": "xsd:string",
  "firstName": "xsd:string",
  "familyName": "xsd:string",
  "maidenName": "xsd:string",
  "governmentId": "xsd:string",
  "governmentIdType": "xsd:string",
  "email": "xsd:string",
  "phoneNumber": "xsd:string",
  "dateOfBirth": "aux:date",
  "placeOfBirth": "xsd:string",
  "idDocumentCountry": "xsd:string",
  "idDocumentNumber": "xsd:string",
  "idDocumentType": "xsd:string",
  "idDocumentDateOfIssue": "aux:date",
  "idDocumentDateOfExpiry": "aux:date",
  "idDocumentFrontFile": "xsd:string",
  "idDocumentBackFile": "xsd:string",
  "selfieFile": "xsd:string",
  "residentialAddressStreet": "xsd:string",
  "residentialAddressHouseNumber": "xsd:string",
  "residentialAddressAdditionalAddressInfo": "xsd:string",
  "residentialAddressCity": "xsd:string",
  "residentialAddressPostalCode": "xsd:string",
  "residentialAddressCountry": "aux:ISO_3166-1_alpha-2",
  "residentialAddressProofCategory": "xsd:string",
  "residentialAddressProofDateOfIssue": "xsd:date",
  "residentialAddressProofFile": "xsd:string"
};
var idos_credential_subject_v1_default = { "@context": __context$2 };
var __context$1 = {
  "@version": 1.1,
  "@protected": true,
  "xsd": "http://www.w3.org/2001/XMLSchema#",
  "approvedAt": "xsd:date",
  "level": "xsd:string"
};
var idos_credentials_v1_default = { "@context": __context$1 };
var __context = {
  "@version": 1.1,
  "@protected": true,
  "id": "@id",
  "type": "@type",
  "VerifiableCredential": {
    "@id": "https://www.w3.org/2018/credentials#VerifiableCredential",
    "@context": {
      "@version": 1.1,
      "@protected": true,
      "id": "@id",
      "type": "@type",
      "cred": "https://www.w3.org/2018/credentials#",
      "sec": "https://w3id.org/security#",
      "xsd": "http://www.w3.org/2001/XMLSchema#",
      "credentialSchema": {
        "@id": "cred:credentialSchema",
        "@type": "@id",
        "@context": {
          "@version": 1.1,
          "@protected": true,
          "id": "@id",
          "type": "@type",
          "cred": "https://www.w3.org/2018/credentials#",
          "JsonSchemaValidator2018": "cred:JsonSchemaValidator2018"
        }
      },
      "credentialStatus": {
        "@id": "cred:credentialStatus",
        "@type": "@id"
      },
      "credentialSubject": {
        "@id": "cred:credentialSubject",
        "@type": "@id"
      },
      "evidence": {
        "@id": "cred:evidence",
        "@type": "@id"
      },
      "expirationDate": {
        "@id": "cred:expirationDate",
        "@type": "xsd:dateTime"
      },
      "holder": {
        "@id": "cred:holder",
        "@type": "@id"
      },
      "issued": {
        "@id": "cred:issued",
        "@type": "xsd:dateTime"
      },
      "issuer": {
        "@id": "cred:issuer",
        "@type": "@id"
      },
      "issuanceDate": {
        "@id": "cred:issuanceDate",
        "@type": "xsd:dateTime"
      },
      "proof": {
        "@id": "sec:proof",
        "@type": "@id",
        "@container": "@graph"
      },
      "refreshService": {
        "@id": "cred:refreshService",
        "@type": "@id",
        "@context": {
          "@version": 1.1,
          "@protected": true,
          "id": "@id",
          "type": "@type",
          "cred": "https://www.w3.org/2018/credentials#",
          "ManualRefreshService2018": "cred:ManualRefreshService2018"
        }
      },
      "termsOfUse": {
        "@id": "cred:termsOfUse",
        "@type": "@id"
      },
      "validFrom": {
        "@id": "cred:validFrom",
        "@type": "xsd:dateTime"
      },
      "validUntil": {
        "@id": "cred:validUntil",
        "@type": "xsd:dateTime"
      }
    }
  },
  "VerifiablePresentation": {
    "@id": "https://www.w3.org/2018/credentials#VerifiablePresentation",
    "@context": {
      "@version": 1.1,
      "@protected": true,
      "id": "@id",
      "type": "@type",
      "cred": "https://www.w3.org/2018/credentials#",
      "sec": "https://w3id.org/security#",
      "holder": {
        "@id": "cred:holder",
        "@type": "@id"
      },
      "proof": {
        "@id": "sec:proof",
        "@type": "@id",
        "@container": "@graph"
      },
      "verifiableCredential": {
        "@id": "cred:verifiableCredential",
        "@type": "@id",
        "@container": "@graph"
      }
    }
  },
  "EcdsaSecp256k1Signature2019": {
    "@id": "https://w3id.org/security#EcdsaSecp256k1Signature2019",
    "@context": {
      "@version": 1.1,
      "@protected": true,
      "id": "@id",
      "type": "@type",
      "sec": "https://w3id.org/security#",
      "xsd": "http://www.w3.org/2001/XMLSchema#",
      "challenge": "sec:challenge",
      "created": {
        "@id": "http://purl.org/dc/terms/created",
        "@type": "xsd:dateTime"
      },
      "domain": "sec:domain",
      "expires": {
        "@id": "sec:expiration",
        "@type": "xsd:dateTime"
      },
      "jws": "sec:jws",
      "nonce": "sec:nonce",
      "proofPurpose": {
        "@id": "sec:proofPurpose",
        "@type": "@vocab",
        "@context": {
          "@version": 1.1,
          "@protected": true,
          "id": "@id",
          "type": "@type",
          "sec": "https://w3id.org/security#",
          "assertionMethod": {
            "@id": "sec:assertionMethod",
            "@type": "@id",
            "@container": "@set"
          },
          "authentication": {
            "@id": "sec:authenticationMethod",
            "@type": "@id",
            "@container": "@set"
          }
        }
      },
      "proofValue": "sec:proofValue",
      "verificationMethod": {
        "@id": "sec:verificationMethod",
        "@type": "@id"
      }
    }
  },
  "EcdsaSecp256r1Signature2019": {
    "@id": "https://w3id.org/security#EcdsaSecp256r1Signature2019",
    "@context": {
      "@version": 1.1,
      "@protected": true,
      "id": "@id",
      "type": "@type",
      "sec": "https://w3id.org/security#",
      "xsd": "http://www.w3.org/2001/XMLSchema#",
      "challenge": "sec:challenge",
      "created": {
        "@id": "http://purl.org/dc/terms/created",
        "@type": "xsd:dateTime"
      },
      "domain": "sec:domain",
      "expires": {
        "@id": "sec:expiration",
        "@type": "xsd:dateTime"
      },
      "jws": "sec:jws",
      "nonce": "sec:nonce",
      "proofPurpose": {
        "@id": "sec:proofPurpose",
        "@type": "@vocab",
        "@context": {
          "@version": 1.1,
          "@protected": true,
          "id": "@id",
          "type": "@type",
          "sec": "https://w3id.org/security#",
          "assertionMethod": {
            "@id": "sec:assertionMethod",
            "@type": "@id",
            "@container": "@set"
          },
          "authentication": {
            "@id": "sec:authenticationMethod",
            "@type": "@id",
            "@container": "@set"
          }
        }
      },
      "proofValue": "sec:proofValue",
      "verificationMethod": {
        "@id": "sec:verificationMethod",
        "@type": "@id"
      }
    }
  },
  "Ed25519Signature2018": {
    "@id": "https://w3id.org/security#Ed25519Signature2018",
    "@context": {
      "@version": 1.1,
      "@protected": true,
      "id": "@id",
      "type": "@type",
      "sec": "https://w3id.org/security#",
      "xsd": "http://www.w3.org/2001/XMLSchema#",
      "challenge": "sec:challenge",
      "created": {
        "@id": "http://purl.org/dc/terms/created",
        "@type": "xsd:dateTime"
      },
      "domain": "sec:domain",
      "expires": {
        "@id": "sec:expiration",
        "@type": "xsd:dateTime"
      },
      "jws": "sec:jws",
      "nonce": "sec:nonce",
      "proofPurpose": {
        "@id": "sec:proofPurpose",
        "@type": "@vocab",
        "@context": {
          "@version": 1.1,
          "@protected": true,
          "id": "@id",
          "type": "@type",
          "sec": "https://w3id.org/security#",
          "assertionMethod": {
            "@id": "sec:assertionMethod",
            "@type": "@id",
            "@container": "@set"
          },
          "authentication": {
            "@id": "sec:authenticationMethod",
            "@type": "@id",
            "@container": "@set"
          }
        }
      },
      "proofValue": "sec:proofValue",
      "verificationMethod": {
        "@id": "sec:verificationMethod",
        "@type": "@id"
      }
    }
  },
  "RsaSignature2018": {
    "@id": "https://w3id.org/security#RsaSignature2018",
    "@context": {
      "@version": 1.1,
      "@protected": true,
      "challenge": "sec:challenge",
      "created": {
        "@id": "http://purl.org/dc/terms/created",
        "@type": "xsd:dateTime"
      },
      "domain": "sec:domain",
      "expires": {
        "@id": "sec:expiration",
        "@type": "xsd:dateTime"
      },
      "jws": "sec:jws",
      "nonce": "sec:nonce",
      "proofPurpose": {
        "@id": "sec:proofPurpose",
        "@type": "@vocab",
        "@context": {
          "@version": 1.1,
          "@protected": true,
          "id": "@id",
          "type": "@type",
          "sec": "https://w3id.org/security#",
          "assertionMethod": {
            "@id": "sec:assertionMethod",
            "@type": "@id",
            "@container": "@set"
          },
          "authentication": {
            "@id": "sec:authenticationMethod",
            "@type": "@id",
            "@container": "@set"
          }
        }
      },
      "proofValue": "sec:proofValue",
      "verificationMethod": {
        "@id": "sec:verificationMethod",
        "@type": "@id"
      }
    }
  },
  "proof": {
    "@id": "https://w3id.org/security#proof",
    "@type": "@id",
    "@container": "@graph"
  }
};
var v1_default = { "@context": __context };
const CONTEXT_V1 = "https://www.w3.org/2018/credentials/v1";
const CONTEXT_IDOS_CREDENTIALS_V1 = "https://raw.githubusercontent.com/idos-network/idos-sdk-js/346f14468348e4f3dd00039c89ce9bb49d88777c/packages/%40credentials/assets/idos-credentials-v1.json";
const CONTEXT_IDOS_CREDENTIALS_V1_SUBJECT = "https://raw.githubusercontent.com/idos-network/idos-sdk-js/346f14468348e4f3dd00039c89ce9bb49d88777c/packages/%40credentials/assets/idos-credential-subject-v1.json";
const CONTEXT_ED25519_SIGNATURE_2020_V1 = "https://w3id.org/security/suites/ed25519-2020/v1";
function buildDocumentLoader() {
  const loader2 = new JsonLdDocumentLoader();
  loader2.addStatic(CONTEXT_V1, v1_default);
  loader2.addStatic(CONTEXT_IDOS_CREDENTIALS_V1, idos_credentials_v1_default);
  loader2.addStatic(CONTEXT_IDOS_CREDENTIALS_V1_SUBJECT, idos_credential_subject_v1_default);
  loader2.addStatic(CONTEXT_ED25519_SIGNATURE_2020_V1, ed25519_signature_2020_v1_default);
  return loader2.build();
}
const defaultDocumentLoader = buildDocumentLoader();
async function verifyCredentials(credential, issuers, customDocumentLoader) {
  for (const issuer of issuers) {
    const publicKey = await issuerToKey(issuer);
    const vcVerifyingSuite = new Ed25519Signature2020({
      key: publicKey,
      verificationMethod: publicKey.id
    });
    const controller = {
      "@context": "https://w3id.org/security/v2",
      id: publicKey.controller,
      assertionMethod: [publicKey.id],
      authentication: [publicKey.id]
    };
    const verifyCredentialResult = await vc.verifyCredential({
      credential,
      suite: vcVerifyingSuite,
      controller,
      documentLoader: defaultDocumentLoader
    });
    if (verifyCredentialResult.verified) return true;
  }
  return false;
}
var idOSConsumer = class idOSConsumer2 {
  address;
  #kwilClient;
  #noncedBox;
  #signer;
  static async init({ recipientEncryptionPrivateKey, nodeUrl = "https://nodes.idos.network", chainId, consumerSigner }) {
    const kwilClient = await createNodeKwilClient({
      nodeUrl,
      chainId
    });
    const [signer, address] = createServerKwilSigner(consumerSigner);
    kwilClient.setSigner(signer);
    return new idOSConsumer2(NoncedBox.nonceFromBase64SecretKey(recipientEncryptionPrivateKey), kwilClient, address, signer);
  }
  constructor(noncedBox, kwilClient, address, signer) {
    this.#noncedBox = noncedBox;
    this.#kwilClient = kwilClient;
    this.address = address;
    this.#signer = signer;
  }
  get signer() {
    return this.#signer;
  }
  get encryptionPublicKey() {
    return encode(this.#noncedBox.keyPair.publicKey);
  }
  async getSharedCredentialFromIDOS(dataId) {
    return getSharedCredential$1(this.#kwilClient, dataId);
  }
  async getSharedCredentialContentDecrypted(dataId) {
    const credentialCopy = await this.getSharedCredentialFromIDOS(dataId);
    invariant(credentialCopy, `Credential with id ${dataId} not found`);
    return await this.#noncedBox.decrypt(credentialCopy.content, credentialCopy.encryptor_public_key);
  }
  async getGrantsCount(userId = null) {
    return getGrantsCount(this.#kwilClient, { user_id: userId });
  }
  async getAccessGrantsForCredential(credentialId) {
    const params = { credential_id: credentialId };
    const accessGrants = await getAccessGrantsForCredential(this.#kwilClient, params);
    return accessGrants[0];
  }
  async getCredentialsSharedByUser(userId) {
    const credentials = await getCredentialsSharedByUser(this.#kwilClient, userId);
    return credentials;
  }
  async getReusableCredentialCompliantly(credentialId) {
    const credential = await this.getSharedCredentialFromIDOS(credentialId);
    invariant(credential, `Credential with id ${credentialId} not found`);
    const accessGrant = await this.getAccessGrantsForCredential(credentialId);
    invariant(accessGrant, `Access grant with id ${credentialId} not found`);
    const credentialContent = await this.#noncedBox.decrypt(credential.content, credential.encryptor_public_key);
    const contentHash = hexEncodeSha256Hash(encode$1(credentialContent));
    if (contentHash !== accessGrant.content_hash) throw new Error("Credential content hash does not match the access grant hash");
    return credential;
  }
  async getAccessGrants(params) {
    return {
      grants: await getGrants(this.#kwilClient, params),
      totalCount: await this.getGrantsCount(params.user_id)
    };
  }
  async createAccessGrantByDag(params) {
    return createAccessGrantByDag(this.#kwilClient, params);
  }
  async getPassportingPeers() {
    return getPassportingPeers(this.#kwilClient);
  }
  async verifyCredentials(credentials, issuers) {
    return verifyCredentials(credentials, issuers);
  }
};
async function getSharedCredential(credentialId, inserterId) {
  const idOSConsumer$1 = await idOSConsumer.init({
    nodeUrl: COMMON_ENV.IDOS_NODE_URL,
    consumerSigner: nacl.sign.keyPair.fromSecretKey(
      Buffer.from(SERVER_ENV.IDOS_CONSUMER_SIGNER, "base64")
    ),
    recipientEncryptionPrivateKey: SERVER_ENV.IDOS_RECIPIENT_ENC_PRIVATE_KEY
  });
  const grant = await idOSConsumer$1.getAccessGrantsForCredential(credentialId);
  if (!grant) {
    throw new Error("Grant not found.");
  }
  if (inserterId && grant.inserter_id !== inserterId) {
    throw new Error(`Invalid inserter id: ${grant.inserter_id} !== ${inserterId}`);
  }
  const credentialContents = await idOSConsumer$1.getSharedCredentialContentDecrypted(credentialId);
  const data2 = JSON.parse(credentialContents);
  const verificationResult = await idOSConsumer$1.verifyCredentials(data2, [
    {
      issuer: SERVER_ENV.KRAKEN_ISSUER,
      publicKeyMultibase: SERVER_ENV.KRAKEN_PUBLIC_KEY_MULTIBASE
    }
  ]);
  if (!verificationResult) {
    throw new Error("Invalid credential signature.");
  }
  return data2;
}
async function loader$9({
  request
}) {
  const url = new URL(request.url);
  const token = url.searchParams.get("token");
  if (!token) {
    throw new Error("Token query parameter is required");
  }
  try {
    const decoded = await verifyFileUrl(token);
    const credentials = await getSharedCredential(decoded.credentialId);
    const encodedFile = credentials.credentialSubject[decoded.fileType];
    const instance = new ascii85.default.Ascii85();
    const file = instance.decode(encodedFile);
    if (!file) {
      throw new Error("File not found");
    }
    const typeFromBuffer = await fileTypeFromBuffer(file);
    const mimeType = typeFromBuffer?.mime ?? "application/pdf";
    return new Response(file, {
      headers: {
        "Content-Type": mimeType,
        "Content-Length": file.length.toString()
      }
    });
  } catch (error) {
    return Response.json({
      error: error.message,
      status: 400
    });
  }
}
const route3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  loader: loader$9
}, Symbol.toStringTag, { value: "Module" }));
const noah = UNSAFE_withComponentProps(function Callback() {
  useEffect(() => {
    window.parent?.postMessage({
      type: "noah-done"
    }, "*");
  }, []);
  return /* @__PURE__ */ jsx("div", {
    children: "Loading..."
  });
});
const route4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: noah
}, Symbol.toStringTag, { value: "Module" }));
const tos = UNSAFE_withComponentProps(function Callback2() {
  const [searchParams] = useSearchParams();
  useEffect(() => {
    window.parent?.postMessage({
      type: "hifi-tos-done",
      signedAgreementId: searchParams.get("signedAgreementId")
    }, "*");
  }, []);
  return /* @__PURE__ */ jsx("div", {
    children: "Processing TOS..."
  });
});
const route5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: tos
}, Symbol.toStringTag, { value: "Module" }));
const userContext = unstable_createContext();
const authMiddleware = async ({ context, request }, next) => {
  const session = await sessionStorage.getSession(request.headers.get("cookie"));
  const user = session.get("user");
  if (!user || !user.isAuthenticated) {
    throw await redirect("/");
  }
  context.set(userContext, user);
  await next();
};
const unstable_middleware = [authMiddleware];
async function loader$8({
  context
}) {
  const user = context.get(userContext);
  return {
    user
  };
}
const useUser = () => {
  const data2 = useRouteLoaderData("layouts/app");
  if (!data2) {
    throw new Error("useUser must be used inside a route which is a child of app/layout");
  }
  return data2.user;
};
const app$1 = UNSAFE_withComponentProps(function Home2() {
  return /* @__PURE__ */ jsx(Outlet, {});
});
const route6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: app$1,
  loader: loader$8,
  unstable_middleware,
  useUser
}, Symbol.toStringTag, { value: "Module" }));
const app = UNSAFE_withComponentProps(function App2() {
  const {
    address
  } = useUser();
  const {
    signOut
  } = useSiwe();
  const {
    send
  } = MachineContext.useActorRef();
  const state = MachineContext.useSelector((state2) => state2.value);
  const provider = MachineContext.useSelector((state2) => state2.context.provider);
  const kycUrl = MachineContext.useSelector((state2) => state2.context.kycUrl);
  const sharableToken = MachineContext.useSelector((state2) => state2.context.sharableToken);
  MachineContext.useSelector((state2) => state2.context.data);
  const noahUrl = MachineContext.useSelector((state2) => state2.context.noahUrl);
  const errorMessage = MachineContext.useSelector((state2) => state2.context.errorMessage);
  const hifiTosUrl = MachineContext.useSelector((state2) => state2.context.hifiTosUrl);
  const onRampAccount = MachineContext.useSelector((state2) => state2.context.onRampAccount);
  const transak = useRef(null);
  console.log("-> state", state);
  const messageReceiver = useCallback((message2) => {
    if (message2.origin.replace(/\/$/, "") === COMMON_ENV.KRAKEN_API_URL.replace(/\/$/, "")) {
      if (message2.data.error) {
        console.error(message2.data.error);
      } else if (message2.data.open) {
        window.open(message2.data.open, message2.data.target, message2.data.features);
      } else {
        send({
          type: "kycCompleted"
        });
      }
    }
    if (message2.data.type === "noah-done") {
      send({
        type: "revokeAccessGrant"
      });
    }
    if (message2.data.type === "hifi-tos-done") {
      send({
        type: "acceptHifiTos",
        signedAgreementId: message2.data.signedAgreementId
      });
    }
  }, []);
  useEffect(() => {
    window.addEventListener("message", messageReceiver);
    return () => window.removeEventListener("message", messageReceiver);
  }, []);
  useEffect(() => {
    if (!provider || state !== "accessGranted") return;
    if (provider === "transak") {
      send({
        type: "getSharableToken"
      });
    }
    if (provider === "noah") {
      send({
        type: "createNoahCustomer"
      });
    }
    if (provider === "hifi") {
      send({
        type: "startHifi"
      });
    }
  }, [state, provider, send]);
  useEffect(() => {
    if (state !== "dataOrTokenFetched" || !provider) return;
    if (provider === "transak" && !transak.current && sharableToken) {
      transak.current = new Transak({
        apiKey: "479983ae-3b37-4ac0-84f2-f42873b1a638",
        // (Required)
        // @ts-ignore - Transak SDK is not typed correctly
        environment: "STAGING",
        // (Required),
        kycShareTokenProvider: "SUMSUB",
        kycShareToken: sharableToken
      });
      transak.current.init();
      Transak.on(Transak.EVENTS.TRANSAK_WIDGET_CLOSE, (orderData) => {
        console.log(orderData);
        transak.current?.close();
        send({
          type: "revokeAccessGrant"
        });
        transak.current = null;
      });
    }
  }, [sharableToken, state, provider, send]);
  const start = async (provider2) => {
    send({
      type: "configure",
      provider: provider2,
      address
    });
  };
  let body = /* @__PURE__ */ jsx("div", {
    children: "Loading..."
  });
  if (state === "notConfigured") {
    body = /* @__PURE__ */ jsxs("div", {
      className: "m-auto flex w-full max-w-md flex-col gap-4",
      children: [/* @__PURE__ */ jsx("button", {
        type: "button",
        className: "w-full cursor-pointer rounded-lg bg-blue-600 px-6 py-3 font-semibold text-lg text-white transition-colors hover:bg-blue-700",
        onClick: () => start("transak"),
        children: "Transak"
      }), /* @__PURE__ */ jsx("button", {
        type: "button",
        className: "w-full cursor-pointer rounded-lg bg-green-600 px-6 py-3 font-semibold text-lg text-white transition-colors hover:bg-green-700",
        onClick: () => start("noah"),
        children: "Noah"
      }), /* @__PURE__ */ jsx("button", {
        type: "button",
        className: "w-full cursor-pointer rounded-lg bg-sky-600 px-6 py-3 font-semibold text-lg text-white transition-colors hover:bg-sky-700",
        onClick: () => start("hifi"),
        children: "Hifi"
      }), /* @__PURE__ */ jsx("button", {
        type: "button",
        className: "w-full cursor-pointer rounded-lg bg-purple-600 px-6 py-3 font-semibold text-lg text-white transition-colors hover:bg-purple-700",
        onClick: () => console.log("Custom selected"),
        children: "Custom"
      })]
    });
  }
  if (state === "waitForKYC" && kycUrl) {
    body = /* @__PURE__ */ jsx("div", {
      className: "w-full",
      children: /* @__PURE__ */ jsx("iframe", {
        src: kycUrl,
        width: "100%",
        height: "800px",
        title: "KYC",
        sandbox: "allow-popups allow-forms allow-scripts allow-same-origin",
        allow: "camera; microphone; geolocation; clipboard-write"
      })
    });
  }
  const messages = {
    findCredential: "Finding credential...",
    requestAccessGrant: "Requesting access grant...",
    waitForCredential: "Waiting for finding credential next attempt...",
    waitForHifiKycStatus: "Waiting for KYC status next attempt...",
    verifyHifiTos: "Verifying and creating a KYC for you...",
    login: "Logging in...",
    error: "Error"
  };
  if (messages[state]) {
    body = /* @__PURE__ */ jsxs("div", {
      className: "mb-4 w-full text-center",
      children: [/* @__PURE__ */ jsx("p", {
        children: messages[state]
      }), errorMessage && /* @__PURE__ */ jsx("p", {
        className: "text-red-500",
        children: errorMessage
      })]
    });
  }
  if (state === "dataOrTokenFetched" && noahUrl && provider === "noah") {
    body = /* @__PURE__ */ jsx("div", {
      className: "w-full",
      children: /* @__PURE__ */ jsx("iframe", {
        src: noahUrl,
        width: "100%",
        height: "800px",
        title: "KYC"
      })
    });
  }
  if (state === "hifiTosFetched" && hifiTosUrl && provider === "hifi") {
    body = /* @__PURE__ */ jsx("div", {
      className: "w-full",
      children: /* @__PURE__ */ jsx("iframe", {
        src: hifiTosUrl,
        width: "100%",
        height: "800px",
        title: "KYC"
      })
    });
  }
  if (state === "dataOrTokenFetched" && provider === "hifi") {
    body = /* @__PURE__ */ jsxs("div", {
      className: "w-full text-center",
      children: [/* @__PURE__ */ jsx("p", {
        children: "KYC completed, you can do a transaction now"
      }), /* @__PURE__ */ jsx("pre", {
        children: JSON.stringify(onRampAccount, null, 2)
      }), /* @__PURE__ */ jsx("button", {
        type: "button",
        onClick: () => send({
          type: "revokeAccessGrant"
        }),
        className: "mt-10 cursor-pointer rounded-lg bg-blue-600 px-4 py-2 font-semibold text-white transition-colors hover:bg-blue-700",
        children: "Continue by revoking an access grant"
      })]
    });
  }
  return /* @__PURE__ */ jsxs("div", {
    className: "flex flex-col items-center gap-8 p-8",
    children: [/* @__PURE__ */ jsx("h1", {
      className: "font-bold text-3xl text-gray-800",
      children: "Choose your provider"
    }), /* @__PURE__ */ jsxs("div", {
      className: "flex items-center gap-4",
      children: [/* @__PURE__ */ jsxs("p", {
        className: "text-gray-600 dark:text-gray-300",
        children: ["You are logged in as ", address]
      }), /* @__PURE__ */ jsx("button", {
        type: "button",
        onClick: signOut,
        className: "cursor-pointer rounded-lg bg-red-600 px-4 py-2 font-semibold text-white transition-colors hover:bg-red-700",
        children: "Logout"
      })]
    }), /* @__PURE__ */ jsxs("div", {
      className: "w-full",
      children: [body, /* @__PURE__ */ jsx("div", {
        id: "idOS-enclave",
        className: provider ? "block w-fit m-auto" : "hidden"
      })]
    })]
  });
});
const route7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: app
}, Symbol.toStringTag, { value: "Module" }));
const fetchSharedToken = async (applicantId) => {
  const response = await fetch(
    `${SERVER_ENV.KRAKEN_API_URL}/public/kyc/${applicantId}/sharedToken?forClientId=transak`,
    {
      method: "GET",
      headers: {
        Authorization: `Bearer ${await getKrakenToken()}`
      },
      // @ts-ignore - Node.js specific option
      agent: new https.Agent({
        rejectUnauthorized: false,
        checkServerIdentity: () => void 0
        // This will bypass the certificate chain verification
      })
    }
  );
  if (!response.ok) {
    throw new Error(`Failed to fetch shared token (${response.statusText}).`);
  }
  const data2 = await response.json();
  return data2.token;
};
const generateKrakenUrl = async () => {
  const payload = {
    clientId: SERVER_ENV.KRAKEN_CLIENT_ID,
    kyc: true,
    level: COMMON_ENV.KRAKEN_LEVEL,
    state: Date.now().toString()
  };
  const token = jwt.sign(payload, SERVER_ENV.KRAKEN_PRIVATE_KEY, { algorithm: "ES512" });
  return `${SERVER_ENV.KRAKEN_API_URL}/kyc?token=${token}`;
};
async function getKrakenToken() {
  const payload = {
    api: true,
    clientId: SERVER_ENV.KRAKEN_CLIENT_ID
  };
  return jwt.sign(payload, SERVER_ENV.KRAKEN_PRIVATE_KEY, {
    algorithm: "ES512",
    expiresIn: "600s"
  });
}
async function loader$7({
  request,
  context
}) {
  const url = new URL(request.url);
  const credentialId = url.searchParams.get("credentialId");
  const user = context.get(userContext);
  if (!credentialId || !user) {
    return Response.json({
      error: "credentialId or user is required"
    }, {
      status: 400
    });
  }
  try {
    const data2 = await getSharedCredential(credentialId, user.address);
    if (!data2.credentialSubject.applicantId) {
      throw new Error("Credentials are from previous version and can't be used.");
    }
    const token = await fetchSharedToken(data2.credentialSubject.applicantId);
    return Response.json({
      token
    });
  } catch (error) {
    return Response.json({
      error: error.message
    }, {
      status: 400
    });
  }
}
const route8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  loader: loader$7
}, Symbol.toStringTag, { value: "Module" }));
async function loader$6({
  request,
  context
}) {
  const url = new URL(request.url);
  const credentialId = url.searchParams.get("credentialId");
  const user = context.get(userContext);
  if (!credentialId || !user) {
    return Response.json({
      error: "credentialId or user is required"
    }, {
      status: 400
    });
  }
  try {
    const data2 = await getSharedCredential(credentialId, user.address);
    return Response.json(data2);
  } catch (error) {
    return Response.json({
      error: error.message
    }, {
      status: 400
    });
  }
}
const route9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  loader: loader$6
}, Symbol.toStringTag, { value: "Module" }));
async function loader$5() {
  const url = await generateKrakenUrl();
  return Response.json({
    url
  });
}
const route10 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  loader: loader$5
}, Symbol.toStringTag, { value: "Module" }));
function formatDate(dateString) {
  if (!dateString) return void 0;
  const date = new Date(dateString);
  return date.toISOString().split("T")[0];
}
async function createNoahCustomer(address, credentials, url) {
  const cs = credentials.credentialSubject;
  const documentTypeMapper = {
    PASSPORT: "Passport",
    DRIVERS: "DrivingLicense",
    ID_CARD: "NationalIDCard"
  };
  const customer = {
    Type: "Individual",
    FullName: {
      FirstName: cs.firstName,
      LastName: cs.familyName,
      MiddleName: cs.maidenName
    },
    DateOfBirth: formatDate(cs.dateOfBirth),
    Email: cs.email,
    PhoneNumber: cs.phoneNumber,
    Identities: [
      {
        IssuingCountry: cs.idDocumentCountry,
        IDNumber: cs.idDocumentNumber,
        IssuedDate: formatDate(cs.idDocumentDateOfIssue),
        ExpiryDate: formatDate(cs.idDocumentDateOfExpiry),
        IDType: documentTypeMapper[cs.idDocumentType] ?? "Passport"
      }
    ],
    PrimaryResidence: {
      // biome-ignore lint/style/noNonNullAssertion: We know that the address is present
      Street: cs.residentialAddressStreet,
      // biome-ignore lint/style/noNonNullAssertion: We know that the address is present
      City: cs.residentialAddressCity,
      // biome-ignore lint/style/noNonNullAssertion: We know that the address is present
      PostCode: cs.residentialAddressPostalCode,
      // biome-ignore lint/style/noNonNullAssertion: We know that the address is present
      State: cs.residentialAddressCountry,
      // biome-ignore lint/style/noNonNullAssertion: We know that the address is present
      Country: cs.residentialAddressCountry
    }
  };
  const returnUrl = new URL(url.toString());
  returnUrl.protocol = "https";
  returnUrl.pathname = "/callbacks/noah";
  returnUrl.search = "";
  returnUrl.hash = "";
  const subject = {
    Customer: customer,
    PaymentMethodCategory: "Card",
    FiatCurrency: "USD",
    CryptoCurrency: "BTC_TEST",
    FiatAmount: "100",
    ReturnURL: returnUrl.toString(),
    ExternalID: crypto.randomUUID(),
    CustomerID: address,
    Nonce: crypto.randomUUID(),
    LineItems: [
      {
        Description: "Book #1",
        Quantity: "1",
        UnitAmount: "50",
        TotalAmount: "50"
      },
      {
        Description: "Book #2",
        Quantity: "10",
        UnitAmount: "5",
        TotalAmount: "50"
      }
    ]
  };
  const response = await fetch(`${SERVER_ENV.NOAH_API_URL}v1/checkout/payin/fiat`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-Api-Key": SERVER_ENV.NOAH_API_KEY
    },
    body: JSON.stringify(subject)
  });
  if (!response.ok) {
    throw new Error("Failed to create Noah customer");
  }
  const data2 = await response.json();
  return data2;
}
async function loader$4({
  request
}) {
  const url = new URL(request.url);
  const credentialId = url.searchParams.get("credentialId");
  const session = await sessionStorage.getSession(request.headers.get("Cookie"));
  const user = session.get("user");
  if (!credentialId || !user) {
    return Response.json({
      error: "credentialId or user is required"
    }, {
      status: 400
    });
  }
  try {
    const data2 = await getSharedCredential(credentialId, user.address);
    const response = await createNoahCustomer(user.address, data2, url);
    session.set("noahCheckoutSessionID", response.CheckoutSession.CheckoutSessionID);
    return Response.json({
      url: response.HostedURL,
      currentUrl: url.toString()
    }, {
      headers: {
        "Set-Cookie": await sessionStorage.commitSession(session)
      }
    });
  } catch (error) {
    return Response.json({
      error: error.message
    }, {
      status: 400
    });
  }
}
const route11 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  loader: loader$4
}, Symbol.toStringTag, { value: "Module" }));
const AD = "AND";
const AE = "ARE";
const AF = "AFG";
const AG = "ATG";
const AI = "AIA";
const AL = "ALB";
const AM = "ARM";
const AO = "AGO";
const AQ = "ATA";
const AR = "ARG";
const AS = "ASM";
const AT = "AUT";
const AU = "AUS";
const AW = "ABW";
const AX = "ALA";
const AZ = "AZE";
const BA = "BIH";
const BB = "BRB";
const BD = "BGD";
const BE = "BEL";
const BF = "BFA";
const BG = "BGR";
const BH = "BHR";
const BI = "BDI";
const BJ = "BEN";
const BL = "BLM";
const BM = "BMU";
const BN = "BRN";
const BO = "BOL";
const BQ = "BES";
const BR = "BRA";
const BS = "BHS";
const BT = "BTN";
const BV = "BVT";
const BW = "BWA";
const BY = "BLR";
const BZ = "BLZ";
const CA = "CAN";
const CC = "CCK";
const CD = "COD";
const CF = "CAF";
const CG = "COG";
const CH = "CHE";
const CI = "CIV";
const CK = "COK";
const CL = "CHL";
const CM = "CMR";
const CN = "CHN";
const CO = "COL";
const CR = "CRI";
const CU = "CUB";
const CV = "CPV";
const CW = "CUW";
const CX = "CXR";
const CY = "CYP";
const CZ = "CZE";
const DE = "DEU";
const DJ = "DJI";
const DK = "DNK";
const DM = "DMA";
const DO = "DOM";
const DZ = "DZA";
const EC = "ECU";
const EE = "EST";
const EG = "EGY";
const EH = "ESH";
const ER = "ERI";
const ES = "ESP";
const ET = "ETH";
const FI = "FIN";
const FJ = "FJI";
const FK = "FLK";
const FM = "FSM";
const FO = "FRO";
const FR = "FRA";
const GA = "GAB";
const GB = "GBR";
const GD = "GRD";
const GE = "GEO";
const GF = "GUF";
const GG = "GGY";
const GH = "GHA";
const GI = "GIB";
const GL = "GRL";
const GM = "GMB";
const GN = "GIN";
const GP = "GLP";
const GQ = "GNQ";
const GR = "GRC";
const GS = "SGS";
const GT = "GTM";
const GU = "GUM";
const GW = "GNB";
const GY = "GUY";
const HK = "HKG";
const HM = "HMD";
const HN = "HND";
const HR = "HRV";
const HT = "HTI";
const HU = "HUN";
const ID = "IDN";
const IE = "IRL";
const IL = "ISR";
const IM = "IMN";
const IN = "IND";
const IO = "IOT";
const IQ = "IRQ";
const IR = "IRN";
const IS = "ISL";
const IT = "ITA";
const JE = "JEY";
const JM = "JAM";
const JO = "JOR";
const JP = "JPN";
const KE = "KEN";
const KG = "KGZ";
const KH = "KHM";
const KI = "KIR";
const KM = "COM";
const KN = "KNA";
const KP = "PRK";
const KR = "KOR";
const KW = "KWT";
const KY = "CYM";
const KZ = "KAZ";
const LA = "LAO";
const LB = "LBN";
const LC = "LCA";
const LI = "LIE";
const LK = "LKA";
const LR = "LBR";
const LS = "LSO";
const LT = "LTU";
const LU = "LUX";
const LV = "LVA";
const LY = "LBY";
const MA = "MAR";
const MC = "MCO";
const MD = "MDA";
const ME = "MNE";
const MF = "MAF";
const MG = "MDG";
const MH = "MHL";
const MK = "MKD";
const ML = "MLI";
const MM = "MMR";
const MN = "MNG";
const MO = "MAC";
const MP = "MNP";
const MQ = "MTQ";
const MR = "MRT";
const MS = "MSR";
const MT = "MLT";
const MU = "MUS";
const MV = "MDV";
const MW = "MWI";
const MX = "MEX";
const MY = "MYS";
const MZ = "MOZ";
const NA = "NAM";
const NC = "NCL";
const NE = "NER";
const NF = "NFK";
const NG = "NGA";
const NI = "NIC";
const NL = "NLD";
const NO = "NOR";
const NP = "NPL";
const NR = "NRU";
const NU = "NIU";
const NZ = "NZL";
const OM = "OMN";
const PA = "PAN";
const PE = "PER";
const PF = "PYF";
const PG = "PNG";
const PH = "PHL";
const PK = "PAK";
const PL = "POL";
const PM = "SPM";
const PN = "PCN";
const PR = "PRI";
const PS = "PSE";
const PT = "PRT";
const PW = "PLW";
const PY = "PRY";
const QA = "QAT";
const RE = "REU";
const RO = "ROU";
const RS = "SRB";
const RU = "RUS";
const RW = "RWA";
const SA = "SAU";
const SB = "SLB";
const SC = "SYC";
const SD = "SDN";
const SE = "SWE";
const SG = "SGP";
const SH = "SHN";
const SI = "SVN";
const SJ = "SJM";
const SK = "SVK";
const SL = "SLE";
const SM = "SMR";
const SN = "SEN";
const SO = "SOM";
const SR = "SUR";
const SS = "SSD";
const ST = "STP";
const SV = "SLV";
const SX = "SXM";
const SY = "SYR";
const SZ = "SWZ";
const TC = "TCA";
const TD = "TCD";
const TF = "ATF";
const TG = "TGO";
const TH = "THA";
const TJ = "TJK";
const TK = "TKL";
const TL = "TLS";
const TM = "TKM";
const TN = "TUN";
const TO = "TON";
const TR = "TUR";
const TT = "TTO";
const TV = "TUV";
const TW = "TWN";
const TZ = "TZA";
const UA = "UKR";
const UG = "UGA";
const UM = "UMI";
const US = "USA";
const UY = "URY";
const UZ = "UZB";
const VA = "VAT";
const VC = "VCT";
const VE = "VEN";
const VG = "VGB";
const VI = "VIR";
const VN = "VNM";
const VU = "VUT";
const WF = "WLF";
const WS = "WSM";
const XK = "XKX";
const YE = "YEM";
const YT = "MYT";
const ZA = "ZAF";
const ZM = "ZMB";
const ZW = "ZWE";
const countries2to3 = {
  AD,
  AE,
  AF,
  AG,
  AI,
  AL,
  AM,
  AO,
  AQ,
  AR,
  AS,
  AT,
  AU,
  AW,
  AX,
  AZ,
  BA,
  BB,
  BD,
  BE,
  BF,
  BG,
  BH,
  BI,
  BJ,
  BL,
  BM,
  BN,
  BO,
  BQ,
  BR,
  BS,
  BT,
  BV,
  BW,
  BY,
  BZ,
  CA,
  CC,
  CD,
  CF,
  CG,
  CH,
  CI,
  CK,
  CL,
  CM,
  CN,
  CO,
  CR,
  CU,
  CV,
  CW,
  CX,
  CY,
  CZ,
  DE,
  DJ,
  DK,
  DM,
  DO,
  DZ,
  EC,
  EE,
  EG,
  EH,
  ER,
  ES,
  ET,
  FI,
  FJ,
  FK,
  FM,
  FO,
  FR,
  GA,
  GB,
  GD,
  GE,
  GF,
  GG,
  GH,
  GI,
  GL,
  GM,
  GN,
  GP,
  GQ,
  GR,
  GS,
  GT,
  GU,
  GW,
  GY,
  HK,
  HM,
  HN,
  HR,
  HT,
  HU,
  ID,
  IE,
  IL,
  IM,
  IN,
  IO,
  IQ,
  IR,
  IS,
  IT,
  JE,
  JM,
  JO,
  JP,
  KE,
  KG,
  KH,
  KI,
  KM,
  KN,
  KP,
  KR,
  KW,
  KY,
  KZ,
  LA,
  LB,
  LC,
  LI,
  LK,
  LR,
  LS,
  LT,
  LU,
  LV,
  LY,
  MA,
  MC,
  MD,
  ME,
  MF,
  MG,
  MH,
  MK,
  ML,
  MM,
  MN,
  MO,
  MP,
  MQ,
  MR,
  MS,
  MT,
  MU,
  MV,
  MW,
  MX,
  MY,
  MZ,
  NA,
  NC,
  NE,
  NF,
  NG,
  NI,
  NL,
  NO,
  NP,
  NR,
  NU,
  NZ,
  OM,
  PA,
  PE,
  PF,
  PG,
  PH,
  PK,
  PL,
  PM,
  PN,
  PR,
  PS,
  PT,
  PW,
  PY,
  QA,
  RE,
  RO,
  RS,
  RU,
  RW,
  SA,
  SB,
  SC,
  SD,
  SE,
  SG,
  SH,
  SI,
  SJ,
  SK,
  SL,
  SM,
  SN,
  SO,
  SR,
  SS,
  ST,
  SV,
  SX,
  SY,
  SZ,
  TC,
  TD,
  TF,
  TG,
  TH,
  TJ,
  TK,
  TL,
  TM,
  TN,
  TO,
  TR,
  TT,
  TV,
  TW,
  TZ,
  UA,
  UG,
  UM,
  US,
  UY,
  UZ,
  VA,
  VC,
  VE,
  VG,
  VI,
  VN,
  VU,
  WF,
  WS,
  XK,
  YE,
  YT,
  ZA,
  ZM,
  ZW
};
async function getISORegionCodeFromNominatim(address) {
  const encoded = encodeURIComponent(address);
  const url = `https://nominatim.openstreetmap.org/search?q=${encoded}&format=json&addressdetails=1`;
  const res = await fetch(url, {
    headers: {
      "User-Agent": "Foxy-Demo/1.0 (jan@idos.network)"
    }
  });
  if (!res.ok) {
    throw new Error(`Open street map no results for '${address}'`);
  }
  const data2 = await res.json();
  if (!data2 || data2.length === 0) {
    throw new Error(`Open street map no results for '${address}'`);
  }
  const result = data2.map((x) => x.address["ISO3166-2-lvl4"]?.split("-")[1] ?? "").filter((x) => x.length > 0);
  if (result.length === 0) {
    throw new Error(`Open street map no ISO3166-2-lvl6 for '${address}'`);
  }
  return result[0];
}
const getKycStatus = async (hifiUserId) => {
  const response = await fetch(`${SERVER_ENV.HIFI_API_URL}v2/users/${hifiUserId}/kyc/status`, {
    method: "GET",
    headers: {
      Authorization: `Bearer ${SERVER_ENV.HIFI_API_KEY}`
    }
  });
  if (!response.ok) {
    const error = await response.json();
    console.log("-> error", JSON.stringify(error, null, 2));
    throw new Error(`Can't get KYC status in HIFI because: ${error.message}`);
  }
  const data2 = await response.json();
  return data2.USD_EURO;
};
const fetchTosLink = async (url) => {
  const returnUrl = new URL(url.toString());
  returnUrl.protocol = "https";
  returnUrl.pathname = "/callbacks/hifi/tos";
  returnUrl.search = "";
  returnUrl.hash = "";
  const idempotencyKey = crypto.randomUUID();
  const response = await fetch(`${SERVER_ENV.HIFI_API_URL}v2/tos-link`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${SERVER_ENV.HIFI_API_KEY}`
    },
    body: JSON.stringify({
      idempotencyKey,
      templateId: "2fb2da24-472a-4e5b-b160-038d9dc82a40",
      // HIFI default template
      redirectUrl: returnUrl.toString()
    })
  });
  const data2 = await response.json();
  return {
    url: data2.url,
    idempotencyKey
  };
};
const createUserAndKYC = async (signedAgreementId, credentialId, data2, url) => {
  const stateProvinceRegion = await getISORegionCodeFromNominatim(
    [
      [
        data2.credentialSubject.residentialAddressStreet,
        data2.credentialSubject.residentialAddressHouseNumber
      ].filter((x) => x).join(" "),
      data2.credentialSubject.residentialAddressCity,
      data2.credentialSubject.residentialAddressPostalCode,
      data2.credentialSubject.residentialAddressCountry,
      data2.credentialSubject.residentialAddressAdditionalAddressInfo
    ].filter((x) => x).join(", ")
  );
  const user = {
    type: "individual",
    firstName: data2.credentialSubject.firstName,
    lastName: data2.credentialSubject.familyName,
    email: data2.credentialSubject.email,
    dateOfBirth: data2.credentialSubject.dateOfBirth.split("T")[0],
    address: {
      // biome-ignore lint/style/noNonNullAssertion: <explanation>
      addressLine1: data2.credentialSubject.residentialAddressStreet,
      addressLine2: data2.credentialSubject.residentialAddressHouseNumber ?? "",
      // biome-ignore lint/style/noNonNullAssertion: <explanation>
      city: data2.credentialSubject.residentialAddressCity,
      // biome-ignore lint/style/noNonNullAssertion: <explanation>
      postalCode: data2.credentialSubject.residentialAddressPostalCode,
      stateProvinceRegion: stateProvinceRegion.slice(0, 2),
      country: countries2to3[
        // biome-ignore lint/style/noNonNullAssertion: <explanation>
        data2.credentialSubject.residentialAddressCountry
      ]
    },
    signedAgreementId
  };
  const createUserResponse = await fetch(`${SERVER_ENV.HIFI_API_URL}v2/users`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${SERVER_ENV.HIFI_API_KEY}`
    },
    body: JSON.stringify(user)
  });
  if (!createUserResponse.ok) {
    const error = await createUserResponse.json();
    console.log("-> error", JSON.stringify(error, null, 2));
    throw new Error(`Can't create an user in HIFI because: ${error.message}`);
  }
  const createUserResponseJson = await createUserResponse.json();
  const userId = createUserResponseJson.id;
  const updateKYCRequest = {
    ...user,
    // @ts-expect-error Missing types
    signedAgreementId: void 0,
    phone: data2.credentialSubject.phoneNumber ?? "+420606707808",
    // TODO: Get this from the data
    taxIdentificationNumber: "123456789",
    govIdType: data2.credentialSubject.idDocumentType.toUpperCase(),
    govIdNumber: data2.credentialSubject.idDocumentNumber,
    govIdIssuanceDate: data2.credentialSubject.idDocumentDateOfIssue?.split("T")[0],
    govIdFrontUrl: generateFileUrl(url, credentialId, "idDocumentFrontFile"),
    govIdBackUrl: data2.credentialSubject.idDocumentBackFile ? generateFileUrl(url, credentialId, "idDocumentBackFile") : generateFileUrl(url, credentialId, "idDocumentFrontFile"),
    // Send front file if back is not provided
    govIdCountry: countries2to3[data2.credentialSubject.idDocumentCountry],
    proofOfAddressType: data2.credentialSubject.residentialAddressProofCategory.toUpperCase(),
    proofOfAddressUrl: generateFileUrl(url, credentialId, "residentialAddressProofFile")
  };
  const updateKYCResponse = await fetch(`${SERVER_ENV.HIFI_API_URL}v2/users/${userId}/kyc`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${SERVER_ENV.HIFI_API_KEY}`
    },
    body: JSON.stringify(updateKYCRequest)
  });
  if (!updateKYCResponse.ok) {
    const error = await updateKYCResponse.json();
    console.log("-> error", JSON.stringify(error, null, 2));
    throw new Error(`Can't update KYC in HIFI because: ${error.message}`);
  }
  const submitKYCResponse = await fetch(
    `${SERVER_ENV.HIFI_API_URL}v2/users/${userId}/kyc/submissions`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${SERVER_ENV.HIFI_API_KEY}`
      },
      body: JSON.stringify({
        rails: "USD_EURO"
      })
    }
  );
  if (!submitKYCResponse.ok) {
    const error = await submitKYCResponse.json();
    console.log("-> error", JSON.stringify(error, null, 2));
    throw new Error(`Can't submit KYC in HIFI because: ${error.message}`);
  }
  return userId;
};
const createOnRampAccount = async (userId, request) => {
  const response = await fetch(`${SERVER_ENV.HIFI_API_URL}v2/users/${userId}/virtual-accounts`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${SERVER_ENV.HIFI_API_KEY}`
    },
    body: JSON.stringify(request)
  });
  if (!response.ok) {
    const error = await response.json();
    console.log("-> error", JSON.stringify(error, null, 2));
    throw new Error(`Can't create an on-ramp account in HIFI because: ${error.message}`);
  }
  return response.json();
};
async function loader$3({
  request,
  context
}) {
  const url = new URL(request.url);
  const session = await sessionStorage.getSession(request.headers.get("Cookie"));
  const user = session.get("user");
  if (!user) {
    return Response.json({
      error: "user is required"
    }, {
      status: 400
    });
  }
  try {
    const link = await fetchTosLink(url);
    session.set("hifiTosId", link.idempotencyKey);
    return Response.json({
      link: link.url
    }, {
      headers: {
        "Set-Cookie": await sessionStorage.commitSession(session)
      }
    });
  } catch (error) {
    return Response.json({
      error: error.message
    }, {
      status: 400
    });
  }
}
const route12 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  loader: loader$3
}, Symbol.toStringTag, { value: "Module" }));
async function loader$2({
  request
}) {
  const url = new URL(request.url);
  const credentialId = url.searchParams.get("credentialId");
  const signedAgreementId = url.searchParams.get("signedAgreementId");
  const session = await sessionStorage.getSession(request.headers.get("Cookie"));
  const user = session.get("user");
  if (!credentialId || !user || !signedAgreementId) {
    return Response.json({
      error: "credentialId, user or signedAgreementId is required"
    }, {
      status: 400
    });
  }
  if (session.get("hifiTosId") !== signedAgreementId) {
    return Response.json({
      error: "User did not accept the right TOS"
    }, {
      status: 400
    });
  }
  try {
    const data2 = await getSharedCredential(credentialId, user.address);
    const userId = await createUserAndKYC(signedAgreementId, credentialId, data2, url);
    session.set("hifiUserId", userId);
    session.unset("hifiTosId");
    return Response.json({
      userId
    }, {
      headers: {
        "Set-Cookie": await sessionStorage.commitSession(session)
      }
    });
  } catch (error) {
    return Response.json({
      error: error.message
    }, {
      status: 400
    });
  }
}
const route13 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  loader: loader$2
}, Symbol.toStringTag, { value: "Module" }));
async function loader$1({
  request
}) {
  const session = await sessionStorage.getSession(request.headers.get("Cookie"));
  const user = session.get("user");
  const hifiUserId = session.get("hifiUserId");
  if (!user) {
    return Response.json({
      error: "user is required"
    }, {
      status: 400
    });
  }
  if (!hifiUserId) {
    return Response.json({
      error: "user.hifiUserId is required"
    }, {
      status: 400
    });
  }
  try {
    const response = await createOnRampAccount(hifiUserId, {
      sourceCurrency: "usd",
      destinationCurrency: "usdc",
      destinationChain: "POLYGON"
    });
    return Response.json({
      response
    });
  } catch (error) {
    return Response.json({
      error: error.message
    }, {
      status: 400
    });
  }
}
const route14 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  loader: loader$1
}, Symbol.toStringTag, { value: "Module" }));
async function loader({
  request
}) {
  const session = await sessionStorage.getSession(request.headers.get("Cookie"));
  const user = session.get("user");
  const hifiUserId = session.get("hifiUserId");
  if (!user) {
    return Response.json({
      error: "user is required"
    }, {
      status: 400
    });
  }
  if (!hifiUserId) {
    return Response.json({
      error: "user.hifiUserId is required"
    }, {
      status: 400
    });
  }
  try {
    const response = await getKycStatus(hifiUserId);
    return Response.json({
      status: response.status,
      message: response.message
    });
  } catch (error) {
    return Response.json({
      error: error.message
    }, {
      status: 400
    });
  }
}
const route15 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  loader
}, Symbol.toStringTag, { value: "Module" }));
const serverManifest = { "entry": { "module": "/assets/entry.client-Br5Vv_yY.js", "imports": ["/assets/chunk-NL6KNZEE-DxjRT9aK.js"], "css": [] }, "routes": { "root": { "id": "root", "parentId": void 0, "path": "", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": true, "module": "/assets/root-DUuFzTYd.js", "imports": ["/assets/chunk-NL6KNZEE-DxjRT9aK.js", "/assets/siwe-provider-Bd1E0PB_.js", "/assets/index-BWZSq4S6.js"], "css": ["/assets/root-CVJeRemq.css"], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/home": { "id": "routes/home", "parentId": "root", "path": void 0, "index": true, "caseSensitive": void 0, "hasAction": false, "hasLoader": true, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/home-BZJT3j1B.js", "imports": ["/assets/chunk-NL6KNZEE-DxjRT9aK.js", "/assets/siwe-provider-Bd1E0PB_.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/auth": { "id": "routes/auth", "parentId": "root", "path": "auth", "index": void 0, "caseSensitive": void 0, "hasAction": true, "hasLoader": true, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/auth-l0sNRNKZ.js", "imports": [], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/file": { "id": "routes/file", "parentId": "root", "path": "file", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": true, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/file-l0sNRNKZ.js", "imports": [], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/callbacks/noah": { "id": "routes/callbacks/noah", "parentId": "root", "path": "callbacks/noah", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/noah-CZeRXLz2.js", "imports": ["/assets/chunk-NL6KNZEE-DxjRT9aK.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/callbacks/hifi/tos": { "id": "routes/callbacks/hifi/tos", "parentId": "root", "path": "callbacks/hifi/tos", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/tos-pZAU5AsK.js", "imports": ["/assets/chunk-NL6KNZEE-DxjRT9aK.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "layouts/app": { "id": "layouts/app", "parentId": "root", "path": void 0, "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": true, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/app-aH6RF3vf.js", "imports": ["/assets/app-DPnztY5X.js", "/assets/chunk-NL6KNZEE-DxjRT9aK.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/app": { "id": "routes/app", "parentId": "layouts/app", "path": "app", "index": true, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/app-q0FZ-4P9.js", "imports": ["/assets/chunk-NL6KNZEE-DxjRT9aK.js", "/assets/app-DPnztY5X.js", "/assets/index-BWZSq4S6.js", "/assets/siwe-provider-Bd1E0PB_.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/kyc/token": { "id": "routes/kyc/token", "parentId": "layouts/app", "path": "app/kyc/token", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": true, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/token-l0sNRNKZ.js", "imports": [], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/kyc/data": { "id": "routes/kyc/data", "parentId": "layouts/app", "path": "app/kyc/data", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": true, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/data-l0sNRNKZ.js", "imports": [], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/kyc/link": { "id": "routes/kyc/link", "parentId": "layouts/app", "path": "app/kyc/link", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": true, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/link-l0sNRNKZ.js", "imports": [], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/kyc/noah/link": { "id": "routes/kyc/noah/link", "parentId": "layouts/app", "path": "app/kyc/noah/link", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": true, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/link-DP2rzg_V.js", "imports": [], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/kyc/hifi/tos": { "id": "routes/kyc/hifi/tos", "parentId": "layouts/app", "path": "app/kyc/hifi/tos", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": true, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/tos-l0sNRNKZ.js", "imports": [], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/kyc/hifi/link": { "id": "routes/kyc/hifi/link", "parentId": "layouts/app", "path": "app/kyc/hifi/link", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": true, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/link-K6Dvbx-E.js", "imports": [], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/kyc/hifi/account": { "id": "routes/kyc/hifi/account", "parentId": "layouts/app", "path": "app/kyc/hifi/account", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": true, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/account-l0sNRNKZ.js", "imports": [], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/kyc/hifi/status": { "id": "routes/kyc/hifi/status", "parentId": "layouts/app", "path": "app/kyc/hifi/status", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": true, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/status-l0sNRNKZ.js", "imports": [], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 } }, "url": "/assets/manifest-a4929f86.js", "version": "a4929f86", "sri": void 0 };
const assetsBuildDirectory = "build/client";
const basename = "/";
const future = { "unstable_middleware": true, "unstable_optimizeDeps": false, "unstable_splitRouteModules": false, "unstable_subResourceIntegrity": false, "unstable_viteEnvironmentApi": false };
const ssr = true;
const isSpaMode = false;
const prerender = [];
const routeDiscovery = { "mode": "lazy", "manifestPath": "/__manifest" };
const publicPath = "/";
const entry = { module: entryServer };
const routes = {
  "root": {
    id: "root",
    parentId: void 0,
    path: "",
    index: void 0,
    caseSensitive: void 0,
    module: route0
  },
  "routes/home": {
    id: "routes/home",
    parentId: "root",
    path: void 0,
    index: true,
    caseSensitive: void 0,
    module: route1
  },
  "routes/auth": {
    id: "routes/auth",
    parentId: "root",
    path: "auth",
    index: void 0,
    caseSensitive: void 0,
    module: route2
  },
  "routes/file": {
    id: "routes/file",
    parentId: "root",
    path: "file",
    index: void 0,
    caseSensitive: void 0,
    module: route3
  },
  "routes/callbacks/noah": {
    id: "routes/callbacks/noah",
    parentId: "root",
    path: "callbacks/noah",
    index: void 0,
    caseSensitive: void 0,
    module: route4
  },
  "routes/callbacks/hifi/tos": {
    id: "routes/callbacks/hifi/tos",
    parentId: "root",
    path: "callbacks/hifi/tos",
    index: void 0,
    caseSensitive: void 0,
    module: route5
  },
  "layouts/app": {
    id: "layouts/app",
    parentId: "root",
    path: void 0,
    index: void 0,
    caseSensitive: void 0,
    module: route6
  },
  "routes/app": {
    id: "routes/app",
    parentId: "layouts/app",
    path: "app",
    index: true,
    caseSensitive: void 0,
    module: route7
  },
  "routes/kyc/token": {
    id: "routes/kyc/token",
    parentId: "layouts/app",
    path: "app/kyc/token",
    index: void 0,
    caseSensitive: void 0,
    module: route8
  },
  "routes/kyc/data": {
    id: "routes/kyc/data",
    parentId: "layouts/app",
    path: "app/kyc/data",
    index: void 0,
    caseSensitive: void 0,
    module: route9
  },
  "routes/kyc/link": {
    id: "routes/kyc/link",
    parentId: "layouts/app",
    path: "app/kyc/link",
    index: void 0,
    caseSensitive: void 0,
    module: route10
  },
  "routes/kyc/noah/link": {
    id: "routes/kyc/noah/link",
    parentId: "layouts/app",
    path: "app/kyc/noah/link",
    index: void 0,
    caseSensitive: void 0,
    module: route11
  },
  "routes/kyc/hifi/tos": {
    id: "routes/kyc/hifi/tos",
    parentId: "layouts/app",
    path: "app/kyc/hifi/tos",
    index: void 0,
    caseSensitive: void 0,
    module: route12
  },
  "routes/kyc/hifi/link": {
    id: "routes/kyc/hifi/link",
    parentId: "layouts/app",
    path: "app/kyc/hifi/link",
    index: void 0,
    caseSensitive: void 0,
    module: route13
  },
  "routes/kyc/hifi/account": {
    id: "routes/kyc/hifi/account",
    parentId: "layouts/app",
    path: "app/kyc/hifi/account",
    index: void 0,
    caseSensitive: void 0,
    module: route14
  },
  "routes/kyc/hifi/status": {
    id: "routes/kyc/hifi/status",
    parentId: "layouts/app",
    path: "app/kyc/hifi/status",
    index: void 0,
    caseSensitive: void 0,
    module: route15
  }
};
export {
  serverManifest as assets,
  assetsBuildDirectory,
  basename,
  entry,
  future,
  isSpaMode,
  prerender,
  publicPath,
  routeDiscovery,
  routes,
  ssr
};
