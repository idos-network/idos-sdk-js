import { Utils } from "@idos-network/kwil-js";
import * as z from "zod";
import type { KwilActionClient } from "../kwil-infra";

// This file is generated by the generator. Do not edit it manually.
export const DataType: typeof Utils.DataType = Utils.DataType;

export type ActionSchemaElement = {
  name: string;
  type: typeof DataType.Uuid | typeof DataType.Text | typeof DataType.Int;
};

export const actionSchema: Record<string, ActionSchemaElement[]> = {
  add_inserter_as_owner: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "name",
      type: DataType.Text,
    },
  ],
  delete_inserter_as_owner: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  add_delegate_as_owner: [
    {
      name: "address",
      type: DataType.Text,
    },
    {
      name: "inserter_id",
      type: DataType.Uuid,
    },
  ],
  delete_delegate_as_owner: [
    {
      name: "address",
      type: DataType.Text,
    },
  ],
  get_inserter: [],
  get_inserter_or_null: [],
  add_user_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "recipient_encryption_public_key",
      type: DataType.Text,
    },
    {
      name: "encryption_password_store",
      type: DataType.Text,
    },
  ],
  update_user_pub_key_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "recipient_encryption_public_key",
      type: DataType.Text,
    },
    {
      name: "encryption_password_store",
      type: DataType.Text,
    },
  ],
  get_user: [],
  get_user_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  upsert_wallet_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "user_id",
      type: DataType.Uuid,
    },
    {
      name: "address",
      type: DataType.Text,
    },
    {
      name: "public_key",
      type: DataType.Text,
    },
    {
      name: "wallet_type",
      type: DataType.Text,
    },
    {
      name: "message",
      type: DataType.Text,
    },
    {
      name: "signature",
      type: DataType.Text,
    },
  ],
  add_wallet: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "address",
      type: DataType.Text,
    },
    {
      name: "public_key",
      type: DataType.Text,
    },
    {
      name: "message",
      type: DataType.Text,
    },
    {
      name: "signature",
      type: DataType.Text,
    },
  ],
  get_wallets: [],
  remove_wallet: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  upsert_credential_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "user_id",
      type: DataType.Uuid,
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text,
    },
    {
      name: "encryptor_public_key",
      type: DataType.Text,
    },
    {
      name: "content",
      type: DataType.Text,
    },
    {
      name: "public_notes",
      type: DataType.Text,
    },
    {
      name: "public_notes_signature",
      type: DataType.Text,
    },
    {
      name: "broader_signature",
      type: DataType.Text,
    },
  ],
  add_credential: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text,
    },
    {
      name: "encryptor_public_key",
      type: DataType.Text,
    },
    {
      name: "content",
      type: DataType.Text,
    },
    {
      name: "public_notes",
      type: DataType.Text,
    },
    {
      name: "public_notes_signature",
      type: DataType.Text,
    },
    {
      name: "broader_signature",
      type: DataType.Text,
    },
  ],
  get_credentials: [],
  get_credentials_shared_by_user: [
    {
      name: "user_id",
      type: DataType.Uuid,
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text,
    },
  ],
  edit_credential: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "public_notes",
      type: DataType.Text,
    },
    {
      name: "public_notes_signature",
      type: DataType.Text,
    },
    {
      name: "broader_signature",
      type: DataType.Text,
    },
    {
      name: "content",
      type: DataType.Text,
    },
    {
      name: "encryptor_public_key",
      type: DataType.Text,
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text,
    },
  ],
  edit_public_notes_as_issuer: [
    {
      name: "public_notes_id",
      type: DataType.Text,
    },
    {
      name: "public_notes",
      type: DataType.Text,
    },
  ],
  remove_credential: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  rescind_shared_credential: [
    {
      name: "credential_id",
      type: DataType.Uuid,
    },
  ],
  create_credentials_by_dwg: [
    {
      name: "issuer_auth_public_key",
      type: DataType.Text,
    },
    {
      name: "original_encryptor_public_key",
      type: DataType.Text,
    },
    {
      name: "original_credential_id",
      type: DataType.Uuid,
    },
    {
      name: "original_content",
      type: DataType.Text,
    },
    {
      name: "original_public_notes",
      type: DataType.Text,
    },
    {
      name: "original_public_notes_signature",
      type: DataType.Text,
    },
    {
      name: "original_broader_signature",
      type: DataType.Text,
    },
    {
      name: "copy_encryptor_public_key",
      type: DataType.Text,
    },
    {
      name: "copy_credential_id",
      type: DataType.Uuid,
    },
    {
      name: "copy_content",
      type: DataType.Text,
    },
    {
      name: "copy_public_notes_signature",
      type: DataType.Text,
    },
    {
      name: "copy_broader_signature",
      type: DataType.Text,
    },
    {
      name: "content_hash",
      type: DataType.Text,
    },
    {
      name: "dwg_owner",
      type: DataType.Text,
    },
    {
      name: "dwg_grantee",
      type: DataType.Text,
    },
    {
      name: "dwg_issuer_public_key",
      type: DataType.Text,
    },
    {
      name: "dwg_id",
      type: DataType.Uuid,
    },
    {
      name: "dwg_access_grant_timelock",
      type: DataType.Text,
    },
    {
      name: "dwg_not_before",
      type: DataType.Text,
    },
    {
      name: "dwg_not_after",
      type: DataType.Text,
    },
    {
      name: "dwg_signature",
      type: DataType.Text,
    },
  ],
  credential_exist_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  get_credential_owned: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  get_sibling_credential_id: [
    {
      name: "content_hash",
      type: DataType.Text,
    },
  ],
  credential_exist: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  add_attribute_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "user_id",
      type: DataType.Uuid,
    },
    {
      name: "attribute_key",
      type: DataType.Text,
    },
    {
      name: "value",
      type: DataType.Text,
    },
  ],
  add_attribute: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "attribute_key",
      type: DataType.Text,
    },
    {
      name: "value",
      type: DataType.Text,
    },
  ],
  get_access_grants_owned: [],
  dag_message: [
    {
      name: "dag_owner_wallet_identifier",
      type: DataType.Text,
    },
    {
      name: "dag_grantee_wallet_identifier",
      type: DataType.Text,
    },
    {
      name: "dag_data_id",
      type: DataType.Uuid,
    },
    {
      name: "dag_locked_until",
      type: DataType.Int,
    },
    {
      name: "dag_content_hash",
      type: DataType.Text,
    },
  ],
  create_access_grant: [
    {
      name: "grantee_wallet_identifier",
      type: DataType.Text,
    },
    {
      name: "data_id",
      type: DataType.Uuid,
    },
    {
      name: "locked_until",
      type: DataType.Int,
    },
    {
      name: "content_hash",
      type: DataType.Text,
    },
    {
      name: "inserter_type",
      type: DataType.Text,
    },
    {
      name: "inserter_id",
      type: DataType.Text,
    },
  ],
  has_profile: [
    {
      name: "address",
      type: DataType.Text,
    },
  ],
  add_passporting_club_as_owner: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "name",
      type: DataType.Text,
    },
  ],
};
export const AddInserterAsOwnerInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  name: z.ZodString;
}> = z.object({
  id: z.uuid(),
  name: z.string(),
});

export type AddInserterAsOwnerInput = z.infer<typeof AddInserterAsOwnerInputSchema>;

/**  INSERTER AND DELEGATE ACTIONS */
export async function addInserterAsOwner(
  kwilClient: KwilActionClient,
  params: AddInserterAsOwnerInput,
): Promise<void> {
  const inputs = AddInserterAsOwnerInputSchema.parse(params);
  await kwilClient.execute({
    name: "add_inserter_as_owner",
    inputs,
    description: "Add inserter as owner",
  });
}

export const DeleteInserterAsOwnerInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type DeleteInserterAsOwnerInput = z.infer<typeof DeleteInserterAsOwnerInputSchema>;

export async function deleteInserterAsOwner(
  kwilClient: KwilActionClient,
  params: DeleteInserterAsOwnerInput,
): Promise<void> {
  const inputs = DeleteInserterAsOwnerInputSchema.parse(params);
  await kwilClient.execute({
    name: "delete_inserter_as_owner",
    inputs,
    description: "Delete inserter as owner",
  });
}

export const AddDelegateAsOwnerInputSchema: z.ZodObject<{
  address: z.ZodString;
  inserter_id: z.ZodUUID;
}> = z.object({
  address: z.string(),
  inserter_id: z.uuid(),
});

export type AddDelegateAsOwnerInput = z.infer<typeof AddDelegateAsOwnerInputSchema>;

export async function addDelegateAsOwner(
  kwilClient: KwilActionClient,
  params: AddDelegateAsOwnerInput,
): Promise<void> {
  const inputs = AddDelegateAsOwnerInputSchema.parse(params);
  await kwilClient.execute({
    name: "add_delegate_as_owner",
    inputs,
    description: "Add a delegate as owner",
  });
}

export const DeleteDelegateAsOwnerInputSchema: z.ZodObject<{
  address: z.ZodString;
}> = z.object({
  address: z.string(),
});

export type DeleteDelegateAsOwnerInput = z.infer<typeof DeleteDelegateAsOwnerInputSchema>;

export async function deleteDelegateAsOwner(
  kwilClient: KwilActionClient,
  params: DeleteDelegateAsOwnerInput,
): Promise<void> {
  const inputs = DeleteDelegateAsOwnerInputSchema.parse(params);
  await kwilClient.execute({
    name: "delete_delegate_as_owner",
    inputs,
    description: "Delete a delegate from idOS",
  });
}

export const GetInserterOutputSchema: z.ZodObject<{
  name: z.ZodString;
}> = z.object({
  name: z.string(),
});

export type GetInserterOutput = z.infer<typeof GetInserterOutputSchema>;

export async function getInserter(kwilClient: KwilActionClient): Promise<GetInserterOutput> {
  return await kwilClient
    .call<GetInserterOutput[]>({ name: "get_inserter", inputs: {} })
    .then((result) => result[0]);
}

export const GetInserterOrNullOutputSchema: z.ZodObject<{
  name: z.ZodString;
}> = z.object({
  name: z.string(),
});

export type GetInserterOrNullOutput = z.infer<typeof GetInserterOrNullOutputSchema>;

export async function getInserterOrNull(
  kwilClient: KwilActionClient,
): Promise<GetInserterOrNullOutput> {
  return await kwilClient
    .call<GetInserterOrNullOutput[]>({ name: "get_inserter_or_null", inputs: {} })
    .then((result) => result[0]);
}

export const AddUserAsInserterInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  recipient_encryption_public_key: z.ZodString;
  encryption_password_store: z.ZodString;
}> = z.object({
  id: z.uuid(),
  recipient_encryption_public_key: z.string(),
  encryption_password_store: z.string(),
});

export type AddUserAsInserterInput = z.infer<typeof AddUserAsInserterInputSchema>;

/**  USER ACTIONS */
export async function addUserAsInserter(
  kwilClient: KwilActionClient,
  params: AddUserAsInserterInput,
): Promise<void> {
  const inputs = AddUserAsInserterInputSchema.parse(params);
  await kwilClient.execute({
    name: "add_user_as_inserter",
    inputs,
    description: "Add a user to idOS",
  });
}

export const UpdateUserPubKeyAsInserterInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  recipient_encryption_public_key: z.ZodString;
  encryption_password_store: z.ZodString;
}> = z.object({
  id: z.uuid(),
  recipient_encryption_public_key: z.string(),
  encryption_password_store: z.string(),
});

export type UpdateUserPubKeyAsInserterInput = z.infer<typeof UpdateUserPubKeyAsInserterInputSchema>;

export async function updateUserPubKeyAsInserter(
  kwilClient: KwilActionClient,
  params: UpdateUserPubKeyAsInserterInput,
): Promise<void> {
  const inputs = UpdateUserPubKeyAsInserterInputSchema.parse(params);
  await kwilClient.execute({
    name: "update_user_pub_key_as_inserter",
    inputs,
    description:
      "Update user's encryption key and password store in idOS as inserter (profile creator)",
  });
}

export const GetUserOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  recipient_encryption_public_key: z.ZodString;
  encryption_password_store: z.ZodString;
}> = z.object({
  id: z.uuid(),
  recipient_encryption_public_key: z.string(),
  encryption_password_store: z.string(),
});

export type GetUserOutput = z.infer<typeof GetUserOutputSchema>;

export async function getUser(kwilClient: KwilActionClient): Promise<GetUserOutput> {
  return await kwilClient
    .call<GetUserOutput[]>({ name: "get_user", inputs: {} })
    .then((result) => result[0]);
}

export const GetUserAsInserterInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type GetUserAsInserterInput = z.infer<typeof GetUserAsInserterInputSchema>;

export const GetUserAsInserterOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  recipient_encryption_public_key: z.ZodString;
  encryption_password_store: z.ZodString;
  inserter: z.ZodString;
}> = z.object({
  id: z.uuid(),
  recipient_encryption_public_key: z.string(),
  encryption_password_store: z.string(),
  inserter: z.string(),
});

export type GetUserAsInserterOutput = z.infer<typeof GetUserAsInserterOutputSchema>;

export async function getUserAsInserter(
  kwilClient: KwilActionClient,
  params: GetUserAsInserterInput,
): Promise<GetUserAsInserterOutput> {
  const inputs = GetUserAsInserterInputSchema.parse(params);
  return await kwilClient
    .call<GetUserAsInserterOutput[]>({
      name: "get_user_as_inserter",
      inputs,
    })
    .then((result) => result[0]);
}

export const UpsertWalletAsInserterInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  address: z.ZodString;
  public_key: z.ZodString;
  wallet_type: z.ZodString;
  message: z.ZodString;
  signature: z.ZodString;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  address: z.string(),
  public_key: z.string(),
  wallet_type: z.string(),
  message: z.string(),
  signature: z.string(),
});

export type UpsertWalletAsInserterInput = z.infer<typeof UpsertWalletAsInserterInputSchema>;

/**  WALLET ACTIONS */
export async function upsertWalletAsInserter(
  kwilClient: KwilActionClient,
  params: UpsertWalletAsInserterInput,
): Promise<void> {
  const inputs = UpsertWalletAsInserterInputSchema.parse(params);
  await kwilClient.execute({
    name: "upsert_wallet_as_inserter",
    inputs,
    description: "Add a wallet to idOS by inserter (profile creator)",
  });
}

export const AddWalletInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  address: z.ZodString;
  public_key: z.ZodString;
  message: z.ZodString;
  signature: z.ZodString;
}> = z.object({
  id: z.uuid(),
  address: z.string(),
  public_key: z.string(),
  message: z.string(),
  signature: z.string(),
});

export type AddWalletInput = z.infer<typeof AddWalletInputSchema>;

export async function addWallet(
  kwilClient: KwilActionClient,
  params: AddWalletInput,
): Promise<void> {
  const inputs = AddWalletInputSchema.parse(params);
  await kwilClient.execute({
    name: "add_wallet",
    inputs,
    description: "Add a wallet to idOS",
  });
}

export const GetWalletsOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  address: z.ZodString;
  public_key: z.ZodString;
  wallet_type: z.ZodString;
  message: z.ZodString;
  signature: z.ZodString;
  inserter: z.ZodString;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  address: z.string(),
  public_key: z.string(),
  wallet_type: z.string(),
  message: z.string(),
  signature: z.string(),
  inserter: z.string(),
});

export type GetWalletsOutput = z.infer<typeof GetWalletsOutputSchema>;

export async function getWallets(kwilClient: KwilActionClient): Promise<GetWalletsOutput[]> {
  return await kwilClient.call<GetWalletsOutput[]>({ name: "get_wallets", inputs: {} });
}

export const RemoveWalletInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type RemoveWalletInput = z.infer<typeof RemoveWalletInputSchema>;

export async function removeWallet(
  kwilClient: KwilActionClient,
  params: RemoveWalletInput,
): Promise<void> {
  const inputs = RemoveWalletInputSchema.parse(params);
  await kwilClient.execute({
    name: "remove_wallet",
    inputs,
    description: "Remove a wallet from idOS",
  });
}

export const UpsertCredentialAsInserterInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  issuer_auth_public_key: z.ZodString;
  encryptor_public_key: z.ZodString;
  content: z.ZodString;
  public_notes: z.ZodString;
  public_notes_signature: z.ZodString;
  broader_signature: z.ZodString;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  issuer_auth_public_key: z.string(),
  encryptor_public_key: z.string(),
  content: z.string(),
  public_notes: z.string(),
  public_notes_signature: z.string(),
  broader_signature: z.string(),
});

export type UpsertCredentialAsInserterInput = z.infer<typeof UpsertCredentialAsInserterInputSchema>;

/**
 *  CREDENTIAL ACTIONS
 *  throw an error if not authorized
 */
export async function upsertCredentialAsInserter(
  kwilClient: KwilActionClient,
  params: UpsertCredentialAsInserterInput,
): Promise<void> {
  const inputs = UpsertCredentialAsInserterInputSchema.parse(params);
  await kwilClient.execute({
    name: "upsert_credential_as_inserter",
    inputs,
    description:
      "Add or update a credential in idOS on behalf of a user by permissioned profile creator (inserter) ",
  });
}

export const AddCredentialInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  issuer_auth_public_key: z.ZodString;
  encryptor_public_key: z.ZodString;
  content: z.ZodString;
  public_notes: z.ZodString;
  public_notes_signature: z.ZodString;
  broader_signature: z.ZodString;
}> = z.object({
  id: z.uuid(),
  issuer_auth_public_key: z.string(),
  encryptor_public_key: z.string(),
  content: z.string(),
  public_notes: z.string(),
  public_notes_signature: z.string(),
  broader_signature: z.string(),
});

export type AddCredentialInput = z.infer<typeof AddCredentialInputSchema>;

export async function addCredential(
  kwilClient: KwilActionClient,
  params: AddCredentialInput,
): Promise<void> {
  const inputs = AddCredentialInputSchema.parse(params);
  await kwilClient.execute({
    name: "add_credential",
    inputs,
    description: "Add a new credential",
  });
}

export const GetCredentialsOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  public_notes: z.ZodString;
  issuer_auth_public_key: z.ZodString;
  inserter: z.ZodNullable<z.ZodString>;
  original_id: z.ZodNullable<z.ZodUUID>;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  public_notes: z.string(),
  issuer_auth_public_key: z.string(),
  inserter: z.string().nullable(),
  original_id: z.uuid().nullable(),
});

export type GetCredentialsOutput = z.infer<typeof GetCredentialsOutputSchema>;

export async function getCredentials(
  kwilClient: KwilActionClient,
): Promise<GetCredentialsOutput[]> {
  return await kwilClient.call<GetCredentialsOutput[]>({ name: "get_credentials", inputs: {} });
}

export const GetCredentialsSharedByUserInputSchema: z.ZodObject<{
  user_id: z.ZodUUID;
  issuer_auth_public_key: z.ZodNullable<z.ZodString>;
}> = z.object({
  user_id: z.uuid(),
  issuer_auth_public_key: z.string().nullable(),
});

export type GetCredentialsSharedByUserInput = z.infer<typeof GetCredentialsSharedByUserInputSchema>;

export const GetCredentialsSharedByUserOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  public_notes: z.ZodString;
  encryptor_public_key: z.ZodString;
  issuer_auth_public_key: z.ZodString;
  inserter: z.ZodNullable<z.ZodString>;
  original_id: z.ZodNullable<z.ZodUUID>;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  public_notes: z.string(),
  encryptor_public_key: z.string(),
  issuer_auth_public_key: z.string(),
  inserter: z.string().nullable(),
  original_id: z.uuid().nullable(),
});

export type GetCredentialsSharedByUserOutput = z.infer<
  typeof GetCredentialsSharedByUserOutputSchema
>;

export async function getCredentialsSharedByUser(
  kwilClient: KwilActionClient,
  params: GetCredentialsSharedByUserInput,
): Promise<GetCredentialsSharedByUserOutput[]> {
  const inputs = GetCredentialsSharedByUserInputSchema.parse(params);
  return await kwilClient.call<GetCredentialsSharedByUserOutput[]>({
    name: "get_credentials_shared_by_user",
    inputs,
  });
}

export const EditCredentialInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  public_notes: z.ZodString;
  public_notes_signature: z.ZodString;
  broader_signature: z.ZodString;
  content: z.ZodString;
  encryptor_public_key: z.ZodString;
  issuer_auth_public_key: z.ZodString;
}> = z.object({
  id: z.uuid(),
  public_notes: z.string(),
  public_notes_signature: z.string(),
  broader_signature: z.string(),
  content: z.string(),
  encryptor_public_key: z.string(),
  issuer_auth_public_key: z.string(),
});

export type EditCredentialInput = z.infer<typeof EditCredentialInputSchema>;

/**
 *  we forbid to edit a copy
 *  only copies can have AGs, so data_id in AGs is id of a copy
 *  if $id is shared_credentials.copy_id - it is a copy
 */
export async function editCredential(
  kwilClient: KwilActionClient,
  params: EditCredentialInput,
): Promise<void> {
  const inputs = EditCredentialInputSchema.parse(params);
  await kwilClient.execute({
    name: "edit_credential",
    inputs,
    description: "Edit a credential",
  });
}

export const EditPublicNotesAsIssuerInputSchema: z.ZodObject<{
  public_notes_id: z.ZodString;
  public_notes: z.ZodString;
}> = z.object({
  public_notes_id: z.string(),
  public_notes: z.string(),
});

export type EditPublicNotesAsIssuerInput = z.infer<typeof EditPublicNotesAsIssuerInputSchema>;

/**
 *  Be aware that @caller here is ed25519 public key, hex encoded.
 *  All other @caller in the schema are either secp256k1 or nep413
 *  This action can't be called by kwil-cli (as kwil-cli uses secp256k1 only)
 */
export async function editPublicNotesAsIssuer(
  kwilClient: KwilActionClient,
  params: EditPublicNotesAsIssuerInput,
): Promise<void> {
  const inputs = EditPublicNotesAsIssuerInputSchema.parse(params);
  await kwilClient.execute({
    name: "edit_public_notes_as_issuer",
    inputs,
    description: "Edit public notes in a credential as issuer",
  });
}

export const RemoveCredentialInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type RemoveCredentialInput = z.infer<typeof RemoveCredentialInputSchema>;

export async function removeCredential(
  kwilClient: KwilActionClient,
  params: RemoveCredentialInput,
): Promise<void> {
  const inputs = RemoveCredentialInputSchema.parse(params);
  await kwilClient.execute({
    name: "remove_credential",
    inputs,
    description: "Remove a credential from your idOS profile",
  });
}

export const RescindSharedCredentialInputSchema: z.ZodObject<{
  credential_id: z.ZodUUID;
}> = z.object({
  credential_id: z.uuid(),
});

export type RescindSharedCredentialInput = z.infer<typeof RescindSharedCredentialInputSchema>;

/**
 *  Passporting scenario
 *  It can be used with EVM-compatible signatures only
 */
export async function rescindSharedCredential(
  kwilClient: KwilActionClient,
  params: RescindSharedCredentialInput,
): Promise<void> {
  const inputs = RescindSharedCredentialInputSchema.parse(params);
  await kwilClient.execute({
    name: "rescind_shared_credential",
    inputs,
    description: "Share a credential through the DAG",
  });
}

export const CreateCredentialsByDwgInputSchema: z.ZodObject<{
  issuer_auth_public_key: z.ZodString;
  original_encryptor_public_key: z.ZodString;
  original_credential_id: z.ZodUUID;
  original_content: z.ZodString;
  original_public_notes: z.ZodString;
  original_public_notes_signature: z.ZodString;
  original_broader_signature: z.ZodString;
  copy_encryptor_public_key: z.ZodString;
  copy_credential_id: z.ZodUUID;
  copy_content: z.ZodString;
  copy_public_notes_signature: z.ZodString;
  copy_broader_signature: z.ZodString;
  content_hash: z.ZodString;
  dwg_owner: z.ZodString;
  dwg_grantee: z.ZodString;
  dwg_issuer_public_key: z.ZodString;
  dwg_id: z.ZodUUID;
  dwg_access_grant_timelock: z.ZodString;
  dwg_not_before: z.ZodString;
  dwg_not_after: z.ZodString;
  dwg_signature: z.ZodString;
}> = z.object({
  issuer_auth_public_key: z.string(),
  original_encryptor_public_key: z.string(),
  original_credential_id: z.uuid(),
  original_content: z.string(),
  original_public_notes: z.string(),
  original_public_notes_signature: z.string(),
  original_broader_signature: z.string(),
  copy_encryptor_public_key: z.string(),
  copy_credential_id: z.uuid(),
  copy_content: z.string(),
  copy_public_notes_signature: z.string(),
  copy_broader_signature: z.string(),
  content_hash: z.string(),
  dwg_owner: z.string(),
  dwg_grantee: z.string(),
  dwg_issuer_public_key: z.string(),
  dwg_id: z.uuid(),
  dwg_access_grant_timelock: z.string(),
  dwg_not_before: z.string(),
  dwg_not_after: z.string(),
  dwg_signature: z.string(),
});

export type CreateCredentialsByDwgInput = z.infer<typeof CreateCredentialsByDwgInputSchema>;

/**
 *  For access grant
 *  Check the content creator (encryptor) of credentials is the issuer that user delegated to issue the credentials
 */
export async function createCredentialsByDwg(
  kwilClient: KwilActionClient,
  params: CreateCredentialsByDwgInput,
): Promise<void> {
  const inputs = CreateCredentialsByDwgInputSchema.parse(params);
  await kwilClient.execute({
    name: "create_credentials_by_dwg",
    inputs,
    description:
      "Add original credential and copy credential with AG on behalf of a user (using delegated write grant given by the user)",
  });
}

export const CredentialExistAsInserterInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type CredentialExistAsInserterInput = z.infer<typeof CredentialExistAsInserterInputSchema>;

export const CredentialExistAsInserterOutputSchema: z.ZodObject<{
  credential_exist: z.ZodBoolean;
}> = z.object({
  credential_exist: z.boolean(),
});

export type CredentialExistAsInserterOutput = z.infer<typeof CredentialExistAsInserterOutputSchema>;

/**
 *  Will fail if not in the RFC3339 format
 *  Check the format and precedence
 *  Check if current block timestamp in time range allowed by write grant.
 *  @block_timestamp is a timestamp of previous block, which is can be a few seconds earlier
 *  (max is 6 seconds in current network consensus settings) then a time on a requester's machine.
 *  Also, if requester's machine has wrong time, it can be an issue.
 *  Insert original credential
 *  Insert copy credential
 */
export async function credentialExistAsInserter(
  kwilClient: KwilActionClient,
  params: CredentialExistAsInserterInput,
): Promise<CredentialExistAsInserterOutput> {
  const inputs = CredentialExistAsInserterInputSchema.parse(params);
  return await kwilClient
    .call<CredentialExistAsInserterOutput[]>({
      name: "credential_exist_as_inserter",
      inputs,
    })
    .then((result) => result[0]);
}

export const GetCredentialOwnedInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type GetCredentialOwnedInput = z.infer<typeof GetCredentialOwnedInputSchema>;

export const GetCredentialOwnedOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  public_notes: z.ZodString;
  content: z.ZodString;
  encryptor_public_key: z.ZodString;
  issuer_auth_public_key: z.ZodString;
  inserter: z.ZodNullable<z.ZodString>;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  public_notes: z.string(),
  content: z.string(),
  encryptor_public_key: z.string(),
  issuer_auth_public_key: z.string(),
  inserter: z.string().nullable(),
});

export type GetCredentialOwnedOutput = z.infer<typeof GetCredentialOwnedOutputSchema>;

/**  As a credential copy doesn't contain PUBLIC notes, we return respective original credential PUBLIC notes */
export async function getCredentialOwned(
  kwilClient: KwilActionClient,
  params: GetCredentialOwnedInput,
): Promise<GetCredentialOwnedOutput[]> {
  const inputs = GetCredentialOwnedInputSchema.parse(params);
  return await kwilClient.call<GetCredentialOwnedOutput[]>({
    name: "get_credential_owned",
    inputs,
  });
}

export const GetSiblingCredentialIdInputSchema: z.ZodObject<{
  content_hash: z.ZodString;
}> = z.object({
  content_hash: z.string(),
});

export type GetSiblingCredentialIdInput = z.infer<typeof GetSiblingCredentialIdInputSchema>;

export const GetSiblingCredentialIdOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type GetSiblingCredentialIdOutput = z.infer<typeof GetSiblingCredentialIdOutputSchema>;

export async function getSiblingCredentialId(
  kwilClient: KwilActionClient,
  params: GetSiblingCredentialIdInput,
): Promise<GetSiblingCredentialIdOutput> {
  const inputs = GetSiblingCredentialIdInputSchema.parse(params);
  return await kwilClient
    .call<GetSiblingCredentialIdOutput[]>({
      name: "get_sibling_credential_id",
      inputs,
    })
    .then((result) => result[0]);
}

export const CredentialExistInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type CredentialExistInput = z.infer<typeof CredentialExistInputSchema>;

export const CredentialExistOutputSchema: z.ZodObject<{
  credential_exist: z.ZodBoolean;
}> = z.object({
  credential_exist: z.boolean(),
});

export type CredentialExistOutput = z.infer<typeof CredentialExistOutputSchema>;

export async function credentialExist(
  kwilClient: KwilActionClient,
  params: CredentialExistInput,
): Promise<CredentialExistOutput> {
  const inputs = CredentialExistInputSchema.parse(params);
  return await kwilClient
    .call<CredentialExistOutput[]>({
      name: "credential_exist",
      inputs,
    })
    .then((result) => result[0]);
}

export const AddAttributeAsInserterInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  attribute_key: z.ZodString;
  value: z.ZodString;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  attribute_key: z.string(),
  value: z.string(),
});

export type AddAttributeAsInserterInput = z.infer<typeof AddAttributeAsInserterInputSchema>;

/**  ATTRIBUTE ACTIONS */
export async function addAttributeAsInserter(
  kwilClient: KwilActionClient,
  params: AddAttributeAsInserterInput,
): Promise<void> {
  const inputs = AddAttributeAsInserterInputSchema.parse(params);
  await kwilClient.execute({
    name: "add_attribute_as_inserter",
    inputs,
    description: "Add a new attribute as inserter",
  });
}

export const AddAttributeInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  attribute_key: z.ZodString;
  value: z.ZodString;
}> = z.object({
  id: z.uuid(),
  attribute_key: z.string(),
  value: z.string(),
});

export type AddAttributeInput = z.infer<typeof AddAttributeInputSchema>;

/**
 *  WRITE GRANTS ACTIONS
 *  Must be in yyyy-mm-ddThh:mm:ssZ format
 *  Must be in yyyy-mm-ddThh:mm:ssZ format
 *  Must be in yyyy-mm-ddThh:mm:ssZ format
 *  Will fail if not in the yyyy-mm-ddThh:mm:ssZ format, and not comply to RFC3339
 *  Check the format and precedence
 *  ACCESS GRANTS ACTIONS
 */
export async function addAttribute(
  kwilClient: KwilActionClient,
  params: AddAttributeInput,
): Promise<void> {
  const inputs = AddAttributeInputSchema.parse(params);
  await kwilClient.execute({
    name: "add_attribute",
    inputs,
    description: "Revoke an Access Grant from idOS",
  });
}

export const GetAccessGrantsOwnedOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  ag_owner_user_id: z.ZodUUID;
  ag_grantee_wallet_identifier: z.ZodString;
  data_id: z.ZodUUID;
  locked_until: z.ZodNumber;
  content_hash: z.ZodNullable<z.ZodString>;
  inserter_type: z.ZodString;
  inserter_id: z.ZodString;
}> = z.object({
  id: z.uuid(),
  ag_owner_user_id: z.uuid(),
  ag_grantee_wallet_identifier: z.string(),
  data_id: z.uuid(),
  locked_until: z.number(),
  content_hash: z.string().nullable(),
  inserter_type: z.string(),
  inserter_id: z.string(),
});

export type GetAccessGrantsOwnedOutput = z.infer<typeof GetAccessGrantsOwnedOutputSchema>;

/**
 *  As arguments can be undefined (user can not send them at all), we have to have default values: page=1, size=20
 *  Page number starts from 1, as UI usually shows to user in pagination element
 *  Ordering is consistent because we use height as first ordering parameter
 */
export async function getAccessGrantsOwned(
  kwilClient: KwilActionClient,
): Promise<GetAccessGrantsOwnedOutput[]> {
  return await kwilClient.call<GetAccessGrantsOwnedOutput[]>({
    name: "get_access_grants_owned",
    inputs: {},
  });
}

export const DagMessageInputSchema: z.ZodObject<{
  dag_owner_wallet_identifier: z.ZodString;
  dag_grantee_wallet_identifier: z.ZodString;
  dag_data_id: z.ZodUUID;
  dag_locked_until: z.ZodNumber;
  dag_content_hash: z.ZodString;
}> = z.object({
  dag_owner_wallet_identifier: z.string(),
  dag_grantee_wallet_identifier: z.string(),
  dag_data_id: z.uuid(),
  dag_locked_until: z.number(),
  dag_content_hash: z.string(),
});

export type DagMessageInput = z.infer<typeof DagMessageInputSchema>;

export const DagMessageOutputSchema: z.ZodObject<{
  message: z.ZodString;
}> = z.object({
  message: z.string(),
});

export type DagMessageOutput = z.infer<typeof DagMessageOutputSchema>;

/**  Get the wallet type and public key for XRPL/NEAR wallets from database */
export async function dagMessage(
  kwilClient: KwilActionClient,
  params: DagMessageInput,
): Promise<DagMessageOutput> {
  const inputs = DagMessageInputSchema.parse(params);
  return await kwilClient
    .call<DagMessageOutput[]>({
      name: "dag_message",
      inputs,
    })
    .then((result) => result[0]);
}

export const CreateAccessGrantInputSchema: z.ZodObject<{
  grantee_wallet_identifier: z.ZodString;
  data_id: z.ZodUUID;
  locked_until: z.ZodNumber;
  content_hash: z.ZodString;
  inserter_type: z.ZodString;
  inserter_id: z.ZodString;
}> = z.object({
  grantee_wallet_identifier: z.string(),
  data_id: z.uuid(),
  locked_until: z.number(),
  content_hash: z.string(),
  inserter_type: z.string(),
  inserter_id: z.string(),
});

export type CreateAccessGrantInput = z.infer<typeof CreateAccessGrantInputSchema>;

/**  data_id is an id of a copy. It always has a user. So if no user found then there is no credential found. */
export async function createAccessGrant(
  kwilClient: KwilActionClient,
  params: CreateAccessGrantInput,
): Promise<void> {
  const inputs = CreateAccessGrantInputSchema.parse(params);
  await kwilClient.execute({
    name: "create_access_grant",
    inputs,
    description: "Create a new access grant",
  });
}

export const HasProfileInputSchema: z.ZodObject<{
  address: z.ZodString;
}> = z.object({
  address: z.string(),
});

export type HasProfileInput = z.infer<typeof HasProfileInputSchema>;

export const HasProfileOutputSchema: z.ZodObject<{
  has_profile: z.ZodBoolean;
}> = z.object({
  has_profile: z.boolean(),
});

export type HasProfileOutput = z.infer<typeof HasProfileOutputSchema>;

/**
 *  OTHER ACTIONS
 *  Should we improve it to work with near wallets too?
 */
export async function hasProfile(
  kwilClient: KwilActionClient,
  params: HasProfileInput,
): Promise<HasProfileOutput> {
  const inputs = HasProfileInputSchema.parse(params);
  return await kwilClient
    .call<HasProfileOutput[]>(
      {
        name: "has_profile",
        inputs,
      },
      undefined, // Signer is not required here
    )
    .then((result) => result[0]);
}

export const AddPassportingClubAsOwnerInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  name: z.ZodString;
}> = z.object({
  id: z.uuid(),
  name: z.string(),
});

export type AddPassportingClubAsOwnerInput = z.infer<typeof AddPassportingClubAsOwnerInputSchema>;

/**
 *  PASSPORTING CLUB ACTIONS
 *  get clubs the peer belongs to
 */
export async function addPassportingClubAsOwner(
  kwilClient: KwilActionClient,
  params: AddPassportingClubAsOwnerInput,
): Promise<void> {
  const inputs = AddPassportingClubAsOwnerInputSchema.parse(params);
  await kwilClient.execute({
    name: "add_passporting_club_as_owner",
    inputs,
    description: "Delete a peer from a passporting club as owner",
  });
}
