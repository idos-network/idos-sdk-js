import { Utils } from "@idos-network/kwil-js";
import * as z from "zod";
import type { KwilActionClient } from "../kwil-infra";

// This file is generated by the generator. Do not edit it manually.
export const DataType: typeof Utils.DataType = Utils.DataType;

export type ActionSchemaElement = {
  name: string;
  type: typeof DataType.Uuid | typeof DataType.Text | typeof DataType.Int;
};

export const actionSchema: Record<string, ActionSchemaElement[]> = {
  add_inserter_as_owner: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "name",
      type: DataType.Text,
    },
  ],
  delete_inserter_as_owner: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  add_delegate_as_owner: [
    {
      name: "address",
      type: DataType.Text,
    },
    {
      name: "inserter_id",
      type: DataType.Uuid,
    },
  ],
  delete_delegate_as_owner: [
    {
      name: "address",
      type: DataType.Text,
    },
  ],
  get_inserter: [],
  get_inserter_or_null: [],
  add_user_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "recipient_encryption_public_key",
      type: DataType.Text,
    },
    {
      name: "encryption_password_store",
      type: DataType.Text,
    },
  ],
  update_user_pub_key_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "recipient_encryption_public_key",
      type: DataType.Text,
    },
    {
      name: "encryption_password_store",
      type: DataType.Text,
    },
  ],
  get_user: [],
  get_user_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  upsert_wallet_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "user_id",
      type: DataType.Uuid,
    },
    {
      name: "address",
      type: DataType.Text,
    },
    {
      name: "public_key",
      type: DataType.Text,
    },
    {
      name: "wallet_type",
      type: DataType.Text,
    },
    {
      name: "message",
      type: DataType.Text,
    },
    {
      name: "signature",
      type: DataType.Text,
    },
  ],
  add_wallet: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "address",
      type: DataType.Text,
    },
    {
      name: "public_key",
      type: DataType.Text,
    },
    {
      name: "message",
      type: DataType.Text,
    },
    {
      name: "signature",
      type: DataType.Text,
    },
  ],
  get_wallets: [],
  remove_wallet: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  upsert_credential_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "user_id",
      type: DataType.Uuid,
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text,
    },
    {
      name: "encryptor_public_key",
      type: DataType.Text,
    },
    {
      name: "content",
      type: DataType.Text,
    },
    {
      name: "public_notes",
      type: DataType.Text,
    },
    {
      name: "public_notes_signature",
      type: DataType.Text,
    },
    {
      name: "broader_signature",
      type: DataType.Text,
    },
  ],
  add_credential: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text,
    },
    {
      name: "encryptor_public_key",
      type: DataType.Text,
    },
    {
      name: "content",
      type: DataType.Text,
    },
    {
      name: "public_notes",
      type: DataType.Text,
    },
    {
      name: "public_notes_signature",
      type: DataType.Text,
    },
    {
      name: "broader_signature",
      type: DataType.Text,
    },
  ],
  get_credentials: [],
  get_credentials_shared_by_user: [
    {
      name: "user_id",
      type: DataType.Uuid,
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text,
    },
  ],
  edit_credential: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "public_notes",
      type: DataType.Text,
    },
    {
      name: "public_notes_signature",
      type: DataType.Text,
    },
    {
      name: "broader_signature",
      type: DataType.Text,
    },
    {
      name: "content",
      type: DataType.Text,
    },
    {
      name: "encryptor_public_key",
      type: DataType.Text,
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text,
    },
  ],
  edit_public_notes_as_issuer: [
    {
      name: "public_notes_id",
      type: DataType.Text,
    },
    {
      name: "public_notes",
      type: DataType.Text,
    },
  ],
  remove_credential: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  rescind_shared_credential: [
    {
      name: "credential_id",
      type: DataType.Uuid,
    },
  ],
  share_credential: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "original_credential_id",
      type: DataType.Uuid,
    },
    {
      name: "public_notes",
      type: DataType.Text,
    },
    {
      name: "public_notes_signature",
      type: DataType.Text,
    },
    {
      name: "broader_signature",
      type: DataType.Text,
    },
    {
      name: "content",
      type: DataType.Text,
    },
    {
      name: "content_hash",
      type: DataType.Text,
    },
    {
      name: "encryptor_public_key",
      type: DataType.Text,
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text,
    },
    {
      name: "grantee_wallet_identifier",
      type: DataType.Text,
    },
    {
      name: "locked_until",
      type: DataType.Int,
    },
  ],
  create_credential_copy: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "original_credential_id",
      type: DataType.Uuid,
    },
    {
      name: "public_notes",
      type: DataType.Text,
    },
    {
      name: "public_notes_signature",
      type: DataType.Text,
    },
    {
      name: "broader_signature",
      type: DataType.Text,
    },
    {
      name: "content",
      type: DataType.Text,
    },
    {
      name: "encryptor_public_key",
      type: DataType.Text,
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text,
    },
  ],
  share_credential_through_dag: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "user_id",
      type: DataType.Uuid,
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text,
    },
    {
      name: "encryptor_public_key",
      type: DataType.Text,
    },
    {
      name: "content",
      type: DataType.Text,
    },
    {
      name: "content_hash",
      type: DataType.Text,
    },
    {
      name: "public_notes",
      type: DataType.Text,
    },
    {
      name: "public_notes_signature",
      type: DataType.Text,
    },
    {
      name: "broader_signature",
      type: DataType.Text,
    },
    {
      name: "original_credential_id",
      type: DataType.Uuid,
    },
    {
      name: "dag_owner_wallet_identifier",
      type: DataType.Text,
    },
    {
      name: "dag_grantee_wallet_identifier",
      type: DataType.Text,
    },
    {
      name: "dag_locked_until",
      type: DataType.Int,
    },
    {
      name: "dag_signature",
      type: DataType.Text,
    },
  ],
  create_credentials_by_dwg: [
    {
      name: "issuer_auth_public_key",
      type: DataType.Text,
    },
    {
      name: "original_encryptor_public_key",
      type: DataType.Text,
    },
    {
      name: "original_credential_id",
      type: DataType.Uuid,
    },
    {
      name: "original_content",
      type: DataType.Text,
    },
    {
      name: "original_public_notes",
      type: DataType.Text,
    },
    {
      name: "original_public_notes_signature",
      type: DataType.Text,
    },
    {
      name: "original_broader_signature",
      type: DataType.Text,
    },
    {
      name: "copy_encryptor_public_key",
      type: DataType.Text,
    },
    {
      name: "copy_credential_id",
      type: DataType.Uuid,
    },
    {
      name: "copy_content",
      type: DataType.Text,
    },
    {
      name: "copy_public_notes_signature",
      type: DataType.Text,
    },
    {
      name: "copy_broader_signature",
      type: DataType.Text,
    },
    {
      name: "content_hash",
      type: DataType.Text,
    },
    {
      name: "dwg_owner",
      type: DataType.Text,
    },
    {
      name: "dwg_grantee",
      type: DataType.Text,
    },
    {
      name: "dwg_issuer_public_key",
      type: DataType.Text,
    },
    {
      name: "dwg_id",
      type: DataType.Uuid,
    },
    {
      name: "dwg_access_grant_timelock",
      type: DataType.Text,
    },
    {
      name: "dwg_not_before",
      type: DataType.Text,
    },
    {
      name: "dwg_not_after",
      type: DataType.Text,
    },
    {
      name: "dwg_signature",
      type: DataType.Text,
    },
  ],
  credential_exist_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  get_credential_owned: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  get_credential_shared: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  get_sibling_credential_id: [
    {
      name: "content_hash",
      type: DataType.Text,
    },
  ],
  credential_belongs_to_caller: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  credential_exist: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  add_attribute_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "user_id",
      type: DataType.Uuid,
    },
    {
      name: "attribute_key",
      type: DataType.Text,
    },
    {
      name: "value",
      type: DataType.Text,
    },
  ],
  add_attribute: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "attribute_key",
      type: DataType.Text,
    },
    {
      name: "value",
      type: DataType.Text,
    },
  ],
  get_attributes: [],
  edit_attribute: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "attribute_key",
      type: DataType.Text,
    },
    {
      name: "value",
      type: DataType.Text,
    },
  ],
  remove_attribute: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  share_attribute: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "original_attribute_id",
      type: DataType.Uuid,
    },
    {
      name: "attribute_key",
      type: DataType.Text,
    },
    {
      name: "value",
      type: DataType.Text,
    },
  ],
  dwg_message: [
    {
      name: "owner_wallet_identifier",
      type: DataType.Text,
    },
    {
      name: "grantee_wallet_identifier",
      type: DataType.Text,
    },
    {
      name: "issuer_public_key",
      type: DataType.Text,
    },
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "access_grant_timelock",
      type: DataType.Text,
    },
    {
      name: "not_usable_before",
      type: DataType.Text,
    },
    {
      name: "not_usable_after",
      type: DataType.Text,
    },
  ],
  revoke_access_grant: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  get_access_grants_owned: [],
  get_access_grants_granted: [
    {
      name: "user_id",
      type: DataType.Uuid,
    },
    {
      name: "page",
      type: DataType.Int,
    },
    {
      name: "size",
      type: DataType.Int,
    },
  ],
  get_access_grants_granted_count: [
    {
      name: "user_id",
      type: DataType.Uuid,
    },
  ],
  has_locked_access_grants: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  dag_message: [
    {
      name: "dag_owner_wallet_identifier",
      type: DataType.Text,
    },
    {
      name: "dag_grantee_wallet_identifier",
      type: DataType.Text,
    },
    {
      name: "dag_data_id",
      type: DataType.Uuid,
    },
    {
      name: "dag_locked_until",
      type: DataType.Int,
    },
    {
      name: "dag_content_hash",
      type: DataType.Text,
    },
  ],
  create_ag_by_dag_for_copy: [
    {
      name: "dag_owner_wallet_identifier",
      type: DataType.Text,
    },
    {
      name: "dag_grantee_wallet_identifier",
      type: DataType.Text,
    },
    {
      name: "dag_data_id",
      type: DataType.Uuid,
    },
    {
      name: "dag_locked_until",
      type: DataType.Int,
    },
    {
      name: "dag_content_hash",
      type: DataType.Text,
    },
    {
      name: "dag_signature",
      type: DataType.Text,
    },
  ],
  create_access_grant: [
    {
      name: "grantee_wallet_identifier",
      type: DataType.Text,
    },
    {
      name: "data_id",
      type: DataType.Uuid,
    },
    {
      name: "locked_until",
      type: DataType.Int,
    },
    {
      name: "content_hash",
      type: DataType.Text,
    },
    {
      name: "inserter_type",
      type: DataType.Text,
    },
    {
      name: "inserter_id",
      type: DataType.Text,
    },
  ],
  get_access_grants_for_credential: [
    {
      name: "credential_id",
      type: DataType.Uuid,
    },
  ],
  has_profile: [
    {
      name: "address",
      type: DataType.Text,
    },
  ],
  add_passporting_club_as_owner: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "name",
      type: DataType.Text,
    },
  ],
  delete_passporting_club_as_owner: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  add_passporting_peer_as_owner: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "name",
      type: DataType.Text,
    },
    {
      name: "issuer_public_key",
      type: DataType.Text,
    },
    {
      name: "passporting_server_url_base",
      type: DataType.Text,
    },
  ],
  delete_passporting_peer_as_owner: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  update_passporting_peer_as_owner: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "name",
      type: DataType.Text,
    },
    {
      name: "issuer_public_key",
      type: DataType.Text,
    },
    {
      name: "passporting_server_url_base",
      type: DataType.Text,
    },
  ],
  add_peer_to_club_as_owner: [
    {
      name: "passporting_club_id",
      type: DataType.Uuid,
    },
    {
      name: "passporting_peer_id",
      type: DataType.Uuid,
    },
  ],
  delete_peer_from_club_as_owner: [
    {
      name: "passporting_club_id",
      type: DataType.Uuid,
    },
    {
      name: "passporting_peer_id",
      type: DataType.Uuid,
    },
  ],
  get_passporting_peers: [],
};
export const AddInserterAsOwnerInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  name: z.ZodString;
}> = z.object({
  id: z.uuid(),
  name: z.string(),
});

export type AddInserterAsOwnerInput = z.infer<typeof AddInserterAsOwnerInputSchema>;

/**  INSERTER AND DELEGATE ACTIONS */
export async function addInserterAsOwner(
  kwilClient: KwilActionClient,
  params: AddInserterAsOwnerInput,
): Promise<void> {
  const inputs = AddInserterAsOwnerInputSchema.parse(params);
  await kwilClient.execute({
    name: "add_inserter_as_owner",
    inputs,
    description: "Add inserter as owner",
  });
}

export const DeleteInserterAsOwnerInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type DeleteInserterAsOwnerInput = z.infer<typeof DeleteInserterAsOwnerInputSchema>;

export async function deleteInserterAsOwner(
  kwilClient: KwilActionClient,
  params: DeleteInserterAsOwnerInput,
): Promise<void> {
  const inputs = DeleteInserterAsOwnerInputSchema.parse(params);
  await kwilClient.execute({
    name: "delete_inserter_as_owner",
    inputs,
    description: "Delete inserter as owner",
  });
}

export const AddDelegateAsOwnerInputSchema: z.ZodObject<{
  address: z.ZodString;
  inserter_id: z.ZodUUID;
}> = z.object({
  address: z.string(),
  inserter_id: z.uuid(),
});

export type AddDelegateAsOwnerInput = z.infer<typeof AddDelegateAsOwnerInputSchema>;

export async function addDelegateAsOwner(
  kwilClient: KwilActionClient,
  params: AddDelegateAsOwnerInput,
): Promise<void> {
  const inputs = AddDelegateAsOwnerInputSchema.parse(params);
  await kwilClient.execute({
    name: "add_delegate_as_owner",
    inputs,
    description: "Add a delegate as owner",
  });
}

export const DeleteDelegateAsOwnerInputSchema: z.ZodObject<{
  address: z.ZodString;
}> = z.object({
  address: z.string(),
});

export type DeleteDelegateAsOwnerInput = z.infer<typeof DeleteDelegateAsOwnerInputSchema>;

export async function deleteDelegateAsOwner(
  kwilClient: KwilActionClient,
  params: DeleteDelegateAsOwnerInput,
): Promise<void> {
  const inputs = DeleteDelegateAsOwnerInputSchema.parse(params);
  await kwilClient.execute({
    name: "delete_delegate_as_owner",
    inputs,
    description: "Delete a delegate from idOS",
  });
}

export const GetInserterOutputSchema: z.ZodObject<{
  name: z.ZodString;
}> = z.object({
  name: z.string(),
});

export type GetInserterOutput = z.infer<typeof GetInserterOutputSchema>;

export async function getInserter(kwilClient: KwilActionClient): Promise<GetInserterOutput> {
  return await kwilClient
    .call<GetInserterOutput[]>({ name: "get_inserter", inputs: {} })
    .then((result) => result[0]);
}

export const GetInserterOrNullOutputSchema: z.ZodObject<{
  name: z.ZodString;
}> = z.object({
  name: z.string(),
});

export type GetInserterOrNullOutput = z.infer<typeof GetInserterOrNullOutputSchema>;

export async function getInserterOrNull(
  kwilClient: KwilActionClient,
): Promise<GetInserterOrNullOutput> {
  return await kwilClient
    .call<GetInserterOrNullOutput[]>({ name: "get_inserter_or_null", inputs: {} })
    .then((result) => result[0]);
}

export const AddUserAsInserterInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  recipient_encryption_public_key: z.ZodString;
  encryption_password_store: z.ZodString;
}> = z.object({
  id: z.uuid(),
  recipient_encryption_public_key: z.string(),
  encryption_password_store: z.string(),
});

export type AddUserAsInserterInput = z.infer<typeof AddUserAsInserterInputSchema>;

/**  USER ACTIONS */
export async function addUserAsInserter(
  kwilClient: KwilActionClient,
  params: AddUserAsInserterInput,
): Promise<void> {
  const inputs = AddUserAsInserterInputSchema.parse(params);
  await kwilClient.execute({
    name: "add_user_as_inserter",
    inputs,
    description: "Add a user to idOS",
  });
}

export const UpdateUserPubKeyAsInserterInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  recipient_encryption_public_key: z.ZodString;
  encryption_password_store: z.ZodString;
}> = z.object({
  id: z.uuid(),
  recipient_encryption_public_key: z.string(),
  encryption_password_store: z.string(),
});

export type UpdateUserPubKeyAsInserterInput = z.infer<typeof UpdateUserPubKeyAsInserterInputSchema>;

export async function updateUserPubKeyAsInserter(
  kwilClient: KwilActionClient,
  params: UpdateUserPubKeyAsInserterInput,
): Promise<void> {
  const inputs = UpdateUserPubKeyAsInserterInputSchema.parse(params);
  await kwilClient.execute({
    name: "update_user_pub_key_as_inserter",
    inputs,
    description:
      "Update user's encryption key and password store in idOS as inserter (profile creator)",
  });
}

export const GetUserOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  recipient_encryption_public_key: z.ZodString;
  encryption_password_store: z.ZodString;
}> = z.object({
  id: z.uuid(),
  recipient_encryption_public_key: z.string(),
  encryption_password_store: z.string(),
});

export type GetUserOutput = z.infer<typeof GetUserOutputSchema>;

export async function getUser(kwilClient: KwilActionClient): Promise<GetUserOutput> {
  return await kwilClient
    .call<GetUserOutput[]>({ name: "get_user", inputs: {} })
    .then((result) => result[0]);
}

export const GetUserAsInserterInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type GetUserAsInserterInput = z.infer<typeof GetUserAsInserterInputSchema>;

export const GetUserAsInserterOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  recipient_encryption_public_key: z.ZodString;
  encryption_password_store: z.ZodString;
  inserter: z.ZodString;
}> = z.object({
  id: z.uuid(),
  recipient_encryption_public_key: z.string(),
  encryption_password_store: z.string(),
  inserter: z.string(),
});

export type GetUserAsInserterOutput = z.infer<typeof GetUserAsInserterOutputSchema>;

export async function getUserAsInserter(
  kwilClient: KwilActionClient,
  params: GetUserAsInserterInput,
): Promise<GetUserAsInserterOutput> {
  const inputs = GetUserAsInserterInputSchema.parse(params);
  return await kwilClient
    .call<GetUserAsInserterOutput[]>({
      name: "get_user_as_inserter",
      inputs,
    })
    .then((result) => result[0]);
}

export const UpsertWalletAsInserterInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  address: z.ZodString;
  public_key: z.ZodString;
  wallet_type: z.ZodString;
  message: z.ZodString;
  signature: z.ZodString;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  address: z.string(),
  public_key: z.string(),
  wallet_type: z.string(),
  message: z.string(),
  signature: z.string(),
});

export type UpsertWalletAsInserterInput = z.infer<typeof UpsertWalletAsInserterInputSchema>;

/**  WALLET ACTIONS */
export async function upsertWalletAsInserter(
  kwilClient: KwilActionClient,
  params: UpsertWalletAsInserterInput,
): Promise<void> {
  const inputs = UpsertWalletAsInserterInputSchema.parse(params);
  await kwilClient.execute({
    name: "upsert_wallet_as_inserter",
    inputs,
    description: "Add a wallet to idOS by inserter (profile creator)",
  });
}

export const AddWalletInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  address: z.ZodString;
  public_key: z.ZodString;
  message: z.ZodString;
  signature: z.ZodString;
}> = z.object({
  id: z.uuid(),
  address: z.string(),
  public_key: z.string(),
  message: z.string(),
  signature: z.string(),
});

export type AddWalletInput = z.infer<typeof AddWalletInputSchema>;

export async function addWallet(
  kwilClient: KwilActionClient,
  params: AddWalletInput,
): Promise<void> {
  const inputs = AddWalletInputSchema.parse(params);
  await kwilClient.execute({
    name: "add_wallet",
    inputs,
    description: "Add a wallet to idOS",
  });
}

export const GetWalletsOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  address: z.ZodString;
  public_key: z.ZodString;
  wallet_type: z.ZodString;
  message: z.ZodString;
  signature: z.ZodString;
  inserter: z.ZodString;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  address: z.string(),
  public_key: z.string(),
  wallet_type: z.string(),
  message: z.string(),
  signature: z.string(),
  inserter: z.string(),
});

export type GetWalletsOutput = z.infer<typeof GetWalletsOutputSchema>;

export async function getWallets(kwilClient: KwilActionClient): Promise<GetWalletsOutput[]> {
  return await kwilClient.call<GetWalletsOutput[]>({ name: "get_wallets", inputs: {} });
}

export const RemoveWalletInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type RemoveWalletInput = z.infer<typeof RemoveWalletInputSchema>;

export async function removeWallet(
  kwilClient: KwilActionClient,
  params: RemoveWalletInput,
): Promise<void> {
  const inputs = RemoveWalletInputSchema.parse(params);
  await kwilClient.execute({
    name: "remove_wallet",
    inputs,
    description: "Remove a wallet from idOS",
  });
}

export const UpsertCredentialAsInserterInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  issuer_auth_public_key: z.ZodString;
  encryptor_public_key: z.ZodString;
  content: z.ZodString;
  public_notes: z.ZodString;
  public_notes_signature: z.ZodString;
  broader_signature: z.ZodString;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  issuer_auth_public_key: z.string(),
  encryptor_public_key: z.string(),
  content: z.string(),
  public_notes: z.string(),
  public_notes_signature: z.string(),
  broader_signature: z.string(),
});

export type UpsertCredentialAsInserterInput = z.infer<typeof UpsertCredentialAsInserterInputSchema>;

/**
 *  CREDENTIAL ACTIONS
 *  throw an error if not authorized
 */
export async function upsertCredentialAsInserter(
  kwilClient: KwilActionClient,
  params: UpsertCredentialAsInserterInput,
): Promise<void> {
  const inputs = UpsertCredentialAsInserterInputSchema.parse(params);
  await kwilClient.execute({
    name: "upsert_credential_as_inserter",
    inputs,
    description:
      "Add or update a credential in idOS on behalf of a user by permissioned profile creator (inserter) ",
  });
}

export const AddCredentialInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  issuer_auth_public_key: z.ZodString;
  encryptor_public_key: z.ZodString;
  content: z.ZodString;
  public_notes: z.ZodString;
  public_notes_signature: z.ZodString;
  broader_signature: z.ZodString;
}> = z.object({
  id: z.uuid(),
  issuer_auth_public_key: z.string(),
  encryptor_public_key: z.string(),
  content: z.string(),
  public_notes: z.string(),
  public_notes_signature: z.string(),
  broader_signature: z.string(),
});

export type AddCredentialInput = z.infer<typeof AddCredentialInputSchema>;

export async function addCredential(
  kwilClient: KwilActionClient,
  params: AddCredentialInput,
): Promise<void> {
  const inputs = AddCredentialInputSchema.parse(params);
  await kwilClient.execute({
    name: "add_credential",
    inputs,
    description: "Add a new credential",
  });
}

export const GetCredentialsOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  public_notes: z.ZodString;
  issuer_auth_public_key: z.ZodString;
  inserter: z.ZodNullable<z.ZodString>;
  original_id: z.ZodNullable<z.ZodUUID>;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  public_notes: z.string(),
  issuer_auth_public_key: z.string(),
  inserter: z.string().nullable(),
  original_id: z.uuid().nullable(),
});

export type GetCredentialsOutput = z.infer<typeof GetCredentialsOutputSchema>;

export async function getCredentials(
  kwilClient: KwilActionClient,
): Promise<GetCredentialsOutput[]> {
  return await kwilClient.call<GetCredentialsOutput[]>({ name: "get_credentials", inputs: {} });
}

export const GetCredentialsSharedByUserInputSchema: z.ZodObject<{
  user_id: z.ZodUUID;
  issuer_auth_public_key: z.ZodNullable<z.ZodString>;
}> = z.object({
  user_id: z.uuid(),
  issuer_auth_public_key: z.string().nullable(),
});

export type GetCredentialsSharedByUserInput = z.infer<typeof GetCredentialsSharedByUserInputSchema>;

export const GetCredentialsSharedByUserOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  public_notes: z.ZodString;
  encryptor_public_key: z.ZodString;
  issuer_auth_public_key: z.ZodString;
  inserter: z.ZodNullable<z.ZodString>;
  original_id: z.ZodNullable<z.ZodUUID>;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  public_notes: z.string(),
  encryptor_public_key: z.string(),
  issuer_auth_public_key: z.string(),
  inserter: z.string().nullable(),
  original_id: z.uuid().nullable(),
});

export type GetCredentialsSharedByUserOutput = z.infer<
  typeof GetCredentialsSharedByUserOutputSchema
>;

export async function getCredentialsSharedByUser(
  kwilClient: KwilActionClient,
  params: GetCredentialsSharedByUserInput,
): Promise<GetCredentialsSharedByUserOutput[]> {
  const inputs = GetCredentialsSharedByUserInputSchema.parse(params);
  return await kwilClient.call<GetCredentialsSharedByUserOutput[]>({
    name: "get_credentials_shared_by_user",
    inputs,
  });
}

export const EditCredentialInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  public_notes: z.ZodString;
  public_notes_signature: z.ZodString;
  broader_signature: z.ZodString;
  content: z.ZodString;
  encryptor_public_key: z.ZodString;
  issuer_auth_public_key: z.ZodString;
}> = z.object({
  id: z.uuid(),
  public_notes: z.string(),
  public_notes_signature: z.string(),
  broader_signature: z.string(),
  content: z.string(),
  encryptor_public_key: z.string(),
  issuer_auth_public_key: z.string(),
});

export type EditCredentialInput = z.infer<typeof EditCredentialInputSchema>;

/**
 *  we forbid to edit a copy
 *  only copies can have AGs, so data_id in AGs is id of a copy
 *  if $id is shared_credentials.copy_id - it is a copy
 */
export async function editCredential(
  kwilClient: KwilActionClient,
  params: EditCredentialInput,
): Promise<void> {
  const inputs = EditCredentialInputSchema.parse(params);
  await kwilClient.execute({
    name: "edit_credential",
    inputs,
    description: "Edit a credential",
  });
}

export const EditPublicNotesAsIssuerInputSchema: z.ZodObject<{
  public_notes_id: z.ZodString;
  public_notes: z.ZodString;
}> = z.object({
  public_notes_id: z.string(),
  public_notes: z.string(),
});

export type EditPublicNotesAsIssuerInput = z.infer<typeof EditPublicNotesAsIssuerInputSchema>;

/**
 *  Be aware that @caller here is ed25519 public key, hex encoded.
 *  All other @caller in the schema are either secp256k1 or nep413
 *  This action can't be called by kwil-cli (as kwil-cli uses secp256k1 only)
 */
export async function editPublicNotesAsIssuer(
  kwilClient: KwilActionClient,
  params: EditPublicNotesAsIssuerInput,
): Promise<void> {
  const inputs = EditPublicNotesAsIssuerInputSchema.parse(params);
  await kwilClient.execute({
    name: "edit_public_notes_as_issuer",
    inputs,
    description: "Edit public notes in a credential as issuer",
  });
}

export const RemoveCredentialInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type RemoveCredentialInput = z.infer<typeof RemoveCredentialInputSchema>;

export async function removeCredential(
  kwilClient: KwilActionClient,
  params: RemoveCredentialInput,
): Promise<void> {
  const inputs = RemoveCredentialInputSchema.parse(params);
  await kwilClient.execute({
    name: "remove_credential",
    inputs,
    description: "Remove a credential from your idOS profile",
  });
}

export const RescindSharedCredentialInputSchema: z.ZodObject<{
  credential_id: z.ZodUUID;
}> = z.object({
  credential_id: z.uuid(),
});

export type RescindSharedCredentialInput = z.infer<typeof RescindSharedCredentialInputSchema>;

export async function rescindSharedCredential(
  kwilClient: KwilActionClient,
  params: RescindSharedCredentialInput,
): Promise<void> {
  const inputs = RescindSharedCredentialInputSchema.parse(params);
  await kwilClient.execute({
    name: "rescind_shared_credential",
    inputs,
  });
}

export const ShareCredentialInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  original_credential_id: z.ZodUUID;
  public_notes: z.ZodString;
  public_notes_signature: z.ZodString;
  broader_signature: z.ZodString;
  content: z.ZodString;
  content_hash: z.ZodString;
  encryptor_public_key: z.ZodString;
  issuer_auth_public_key: z.ZodString;
  grantee_wallet_identifier: z.ZodString;
  locked_until: z.ZodNumber;
}> = z.object({
  id: z.uuid(),
  original_credential_id: z.uuid(),
  public_notes: z.string(),
  public_notes_signature: z.string(),
  broader_signature: z.string(),
  content: z.string(),
  content_hash: z.string(),
  encryptor_public_key: z.string(),
  issuer_auth_public_key: z.string(),
  grantee_wallet_identifier: z.string(),
  locked_until: z.number(),
});

export type ShareCredentialInput = z.infer<typeof ShareCredentialInputSchema>;

export async function shareCredential(
  kwilClient: KwilActionClient,
  params: ShareCredentialInput,
): Promise<void> {
  const inputs = ShareCredentialInputSchema.parse(params);
  await kwilClient.execute({
    name: "share_credential",
    inputs,
    description: "Share a credential with creating AG",
  });
}

export const CreateCredentialCopyInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  original_credential_id: z.ZodUUID;
  public_notes: z.ZodString;
  public_notes_signature: z.ZodString;
  broader_signature: z.ZodString;
  content: z.ZodString;
  encryptor_public_key: z.ZodString;
  issuer_auth_public_key: z.ZodString;
}> = z.object({
  id: z.uuid(),
  original_credential_id: z.uuid(),
  public_notes: z.string(),
  public_notes_signature: z.string(),
  broader_signature: z.string(),
  content: z.string(),
  encryptor_public_key: z.string(),
  issuer_auth_public_key: z.string(),
});

export type CreateCredentialCopyInput = z.infer<typeof CreateCredentialCopyInputSchema>;

/**  Passporting scenario */
export async function createCredentialCopy(
  kwilClient: KwilActionClient,
  params: CreateCredentialCopyInput,
): Promise<void> {
  const inputs = CreateCredentialCopyInputSchema.parse(params);
  await kwilClient.execute({
    name: "create_credential_copy",
    inputs,
    description: "Share a credential without AG (access grant)",
  });
}

export const ShareCredentialThroughDagInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  issuer_auth_public_key: z.ZodString;
  encryptor_public_key: z.ZodString;
  content: z.ZodString;
  content_hash: z.ZodString;
  public_notes: z.ZodString;
  public_notes_signature: z.ZodString;
  broader_signature: z.ZodString;
  original_credential_id: z.ZodUUID;
  dag_owner_wallet_identifier: z.ZodString;
  dag_grantee_wallet_identifier: z.ZodString;
  dag_locked_until: z.ZodNumber;
  dag_signature: z.ZodString;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  issuer_auth_public_key: z.string(),
  encryptor_public_key: z.string(),
  content: z.string(),
  content_hash: z.string(),
  public_notes: z.string(),
  public_notes_signature: z.string(),
  broader_signature: z.string(),
  original_credential_id: z.uuid(),
  dag_owner_wallet_identifier: z.string(),
  dag_grantee_wallet_identifier: z.string(),
  dag_locked_until: z.number(),
  dag_signature: z.string(),
});

export type ShareCredentialThroughDagInput = z.infer<typeof ShareCredentialThroughDagInputSchema>;

/**
 *  It can be used with EVM-compatible signatures only
 *  This works for EVM-compatible signatures only
 */
export async function shareCredentialThroughDag(
  kwilClient: KwilActionClient,
  params: ShareCredentialThroughDagInput,
): Promise<void> {
  const inputs = ShareCredentialThroughDagInputSchema.parse(params);
  await kwilClient.execute({
    name: "share_credential_through_dag",
    inputs,
    description: "Share a credential through the DAG",
  });
}

export const CreateCredentialsByDwgInputSchema: z.ZodObject<{
  issuer_auth_public_key: z.ZodString;
  original_encryptor_public_key: z.ZodString;
  original_credential_id: z.ZodUUID;
  original_content: z.ZodString;
  original_public_notes: z.ZodString;
  original_public_notes_signature: z.ZodString;
  original_broader_signature: z.ZodString;
  copy_encryptor_public_key: z.ZodString;
  copy_credential_id: z.ZodUUID;
  copy_content: z.ZodString;
  copy_public_notes_signature: z.ZodString;
  copy_broader_signature: z.ZodString;
  content_hash: z.ZodString;
  dwg_owner: z.ZodString;
  dwg_grantee: z.ZodString;
  dwg_issuer_public_key: z.ZodString;
  dwg_id: z.ZodUUID;
  dwg_access_grant_timelock: z.ZodString;
  dwg_not_before: z.ZodString;
  dwg_not_after: z.ZodString;
  dwg_signature: z.ZodString;
}> = z.object({
  issuer_auth_public_key: z.string(),
  original_encryptor_public_key: z.string(),
  original_credential_id: z.uuid(),
  original_content: z.string(),
  original_public_notes: z.string(),
  original_public_notes_signature: z.string(),
  original_broader_signature: z.string(),
  copy_encryptor_public_key: z.string(),
  copy_credential_id: z.uuid(),
  copy_content: z.string(),
  copy_public_notes_signature: z.string(),
  copy_broader_signature: z.string(),
  content_hash: z.string(),
  dwg_owner: z.string(),
  dwg_grantee: z.string(),
  dwg_issuer_public_key: z.string(),
  dwg_id: z.uuid(),
  dwg_access_grant_timelock: z.string(),
  dwg_not_before: z.string(),
  dwg_not_after: z.string(),
  dwg_signature: z.string(),
});

export type CreateCredentialsByDwgInput = z.infer<typeof CreateCredentialsByDwgInputSchema>;

/**
 *  For access grant
 *  Check the content creator (encryptor) of credentials is the issuer that user delegated to issue the credentials
 *  Get the wallet type and public key for XRPL/NEAR wallets from database
 *  Will fail if not in the RFC3339 format
 *  Check the format and precedence
 *  Check if current block timestamp in time range allowed by write grant.
 *  @block_timestamp is a timestamp of previous block, which is can be a few seconds earlier
 *  (max is 6 seconds in current network consensus settings) then a time on a requester's machine.
 *  Also, if requester's machine has wrong time, it can be an issue.
 *  Insert original credential
 *  Insert copy credential
 */
export async function createCredentialsByDwg(
  kwilClient: KwilActionClient,
  params: CreateCredentialsByDwgInput,
): Promise<void> {
  const inputs = CreateCredentialsByDwgInputSchema.parse(params);
  await kwilClient.execute({
    name: "create_credentials_by_dwg",
    inputs,
    description:
      "Add original credential and copy credential with AG on behalf of a user (using delegated write grant given by the user)",
  });
}

export const CredentialExistAsInserterInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type CredentialExistAsInserterInput = z.infer<typeof CredentialExistAsInserterInputSchema>;

export const CredentialExistAsInserterOutputSchema: z.ZodObject<{
  credential_exist: z.ZodBoolean;
}> = z.object({
  credential_exist: z.boolean(),
});

export type CredentialExistAsInserterOutput = z.infer<typeof CredentialExistAsInserterOutputSchema>;

export async function credentialExistAsInserter(
  kwilClient: KwilActionClient,
  params: CredentialExistAsInserterInput,
): Promise<CredentialExistAsInserterOutput> {
  const inputs = CredentialExistAsInserterInputSchema.parse(params);
  return await kwilClient
    .call<CredentialExistAsInserterOutput[]>({
      name: "credential_exist_as_inserter",
      inputs,
    })
    .then((result) => result[0]);
}

export const GetCredentialOwnedInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type GetCredentialOwnedInput = z.infer<typeof GetCredentialOwnedInputSchema>;

export const GetCredentialOwnedOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  public_notes: z.ZodString;
  content: z.ZodString;
  encryptor_public_key: z.ZodString;
  issuer_auth_public_key: z.ZodString;
  inserter: z.ZodNullable<z.ZodString>;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  public_notes: z.string(),
  content: z.string(),
  encryptor_public_key: z.string(),
  issuer_auth_public_key: z.string(),
  inserter: z.string().nullable(),
});

export type GetCredentialOwnedOutput = z.infer<typeof GetCredentialOwnedOutputSchema>;

export async function getCredentialOwned(
  kwilClient: KwilActionClient,
  params: GetCredentialOwnedInput,
): Promise<GetCredentialOwnedOutput[]> {
  const inputs = GetCredentialOwnedInputSchema.parse(params);
  return await kwilClient.call<GetCredentialOwnedOutput[]>({
    name: "get_credential_owned",
    inputs,
  });
}

export const GetCredentialSharedInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type GetCredentialSharedInput = z.infer<typeof GetCredentialSharedInputSchema>;

export const GetCredentialSharedOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  public_notes: z.ZodString;
  content: z.ZodString;
  encryptor_public_key: z.ZodString;
  issuer_auth_public_key: z.ZodString;
  inserter: z.ZodNullable<z.ZodString>;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  public_notes: z.string(),
  content: z.string(),
  encryptor_public_key: z.string(),
  issuer_auth_public_key: z.string(),
  inserter: z.string().nullable(),
});

export type GetCredentialSharedOutput = z.infer<typeof GetCredentialSharedOutputSchema>;

/**  As a credential copy doesn't contain PUBLIC notes, we return respective original credential PUBLIC notes */
export async function getCredentialShared(
  kwilClient: KwilActionClient,
  params: GetCredentialSharedInput,
): Promise<GetCredentialSharedOutput[]> {
  const inputs = GetCredentialSharedInputSchema.parse(params);
  return await kwilClient.call<GetCredentialSharedOutput[]>({
    name: "get_credential_shared",
    inputs,
  });
}

export const GetSiblingCredentialIdInputSchema: z.ZodObject<{
  content_hash: z.ZodString;
}> = z.object({
  content_hash: z.string(),
});

export type GetSiblingCredentialIdInput = z.infer<typeof GetSiblingCredentialIdInputSchema>;

export const GetSiblingCredentialIdOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type GetSiblingCredentialIdOutput = z.infer<typeof GetSiblingCredentialIdOutputSchema>;

export async function getSiblingCredentialId(
  kwilClient: KwilActionClient,
  params: GetSiblingCredentialIdInput,
): Promise<GetSiblingCredentialIdOutput> {
  const inputs = GetSiblingCredentialIdInputSchema.parse(params);
  return await kwilClient
    .call<GetSiblingCredentialIdOutput[]>({
      name: "get_sibling_credential_id",
      inputs,
    })
    .then((result) => result[0]);
}

export const CredentialBelongsToCallerInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type CredentialBelongsToCallerInput = z.infer<typeof CredentialBelongsToCallerInputSchema>;

export const CredentialBelongsToCallerOutputSchema: z.ZodObject<{
  belongs: z.ZodBoolean;
}> = z.object({
  belongs: z.boolean(),
});

export type CredentialBelongsToCallerOutput = z.infer<typeof CredentialBelongsToCallerOutputSchema>;

export async function credentialBelongsToCaller(
  kwilClient: KwilActionClient,
  params: CredentialBelongsToCallerInput,
): Promise<CredentialBelongsToCallerOutput> {
  const inputs = CredentialBelongsToCallerInputSchema.parse(params);
  return await kwilClient
    .call<CredentialBelongsToCallerOutput[]>({
      name: "credential_belongs_to_caller",
      inputs,
    })
    .then((result) => result[0]);
}

export const CredentialExistInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type CredentialExistInput = z.infer<typeof CredentialExistInputSchema>;

export const CredentialExistOutputSchema: z.ZodObject<{
  credential_exist: z.ZodBoolean;
}> = z.object({
  credential_exist: z.boolean(),
});

export type CredentialExistOutput = z.infer<typeof CredentialExistOutputSchema>;

export async function credentialExist(
  kwilClient: KwilActionClient,
  params: CredentialExistInput,
): Promise<CredentialExistOutput> {
  const inputs = CredentialExistInputSchema.parse(params);
  return await kwilClient
    .call<CredentialExistOutput[]>({
      name: "credential_exist",
      inputs,
    })
    .then((result) => result[0]);
}

export const AddAttributeAsInserterInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  attribute_key: z.ZodString;
  value: z.ZodString;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  attribute_key: z.string(),
  value: z.string(),
});

export type AddAttributeAsInserterInput = z.infer<typeof AddAttributeAsInserterInputSchema>;

/**  ATTRIBUTE ACTIONS */
export async function addAttributeAsInserter(
  kwilClient: KwilActionClient,
  params: AddAttributeAsInserterInput,
): Promise<void> {
  const inputs = AddAttributeAsInserterInputSchema.parse(params);
  await kwilClient.execute({
    name: "add_attribute_as_inserter",
    inputs,
    description: "Add a new attribute as inserter",
  });
}

export const AddAttributeInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  attribute_key: z.ZodString;
  value: z.ZodString;
}> = z.object({
  id: z.uuid(),
  attribute_key: z.string(),
  value: z.string(),
});

export type AddAttributeInput = z.infer<typeof AddAttributeInputSchema>;

export async function addAttribute(
  kwilClient: KwilActionClient,
  params: AddAttributeInput,
): Promise<void> {
  const inputs = AddAttributeInputSchema.parse(params);
  await kwilClient.execute({
    name: "add_attribute",
    inputs,
    description: "Create a new attribute in your idOS profile",
  });
}

export const GetAttributesOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  attribute_key: z.ZodString;
  value: z.ZodString;
  original_id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  attribute_key: z.string(),
  value: z.string(),
  original_id: z.uuid(),
});

export type GetAttributesOutput = z.infer<typeof GetAttributesOutputSchema>;

export async function getAttributes(kwilClient: KwilActionClient): Promise<GetAttributesOutput[]> {
  return await kwilClient.call<GetAttributesOutput[]>({ name: "get_attributes", inputs: {} });
}

export const EditAttributeInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  attribute_key: z.ZodString;
  value: z.ZodString;
}> = z.object({
  id: z.uuid(),
  attribute_key: z.string(),
  value: z.string(),
});

export type EditAttributeInput = z.infer<typeof EditAttributeInputSchema>;

export async function editAttribute(
  kwilClient: KwilActionClient,
  params: EditAttributeInput,
): Promise<void> {
  const inputs = EditAttributeInputSchema.parse(params);
  await kwilClient.execute({
    name: "edit_attribute",
    inputs,
    description: "Edit an existing attribute",
  });
}

export const RemoveAttributeInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type RemoveAttributeInput = z.infer<typeof RemoveAttributeInputSchema>;

export async function removeAttribute(
  kwilClient: KwilActionClient,
  params: RemoveAttributeInput,
): Promise<void> {
  const inputs = RemoveAttributeInputSchema.parse(params);
  await kwilClient.execute({
    name: "remove_attribute",
    inputs,
    description: "Remove an existing attribute",
  });
}

export const ShareAttributeInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  original_attribute_id: z.ZodUUID;
  attribute_key: z.ZodString;
  value: z.ZodString;
}> = z.object({
  id: z.uuid(),
  original_attribute_id: z.uuid(),
  attribute_key: z.string(),
  value: z.string(),
});

export type ShareAttributeInput = z.infer<typeof ShareAttributeInputSchema>;

export async function shareAttribute(
  kwilClient: KwilActionClient,
  params: ShareAttributeInput,
): Promise<void> {
  const inputs = ShareAttributeInputSchema.parse(params);
  await kwilClient.execute({
    name: "share_attribute",
    inputs,
    description: "Share an attribute",
  });
}

export const DwgMessageInputSchema: z.ZodObject<{
  owner_wallet_identifier: z.ZodString;
  grantee_wallet_identifier: z.ZodString;
  issuer_public_key: z.ZodString;
  id: z.ZodUUID;
  access_grant_timelock: z.ZodString;
  not_usable_before: z.ZodString;
  not_usable_after: z.ZodString;
}> = z.object({
  owner_wallet_identifier: z.string(),
  grantee_wallet_identifier: z.string(),
  issuer_public_key: z.string(),
  id: z.uuid(),
  access_grant_timelock: z.string(),
  not_usable_before: z.string(),
  not_usable_after: z.string(),
});

export type DwgMessageInput = z.infer<typeof DwgMessageInputSchema>;

export const DwgMessageOutputSchema: z.ZodObject<{
  message: z.ZodString;
}> = z.object({
  message: z.string(),
});

export type DwgMessageOutput = z.infer<typeof DwgMessageOutputSchema>;

/**
 *  WRITE GRANTS ACTIONS
 *  Must be in yyyy-mm-ddThh:mm:ssZ format
 *  Must be in yyyy-mm-ddThh:mm:ssZ format
 *  Must be in yyyy-mm-ddThh:mm:ssZ format
 *  Will fail if not in the yyyy-mm-ddThh:mm:ssZ format, and not comply to RFC3339
 *  Check the format and precedence
 */
export async function dwgMessage(
  kwilClient: KwilActionClient,
  params: DwgMessageInput,
): Promise<DwgMessageOutput> {
  const inputs = DwgMessageInputSchema.parse(params);
  return await kwilClient
    .call<DwgMessageOutput[]>({
      name: "dwg_message",
      inputs,
    })
    .then((result) => result[0]);
}

export const RevokeAccessGrantInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type RevokeAccessGrantInput = z.infer<typeof RevokeAccessGrantInputSchema>;

/**  ACCESS GRANTS ACTIONS */
export async function revokeAccessGrant(
  kwilClient: KwilActionClient,
  params: RevokeAccessGrantInput,
): Promise<void> {
  const inputs = RevokeAccessGrantInputSchema.parse(params);
  await kwilClient.execute({
    name: "revoke_access_grant",
    inputs,
    description: "Revoke an Access Grant from idOS",
  });
}

export const GetAccessGrantsOwnedOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  ag_owner_user_id: z.ZodUUID;
  ag_grantee_wallet_identifier: z.ZodString;
  data_id: z.ZodUUID;
  locked_until: z.ZodNumber;
  content_hash: z.ZodNullable<z.ZodString>;
  inserter_type: z.ZodString;
  inserter_id: z.ZodString;
}> = z.object({
  id: z.uuid(),
  ag_owner_user_id: z.uuid(),
  ag_grantee_wallet_identifier: z.string(),
  data_id: z.uuid(),
  locked_until: z.number(),
  content_hash: z.string().nullable(),
  inserter_type: z.string(),
  inserter_id: z.string(),
});

export type GetAccessGrantsOwnedOutput = z.infer<typeof GetAccessGrantsOwnedOutputSchema>;

export async function getAccessGrantsOwned(
  kwilClient: KwilActionClient,
): Promise<GetAccessGrantsOwnedOutput[]> {
  return await kwilClient.call<GetAccessGrantsOwnedOutput[]>({
    name: "get_access_grants_owned",
    inputs: {},
  });
}

export const GetAccessGrantsGrantedInputSchema: z.ZodObject<{
  user_id: z.ZodNullable<z.ZodUUID>;
  page: z.ZodNumber;
  size: z.ZodNumber;
}> = z.object({
  user_id: z.uuid().nullable(),
  page: z.number(),
  size: z.number(),
});

export type GetAccessGrantsGrantedInput = z.infer<typeof GetAccessGrantsGrantedInputSchema>;

export const GetAccessGrantsGrantedOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  ag_owner_user_id: z.ZodUUID;
  ag_grantee_wallet_identifier: z.ZodString;
  data_id: z.ZodUUID;
  locked_until: z.ZodNumber;
  content_hash: z.ZodNullable<z.ZodString>;
  inserter_type: z.ZodString;
  inserter_id: z.ZodString;
}> = z.object({
  id: z.uuid(),
  ag_owner_user_id: z.uuid(),
  ag_grantee_wallet_identifier: z.string(),
  data_id: z.uuid(),
  locked_until: z.number(),
  content_hash: z.string().nullable(),
  inserter_type: z.string(),
  inserter_id: z.string(),
});

export type GetAccessGrantsGrantedOutput = z.infer<typeof GetAccessGrantsGrantedOutputSchema>;

/**
 *  As arguments can be undefined (user can not send them at all), we have to have default values: page=1, size=20
 *  Page number starts from 1, as UI usually shows to user in pagination element
 *  Ordering is consistent because we use height as first ordering parameter
 */
export async function getAccessGrantsGranted(
  kwilClient: KwilActionClient,
  params: GetAccessGrantsGrantedInput,
): Promise<GetAccessGrantsGrantedOutput[]> {
  const inputs = GetAccessGrantsGrantedInputSchema.parse(params);
  return await kwilClient.call<GetAccessGrantsGrantedOutput[]>({
    name: "get_access_grants_granted",
    inputs,
  });
}

export const GetAccessGrantsGrantedCountInputSchema: z.ZodObject<{
  user_id: z.ZodNullable<z.ZodUUID>;
}> = z.object({
  user_id: z.uuid().nullable(),
});

export type GetAccessGrantsGrantedCountInput = z.infer<
  typeof GetAccessGrantsGrantedCountInputSchema
>;

export const GetAccessGrantsGrantedCountOutputSchema: z.ZodObject<{
  count: z.ZodNumber;
}> = z.object({
  count: z.number(),
});

export type GetAccessGrantsGrantedCountOutput = z.infer<
  typeof GetAccessGrantsGrantedCountOutputSchema
>;

export async function getAccessGrantsGrantedCount(
  kwilClient: KwilActionClient,
  params: GetAccessGrantsGrantedCountInput,
): Promise<GetAccessGrantsGrantedCountOutput> {
  const inputs = GetAccessGrantsGrantedCountInputSchema.parse(params);
  return await kwilClient
    .call<GetAccessGrantsGrantedCountOutput[]>({
      name: "get_access_grants_granted_count",
      inputs,
    })
    .then((result) => result[0]);
}

export const HasLockedAccessGrantsInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type HasLockedAccessGrantsInput = z.infer<typeof HasLockedAccessGrantsInputSchema>;

export const HasLockedAccessGrantsOutputSchema: z.ZodObject<{
  has: z.ZodBoolean;
}> = z.object({
  has: z.boolean(),
});

export type HasLockedAccessGrantsOutput = z.infer<typeof HasLockedAccessGrantsOutputSchema>;

export async function hasLockedAccessGrants(
  kwilClient: KwilActionClient,
  params: HasLockedAccessGrantsInput,
): Promise<HasLockedAccessGrantsOutput> {
  const inputs = HasLockedAccessGrantsInputSchema.parse(params);
  return await kwilClient
    .call<HasLockedAccessGrantsOutput[]>({
      name: "has_locked_access_grants",
      inputs,
    })
    .then((result) => result[0]);
}

export const DagMessageInputSchema: z.ZodObject<{
  dag_owner_wallet_identifier: z.ZodString;
  dag_grantee_wallet_identifier: z.ZodString;
  dag_data_id: z.ZodUUID;
  dag_locked_until: z.ZodNumber;
  dag_content_hash: z.ZodString;
}> = z.object({
  dag_owner_wallet_identifier: z.string(),
  dag_grantee_wallet_identifier: z.string(),
  dag_data_id: z.uuid(),
  dag_locked_until: z.number(),
  dag_content_hash: z.string(),
});

export type DagMessageInput = z.infer<typeof DagMessageInputSchema>;

export const DagMessageOutputSchema: z.ZodObject<{
  message: z.ZodString;
}> = z.object({
  message: z.string(),
});

export type DagMessageOutput = z.infer<typeof DagMessageOutputSchema>;

export async function dagMessage(
  kwilClient: KwilActionClient,
  params: DagMessageInput,
): Promise<DagMessageOutput> {
  const inputs = DagMessageInputSchema.parse(params);
  return await kwilClient
    .call<DagMessageOutput[]>({
      name: "dag_message",
      inputs,
    })
    .then((result) => result[0]);
}

export const CreateAgByDagForCopyInputSchema: z.ZodObject<{
  dag_owner_wallet_identifier: z.ZodString;
  dag_grantee_wallet_identifier: z.ZodString;
  dag_data_id: z.ZodUUID;
  dag_locked_until: z.ZodNumber;
  dag_content_hash: z.ZodString;
  dag_signature: z.ZodString;
}> = z.object({
  dag_owner_wallet_identifier: z.string(),
  dag_grantee_wallet_identifier: z.string(),
  dag_data_id: z.uuid(),
  dag_locked_until: z.number(),
  dag_content_hash: z.string(),
  dag_signature: z.string(),
});

export type CreateAgByDagForCopyInput = z.infer<typeof CreateAgByDagForCopyInputSchema>;

/**
 *  Get the wallet type and public key for XRPL/NEAR wallets from database
 *  This works for EVM-compatible signatures only
 */
export async function createAgByDagForCopy(
  kwilClient: KwilActionClient,
  params: CreateAgByDagForCopyInput,
): Promise<void> {
  const inputs = CreateAgByDagForCopyInputSchema.parse(params);
  await kwilClient.execute({
    name: "create_ag_by_dag_for_copy",
    inputs,
    description: "Create an Access Grant in idOS",
  });
}

export const CreateAccessGrantInputSchema: z.ZodObject<{
  grantee_wallet_identifier: z.ZodString;
  data_id: z.ZodUUID;
  locked_until: z.ZodNumber;
  content_hash: z.ZodString;
  inserter_type: z.ZodString;
  inserter_id: z.ZodString;
}> = z.object({
  grantee_wallet_identifier: z.string(),
  data_id: z.uuid(),
  locked_until: z.number(),
  content_hash: z.string(),
  inserter_type: z.string(),
  inserter_id: z.string(),
});

export type CreateAccessGrantInput = z.infer<typeof CreateAccessGrantInputSchema>;

/**  data_id is an id of a copy. It always has a user. So if no user found then there is no credential found. */
export async function createAccessGrant(
  kwilClient: KwilActionClient,
  params: CreateAccessGrantInput,
): Promise<void> {
  const inputs = CreateAccessGrantInputSchema.parse(params);
  await kwilClient.execute({
    name: "create_access_grant",
    inputs,
    description: "Create a new access grant",
  });
}

export const GetAccessGrantsForCredentialInputSchema: z.ZodObject<{
  credential_id: z.ZodUUID;
}> = z.object({
  credential_id: z.uuid(),
});

export type GetAccessGrantsForCredentialInput = z.infer<
  typeof GetAccessGrantsForCredentialInputSchema
>;

export const GetAccessGrantsForCredentialOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  ag_owner_user_id: z.ZodUUID;
  ag_grantee_wallet_identifier: z.ZodString;
  data_id: z.ZodUUID;
  locked_until: z.ZodNumber;
  content_hash: z.ZodNullable<z.ZodString>;
  inserter_type: z.ZodString;
  inserter_id: z.ZodString;
}> = z.object({
  id: z.uuid(),
  ag_owner_user_id: z.uuid(),
  ag_grantee_wallet_identifier: z.string(),
  data_id: z.uuid(),
  locked_until: z.number(),
  content_hash: z.string().nullable(),
  inserter_type: z.string(),
  inserter_id: z.string(),
});

export type GetAccessGrantsForCredentialOutput = z.infer<
  typeof GetAccessGrantsForCredentialOutputSchema
>;

export async function getAccessGrantsForCredential(
  kwilClient: KwilActionClient,
  params: GetAccessGrantsForCredentialInput,
): Promise<GetAccessGrantsForCredentialOutput[]> {
  const inputs = GetAccessGrantsForCredentialInputSchema.parse(params);
  return await kwilClient.call<GetAccessGrantsForCredentialOutput[]>({
    name: "get_access_grants_for_credential",
    inputs,
  });
}

export const HasProfileInputSchema: z.ZodObject<{
  address: z.ZodString;
}> = z.object({
  address: z.string(),
});

export type HasProfileInput = z.infer<typeof HasProfileInputSchema>;

export const HasProfileOutputSchema: z.ZodObject<{
  has_profile: z.ZodBoolean;
}> = z.object({
  has_profile: z.boolean(),
});

export type HasProfileOutput = z.infer<typeof HasProfileOutputSchema>;

/**
 *  OTHER ACTIONS
 *  Should we improve it to work with near wallets too?
 */
export async function hasProfile(
  kwilClient: KwilActionClient,
  params: HasProfileInput,
): Promise<HasProfileOutput> {
  const inputs = HasProfileInputSchema.parse(params);
  return await kwilClient
    .call<HasProfileOutput[]>(
      {
        name: "has_profile",
        inputs,
      },
      undefined, // Signer is not required here
    )
    .then((result) => result[0]);
}

export const AddPassportingClubAsOwnerInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  name: z.ZodString;
}> = z.object({
  id: z.uuid(),
  name: z.string(),
});

export type AddPassportingClubAsOwnerInput = z.infer<typeof AddPassportingClubAsOwnerInputSchema>;

/**  PASSPORTING CLUB ACTIONS */
export async function addPassportingClubAsOwner(
  kwilClient: KwilActionClient,
  params: AddPassportingClubAsOwnerInput,
): Promise<void> {
  const inputs = AddPassportingClubAsOwnerInputSchema.parse(params);
  await kwilClient.execute({
    name: "add_passporting_club_as_owner",
    inputs,
    description: "Add a new passporting club as owner",
  });
}

export const DeletePassportingClubAsOwnerInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type DeletePassportingClubAsOwnerInput = z.infer<
  typeof DeletePassportingClubAsOwnerInputSchema
>;

export async function deletePassportingClubAsOwner(
  kwilClient: KwilActionClient,
  params: DeletePassportingClubAsOwnerInput,
): Promise<void> {
  const inputs = DeletePassportingClubAsOwnerInputSchema.parse(params);
  await kwilClient.execute({
    name: "delete_passporting_club_as_owner",
    inputs,
    description: "Delete a passporting club as owner",
  });
}

export const AddPassportingPeerAsOwnerInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  name: z.ZodString;
  issuer_public_key: z.ZodString;
  passporting_server_url_base: z.ZodString;
}> = z.object({
  id: z.uuid(),
  name: z.string(),
  issuer_public_key: z.string(),
  passporting_server_url_base: z.string(),
});

export type AddPassportingPeerAsOwnerInput = z.infer<typeof AddPassportingPeerAsOwnerInputSchema>;

export async function addPassportingPeerAsOwner(
  kwilClient: KwilActionClient,
  params: AddPassportingPeerAsOwnerInput,
): Promise<void> {
  const inputs = AddPassportingPeerAsOwnerInputSchema.parse(params);
  await kwilClient.execute({
    name: "add_passporting_peer_as_owner",
    inputs,
    description: "Add a passporting peer as owner",
  });
}

export const DeletePassportingPeerAsOwnerInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type DeletePassportingPeerAsOwnerInput = z.infer<
  typeof DeletePassportingPeerAsOwnerInputSchema
>;

export async function deletePassportingPeerAsOwner(
  kwilClient: KwilActionClient,
  params: DeletePassportingPeerAsOwnerInput,
): Promise<void> {
  const inputs = DeletePassportingPeerAsOwnerInputSchema.parse(params);
  await kwilClient.execute({
    name: "delete_passporting_peer_as_owner",
    inputs,
    description: "Delete a passporting peer as owner",
  });
}

export const UpdatePassportingPeerAsOwnerInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  name: z.ZodString;
  issuer_public_key: z.ZodString;
  passporting_server_url_base: z.ZodString;
}> = z.object({
  id: z.uuid(),
  name: z.string(),
  issuer_public_key: z.string(),
  passporting_server_url_base: z.string(),
});

export type UpdatePassportingPeerAsOwnerInput = z.infer<
  typeof UpdatePassportingPeerAsOwnerInputSchema
>;

export async function updatePassportingPeerAsOwner(
  kwilClient: KwilActionClient,
  params: UpdatePassportingPeerAsOwnerInput,
): Promise<void> {
  const inputs = UpdatePassportingPeerAsOwnerInputSchema.parse(params);
  await kwilClient.execute({
    name: "update_passporting_peer_as_owner",
    inputs,
    description: "Update a passporting peer as owner",
  });
}

export const AddPeerToClubAsOwnerInputSchema: z.ZodObject<{
  passporting_club_id: z.ZodUUID;
  passporting_peer_id: z.ZodUUID;
}> = z.object({
  passporting_club_id: z.uuid(),
  passporting_peer_id: z.uuid(),
});

export type AddPeerToClubAsOwnerInput = z.infer<typeof AddPeerToClubAsOwnerInputSchema>;

export async function addPeerToClubAsOwner(
  kwilClient: KwilActionClient,
  params: AddPeerToClubAsOwnerInput,
): Promise<void> {
  const inputs = AddPeerToClubAsOwnerInputSchema.parse(params);
  await kwilClient.execute({
    name: "add_peer_to_club_as_owner",
    inputs,
    description: "Add a peer to a passporting club as owner",
  });
}

export const DeletePeerFromClubAsOwnerInputSchema: z.ZodObject<{
  passporting_club_id: z.ZodUUID;
  passporting_peer_id: z.ZodUUID;
}> = z.object({
  passporting_club_id: z.uuid(),
  passporting_peer_id: z.uuid(),
});

export type DeletePeerFromClubAsOwnerInput = z.infer<typeof DeletePeerFromClubAsOwnerInputSchema>;

export async function deletePeerFromClubAsOwner(
  kwilClient: KwilActionClient,
  params: DeletePeerFromClubAsOwnerInput,
): Promise<void> {
  const inputs = DeletePeerFromClubAsOwnerInputSchema.parse(params);
  await kwilClient.execute({
    name: "delete_peer_from_club_as_owner",
    inputs,
    description: "Delete a peer from a passporting club as owner",
  });
}

export const GetPassportingPeersOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  name: z.ZodString;
  issuer_public_key: z.ZodString;
  passporting_server_url_base: z.ZodString;
  club_id: z.ZodUUID;
  club_name: z.ZodString;
}> = z.object({
  id: z.uuid(),
  name: z.string(),
  issuer_public_key: z.string(),
  passporting_server_url_base: z.string(),
  club_id: z.uuid(),
  club_name: z.string(),
});

export type GetPassportingPeersOutput = z.infer<typeof GetPassportingPeersOutputSchema>;

/**  get clubs the peer belongs to */
export async function getPassportingPeers(
  kwilClient: KwilActionClient,
): Promise<GetPassportingPeersOutput[]> {
  return await kwilClient.call<GetPassportingPeersOutput[]>({
    name: "get_passporting_peers",
    inputs: {},
  });
}
