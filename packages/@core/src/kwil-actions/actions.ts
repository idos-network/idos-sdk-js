import { Utils } from "@idos-network/kwil-js";
import * as z from "zod";
import type { KwilActionClient } from "../kwil-infra";

// This file is generated by the generator. Do not edit it manually.
export const DataType: typeof Utils.DataType = Utils.DataType;

export type ActionSchemaElement = {
  name: string;
  type: typeof DataType.Uuid | typeof DataType.Text | typeof DataType.Int;
};

export const actionSchema: Record<string, ActionSchemaElement[]> = {
  add_user_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "recipient_encryption_public_key",
      type: DataType.Text,
    },
    {
      name: "encryption_password_store",
      type: DataType.Text,
    },
  ],
  get_user: [],
  upsert_wallet_as_inserter: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "user_id",
      type: DataType.Uuid,
    },
    {
      name: "address",
      type: DataType.Text,
    },
    {
      name: "public_key",
      type: DataType.Text,
    },
    {
      name: "wallet_type",
      type: DataType.Text,
    },
    {
      name: "message",
      type: DataType.Text,
    },
    {
      name: "signature",
      type: DataType.Text,
    },
  ],
  add_wallet: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "address",
      type: DataType.Text,
    },
    {
      name: "public_key",
      type: DataType.Text,
    },
    {
      name: "message",
      type: DataType.Text,
    },
    {
      name: "signature",
      type: DataType.Text,
    },
  ],
  get_wallets: [],
  remove_wallet: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  get_credentials: [],
  get_credentials_shared_by_user: [
    {
      name: "user_id",
      type: DataType.Uuid,
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text,
    },
  ],
  edit_public_notes_as_issuer: [
    {
      name: "public_notes_id",
      type: DataType.Text,
    },
    {
      name: "public_notes",
      type: DataType.Text,
    },
  ],
  remove_credential: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  share_credential: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "original_credential_id",
      type: DataType.Uuid,
    },
    {
      name: "public_notes",
      type: DataType.Text,
    },
    {
      name: "public_notes_signature",
      type: DataType.Text,
    },
    {
      name: "broader_signature",
      type: DataType.Text,
    },
    {
      name: "content",
      type: DataType.Text,
    },
    {
      name: "content_hash",
      type: DataType.Text,
    },
    {
      name: "encryptor_public_key",
      type: DataType.Text,
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text,
    },
    {
      name: "grantee_wallet_identifier",
      type: DataType.Text,
    },
    {
      name: "locked_until",
      type: DataType.Int,
    },
  ],
  create_credential_copy: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "original_credential_id",
      type: DataType.Uuid,
    },
    {
      name: "public_notes",
      type: DataType.Text,
    },
    {
      name: "public_notes_signature",
      type: DataType.Text,
    },
    {
      name: "broader_signature",
      type: DataType.Text,
    },
    {
      name: "content",
      type: DataType.Text,
    },
    {
      name: "encryptor_public_key",
      type: DataType.Text,
    },
    {
      name: "issuer_auth_public_key",
      type: DataType.Text,
    },
  ],
  create_credentials_by_dwg: [
    {
      name: "issuer_auth_public_key",
      type: DataType.Text,
    },
    {
      name: "original_encryptor_public_key",
      type: DataType.Text,
    },
    {
      name: "original_credential_id",
      type: DataType.Uuid,
    },
    {
      name: "original_content",
      type: DataType.Text,
    },
    {
      name: "original_public_notes",
      type: DataType.Text,
    },
    {
      name: "original_public_notes_signature",
      type: DataType.Text,
    },
    {
      name: "original_broader_signature",
      type: DataType.Text,
    },
    {
      name: "copy_encryptor_public_key",
      type: DataType.Text,
    },
    {
      name: "copy_credential_id",
      type: DataType.Uuid,
    },
    {
      name: "copy_content",
      type: DataType.Text,
    },
    {
      name: "copy_public_notes_signature",
      type: DataType.Text,
    },
    {
      name: "copy_broader_signature",
      type: DataType.Text,
    },
    {
      name: "content_hash",
      type: DataType.Text,
    },
    {
      name: "dwg_owner",
      type: DataType.Text,
    },
    {
      name: "dwg_grantee",
      type: DataType.Text,
    },
    {
      name: "dwg_issuer_public_key",
      type: DataType.Text,
    },
    {
      name: "dwg_id",
      type: DataType.Uuid,
    },
    {
      name: "dwg_access_grant_timelock",
      type: DataType.Text,
    },
    {
      name: "dwg_not_before",
      type: DataType.Text,
    },
    {
      name: "dwg_not_after",
      type: DataType.Text,
    },
    {
      name: "dwg_signature",
      type: DataType.Text,
    },
  ],
  get_credential_owned: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  get_credential_shared: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  get_sibling_credential_id: [
    {
      name: "content_hash",
      type: DataType.Text,
    },
  ],
  add_attribute: [
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "attribute_key",
      type: DataType.Text,
    },
    {
      name: "value",
      type: DataType.Text,
    },
  ],
  get_attributes: [],
  dwg_message: [
    {
      name: "owner_wallet_identifier",
      type: DataType.Text,
    },
    {
      name: "grantee_wallet_identifier",
      type: DataType.Text,
    },
    {
      name: "issuer_public_key",
      type: DataType.Text,
    },
    {
      name: "id",
      type: DataType.Uuid,
    },
    {
      name: "access_grant_timelock",
      type: DataType.Text,
    },
    {
      name: "not_usable_before",
      type: DataType.Text,
    },
    {
      name: "not_usable_after",
      type: DataType.Text,
    },
  ],
  revoke_access_grant: [
    {
      name: "id",
      type: DataType.Uuid,
    },
  ],
  get_access_grants_owned: [],
  get_access_grants_granted: [
    {
      name: "user_id",
      type: DataType.Uuid,
    },
    {
      name: "page",
      type: DataType.Int,
    },
    {
      name: "size",
      type: DataType.Int,
    },
  ],
  get_access_grants_granted_count: [
    {
      name: "user_id",
      type: DataType.Uuid,
    },
  ],
  dag_message: [
    {
      name: "dag_owner_wallet_identifier",
      type: DataType.Text,
    },
    {
      name: "dag_grantee_wallet_identifier",
      type: DataType.Text,
    },
    {
      name: "dag_data_id",
      type: DataType.Uuid,
    },
    {
      name: "dag_locked_until",
      type: DataType.Int,
    },
    {
      name: "dag_content_hash",
      type: DataType.Text,
    },
  ],
  create_ag_by_dag_for_copy: [
    {
      name: "dag_owner_wallet_identifier",
      type: DataType.Text,
    },
    {
      name: "dag_grantee_wallet_identifier",
      type: DataType.Text,
    },
    {
      name: "dag_data_id",
      type: DataType.Uuid,
    },
    {
      name: "dag_locked_until",
      type: DataType.Int,
    },
    {
      name: "dag_content_hash",
      type: DataType.Text,
    },
    {
      name: "dag_signature",
      type: DataType.Text,
    },
  ],
  get_access_grants_for_credential: [
    {
      name: "credential_id",
      type: DataType.Uuid,
    },
  ],
  has_profile: [
    {
      name: "address",
      type: DataType.Text,
    },
  ],
  get_passporting_peers: [],
};
export const idOSUserSchema: z.ZodObject<{
  id: z.ZodUUID;
  recipient_encryption_public_key: z.ZodString;
  encryption_password_store: z.ZodString;
}> = z.object({
  id: z.uuid(),
  recipient_encryption_public_key: z.string(),
  encryption_password_store: z.string(),
});

export type idOSUser = z.infer<typeof idOSUserSchema>;

/**  USER ACTIONS */
export async function createUser(kwilClient: KwilActionClient, params: idOSUser): Promise<void> {
  const inputs = idOSUserSchema.parse(params);
  await kwilClient.execute({
    name: "add_user_as_inserter",
    inputs,
    description: "Add a user to idOS",
  });
}

export const GetUserOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  recipient_encryption_public_key: z.ZodString;
  encryption_password_store: z.ZodString;
}> = z.object({
  id: z.uuid(),
  recipient_encryption_public_key: z.string(),
  encryption_password_store: z.string(),
});

export type GetUserOutput = z.infer<typeof GetUserOutputSchema>;

export async function getUser(kwilClient: KwilActionClient): Promise<GetUserOutput> {
  return await kwilClient
    .call<GetUserOutput[]>({ name: "get_user", inputs: {} })
    .then((result) => result[0]);
}

export const idOSWalletSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  address: z.ZodString;
  public_key: z.ZodString;
  wallet_type: z.ZodString;
  message: z.ZodString;
  signature: z.ZodString;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  address: z.string(),
  public_key: z.string(),
  wallet_type: z.string(),
  message: z.string(),
  signature: z.string(),
});

export type idOSWallet = z.infer<typeof idOSWalletSchema>;

/**  WALLET ACTIONS */
export async function upsertWalletAsInserter(
  kwilClient: KwilActionClient,
  params: idOSWallet,
): Promise<void> {
  const inputs = idOSWalletSchema.parse(params);
  await kwilClient.execute({
    name: "upsert_wallet_as_inserter",
    inputs,
    description: "Add a wallet to idOS",
  });
}

export const AddWalletInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  address: z.ZodString;
  public_key: z.ZodString;
  message: z.ZodString;
  signature: z.ZodString;
}> = z.object({
  id: z.uuid(),
  address: z.string(),
  public_key: z.string(),
  message: z.string(),
  signature: z.string(),
});

export type AddWalletInput = z.infer<typeof AddWalletInputSchema>;

export async function addWallet(
  kwilClient: KwilActionClient,
  params: AddWalletInput,
): Promise<void> {
  const inputs = AddWalletInputSchema.parse(params);
  await kwilClient.execute({
    name: "add_wallet",
    inputs,
    description: "Add a wallet to idOS",
  });
}

export const GetWalletsOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  address: z.ZodString;
  public_key: z.ZodString;
  wallet_type: z.ZodString;
  message: z.ZodString;
  signature: z.ZodString;
  inserter: z.ZodString;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  address: z.string(),
  public_key: z.string(),
  wallet_type: z.string(),
  message: z.string(),
  signature: z.string(),
  inserter: z.string(),
});

export type GetWalletsOutput = z.infer<typeof GetWalletsOutputSchema>;

export async function getWallets(kwilClient: KwilActionClient): Promise<GetWalletsOutput[]> {
  return await kwilClient.call<GetWalletsOutput[]>({ name: "get_wallets", inputs: {} });
}

export const RemoveWalletInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type RemoveWalletInput = z.infer<typeof RemoveWalletInputSchema>;

export async function removeWallet(
  kwilClient: KwilActionClient,
  params: RemoveWalletInput,
): Promise<void> {
  const inputs = RemoveWalletInputSchema.parse(params);
  await kwilClient.execute({
    name: "remove_wallet",
    inputs,
    description: "Remove a wallet from idOS",
  });
}

export const idOSCredentialListItemSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  public_notes: z.ZodString;
  issuer_auth_public_key: z.ZodString;
  inserter: z.ZodString;
  original_id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  public_notes: z.string(),
  issuer_auth_public_key: z.string(),
  inserter: z.string(),
  original_id: z.uuid(),
});

export type idOSCredentialListItem = z.infer<typeof idOSCredentialListItemSchema>;

export async function getCredentials(
  kwilClient: KwilActionClient,
): Promise<idOSCredentialListItem[]> {
  return await kwilClient.call<idOSCredentialListItem[]>({ name: "get_credentials", inputs: {} });
}

export const GetCredentialsSharedByUserInputSchema: z.ZodObject<{
  user_id: z.ZodUUID;
  issuer_auth_public_key: z.ZodNullable<z.ZodString>;
}> = z.object({
  user_id: z.uuid(),
  issuer_auth_public_key: z.string().nullable(),
});

export type GetCredentialsSharedByUserInput = z.infer<typeof GetCredentialsSharedByUserInputSchema>;

export const GetCredentialsSharedByUserOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  public_notes: z.ZodString;
  encryptor_public_key: z.ZodString;
  issuer_auth_public_key: z.ZodString;
  inserter: z.ZodString;
  original_id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  public_notes: z.string(),
  encryptor_public_key: z.string(),
  issuer_auth_public_key: z.string(),
  inserter: z.string(),
  original_id: z.uuid(),
});

export type GetCredentialsSharedByUserOutput = z.infer<
  typeof GetCredentialsSharedByUserOutputSchema
>;

export async function getCredentialsSharedByUser(
  kwilClient: KwilActionClient,
  params: GetCredentialsSharedByUserInput,
): Promise<GetCredentialsSharedByUserOutput[]> {
  const inputs = GetCredentialsSharedByUserInputSchema.parse(params);
  return await kwilClient.call<GetCredentialsSharedByUserOutput[]>({
    name: "get_credentials_shared_by_user",
    inputs,
  });
}

export const EditCredentialAsIssuerParamsSchema: z.ZodObject<{
  public_notes_id: z.ZodString;
  public_notes: z.ZodString;
}> = z.object({
  public_notes_id: z.string(),
  public_notes: z.string(),
});

export type EditCredentialAsIssuerParams = z.infer<typeof EditCredentialAsIssuerParamsSchema>;

/**
 *  Be aware that @caller here is ed25519 public key, hex encoded.
 *  All other @caller in the schema are either secp256k1 or nep413
 *  This action can't be called by kwil-cli (as kwil-cli uses secp256k1 only)
 */
export async function editCredentialAsIssuer(
  kwilClient: KwilActionClient,
  params: EditCredentialAsIssuerParams,
): Promise<void> {
  const inputs = EditCredentialAsIssuerParamsSchema.parse(params);
  await kwilClient.execute({
    name: "edit_public_notes_as_issuer",
    inputs,
    description: "Edit a credential in your idOS profile",
  });
}

export const RemoveCredentialInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type RemoveCredentialInput = z.infer<typeof RemoveCredentialInputSchema>;

export async function removeCredential(
  kwilClient: KwilActionClient,
  params: RemoveCredentialInput,
): Promise<void> {
  const inputs = RemoveCredentialInputSchema.parse(params);
  await kwilClient.execute({
    name: "remove_credential",
    inputs,
    description: "Remove a credential from your idOS profile",
  });
}

export const ShareCredentialInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  original_credential_id: z.ZodUUID;
  public_notes: z.ZodString;
  public_notes_signature: z.ZodString;
  broader_signature: z.ZodString;
  content: z.ZodString;
  content_hash: z.ZodString;
  encryptor_public_key: z.ZodString;
  issuer_auth_public_key: z.ZodString;
  grantee_wallet_identifier: z.ZodString;
  locked_until: z.ZodNumber;
}> = z.object({
  id: z.uuid(),
  original_credential_id: z.uuid(),
  public_notes: z.string(),
  public_notes_signature: z.string(),
  broader_signature: z.string(),
  content: z.string(),
  content_hash: z.string(),
  encryptor_public_key: z.string(),
  issuer_auth_public_key: z.string(),
  grantee_wallet_identifier: z.string(),
  locked_until: z.number(),
});

export type ShareCredentialInput = z.infer<typeof ShareCredentialInputSchema>;

export async function shareCredential(
  kwilClient: KwilActionClient,
  params: ShareCredentialInput,
): Promise<void> {
  const inputs = ShareCredentialInputSchema.parse(params);
  await kwilClient.execute({
    name: "share_credential",
    inputs,
    description: "Share a credential with another idOS user",
  });
}

export const CreateCredentialCopyInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  original_credential_id: z.ZodUUID;
  public_notes: z.ZodString;
  public_notes_signature: z.ZodString;
  broader_signature: z.ZodString;
  content: z.ZodString;
  encryptor_public_key: z.ZodString;
  issuer_auth_public_key: z.ZodString;
}> = z.object({
  id: z.uuid(),
  original_credential_id: z.uuid(),
  public_notes: z.string(),
  public_notes_signature: z.string(),
  broader_signature: z.string(),
  content: z.string(),
  encryptor_public_key: z.string(),
  issuer_auth_public_key: z.string(),
});

export type CreateCredentialCopyInput = z.infer<typeof CreateCredentialCopyInputSchema>;

/**  Passporting scenario */
export async function createCredentialCopy(
  kwilClient: KwilActionClient,
  params: CreateCredentialCopyInput,
): Promise<void> {
  const inputs = CreateCredentialCopyInputSchema.parse(params);
  await kwilClient.execute({
    name: "create_credential_copy",
    inputs,
    description: "Share a credential with another user on idOS",
  });
}

export const CreateCredentialByDelegatedWriteGrantInputSchema: z.ZodObject<{
  issuer_auth_public_key: z.ZodString;
  original_encryptor_public_key: z.ZodString;
  original_credential_id: z.ZodUUID;
  original_content: z.ZodString;
  original_public_notes: z.ZodString;
  original_public_notes_signature: z.ZodString;
  original_broader_signature: z.ZodString;
  copy_encryptor_public_key: z.ZodString;
  copy_credential_id: z.ZodUUID;
  copy_content: z.ZodString;
  copy_public_notes_signature: z.ZodString;
  copy_broader_signature: z.ZodString;
  content_hash: z.ZodString;
  dwg_owner: z.ZodString;
  dwg_grantee: z.ZodString;
  dwg_issuer_public_key: z.ZodString;
  dwg_id: z.ZodUUID;
  dwg_access_grant_timelock: z.ZodString;
  dwg_not_before: z.ZodString;
  dwg_not_after: z.ZodString;
  dwg_signature: z.ZodString;
}> = z.object({
  issuer_auth_public_key: z.string(),
  original_encryptor_public_key: z.string(),
  original_credential_id: z.uuid(),
  original_content: z.string(),
  original_public_notes: z.string(),
  original_public_notes_signature: z.string(),
  original_broader_signature: z.string(),
  copy_encryptor_public_key: z.string(),
  copy_credential_id: z.uuid(),
  copy_content: z.string(),
  copy_public_notes_signature: z.string(),
  copy_broader_signature: z.string(),
  content_hash: z.string(),
  dwg_owner: z.string(),
  dwg_grantee: z.string(),
  dwg_issuer_public_key: z.string(),
  dwg_id: z.uuid(),
  dwg_access_grant_timelock: z.string(),
  dwg_not_before: z.string(),
  dwg_not_after: z.string(),
  dwg_signature: z.string(),
});

export type CreateCredentialByDelegatedWriteGrantInput = z.infer<
  typeof CreateCredentialByDelegatedWriteGrantInputSchema
>;

/**
 *  For access grant
 *  Check the content creator (encryptor) is the issuer that user delegated to issue the credential
 *  Get the wallet type and public key for XRPL/NEAR wallets from database
 *  Will fail if not in the RFC3339 format
 *  Check the format and precedence
 *  Check if current block timestamp in time range allowed by write grant.
 *  @block_timestamp is a timestamp of previous block, which is can be a few seconds earlier
 *  (max is 6 seconds in current network consensus settings) then a time on a requester's machine.
 *  Also, if requester's machine has wrong time, it can be an issue.
 *  Insert original credential
 *  Insert copy credential
 */
export async function createCredentialByDelegatedWriteGrant(
  kwilClient: KwilActionClient,
  params: CreateCredentialByDelegatedWriteGrantInput,
): Promise<void> {
  const inputs = CreateCredentialByDelegatedWriteGrantInputSchema.parse(params);
  await kwilClient.execute({
    name: "create_credentials_by_dwg",
    inputs,
    description: "Create a new credential in your idOS profile",
  });
}

export const GetCredentialOwnedInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type GetCredentialOwnedInput = z.infer<typeof GetCredentialOwnedInputSchema>;

export const idOSCredentialSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  public_notes: z.ZodString;
  content: z.ZodString;
  encryptor_public_key: z.ZodString;
  issuer_auth_public_key: z.ZodString;
  inserter: z.ZodString;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  public_notes: z.string(),
  content: z.string(),
  encryptor_public_key: z.string(),
  issuer_auth_public_key: z.string(),
  inserter: z.string(),
});

export type idOSCredential = z.infer<typeof idOSCredentialSchema>;

export async function getCredentialOwned(
  kwilClient: KwilActionClient,
  params: GetCredentialOwnedInput,
): Promise<idOSCredential[]> {
  const inputs = GetCredentialOwnedInputSchema.parse(params);
  return await kwilClient.call<idOSCredential[]>({
    name: "get_credential_owned",
    inputs,
  });
}

export const GetSharedCredentialInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type GetSharedCredentialInput = z.infer<typeof GetSharedCredentialInputSchema>;

/**  As a credential copy doesn't contain PUBLIC notes, we return respective original credential PUBLIC notes */
export async function getSharedCredential(
  kwilClient: KwilActionClient,
  params: GetSharedCredentialInput,
): Promise<idOSCredential[]> {
  const inputs = GetSharedCredentialInputSchema.parse(params);
  return await kwilClient.call<idOSCredential[]>({
    name: "get_credential_shared",
    inputs,
  });
}

export const GetCredentialIdByContentHashInputSchema: z.ZodObject<{
  content_hash: z.ZodString;
}> = z.object({
  content_hash: z.string(),
});

export type GetCredentialIdByContentHashInput = z.infer<
  typeof GetCredentialIdByContentHashInputSchema
>;

export const GetCredentialIdByContentHashOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type GetCredentialIdByContentHashOutput = z.infer<
  typeof GetCredentialIdByContentHashOutputSchema
>;

export async function getCredentialIdByContentHash(
  kwilClient: KwilActionClient,
  params: GetCredentialIdByContentHashInput,
): Promise<GetCredentialIdByContentHashOutput> {
  const inputs = GetCredentialIdByContentHashInputSchema.parse(params);
  return await kwilClient
    .call<GetCredentialIdByContentHashOutput[]>({
      name: "get_sibling_credential_id",
      inputs,
    })
    .then((result) => result[0]);
}

export const AddAttributeInputSchema: z.ZodObject<{
  id: z.ZodUUID;
  attribute_key: z.ZodString;
  value: z.ZodString;
}> = z.object({
  id: z.uuid(),
  attribute_key: z.string(),
  value: z.string(),
});

export type AddAttributeInput = z.infer<typeof AddAttributeInputSchema>;

export async function addAttribute(
  kwilClient: KwilActionClient,
  params: AddAttributeInput,
): Promise<void> {
  const inputs = AddAttributeInputSchema.parse(params);
  await kwilClient.execute({
    name: "add_attribute",
    inputs,
    description: "Create a new attribute in your idOS profile",
  });
}

export const idOSUserAttributeSchema: z.ZodObject<{
  id: z.ZodUUID;
  user_id: z.ZodUUID;
  attribute_key: z.ZodString;
  value: z.ZodString;
  original_id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
  user_id: z.uuid(),
  attribute_key: z.string(),
  value: z.string(),
  original_id: z.uuid(),
});

export type idOSUserAttribute = z.infer<typeof idOSUserAttributeSchema>;

export async function getAttributes(kwilClient: KwilActionClient): Promise<idOSUserAttribute[]> {
  return await kwilClient.call<idOSUserAttribute[]>({ name: "get_attributes", inputs: {} });
}

export const idOSDelegatedWriteGrantSchema: z.ZodObject<{
  owner_wallet_identifier: z.ZodString;
  grantee_wallet_identifier: z.ZodString;
  issuer_public_key: z.ZodString;
  id: z.ZodUUID;
  access_grant_timelock: z.ZodString;
  not_usable_before: z.ZodString;
  not_usable_after: z.ZodString;
}> = z.object({
  owner_wallet_identifier: z.string(),
  grantee_wallet_identifier: z.string(),
  issuer_public_key: z.string(),
  id: z.uuid(),
  access_grant_timelock: z.string(),
  not_usable_before: z.string(),
  not_usable_after: z.string(),
});

export type idOSDelegatedWriteGrant = z.infer<typeof idOSDelegatedWriteGrantSchema>;

export const DwgMessageOutputSchema: z.ZodObject<{
  message: z.ZodString;
}> = z.object({
  message: z.string(),
});

export type DwgMessageOutput = z.infer<typeof DwgMessageOutputSchema>;

/**
 *  WRITE GRANTS ACTIONS
 *  Must be in yyyy-mm-ddThh:mm:ssZ format
 *  Must be in yyyy-mm-ddThh:mm:ssZ format
 *  Must be in yyyy-mm-ddThh:mm:ssZ format
 *  Will fail if not in the yyyy-mm-ddThh:mm:ssZ format, and not comply to RFC3339
 *  Check the format and precedence
 */
export async function dwgMessage(
  kwilClient: KwilActionClient,
  params: idOSDelegatedWriteGrant,
): Promise<DwgMessageOutput> {
  const inputs = idOSDelegatedWriteGrantSchema.parse(params);
  return await kwilClient
    .call<DwgMessageOutput[]>({
      name: "dwg_message",
      inputs,
    })
    .then((result) => result[0]);
}

export const RevokeAccessGrantInputSchema: z.ZodObject<{
  id: z.ZodUUID;
}> = z.object({
  id: z.uuid(),
});

export type RevokeAccessGrantInput = z.infer<typeof RevokeAccessGrantInputSchema>;

/**  ACCESS GRANTS ACTIONS */
export async function revokeAccessGrant(
  kwilClient: KwilActionClient,
  params: RevokeAccessGrantInput,
): Promise<void> {
  const inputs = RevokeAccessGrantInputSchema.parse(params);
  await kwilClient.execute({
    name: "revoke_access_grant",
    inputs,
    description: "Revoke an Access Grant from idOS",
  });
}

export const idOSGrantSchema: z.ZodObject<{
  id: z.ZodUUID;
  ag_owner_user_id: z.ZodUUID;
  ag_grantee_wallet_identifier: z.ZodString;
  data_id: z.ZodUUID;
  locked_until: z.ZodNumber;
  content_hash: z.ZodString;
  inserter_type: z.ZodString;
  inserter_id: z.ZodString;
}> = z.object({
  id: z.uuid(),
  ag_owner_user_id: z.uuid(),
  ag_grantee_wallet_identifier: z.string(),
  data_id: z.uuid(),
  locked_until: z.number(),
  content_hash: z.string(),
  inserter_type: z.string(),
  inserter_id: z.string(),
});

export type idOSGrant = z.infer<typeof idOSGrantSchema>;

export async function getAccessGrantsOwned(kwilClient: KwilActionClient): Promise<idOSGrant[]> {
  return await kwilClient.call<idOSGrant[]>({ name: "get_access_grants_owned", inputs: {} });
}

export const GetGrantsPaginatedInputSchema: z.ZodObject<{
  user_id: z.ZodNullable<z.ZodUUID>;
  page: z.ZodNumber;
  size: z.ZodNumber;
}> = z.object({
  user_id: z.uuid().nullable(),
  page: z.number(),
  size: z.number(),
});

export type GetGrantsPaginatedInput = z.infer<typeof GetGrantsPaginatedInputSchema>;

/**
 *  As arguments can be undefined (user can not send them at all), we have to have default values: page=1, size=20
 *  Page number starts from 1, as UI usually shows to user in pagination element
 *  Ordering is consistent because we use height as first ordering parameter
 */
export async function getGrantsPaginated(
  kwilClient: KwilActionClient,
  params: GetGrantsPaginatedInput,
): Promise<idOSGrant[]> {
  const inputs = GetGrantsPaginatedInputSchema.parse(params);
  return await kwilClient.call<idOSGrant[]>({
    name: "get_access_grants_granted",
    inputs,
  });
}

export const GetGrantsCountInputSchema: z.ZodObject<{
  user_id: z.ZodNullable<z.ZodUUID>;
}> = z.object({
  user_id: z.uuid().nullable(),
});

export type GetGrantsCountInput = z.infer<typeof GetGrantsCountInputSchema>;

export const GetGrantsCountOutputSchema: z.ZodObject<{
  count: z.ZodNumber;
}> = z.object({
  count: z.number(),
});

export type GetGrantsCountOutput = z.infer<typeof GetGrantsCountOutputSchema>;

export async function getGrantsCount(
  kwilClient: KwilActionClient,
  params: GetGrantsCountInput,
): Promise<GetGrantsCountOutput> {
  const inputs = GetGrantsCountInputSchema.parse(params);
  return await kwilClient
    .call<GetGrantsCountOutput[]>({
      name: "get_access_grants_granted_count",
      inputs,
    })
    .then((result) => result[0]);
}

export const DagMessageInputSchema: z.ZodObject<{
  dag_owner_wallet_identifier: z.ZodString;
  dag_grantee_wallet_identifier: z.ZodString;
  dag_data_id: z.ZodUUID;
  dag_locked_until: z.ZodNumber;
  dag_content_hash: z.ZodString;
}> = z.object({
  dag_owner_wallet_identifier: z.string(),
  dag_grantee_wallet_identifier: z.string(),
  dag_data_id: z.uuid(),
  dag_locked_until: z.number(),
  dag_content_hash: z.string(),
});

export type DagMessageInput = z.infer<typeof DagMessageInputSchema>;

export const DagMessageOutputSchema: z.ZodObject<{
  message: z.ZodString;
}> = z.object({
  message: z.string(),
});

export type DagMessageOutput = z.infer<typeof DagMessageOutputSchema>;

export async function dagMessage(
  kwilClient: KwilActionClient,
  params: DagMessageInput,
): Promise<DagMessageOutput> {
  const inputs = DagMessageInputSchema.parse(params);
  return await kwilClient
    .call<DagMessageOutput[]>({
      name: "dag_message",
      inputs,
    })
    .then((result) => result[0]);
}

export const CreateAccessGrantByDagInputSchema: z.ZodObject<{
  dag_owner_wallet_identifier: z.ZodString;
  dag_grantee_wallet_identifier: z.ZodString;
  dag_data_id: z.ZodUUID;
  dag_locked_until: z.ZodNumber;
  dag_content_hash: z.ZodString;
  dag_signature: z.ZodString;
}> = z.object({
  dag_owner_wallet_identifier: z.string(),
  dag_grantee_wallet_identifier: z.string(),
  dag_data_id: z.uuid(),
  dag_locked_until: z.number(),
  dag_content_hash: z.string(),
  dag_signature: z.string(),
});

export type CreateAccessGrantByDagInput = z.infer<typeof CreateAccessGrantByDagInputSchema>;

/**
 *  Get the wallet type and public key for XRPL/NEAR wallets from database
 *  This works for EVM-compatible signatures only
 */
export async function createAccessGrantByDag(
  kwilClient: KwilActionClient,
  params: CreateAccessGrantByDagInput,
): Promise<void> {
  const inputs = CreateAccessGrantByDagInputSchema.parse(params);
  await kwilClient.execute({
    name: "create_ag_by_dag_for_copy",
    inputs,
    description: "Create an Access Grant in idOS",
  });
}

export const GetAccessGrantsForCredentialInputSchema: z.ZodObject<{
  credential_id: z.ZodUUID;
}> = z.object({
  credential_id: z.uuid(),
});

export type GetAccessGrantsForCredentialInput = z.infer<
  typeof GetAccessGrantsForCredentialInputSchema
>;

export const GetAccessGrantsForCredentialOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  ag_owner_user_id: z.ZodUUID;
  ag_grantee_wallet_identifier: z.ZodString;
  data_id: z.ZodUUID;
  locked_until: z.ZodNumber;
  content_hash: z.ZodString;
  inserter_type: z.ZodString;
  inserter_id: z.ZodString;
}> = z.object({
  id: z.uuid(),
  ag_owner_user_id: z.uuid(),
  ag_grantee_wallet_identifier: z.string(),
  data_id: z.uuid(),
  locked_until: z.number(),
  content_hash: z.string(),
  inserter_type: z.string(),
  inserter_id: z.string(),
});

export type GetAccessGrantsForCredentialOutput = z.infer<
  typeof GetAccessGrantsForCredentialOutputSchema
>;

export async function getAccessGrantsForCredential(
  kwilClient: KwilActionClient,
  params: GetAccessGrantsForCredentialInput,
): Promise<GetAccessGrantsForCredentialOutput[]> {
  const inputs = GetAccessGrantsForCredentialInputSchema.parse(params);
  return await kwilClient.call<GetAccessGrantsForCredentialOutput[]>({
    name: "get_access_grants_for_credential",
    inputs,
  });
}

export const HasProfileInputSchema: z.ZodObject<{
  address: z.ZodString;
}> = z.object({
  address: z.string(),
});

export type HasProfileInput = z.infer<typeof HasProfileInputSchema>;

export const HasProfileOutputSchema: z.ZodObject<{
  has_profile: z.ZodBoolean;
}> = z.object({
  has_profile: z.boolean(),
});

export type HasProfileOutput = z.infer<typeof HasProfileOutputSchema>;

/**
 *  OTHER ACTIONS
 *  Should we improve it to work with near wallets too?
 */
export async function hasProfile(
  kwilClient: KwilActionClient,
  params: HasProfileInput,
): Promise<HasProfileOutput> {
  const inputs = HasProfileInputSchema.parse(params);
  return await kwilClient
    .call<HasProfileOutput[]>(
      {
        name: "has_profile",
        inputs,
      },
      undefined, // Signer is not required here
    )
    .then((result) => result[0]);
}

export const GetPassportingPeersOutputSchema: z.ZodObject<{
  id: z.ZodUUID;
  name: z.ZodString;
  issuer_public_key: z.ZodString;
  passporting_server_url_base: z.ZodString;
  club_id: z.ZodUUID;
  club_name: z.ZodString;
}> = z.object({
  id: z.uuid(),
  name: z.string(),
  issuer_public_key: z.string(),
  passporting_server_url_base: z.string(),
  club_id: z.uuid(),
  club_name: z.string(),
});

export type GetPassportingPeersOutput = z.infer<typeof GetPassportingPeersOutputSchema>;

/**  get clubs the peer belongs to */
export async function getPassportingPeers(
  kwilClient: KwilActionClient,
): Promise<GetPassportingPeersOutput[]> {
  return await kwilClient.call<GetPassportingPeersOutput[]>({
    name: "get_passporting_peers",
    inputs: {},
  });
}
